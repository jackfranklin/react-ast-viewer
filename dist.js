!function(a){"use strict";function b(a){return{configurable:!0,enumerable:!1,value:a,writable:!0}}function c(){return"__$"+Math.floor(1e9*Math.random())+"$"+ ++S+"$__"}function d(a){return X[a]}function e(){var a=c();return X[a]=!0,a}function f(a){return"object"==typeof a&&a instanceof i}function g(a){return f(a)?"symbol":typeof a}function h(a){var b=new i(a);if(!(this instanceof h))return b;throw new TypeError("Symbol cannot be new'ed")}function i(a){var b=c();I(this,V,{value:this}),I(this,T,{value:b}),I(this,U,{value:a}),k(this),W[b]=this}function j(a){var b=a[Y];return b&&b.self===a?b:Q(a)?($.hash.value=_++,$.self.value=a,Z.value=G(null,$),I(a,Y,Z),Z.value):void 0}function k(a){return j(a),J.apply(this,arguments)}function l(a){return j(a),O.apply(this,arguments)}function m(a){return j(a),P.apply(this,arguments)}function n(a){return W[a]||X[a]}function o(a){return f(a)?a[T]:a}function p(a){for(var b=[],c=0;c<a.length;c++)n(a[c])||b.push(a[c]);return b}function q(a){return p(L(a))}function r(a){return p(M(a))}function s(a){for(var b=[],c=L(a),d=0;d<c.length;d++){var e=W[c[d]];e&&b.push(e)}return b}function t(a,b){return K(a,o(b))}function u(a){return N.call(this,o(a))}function v(b){return a.$traceurRuntime.options[b]}function w(a,b,c){return f(b)&&(b=b[T]),I(a,b,c),a}function x(a){I(a,"defineProperty",{value:w}),I(a,"getOwnPropertyNames",{value:q}),I(a,"getOwnPropertyDescriptor",{value:t}),I(a.prototype,"hasOwnProperty",{value:u}),I(a,"freeze",{value:k}),I(a,"preventExtensions",{value:l}),I(a,"seal",{value:m}),I(a,"keys",{value:r})}function y(a){for(var b=1;b<arguments.length;b++)for(var c=L(arguments[b]),d=0;d<c.length;d++){var e=c[d];n(e)||!function(b,c){I(a,c,{get:function(){return b[c]},enumerable:!0})}(arguments[b],c[d])}return a}function z(a){return null!=a&&("object"==typeof a||"function"==typeof a)}function A(a){if(null==a)throw F();return E(a)}function B(a){if(null==a)throw new TypeError("Value cannot be converted to an Object");return a}function C(a,b){a.Symbol||(a.Symbol=b,Object.getOwnPropertySymbols=s),a.Symbol.iterator||(a.Symbol.iterator=b("Symbol.iterator"))}function D(a){C(a,h),a.Reflect=a.Reflect||{},a.Reflect.global=a.Reflect.global||a,x(a.Object)}if(!a.$traceurRuntime){var E=Object,F=TypeError,G=E.create,H=E.defineProperties,I=E.defineProperty,J=E.freeze,K=E.getOwnPropertyDescriptor,L=E.getOwnPropertyNames,M=E.keys,N=E.prototype.hasOwnProperty,O=(E.prototype.toString,Object.preventExtensions),P=Object.seal,Q=Object.isExtensible,R=b,S=0,T=c(),U=c(),V=c(),W=G(null),X=G(null);I(h.prototype,"constructor",b(h)),I(h.prototype,"toString",R(function(){var a=this[V];return a[T]})),I(h.prototype,"valueOf",R(function(){var a=this[V];if(!a)throw TypeError("Conversion from symbol to string");return v("symbols")?a:a[T]})),I(i.prototype,"constructor",b(h)),I(i.prototype,"toString",{value:h.prototype.toString,enumerable:!1}),I(i.prototype,"valueOf",{value:h.prototype.valueOf,enumerable:!1});var Y=e(),Z={value:void 0},$={hash:{value:void 0},self:{value:void 0}},_=0;k(i.prototype),D(a),a.$traceurRuntime={checkObjectCoercible:B,createPrivateName:e,defineProperties:H,defineProperty:I,exportStar:y,getOwnHashObject:j,getOwnPropertyDescriptor:K,getOwnPropertyNames:L,isObject:z,isPrivateName:d,isSymbolString:n,keys:M,options:{},setupGlobals:D,toObject:A,toProperty:o,"typeof":g}}}("undefined"!=typeof window?window:"undefined"!=typeof global?global:"undefined"!=typeof self?self:this),function(){function a(a,b,c,d,e,f,g){var h=[];return a&&h.push(a,":"),c&&(h.push("//"),b&&h.push(b,"@"),h.push(c),d&&h.push(":",d)),e&&h.push(e),f&&h.push("?",f),g&&h.push("#",g),h.join("")}function b(a){return a.match(h)}function c(a){if("/"===a)return"/";for(var b="/"===a[0]?"/":"",c="/"===a.slice(-1)?"/":"",d=a.split("/"),e=[],f=0,g=0;g<d.length;g++){var h=d[g];switch(h){case"":case".":break;case"..":e.length?e.pop():f++;break;default:e.push(h)}}if(!b){for(;f-->0;)e.unshift("..");0===e.length&&e.push(".")}return b+e.join("/")+c}function d(b){var d=b[i.PATH]||"";return d=c(d),b[i.PATH]=d,a(b[i.SCHEME],b[i.USER_INFO],b[i.DOMAIN],b[i.PORT],b[i.PATH],b[i.QUERY_DATA],b[i.FRAGMENT])}function e(a){var c=b(a);return d(c)}function f(a,c){var e=b(c),f=b(a);if(e[i.SCHEME])return d(e);e[i.SCHEME]=f[i.SCHEME];for(var g=i.SCHEME;g<=i.PORT;g++)e[g]||(e[g]=f[g]);if("/"==e[i.PATH][0])return d(e);var h=f[i.PATH],j=h.lastIndexOf("/");return h=h.slice(0,j+1)+e[i.PATH],e[i.PATH]=h,d(e)}function g(a){if(!a)return!1;if("/"===a[0])return!0;var c=b(a);return c[i.SCHEME]?!0:!1}var h=new RegExp("^(?:([^:/?#.]+):)?(?://(?:([^/?#]*)@)?([\\w\\d\\-\\u0100-\\uffff.%]*)(?::([0-9]+))?)?([^?#]+)?(?:\\?([^#]*))?(?:#(.*))?$"),i={SCHEME:1,USER_INFO:2,DOMAIN:3,PORT:4,PATH:5,QUERY_DATA:6,FRAGMENT:7};$traceurRuntime.canonicalizeUrl=e,$traceurRuntime.isAbsolute=g,$traceurRuntime.removeDotSegments=c,$traceurRuntime.resolveUrl=f}(),function(a){"use strict";function b(a,b){this.url=a,this.value_=b}function c(a,b){this.message=this.constructor.name+": "+this.stripCause(b)+" in "+a,this.stack=b instanceof c||!b.stack?"":this.stripStack(b.stack)}function d(a,b){var c=[],d=b-3;0>d&&(d=0);for(var e=d;b>e;e++)c.push(a[e]);return c}function e(a,b){var c=b+1;c>a.length-1&&(c=a.length-1);for(var d=[],e=b;c>=e;e++)d.push(a[e]);return d}function f(a){for(var b="",c=0;a-1>c;c++)b+="-";return b}function g(a,c){b.call(this,a,null),this.func=c}function h(a){if(a){var b=r.normalize(a);return o[b]}}function i(a){var b=arguments[1],c=Object.create(null);return Object.getOwnPropertyNames(a).forEach(function(d){var e,f;if(b===q){var g=Object.getOwnPropertyDescriptor(a,d);g.get&&(e=g.get)}e||(f=a[d],e=function(){return f}),Object.defineProperty(c,d,{get:e,enumerable:!0})}),Object.preventExtensions(c),c}var j,k=$traceurRuntime,l=k.canonicalizeUrl,m=k.resolveUrl,n=k.isAbsolute,o=Object.create(null);j=a.location&&a.location.href?m(a.location.href,"./"):"",c.prototype=Object.create(Error.prototype),c.prototype.constructor=c,c.prototype.stripError=function(a){return a.replace(/.*Error:/,this.constructor.name+":")},c.prototype.stripCause=function(a){return a?a.message?this.stripError(a.message):a+"":""},c.prototype.loadedBy=function(a){this.stack+="\n loaded by "+a},c.prototype.stripStack=function(a){var b=[];return a.split("\n").some(function(a){return/UncoatedModuleInstantiator/.test(a)?!0:void b.push(a)}),b[0]=this.stripError(b[0]),b.join("\n")},g.prototype=Object.create(b.prototype),g.prototype.getUncoatedModule=function(){if(this.value_)return this.value_;try{var b;return void 0!==typeof $traceurRuntime&&$traceurRuntime.require&&(b=$traceurRuntime.require.bind(null,this.url)),this.value_=this.func.call(a,b)}catch(g){if(g instanceof c)throw g.loadedBy(this.url),g;if(g.stack){var h=this.func.toString().split("\n"),i=[];g.stack.split("\n").some(function(a){if(a.indexOf("UncoatedModuleInstantiator.getUncoatedModule")>0)return!0;var b=/(at\s[^\s]*\s).*>:(\d*):(\d*)\)/.exec(a);if(b){var c=parseInt(b[2],10);i=i.concat(d(h,c)),i.push(f(b[3])+"^"),i=i.concat(e(h,c)),i.push("= = = = = = = = =")}else i.push(a)}),g.stack=i.join("\n")}throw new c(this.url,g)}};var p=Object.create(null),q={},r={normalize:function(a,b){if("string"!=typeof a)throw new TypeError("module name must be a string, not "+typeof a);if(n(a))return l(a);if(/[^\.]\/\.\.\//.test(a))throw new Error("module name embeds /../: "+a);return"."===a[0]&&b?m(b,a):l(a)},get:function(a){var b=h(a);if(!b)return void 0;var c=p[b.url];return c?c:(c=i(b.getUncoatedModule(),q),p[b.url]=c)},set:function(a,b){a=String(a),o[a]=new g(a,function(){return b}),p[a]=b},get baseURL(){return j},set baseURL(a){j=String(a)},registerModule:function(a,b,c){var d=r.normalize(a);if(o[d])throw new Error("duplicate module named "+d);o[d]=new g(d,c)},bundleStore:Object.create(null),register:function(a,b,c){b&&(b.length||c.length)?this.bundleStore[a]={deps:b,execute:function(){var a=arguments,d={};b.forEach(function(b,c){return d[b]=a[c]});var e=c.call(this,d);return e.execute.call(this),e.exports}}:this.registerModule(a,b,c)},getAnonymousModule:function(b){return new i(b.call(a),q)},getForTesting:function(a){var b=this;return this.testingPrefix_||Object.keys(p).some(function(a){var c=/(traceur@[^\/]*\/)/.exec(a);return c?(b.testingPrefix_=c[1],!0):void 0}),this.get(this.testingPrefix_+a)}},s=new i({ModuleStore:r});r.set("@traceur/src/runtime/ModuleStore",s),r.set("@traceur/src/runtime/ModuleStore.js",s);var t=$traceurRuntime.setupGlobals;$traceurRuntime.setupGlobals=function(a){t(a)},$traceurRuntime.ModuleStore=r,a.System={register:r.register.bind(r),registerModule:r.registerModule.bind(r),get:r.get,set:r.set,normalize:r.normalize},$traceurRuntime.getModuleImpl=function(a){var b=h(a);return b&&b.getUncoatedModule()}}("undefined"!=typeof window?window:"undefined"!=typeof global?global:"undefined"!=typeof self?self:this),System.registerModule("traceur-runtime@0.0.84/src/runtime/classes.js",[],function(){"use strict";function a(a,b){var c=n(a);do{var d=m(c,b);if(d)return d;c=n(c)}while(c);return void 0}function b(a){return a.__proto__}function c(b,c,d){var e=a(c,d);return e?e.get?e.get.call(b):e.value:void 0}function d(b,c,d,e){var f=a(c,d);if(f&&f.set)return f.set.call(b,e),e;throw i("super has no setter '"+d+"'.")}function e(a){for(var b={},c=p(a),d=0;d<c.length;d++){var e=c[d];b[e]=m(a,e)}for(var f=q(a),d=0;d<f.length;d++){var g=f[d];b[$traceurRuntime.toProperty(g)]=m(a,$traceurRuntime.toProperty(g))}return b}function f(a,b,c,d){return l(b,"constructor",{value:a,configurable:!0,enumerable:!1,writable:!0}),arguments.length>3?("function"==typeof d&&(a.__proto__=d),a.prototype=j(g(d),e(b))):a.prototype=b,l(a,"prototype",{configurable:!1,writable:!1}),k(a,e(c))}function g(a){if("function"==typeof a){var b=a.prototype;if(h(b)===b||null===b)return a.prototype;throw new i("super prototype must be an Object or null")}if(null===a)return null;throw new i("Super expression must either be null or a function, not "+typeof a+".")}var h=Object,i=TypeError,j=h.create,k=$traceurRuntime.defineProperties,l=$traceurRuntime.defineProperty,m=$traceurRuntime.getOwnPropertyDescriptor,n=($traceurRuntime.getOwnPropertyNames,Object.getPrototypeOf),o=Object,p=o.getOwnPropertyNames,q=o.getOwnPropertySymbols;return $traceurRuntime.createClass=f,$traceurRuntime.superConstructor=b,$traceurRuntime.superGet=c,$traceurRuntime.superSet=d,{}}),System.registerModule("traceur-runtime@0.0.84/src/runtime/destructuring.js",[],function(){"use strict";function a(a){for(var b,c=[],d=0;!(b=a.next()).done;)c[d++]=b.value;return c}return $traceurRuntime.iteratorToArray=a,{}}),System.registerModule("traceur-runtime@0.0.84/src/runtime/generators.js",[],function(){"use strict";function a(a){return{configurable:!0,enumerable:!1,value:a,writable:!0}}function b(a){return new Error("Traceur compiler bug: invalid state in state machine: "+a)}function c(){this.state=0,this.GState=r,this.storedException=void 0,this.finallyFallThrough=void 0,this.sent_=void 0,this.returnValue=void 0,this.oldReturnValue=void 0,this.tryStack_=[]}function d(a,b,c,d){switch(a.GState){case s:throw new Error('"'+c+'" on executing generator');case u:if("next"==c)return{value:void 0,done:!0};if(d===x)return{value:a.returnValue,done:!0};throw d;case r:if("throw"===c){if(a.GState=u,d===x)return{value:a.returnValue,done:!0};throw d}if(void 0!==d)throw q("Sent value to newborn generator");case t:a.GState=s,a.action=c,a.sent=d;var e;try{e=b(a)}catch(f){if(f!==x)throw f;e=a}var g=e===a;return g&&(e=a.returnValue),a.GState=g?u:t,{value:e,done:g}}}function e(){}function f(){}function g(a,b,d){var e=k(a,d),f=new c,g=p(b.prototype);return g[y]=f,g[z]=e,g}function h(a){return a.prototype=p(f.prototype),a.__proto__=f,a}function i(){c.call(this),this.err=void 0;var a=this;a.result=new Promise(function(b,c){a.resolve=b,a.reject=c})}function j(a,b){var c=k(a,b),d=new i;return d.createCallback=function(a){return function(b){d.state=a,d.value=b,c(d)}},d.errback=function(a){l(d,a),c(d)},c(d),d.result}function k(a,b){return function(c){for(;;)try{return a.call(b,c)}catch(d){l(c,d)}}}function l(a,b){a.storedException=b;var c=a.tryStack_[a.tryStack_.length-1];return c?(a.state=b!==x&&void 0!==c["catch"]?c["catch"]:c["finally"],void(void 0!==c.finallyFallThrough&&(a.finallyFallThrough=c.finallyFallThrough))):void a.handleException(b)}if("object"!=typeof $traceurRuntime)throw new Error("traceur runtime not found.");var m=$traceurRuntime.createPrivateName,n=$traceurRuntime.defineProperties,o=$traceurRuntime.defineProperty,p=Object.create,q=TypeError,r=0,s=1,t=2,u=3,v=-2,w=-3,x={};c.prototype={pushTry:function(a,b){if(null!==b){for(var c=null,d=this.tryStack_.length-1;d>=0;d--)if(void 0!==this.tryStack_[d]["catch"]){c=this.tryStack_[d]["catch"];break}null===c&&(c=w),this.tryStack_.push({"finally":b,finallyFallThrough:c})}null!==a&&this.tryStack_.push({"catch":a})},popTry:function(){this.tryStack_.pop()},get sent(){return this.maybeThrow(),this.sent_},set sent(a){this.sent_=a},get sentIgnoreThrow(){return this.sent_},maybeThrow:function(){if("throw"===this.action)throw this.action="next",this.sent_},end:function(){switch(this.state){case v:return this;case w:throw this.storedException;default:throw b(this.state)}},handleException:function(a){throw this.GState=u,this.state=v,a},wrapYieldStar:function(a){var b=this;return{next:function(b){return a.next(b)},"throw":function(c){var d;if(c===x){if(a["return"]){if(d=a["return"](b.returnValue),!d.done)return b.returnValue=b.oldReturnValue,d;b.returnValue=d.value}throw c}if(a["throw"])return a["throw"](c);throw a["return"]&&a["return"](),q("Inner iterator does not have a throw method")}}}};var y=m(),z=m();return e.prototype=f,o(f,"constructor",a(e)),f.prototype={constructor:f,next:function(a){return d(this[y],this[z],"next",a)},"throw":function(a){return d(this[y],this[z],"throw",a)},"return":function(a){return this[y].oldReturnValue=this[y].returnValue,this[y].returnValue=a,d(this[y],this[z],"throw",x)}},n(f.prototype,{constructor:{enumerable:!1},next:{enumerable:!1},"throw":{enumerable:!1},"return":{enumerable:!1}}),Object.defineProperty(f.prototype,Symbol.iterator,a(function(){return this})),i.prototype=p(c.prototype),i.prototype.end=function(){switch(this.state){case v:this.resolve(this.returnValue);break;case w:this.reject(this.storedException);break;default:this.reject(b(this.state))}},i.prototype.handleException=function(){this.state=w},$traceurRuntime.asyncWrap=j,$traceurRuntime.initGeneratorFunction=h,$traceurRuntime.createGeneratorInstance=g,{}}),System.registerModule("traceur-runtime@0.0.84/src/runtime/relativeRequire.js",[],function(){"use strict";function a(a,c){function d(a){return"/"===a.slice(-1)}function e(a){return"/"===a[0]}function f(a){return"."===a[0]}return b=b||"undefined"!=typeof require&&require("path"),d(c)||e(c)?void 0:require(f(c)?b.resolve(b.dirname(a),c):c)}var b;return $traceurRuntime.require=a,{}}),System.registerModule("traceur-runtime@0.0.84/src/runtime/spread.js",[],function(){"use strict";function a(){for(var a,b=[],c=0,d=0;d<arguments.length;d++){var e=$traceurRuntime.checkObjectCoercible(arguments[d]);if("function"!=typeof e[$traceurRuntime.toProperty(Symbol.iterator)])throw new TypeError("Cannot spread non-iterable object.");for(var f=e[$traceurRuntime.toProperty(Symbol.iterator)]();!(a=f.next()).done;)b[c++]=a.value}return b}return $traceurRuntime.spread=a,{}}),System.registerModule("traceur-runtime@0.0.84/src/runtime/type-assertions.js",[],function(){"use strict";function a(a){for(var b=[],e=1;e<arguments.length;e++)b[e-1]=arguments[e];var f=d,g=$traceurRuntime.getOwnHashObject(a).hash;f[g]||(f[g]=Object.create(null)),f=f[g];for(var h=0;h<b.length-1;h++)g=$traceurRuntime.getOwnHashObject(b[h]).hash,f[g]||(f[g]=Object.create(null)),f=f[g];var i=b[b.length-1];return g=$traceurRuntime.getOwnHashObject(i).hash,f[g]||(f[g]=new c(a,b)),f[g]}var b={any:{name:"any"},"boolean":{name:"boolean"},number:{name:"number"},string:{name:"string"},symbol:{name:"symbol"},"void":{name:"void"}},c=function(a,b){this.type=a,this.argumentTypes=b};$traceurRuntime.createClass(c,{},{});var d=Object.create(null);return $traceurRuntime.GenericType=c,$traceurRuntime.genericType=a,$traceurRuntime.type=b,{}}),System.registerModule("traceur-runtime@0.0.84/src/runtime/runtime-modules.js",[],function(){"use strict";return System.get("traceur-runtime@0.0.84/src/runtime/relativeRequire.js"),System.get("traceur-runtime@0.0.84/src/runtime/spread.js"),System.get("traceur-runtime@0.0.84/src/runtime/destructuring.js"),System.get("traceur-runtime@0.0.84/src/runtime/classes.js"),System.get("traceur-runtime@0.0.84/src/runtime/generators.js"),System.get("traceur-runtime@0.0.84/src/runtime/type-assertions.js"),{}}),System.get("traceur-runtime@0.0.84/src/runtime/runtime-modules.js"),System.registerModule("traceur-runtime@0.0.84/src/runtime/polyfills/utils.js",[],function(){"use strict";function a(a){return a>>>0}function b(a){return a&&("object"==typeof a||"function"==typeof a)}function c(a){return"function"==typeof a}function d(a){return"number"==typeof a}function e(a){return a=+a,u(a)?0:0!==a&&t(a)?a>0?s(a):r(a):a}function f(a){var b=e(a);return 0>b?0:w(b,y)}function g(a){return b(a)?a[Symbol.iterator]:void 0}function h(a){return c(a)}function i(a,b){return{value:a,done:b}}function j(a,b,c){b in a||Object.defineProperty(a,b,c)}function k(a,b,c){j(a,b,{value:c,configurable:!0,enumerable:!1,writable:!0})}function l(a,b,c){j(a,b,{value:c,configurable:!1,enumerable:!1,writable:!1})}function m(a,b){for(var c=0;c<b.length;c+=2){var d=b[c],e=b[c+1];k(a,d,e)}}function n(a,b){for(var c=0;c<b.length;c+=2){var d=b[c],e=b[c+1];l(a,d,e)}}function o(a,b,c){c&&c.iterator&&!a[c.iterator]&&(a["@@iterator"]&&(b=a["@@iterator"]),Object.defineProperty(a,c.iterator,{value:b,configurable:!0,enumerable:!1,writable:!0}))}function p(a){z.push(a)}function q(a){z.forEach(function(b){return b(a)})}var r=Math.ceil,s=Math.floor,t=isFinite,u=isNaN,v=Math.pow,w=Math.min,x=$traceurRuntime.toObject,y=v(2,53)-1,z=[];return{get toObject(){return x},get toUint32(){return a},get isObject(){return b},get isCallable(){return c},get isNumber(){return d},get toInteger(){return e},get toLength(){return f},get checkIterable(){return g},get isConstructor(){return h},get createIteratorResultObject(){return i},get maybeDefine(){return j},get maybeDefineMethod(){return k},get maybeDefineConst(){return l},get maybeAddFunctions(){return m},get maybeAddConsts(){return n},get maybeAddIterator(){return o},get registerPolyfill(){return p},get polyfillAll(){return q}}}),System.registerModule("traceur-runtime@0.0.84/src/runtime/polyfills/Map.js",[],function(){"use strict";function a(a,b){if(e(b)){var c=h(b);return c&&a.objectIndex_[c.hash]}return"string"==typeof b?a.stringIndex_[b]:a.primitiveIndex_[b]}function b(a){a.entries_=[],a.objectIndex_=Object.create(null),a.stringIndex_=Object.create(null),a.primitiveIndex_=Object.create(null),a.deletedCount_=0}function c(a){var b=a,c=b.Object,d=b.Symbol;a.Map||(a.Map=k);var e=a.Map.prototype;void 0===e.entries&&(a.Map=k),e.entries&&(f(e,e.entries,d),f(c.getPrototypeOf((new a.Map).entries()),function(){return this},d))}var d=System.get("traceur-runtime@0.0.84/src/runtime/polyfills/utils.js"),e=d.isObject,f=d.maybeAddIterator,g=d.registerPolyfill,h=$traceurRuntime.getOwnHashObject,i=Object.prototype.hasOwnProperty,j={},k=function(){var a,c,d=arguments[0];if(!e(this))throw new TypeError("Map called on incompatible type");if(i.call(this,"entries_"))throw new TypeError("Map can not be reentrantly initialised");if(b(this),null!==d&&void 0!==d)for(var f=d[$traceurRuntime.toProperty(Symbol.iterator)](),g=void 0;!(g=f.next()).done;){var h=g.value,j=(a=h[$traceurRuntime.toProperty(Symbol.iterator)](),(c=a.next()).done?void 0:c.value),k=(c=a.next()).done?void 0:c.value;this.set(j,k)}};return $traceurRuntime.createClass(k,{get size(){return this.entries_.length/2-this.deletedCount_},get:function(b){var c=a(this,b);return void 0!==c?this.entries_[c+1]:void 0},set:function(b,c){var d=e(b),f="string"==typeof b,g=a(this,b);if(void 0!==g)this.entries_[g+1]=c;else if(g=this.entries_.length,this.entries_[g]=b,this.entries_[g+1]=c,d){var i=h(b),j=i.hash;this.objectIndex_[j]=g}else f?this.stringIndex_[b]=g:this.primitiveIndex_[b]=g;return this},has:function(b){return void 0!==a(this,b)},"delete":function(a){var b,c,d=e(a),f="string"==typeof a;if(d){var g=h(a);g&&(b=this.objectIndex_[c=g.hash],delete this.objectIndex_[c])}else f?(b=this.stringIndex_[a],delete this.stringIndex_[a]):(b=this.primitiveIndex_[a],delete this.primitiveIndex_[a]);return void 0!==b?(this.entries_[b]=j,this.entries_[b+1]=void 0,this.deletedCount_++,!0):!1},clear:function(){b(this)},forEach:function(a){for(var b=arguments[1],c=0;c<this.entries_.length;c+=2){var d=this.entries_[c],e=this.entries_[c+1];d!==j&&a.call(b,e,d,this)}},entries:$traceurRuntime.initGeneratorFunction(function l(){var a,b,c;return $traceurRuntime.createGeneratorInstance(function(d){for(;;)switch(d.state){case 0:a=0,d.state=12;break;case 12:d.state=a<this.entries_.length?8:-2;break;case 4:a+=2,d.state=12;break;case 8:b=this.entries_[a],c=this.entries_[a+1],d.state=9;break;case 9:d.state=b===j?4:6;break;case 6:return d.state=2,[b,c];case 2:d.maybeThrow(),d.state=4;break;default:return d.end()}},l,this)}),keys:$traceurRuntime.initGeneratorFunction(function m(){var a,b,c;return $traceurRuntime.createGeneratorInstance(function(d){for(;;)switch(d.state){case 0:a=0,d.state=12;break;case 12:d.state=a<this.entries_.length?8:-2;break;case 4:a+=2,d.state=12;break;case 8:b=this.entries_[a],c=this.entries_[a+1],d.state=9;break;case 9:d.state=b===j?4:6;break;case 6:return d.state=2,b;case 2:d.maybeThrow(),d.state=4;break;default:return d.end()}},m,this)}),values:$traceurRuntime.initGeneratorFunction(function n(){var a,b,c;return $traceurRuntime.createGeneratorInstance(function(d){for(;;)switch(d.state){case 0:a=0,d.state=12;break;case 12:d.state=a<this.entries_.length?8:-2;break;case 4:a+=2,d.state=12;break;case 8:b=this.entries_[a],c=this.entries_[a+1],d.state=9;break;case 9:d.state=b===j?4:6;break;case 6:return d.state=2,c;case 2:d.maybeThrow(),d.state=4;break;default:return d.end()}},n,this)})},{}),Object.defineProperty(k.prototype,Symbol.iterator,{configurable:!0,writable:!0,value:k.prototype.entries}),g(c),{get Map(){return k},get polyfillMap(){return c}}}),System.get("traceur-runtime@0.0.84/src/runtime/polyfills/Map.js"),System.registerModule("traceur-runtime@0.0.84/src/runtime/polyfills/Set.js",[],function(){"use strict";function a(a){a.map_=new g}function b(a){var b=a,c=b.Object,d=b.Symbol;a.Set||(a.Set=i);var f=a.Set.prototype;f.values&&(e(f,f.values,d),e(c.getPrototypeOf((new a.Set).values()),function(){return this},d))}var c=System.get("traceur-runtime@0.0.84/src/runtime/polyfills/utils.js"),d=c.isObject,e=c.maybeAddIterator,f=c.registerPolyfill,g=System.get("traceur-runtime@0.0.84/src/runtime/polyfills/Map.js").Map,h=($traceurRuntime.getOwnHashObject,Object.prototype.hasOwnProperty),i=function(){var b=arguments[0];if(!d(this))throw new TypeError("Set called on incompatible type");if(h.call(this,"map_"))throw new TypeError("Set can not be reentrantly initialised");if(a(this),null!==b&&void 0!==b)for(var c=b[$traceurRuntime.toProperty(Symbol.iterator)](),e=void 0;!(e=c.next()).done;){var f=e.value;this.add(f)}};return $traceurRuntime.createClass(i,{get size(){return this.map_.size},has:function(a){return this.map_.has(a)},add:function(a){return this.map_.set(a,a),this},"delete":function(a){return this.map_["delete"](a)},clear:function(){return this.map_.clear()},forEach:function(a){var b=arguments[1],c=this;return this.map_.forEach(function(d,e){a.call(b,e,e,c)})},values:$traceurRuntime.initGeneratorFunction(function j(){var a,b;return $traceurRuntime.createGeneratorInstance(function(c){for(;;)switch(c.state){case 0:a=c.wrapYieldStar(this.map_.keys()[Symbol.iterator]()),c.sent=void 0,c.action="next",c.state=12;break;case 12:b=a[c.action](c.sentIgnoreThrow),c.state=9;break;case 9:c.state=b.done?3:2;break;case 3:c.sent=b.value,c.state=-2;break;case 2:return c.state=12,b.value;default:return c.end()}},j,this)}),entries:$traceurRuntime.initGeneratorFunction(function k(){var a,b;return $traceurRuntime.createGeneratorInstance(function(c){for(;;)switch(c.state){case 0:a=c.wrapYieldStar(this.map_.entries()[Symbol.iterator]()),c.sent=void 0,c.action="next",c.state=12;break;case 12:b=a[c.action](c.sentIgnoreThrow),c.state=9;break;case 9:c.state=b.done?3:2;break;case 3:c.sent=b.value,c.state=-2;break;case 2:return c.state=12,b.value;default:return c.end()}},k,this)})},{}),Object.defineProperty(i.prototype,Symbol.iterator,{configurable:!0,writable:!0,value:i.prototype.values}),Object.defineProperty(i.prototype,"keys",{configurable:!0,writable:!0,value:i.prototype.values}),f(b),{get Set(){return i},get polyfillSet(){return b}}}),System.get("traceur-runtime@0.0.84/src/runtime/polyfills/Set.js"),System.registerModule("traceur-runtime@0.0.84/node_modules/rsvp/lib/rsvp/asap.js",[],function(){"use strict";function a(a,b){m[h]=a,m[h+1]=b,h+=2,2===h&&g()}function b(){return function(){process.nextTick(f)}}function c(){var a=0,b=new k(f),c=document.createTextNode("");return b.observe(c,{characterData:!0}),function(){c.data=a=++a%2}}function d(){var a=new MessageChannel;return a.port1.onmessage=f,function(){a.port2.postMessage(0)}}function e(){return function(){setTimeout(f,1)}}function f(){for(var a=0;h>a;a+=2){var b=m[a],c=m[a+1];b(c),m[a]=void 0,m[a+1]=void 0}h=0}var g,h=0,i=a,j="undefined"!=typeof window?window:{},k=j.MutationObserver||j.WebKitMutationObserver,l="undefined"!=typeof Uint8ClampedArray&&"undefined"!=typeof importScripts&&"undefined"!=typeof MessageChannel,m=new Array(1e3);return g="undefined"!=typeof process&&"[object process]"==={}.toString.call(process)?b():k?c():l?d():e(),{get default(){return i}}}),System.registerModule("traceur-runtime@0.0.84/src/runtime/polyfills/Promise.js",[],function(){"use strict";function a(a){return a&&"object"==typeof a&&void 0!==a.status_}function b(a){return a}function c(a){throw a}function d(a){var d=void 0!==arguments[1]?arguments[1]:b,f=void 0!==arguments[2]?arguments[2]:c,g=e(a.constructor);switch(a.status_){case void 0:throw TypeError;case 0:a.onResolve_.push(d,g),a.onReject_.push(f,g);break;case 1:k(a.value_,[d,g]);break;case-1:k(a.value_,[f,g])}return g.promise}function e(a){if(this===t){var b=g(new t(r));return{promise:b,resolve:function(a){h(b,a)},reject:function(a){i(b,a)}}}var c={};return c.promise=new a(function(a,b){c.resolve=a,c.reject=b}),c}function f(a,b,c,d,e){return a.status_=b,a.value_=c,a.onResolve_=d,a.onReject_=e,a}function g(a){return f(a,0,void 0,[],[])}function h(a,b){j(a,1,b,a.onResolve_)}function i(a,b){j(a,-1,b,a.onReject_)}function j(a,b,c,d){0===a.status_&&(k(c,d),f(a,b,c))}function k(a,b){p(function(){for(var c=0;c<b.length;c+=2)l(a,b[c],b[c+1])})}function l(b,c,e){try{var f=c(b);if(f===e.promise)throw new TypeError;a(f)?d(f,e.resolve,e.reject):e.resolve(f)}catch(g){try{e.reject(g)}catch(g){}}}function m(a){return a&&("object"==typeof a||"function"==typeof a)}function n(b,c){if(!a(c)&&m(c)){var d;try{d=c.then}catch(f){var g=u.call(b,f);return c[v]=g,g}if("function"==typeof d){var h=c[v];if(h)return h;var i=e(b);c[v]=i.promise;try{d.call(c,i.resolve,i.reject)}catch(f){i.reject(f)}return i.promise}}return c}function o(a){a.Promise||(a.Promise=s)}var p=System.get("traceur-runtime@0.0.84/node_modules/rsvp/lib/rsvp/asap.js")["default"],q=System.get("traceur-runtime@0.0.84/src/runtime/polyfills/utils.js").registerPolyfill,r={},s=function(a){if(a!==r){if("function"!=typeof a)throw new TypeError;var b=g(this);try{a(function(a){h(b,a)},function(a){i(b,a)})}catch(c){i(b,c)}}};$traceurRuntime.createClass(s,{"catch":function(a){return this.then(void 0,a)},then:function(e,f){"function"!=typeof e&&(e=b),"function"!=typeof f&&(f=c);var g=this,h=this.constructor;return d(this,function(b){return b=n(h,b),b===g?f(new TypeError):a(b)?b.then(e,f):e(b)},f)}},{resolve:function(b){return this===t?a(b)?b:f(new t(r),1,b):new this(function(a){a(b)})},reject:function(a){return this===t?f(new t(r),-1,a):new this(function(b,c){c(a)})},all:function(a){var b=e(this),c=[];try{for(var d=function(a){return function(d){c[a]=d,0===--f&&b.resolve(c)}},f=0,g=0,h=a[$traceurRuntime.toProperty(Symbol.iterator)](),i=void 0;!(i=h.next()).done;){var j=i.value,k=d(g);this.resolve(j).then(k,function(a){b.reject(a)}),++g,++f}0===f&&b.resolve(c)}catch(l){b.reject(l)}return b.promise},race:function(a){var b=e(this);try{for(var c=0;c<a.length;c++)this.resolve(a[c]).then(function(a){b.resolve(a)},function(a){b.reject(a)})}catch(d){b.reject(d)}return b.promise}});var t=s,u=t.reject,v="@@thenable";return q(o),{get Promise(){return s},get polyfillPromise(){return o}}}),System.get("traceur-runtime@0.0.84/src/runtime/polyfills/Promise.js"),System.registerModule("traceur-runtime@0.0.84/src/runtime/polyfills/StringIterator.js",[],function(){"use strict";function a(a){var b=String(a),c=Object.create(j.prototype);return c[f(h)]=b,c[f(i)]=0,c}var b,c=System.get("traceur-runtime@0.0.84/src/runtime/polyfills/utils.js"),d=c.createIteratorResultObject,e=c.isObject,f=$traceurRuntime.toProperty,g=Object.prototype.hasOwnProperty,h=Symbol("iteratedString"),i=Symbol("stringIteratorNextIndex"),j=function(){};return $traceurRuntime.createClass(j,(b={},Object.defineProperty(b,"next",{value:function(){var a=this;if(!e(a)||!g.call(a,h))throw new TypeError("this must be a StringIterator object");var b=a[f(h)];if(void 0===b)return d(void 0,!0);var c=a[f(i)],j=b.length;if(c>=j)return a[f(h)]=void 0,d(void 0,!0);var k,l=b.charCodeAt(c);if(55296>l||l>56319||c+1===j)k=String.fromCharCode(l);else{var m=b.charCodeAt(c+1);k=56320>m||m>57343?String.fromCharCode(l):String.fromCharCode(l)+String.fromCharCode(m)}return a[f(i)]=c+k.length,d(k,!1)},configurable:!0,enumerable:!0,writable:!0}),Object.defineProperty(b,Symbol.iterator,{value:function(){return this},configurable:!0,enumerable:!0,writable:!0}),b),{}),{get createStringIterator(){return a}}}),System.registerModule("traceur-runtime@0.0.84/src/runtime/polyfills/String.js",[],function(){"use strict";function a(a){var b=String(this);if(null==this||"[object RegExp]"==o.call(a))throw TypeError();var c=b.length,d=String(a),e=(d.length,arguments.length>1?arguments[1]:void 0),f=e?Number(e):0;isNaN(f)&&(f=0);var g=Math.min(Math.max(f,0),c);return p.call(b,d,f)==g}function b(a){var b=String(this);if(null==this||"[object RegExp]"==o.call(a))throw TypeError();var c=b.length,d=String(a),e=d.length,f=c;if(arguments.length>1){var g=arguments[1];void 0!==g&&(f=g?Number(g):0,isNaN(f)&&(f=0))}var h=Math.min(Math.max(f,0),c),i=h-e;return 0>i?!1:q.call(b,d,i)==i}function c(a){if(null==this)throw TypeError();var b=String(this);if(a&&"[object RegExp]"==o.call(a))throw TypeError();var c=b.length,d=String(a),e=d.length,f=arguments.length>1?arguments[1]:void 0,g=f?Number(f):0;g!=g&&(g=0);var h=Math.min(Math.max(g,0),c);return e+h>c?!1:-1!=p.call(b,d,g)}function d(a){if(null==this)throw TypeError();var b=String(this),c=a?Number(a):0;if(isNaN(c)&&(c=0),0>c||1/0==c)throw RangeError();if(0==c)return"";for(var d="";c--;)d+=b;return d}function e(a){if(null==this)throw TypeError();var b=String(this),c=b.length,d=a?Number(a):0;if(isNaN(d)&&(d=0),0>d||d>=c)return void 0;var e,f=b.charCodeAt(d);return f>=55296&&56319>=f&&c>d+1&&(e=b.charCodeAt(d+1),e>=56320&&57343>=e)?1024*(f-55296)+e-56320+65536:f}function f(a){var b=a.raw,c=b.length>>>0;if(0===c)return"";for(var d="",e=0;;){if(d+=b[e],e+1===c)return d;d+=arguments[++e]}}function g(){var a,b,c=[],d=Math.floor,e=-1,f=arguments.length;if(!f)return"";for(;++e<f;){var g=Number(arguments[e]);if(!isFinite(g)||0>g||g>1114111||d(g)!=g)throw RangeError("Invalid code point: "+g);65535>=g?c.push(g):(g-=65536,a=(g>>10)+55296,b=g%1024+56320,c.push(a,b))}return String.fromCharCode.apply(null,c)}function h(){var a=$traceurRuntime.checkObjectCoercible(this),b=String(a);return j(b)
}function i(i){var j=i.String;l(j.prototype,["codePointAt",e,"endsWith",b,"includes",c,"repeat",d,"startsWith",a]),l(j,["fromCodePoint",g,"raw",f]),m(j.prototype,h,Symbol)}var j=System.get("traceur-runtime@0.0.84/src/runtime/polyfills/StringIterator.js").createStringIterator,k=System.get("traceur-runtime@0.0.84/src/runtime/polyfills/utils.js"),l=k.maybeAddFunctions,m=k.maybeAddIterator,n=k.registerPolyfill,o=Object.prototype.toString,p=String.prototype.indexOf,q=String.prototype.lastIndexOf;return n(i),{get startsWith(){return a},get endsWith(){return b},get includes(){return c},get repeat(){return d},get codePointAt(){return e},get raw(){return f},get fromCodePoint(){return g},get stringPrototypeIterator(){return h},get polyfillString(){return i}}}),System.get("traceur-runtime@0.0.84/src/runtime/polyfills/String.js"),System.registerModule("traceur-runtime@0.0.84/src/runtime/polyfills/ArrayIterator.js",[],function(){"use strict";function a(a,b){var c=g(a),d=new m;return d.iteratorObject_=c,d.arrayIteratorNextIndex_=0,d.arrayIterationKind_=b,d}function b(){return a(this,l)}function c(){return a(this,j)}function d(){return a(this,k)}var e,f=System.get("traceur-runtime@0.0.84/src/runtime/polyfills/utils.js"),g=f.toObject,h=f.toUint32,i=f.createIteratorResultObject,j=1,k=2,l=3,m=function(){};return $traceurRuntime.createClass(m,(e={},Object.defineProperty(e,"next",{value:function(){var a=g(this),b=a.iteratorObject_;if(!b)throw new TypeError("Object is not an ArrayIterator");var c=a.arrayIteratorNextIndex_,d=a.arrayIterationKind_,e=h(b.length);return c>=e?(a.arrayIteratorNextIndex_=1/0,i(void 0,!0)):(a.arrayIteratorNextIndex_=c+1,d==k?i(b[c],!1):d==l?i([c,b[c]],!1):i(c,!1))},configurable:!0,enumerable:!0,writable:!0}),Object.defineProperty(e,Symbol.iterator,{value:function(){return this},configurable:!0,enumerable:!0,writable:!0}),e),{}),{get entries(){return b},get keys(){return c},get values(){return d}}}),System.registerModule("traceur-runtime@0.0.84/src/runtime/polyfills/Array.js",[],function(){"use strict";function a(a){var b,c,d=arguments[1],e=arguments[2],f=this,g=u(a),h=void 0!==d,i=0;if(h&&!n(d))throw TypeError();if(m(g)){b=o(f)?new f:[];for(var j=g[$traceurRuntime.toProperty(Symbol.iterator)](),k=void 0;!(k=j.next()).done;){var l=k.value;b[i]=h?d.call(e,l,i):l,i++}return b.length=i,b}for(c=t(g.length),b=o(f)?new f(c):new Array(c);c>i;i++)b[i]=h?"undefined"==typeof e?d(g[i],i):d.call(e,g[i],i):g[i];return b.length=c,b}function b(){for(var a=[],b=0;b<arguments.length;b++)a[b]=arguments[b];for(var c=this,d=a.length,e=o(c)?new c(d):new Array(d),f=0;d>f;f++)e[f]=a[f];return e.length=d,e}function c(a){var b=void 0!==arguments[1]?arguments[1]:0,c=arguments[2],d=u(this),e=t(d.length),f=s(b),g=void 0!==c?s(c):e;for(f=0>f?Math.max(e+f,0):Math.min(f,e),g=0>g?Math.max(e+g,0):Math.min(g,e);g>f;)d[f]=a,f++;return d}function d(a){var b=arguments[1];return f(this,a,b)}function e(a){var b=arguments[1];return f(this,a,b,!0)}function f(a,b){var c=arguments[2],d=void 0!==arguments[3]?arguments[3]:!1,e=u(a),f=t(e.length);if(!n(b))throw TypeError();for(var g=0;f>g;g++){var h=e[g];if(b.call(c,h,g,e))return d?g:h}return d?-1:void 0}function g(f){var g=f,h=g.Array,l=g.Object,m=g.Symbol;p(h.prototype,["entries",i,"keys",j,"values",k,"fill",c,"find",d,"findIndex",e]),p(h,["from",a,"of",b]),q(h.prototype,k,m),q(l.getPrototypeOf([].values()),function(){return this},m)}var h=System.get("traceur-runtime@0.0.84/src/runtime/polyfills/ArrayIterator.js"),i=h.entries,j=h.keys,k=h.values,l=System.get("traceur-runtime@0.0.84/src/runtime/polyfills/utils.js"),m=l.checkIterable,n=l.isCallable,o=l.isConstructor,p=l.maybeAddFunctions,q=l.maybeAddIterator,r=l.registerPolyfill,s=l.toInteger,t=l.toLength,u=l.toObject;return r(g),{get from(){return a},get of(){return b},get fill(){return c},get find(){return d},get findIndex(){return e},get polyfillArray(){return g}}}),System.get("traceur-runtime@0.0.84/src/runtime/polyfills/Array.js"),System.registerModule("traceur-runtime@0.0.84/src/runtime/polyfills/Object.js",[],function(){"use strict";function a(a,b){return a===b?0!==a||1/a===1/b:a!==a&&b!==b}function b(a){for(var b=1;b<arguments.length;b++){var c=arguments[b],d=null==c?[]:m(c),e=void 0,f=d.length;for(e=0;f>e;e++){var g=d[e];l(g)||(a[g]=c[g])}}return a}function c(a,b){var c,d,e=k(b),f=e.length;for(c=0;f>c;c++){var g=e[c];l(g)||(d=j(b,e[c]),i(a,e[c],d))}return a}function d(d){var e=d.Object;f(e,["assign",b,"is",a,"mixin",c])}var e=System.get("traceur-runtime@0.0.84/src/runtime/polyfills/utils.js"),f=e.maybeAddFunctions,g=e.registerPolyfill,h=$traceurRuntime,i=h.defineProperty,j=h.getOwnPropertyDescriptor,k=h.getOwnPropertyNames,l=h.isPrivateName,m=h.keys;return g(d),{get is(){return a},get assign(){return b},get mixin(){return c},get polyfillObject(){return d}}}),System.get("traceur-runtime@0.0.84/src/runtime/polyfills/Object.js"),System.registerModule("traceur-runtime@0.0.84/src/runtime/polyfills/Number.js",[],function(){"use strict";function a(a){return g(a)&&m(a)}function b(b){return a(b)&&k(b)===b}function c(a){return g(a)&&n(a)}function d(b){if(a(b)){var c=k(b);if(c===b)return l(c)<=o}return!1}function e(e){var f=e.Number;h(f,["MAX_SAFE_INTEGER",o,"MIN_SAFE_INTEGER",p,"EPSILON",q]),i(f,["isFinite",a,"isInteger",b,"isNaN",c,"isSafeInteger",d])}var f=System.get("traceur-runtime@0.0.84/src/runtime/polyfills/utils.js"),g=f.isNumber,h=f.maybeAddConsts,i=f.maybeAddFunctions,j=f.registerPolyfill,k=f.toInteger,l=Math.abs,m=isFinite,n=isNaN,o=Math.pow(2,53)-1,p=-Math.pow(2,53)+1,q=Math.pow(2,-52);return j(e),{get MAX_SAFE_INTEGER(){return o},get MIN_SAFE_INTEGER(){return p},get EPSILON(){return q},get isFinite(){return a},get isInteger(){return b},get isNaN(){return c},get isSafeInteger(){return d},get polyfillNumber(){return e}}}),System.get("traceur-runtime@0.0.84/src/runtime/polyfills/Number.js"),System.registerModule("traceur-runtime@0.0.84/src/runtime/polyfills/Math.js",[],function(){"use strict";function a(a){if(a=v(+a),0==a)return 32;var b=0;return 0===(4294901760&a)&&(a<<=16,b+=16),0===(4278190080&a)&&(a<<=8,b+=8),0===(4026531840&a)&&(a<<=4,b+=4),0===(3221225472&a)&&(a<<=2,b+=2),0===(2147483648&a)&&(a<<=1,b+=1),b}function b(a,b){a=v(+a),b=v(+b);var c=a>>>16&65535,d=65535&a,e=b>>>16&65535,f=65535&b;return d*f+(c*f+d*e<<16>>>0)|0}function c(a){return a=+a,a>0?1:0>a?-1:a}function d(a){return.4342944819032518*D(a)}function e(a){return 1.4426950408889634*D(a)}function f(a){if(a=+a,-1>a||x(a))return 0/0;if(0===a||1/0===a)return a;if(-1===a)return-1/0;var b=0,c=50;if(0>a||a>1)return D(1+a);for(var d=1;c>d;d++)d%2===0?b-=E(a,d)/d:b+=E(a,d)/d;return b}function g(a){return a=+a,a===-1/0?-1:w(a)&&0!==a?B(a)-1:a}function h(a){return a=+a,0===a?1:x(a)?0/0:w(a)?(0>a&&(a=-a),a>21?B(a)/2:(B(a)+B(-a))/2):1/0}function i(a){return a=+a,w(a)&&0!==a?(B(a)-B(-a))/2:a}function j(a){if(a=+a,0===a)return a;if(!w(a))return c(a);var b=B(a),d=B(-a);return(b-d)/(b+d)}function k(a){return a=+a,1>a?0/0:w(a)?D(a+F(a+1)*F(a-1)):a}function l(a){return a=+a,0!==a&&w(a)?a>0?D(a+F(a*a+1)):-D(-a+F(a*a+1)):a}function m(a){return a=+a,-1===a?-1/0:1===a?1/0:0===a?a:x(a)||-1>a||a>1?0/0:.5*D((1+a)/(1-a))}function n(){for(var a=arguments.length,b=new Array(a),c=0,d=0;a>d;d++){var e=arguments[d];if(e=+e,1/0===e||e===-1/0)return 1/0;e=z(e),e>c&&(c=e),b[d]=e}0===c&&(c=1);for(var f=0,g=0,d=0;a>d;d++){var e=b[d]/c,h=e*e-g,i=f+h;g=i-f-h,f=i}return F(f)*c}function o(a){return a=+a,a>0?C(a):0>a?A(a):a}function p(a){return G[0]=+a,G[0]}function q(a){if(a=+a,0===a)return a;var b=0>a;b&&(a=-a);var c=E(a,1/3);return b?-c:c}function r(r){var s=r.Math;t(s,["acosh",k,"asinh",l,"atanh",m,"cbrt",q,"clz32",a,"cosh",h,"expm1",g,"fround",p,"hypot",n,"imul",b,"log10",d,"log1p",f,"log2",e,"sign",c,"sinh",i,"tanh",j,"trunc",o])}var s=System.get("traceur-runtime@0.0.84/src/runtime/polyfills/utils.js"),t=s.maybeAddFunctions,u=s.registerPolyfill,v=s.toUint32,w=isFinite,x=isNaN,y=Math,z=y.abs,A=y.ceil,B=y.exp,C=y.floor,D=y.log,E=y.pow,F=y.sqrt,G=new Float32Array(1);return u(r),{get clz32(){return a},get imul(){return b},get sign(){return c},get log10(){return d},get log2(){return e},get log1p(){return f},get expm1(){return g},get cosh(){return h},get sinh(){return i},get tanh(){return j},get acosh(){return k},get asinh(){return l},get atanh(){return m},get hypot(){return n},get trunc(){return o},get fround(){return p},get cbrt(){return q},get polyfillMath(){return r}}}),System.get("traceur-runtime@0.0.84/src/runtime/polyfills/Math.js"),System.registerModule("traceur-runtime@0.0.84/src/runtime/polyfills/polyfills.js",[],function(){"use strict";var a=System.get("traceur-runtime@0.0.84/src/runtime/polyfills/utils.js").polyfillAll;a(Reflect.global);var b=$traceurRuntime.setupGlobals;return $traceurRuntime.setupGlobals=function(c){b(c),a(c)},{}}),System.get("traceur-runtime@0.0.84/src/runtime/polyfills/polyfills.js");
//# sourceMappingURL=traceur-runtime.js.map"format register";
(function(global) {

  var defined = {};

  // indexOf polyfill for IE8
  var indexOf = Array.prototype.indexOf || function(item) {
    for (var i = 0, l = this.length; i < l; i++)
      if (this[i] === item)
        return i;
    return -1;
  }

  function dedupe(deps) {
    var newDeps = [];
    for (var i = 0, l = deps.length; i < l; i++)
      if (indexOf.call(newDeps, deps[i]) == -1)
        newDeps.push(deps[i])
    return newDeps;
  }

  function register(name, deps, declare, execute) {
    if (typeof name != 'string')
      throw "System.register provided no module name";
    
    var entry;

    // dynamic
    if (typeof declare == 'boolean') {
      entry = {
        declarative: false,
        deps: deps,
        execute: execute,
        executingRequire: declare
      };
    }
    else {
      // ES6 declarative
      entry = {
        declarative: true,
        deps: deps,
        declare: declare
      };
    }

    entry.name = name;
    
    // we never overwrite an existing define
    if (!defined[name])
      defined[name] = entry; 

    entry.deps = dedupe(entry.deps);

    // we have to normalize dependencies
    // (assume dependencies are normalized for now)
    // entry.normalizedDeps = entry.deps.map(normalize);
    entry.normalizedDeps = entry.deps;
  }

  function buildGroups(entry, groups) {
    groups[entry.groupIndex] = groups[entry.groupIndex] || [];

    if (indexOf.call(groups[entry.groupIndex], entry) != -1)
      return;

    groups[entry.groupIndex].push(entry);

    for (var i = 0, l = entry.normalizedDeps.length; i < l; i++) {
      var depName = entry.normalizedDeps[i];
      var depEntry = defined[depName];
      
      // not in the registry means already linked / ES6
      if (!depEntry || depEntry.evaluated)
        continue;
      
      // now we know the entry is in our unlinked linkage group
      var depGroupIndex = entry.groupIndex + (depEntry.declarative != entry.declarative);

      // the group index of an entry is always the maximum
      if (depEntry.groupIndex === undefined || depEntry.groupIndex < depGroupIndex) {
        
        // if already in a group, remove from the old group
        if (depEntry.groupIndex !== undefined) {
          groups[depEntry.groupIndex].splice(indexOf.call(groups[depEntry.groupIndex], depEntry), 1);

          // if the old group is empty, then we have a mixed depndency cycle
          if (groups[depEntry.groupIndex].length == 0)
            throw new TypeError("Mixed dependency cycle detected");
        }

        depEntry.groupIndex = depGroupIndex;
      }

      buildGroups(depEntry, groups);
    }
  }

  function link(name) {
    var startEntry = defined[name];

    startEntry.groupIndex = 0;

    var groups = [];

    buildGroups(startEntry, groups);

    var curGroupDeclarative = !!startEntry.declarative == groups.length % 2;
    for (var i = groups.length - 1; i >= 0; i--) {
      var group = groups[i];
      for (var j = 0; j < group.length; j++) {
        var entry = group[j];

        // link each group
        if (curGroupDeclarative)
          linkDeclarativeModule(entry);
        else
          linkDynamicModule(entry);
      }
      curGroupDeclarative = !curGroupDeclarative; 
    }
  }

  // module binding records
  var moduleRecords = {};
  function getOrCreateModuleRecord(name) {
    return moduleRecords[name] || (moduleRecords[name] = {
      name: name,
      dependencies: [],
      exports: {}, // start from an empty module and extend
      importers: []
    })
  }

  function linkDeclarativeModule(entry) {
    // only link if already not already started linking (stops at circular)
    if (entry.module)
      return;

    var module = entry.module = getOrCreateModuleRecord(entry.name);
    var exports = entry.module.exports;

    var declaration = entry.declare.call(global, function(name, value) {
      module.locked = true;
      exports[name] = value;

      for (var i = 0, l = module.importers.length; i < l; i++) {
        var importerModule = module.importers[i];
        if (!importerModule.locked) {
          var importerIndex = indexOf.call(importerModule.dependencies, module);
          importerModule.setters[importerIndex](exports);
        }
      }

      module.locked = false;
      return value;
    });
    
    module.setters = declaration.setters;
    module.execute = declaration.execute;

    if (!module.setters || !module.execute)
      throw new TypeError("Invalid System.register form for " + entry.name);

    // now link all the module dependencies
    for (var i = 0, l = entry.normalizedDeps.length; i < l; i++) {
      var depName = entry.normalizedDeps[i];
      var depEntry = defined[depName];
      var depModule = moduleRecords[depName];

      // work out how to set depExports based on scenarios...
      var depExports;

      if (depModule) {
        depExports = depModule.exports;
      }
      else if (depEntry && !depEntry.declarative) {
        depExports = { 'default': depEntry.module.exports, __useDefault: true };
      }
      // in the module registry
      else if (!depEntry) {
        depExports = load(depName);
      }
      // we have an entry -> link
      else {
        linkDeclarativeModule(depEntry);
        depModule = depEntry.module;
        depExports = depModule.exports;
      }

      // only declarative modules have dynamic bindings
      if (depModule && depModule.importers) {
        depModule.importers.push(module);
        module.dependencies.push(depModule);
      }
      else
        module.dependencies.push(null);

      // run the setter for this dependency
      if (module.setters[i])
        module.setters[i](depExports);
    }
  }

  // An analog to loader.get covering execution of all three layers (real declarative, simulated declarative, simulated dynamic)
  function getModule(name) {
    var exports;
    var entry = defined[name];

    if (!entry) {
      exports = load(name);
      if (!exports)
        throw new Error("Unable to load dependency " + name + ".");
    }

    else {
      if (entry.declarative)
        ensureEvaluated(name, []);
    
      else if (!entry.evaluated)
        linkDynamicModule(entry);

      exports = entry.module.exports;
    }

    if ((!entry || entry.declarative) && exports && exports.__useDefault)
      return exports['default'];

    return exports;
  }

  function linkDynamicModule(entry) {
    if (entry.module)
      return;

    var exports = {};

    var module = entry.module = { exports: exports, id: entry.name };

    // AMD requires execute the tree first
    if (!entry.executingRequire) {
      for (var i = 0, l = entry.normalizedDeps.length; i < l; i++) {
        var depName = entry.normalizedDeps[i];
        var depEntry = defined[depName];
        if (depEntry)
          linkDynamicModule(depEntry);
      }
    }

    // now execute
    entry.evaluated = true;
    var output = entry.execute.call(global, function(name) {
      for (var i = 0, l = entry.deps.length; i < l; i++) {
        if (entry.deps[i] != name)
          continue;
        return getModule(entry.normalizedDeps[i]);
      }
      throw new TypeError('Module ' + name + ' not declared as a dependency.');
    }, exports, module);
    
    if (output)
      module.exports = output;
  }

  /*
   * Given a module, and the list of modules for this current branch,
   *  ensure that each of the dependencies of this module is evaluated
   *  (unless one is a circular dependency already in the list of seen
   *  modules, in which case we execute it)
   *
   * Then we evaluate the module itself depth-first left to right 
   * execution to match ES6 modules
   */
  function ensureEvaluated(moduleName, seen) {
    var entry = defined[moduleName];

    // if already seen, that means it's an already-evaluated non circular dependency
    if (entry.evaluated || !entry.declarative)
      return;

    // this only applies to declarative modules which late-execute

    seen.push(moduleName);

    for (var i = 0, l = entry.normalizedDeps.length; i < l; i++) {
      var depName = entry.normalizedDeps[i];
      if (indexOf.call(seen, depName) == -1) {
        if (!defined[depName])
          load(depName);
        else
          ensureEvaluated(depName, seen);
      }
    }

    if (entry.evaluated)
      return;

    entry.evaluated = true;
    entry.module.execute.call(global);
  }

  // magical execution function
  var modules = {};
  function load(name) {
    if (modules[name])
      return modules[name];

    var entry = defined[name];

    // first we check if this module has already been defined in the registry
    if (!entry)
      throw "Module " + name + " not present.";

    // recursively ensure that the module and all its 
    // dependencies are linked (with dependency group handling)
    link(name);

    // now handle dependency execution in correct order
    ensureEvaluated(name, []);

    // remove from the registry
    defined[name] = undefined;

    var module = entry.declarative ? entry.module.exports : { 'default': entry.module.exports, '__useDefault': true };

    // return the defined module object
    return modules[name] = module;
  };

  return function(main, declare) {

    var System;

    // if there's a system loader, define onto it
    if (typeof System != 'undefined' && System.register) {
      declare(System);
      System['import'](main);
    }
    // otherwise, self execute
    else {
      declare(System = {
        register: register, 
        get: load, 
        set: function(name, module) {
          modules[name] = module; 
        },
        newModule: function(module) {
          return module;
        },
        global: global 
      });
      System.set('@empty', System.newModule({}));
      load(main);
    }
  };

})(typeof window != 'undefined' ? window : global)
/* ('mainModule', function(System) {
  System.register(...);
}); */

('app/main.jsx!github:floatdrop/plugin-jsx@0.1.1', function(System) {

System.register("npm:process@0.10.1/browser", [], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  var process = module.exports = {};
  var queue = [];
  var draining = false;
  function drainQueue() {
    if (draining) {
      return ;
    }
    draining = true;
    var currentQueue;
    var len = queue.length;
    while (len) {
      currentQueue = queue;
      queue = [];
      var i = -1;
      while (++i < len) {
        currentQueue[i]();
      }
      len = queue.length;
    }
    draining = false;
  }
  process.nextTick = function(fun) {
    queue.push(fun);
    if (!draining) {
      setTimeout(drainQueue, 0);
    }
  };
  process.title = 'browser';
  process.browser = true;
  process.env = {};
  process.argv = [];
  process.version = '';
  process.versions = {};
  function noop() {}
  process.on = noop;
  process.addListener = noop;
  process.once = noop;
  process.off = noop;
  process.removeListener = noop;
  process.removeAllListeners = noop;
  process.emit = noop;
  process.binding = function(name) {
    throw new Error('process.binding is not supported');
  };
  process.cwd = function() {
    return '/';
  };
  process.chdir = function(dir) {
    throw new Error('process.chdir is not supported');
  };
  process.umask = function() {
    return 0;
  };
  global.define = __define;
  return module.exports;
});



System.register("npm:react@0.12.2/lib/escapeTextForBrowser", [], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  "use strict";
  var ESCAPE_LOOKUP = {
    "&": "&amp;",
    ">": "&gt;",
    "<": "&lt;",
    "\"": "&quot;",
    "'": "&#x27;"
  };
  var ESCAPE_REGEX = /[&><"']/g;
  function escaper(match) {
    return ESCAPE_LOOKUP[match];
  }
  function escapeTextForBrowser(text) {
    return ('' + text).replace(ESCAPE_REGEX, escaper);
  }
  module.exports = escapeTextForBrowser;
  global.define = __define;
  return module.exports;
});



System.register("npm:react@0.12.2/lib/memoizeStringOnly", [], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  "use strict";
  function memoizeStringOnly(callback) {
    var cache = {};
    return function(string) {
      if (cache.hasOwnProperty(string)) {
        return cache[string];
      } else {
        return cache[string] = callback.call(this, string);
      }
    };
  }
  module.exports = memoizeStringOnly;
  global.define = __define;
  return module.exports;
});



System.register("npm:react@0.12.2/lib/emptyFunction", [], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  function makeEmptyFunction(arg) {
    return function() {
      return arg;
    };
  }
  function emptyFunction() {}
  emptyFunction.thatReturns = makeEmptyFunction;
  emptyFunction.thatReturnsFalse = makeEmptyFunction(false);
  emptyFunction.thatReturnsTrue = makeEmptyFunction(true);
  emptyFunction.thatReturnsNull = makeEmptyFunction(null);
  emptyFunction.thatReturnsThis = function() {
    return this;
  };
  emptyFunction.thatReturnsArgument = function(arg) {
    return arg;
  };
  module.exports = emptyFunction;
  global.define = __define;
  return module.exports;
});



System.register("npm:react@0.12.2/lib/keyMirror", ["npm:react@0.12.2/lib/invariant", "github:jspm/nodelibs-process@0.1.1"], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  (function(process) {
    "use strict";
    var invariant = require("npm:react@0.12.2/lib/invariant");
    var keyMirror = function(obj) {
      var ret = {};
      var key;
      ("production" !== process.env.NODE_ENV ? invariant(obj instanceof Object && !Array.isArray(obj), 'keyMirror(...): Argument must be an object.') : invariant(obj instanceof Object && !Array.isArray(obj)));
      for (key in obj) {
        if (!obj.hasOwnProperty(key)) {
          continue;
        }
        ret[key] = key;
      }
      return ret;
    };
    module.exports = keyMirror;
  })(require("github:jspm/nodelibs-process@0.1.1"));
  global.define = __define;
  return module.exports;
});



System.register("npm:react@0.12.2/lib/PooledClass", ["npm:react@0.12.2/lib/invariant", "github:jspm/nodelibs-process@0.1.1"], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  (function(process) {
    "use strict";
    var invariant = require("npm:react@0.12.2/lib/invariant");
    var oneArgumentPooler = function(copyFieldsFrom) {
      var Klass = this;
      if (Klass.instancePool.length) {
        var instance = Klass.instancePool.pop();
        Klass.call(instance, copyFieldsFrom);
        return instance;
      } else {
        return new Klass(copyFieldsFrom);
      }
    };
    var twoArgumentPooler = function(a1, a2) {
      var Klass = this;
      if (Klass.instancePool.length) {
        var instance = Klass.instancePool.pop();
        Klass.call(instance, a1, a2);
        return instance;
      } else {
        return new Klass(a1, a2);
      }
    };
    var threeArgumentPooler = function(a1, a2, a3) {
      var Klass = this;
      if (Klass.instancePool.length) {
        var instance = Klass.instancePool.pop();
        Klass.call(instance, a1, a2, a3);
        return instance;
      } else {
        return new Klass(a1, a2, a3);
      }
    };
    var fiveArgumentPooler = function(a1, a2, a3, a4, a5) {
      var Klass = this;
      if (Klass.instancePool.length) {
        var instance = Klass.instancePool.pop();
        Klass.call(instance, a1, a2, a3, a4, a5);
        return instance;
      } else {
        return new Klass(a1, a2, a3, a4, a5);
      }
    };
    var standardReleaser = function(instance) {
      var Klass = this;
      ("production" !== process.env.NODE_ENV ? invariant(instance instanceof Klass, 'Trying to release an instance into a pool of a different type.') : invariant(instance instanceof Klass));
      if (instance.destructor) {
        instance.destructor();
      }
      if (Klass.instancePool.length < Klass.poolSize) {
        Klass.instancePool.push(instance);
      }
    };
    var DEFAULT_POOL_SIZE = 10;
    var DEFAULT_POOLER = oneArgumentPooler;
    var addPoolingTo = function(CopyConstructor, pooler) {
      var NewKlass = CopyConstructor;
      NewKlass.instancePool = [];
      NewKlass.getPooled = pooler || DEFAULT_POOLER;
      if (!NewKlass.poolSize) {
        NewKlass.poolSize = DEFAULT_POOL_SIZE;
      }
      NewKlass.release = standardReleaser;
      return NewKlass;
    };
    var PooledClass = {
      addPoolingTo: addPoolingTo,
      oneArgumentPooler: oneArgumentPooler,
      twoArgumentPooler: twoArgumentPooler,
      threeArgumentPooler: threeArgumentPooler,
      fiveArgumentPooler: fiveArgumentPooler
    };
    module.exports = PooledClass;
  })(require("github:jspm/nodelibs-process@0.1.1"));
  global.define = __define;
  return module.exports;
});



System.register("npm:react@0.12.2/lib/Object.assign", [], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  function assign(target, sources) {
    if (target == null) {
      throw new TypeError('Object.assign target cannot be null or undefined');
    }
    var to = Object(target);
    var hasOwnProperty = Object.prototype.hasOwnProperty;
    for (var nextIndex = 1; nextIndex < arguments.length; nextIndex++) {
      var nextSource = arguments[nextIndex];
      if (nextSource == null) {
        continue;
      }
      var from = Object(nextSource);
      for (var key in from) {
        if (hasOwnProperty.call(from, key)) {
          to[key] = from[key];
        }
      }
    }
    return to;
  }
  ;
  module.exports = assign;
  global.define = __define;
  return module.exports;
});



System.register("npm:react@0.12.2/lib/ReactCurrentOwner", [], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  "use strict";
  var ReactCurrentOwner = {current: null};
  module.exports = ReactCurrentOwner;
  global.define = __define;
  return module.exports;
});



System.register("npm:react@0.12.2/lib/ReactRootIndex", [], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  "use strict";
  var ReactRootIndexInjection = {injectCreateReactRootIndex: function(_createReactRootIndex) {
      ReactRootIndex.createReactRootIndex = _createReactRootIndex;
    }};
  var ReactRootIndex = {
    createReactRootIndex: null,
    injection: ReactRootIndexInjection
  };
  module.exports = ReactRootIndex;
  global.define = __define;
  return module.exports;
});



System.register("npm:react@0.12.2/lib/emptyObject", ["github:jspm/nodelibs-process@0.1.1"], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  (function(process) {
    "use strict";
    var emptyObject = {};
    if ("production" !== process.env.NODE_ENV) {
      Object.freeze(emptyObject);
    }
    module.exports = emptyObject;
  })(require("github:jspm/nodelibs-process@0.1.1"));
  global.define = __define;
  return module.exports;
});



System.register("npm:react@0.12.2/lib/CallbackQueue", ["npm:react@0.12.2/lib/PooledClass", "npm:react@0.12.2/lib/Object.assign", "npm:react@0.12.2/lib/invariant", "github:jspm/nodelibs-process@0.1.1"], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  (function(process) {
    "use strict";
    var PooledClass = require("npm:react@0.12.2/lib/PooledClass");
    var assign = require("npm:react@0.12.2/lib/Object.assign");
    var invariant = require("npm:react@0.12.2/lib/invariant");
    function CallbackQueue() {
      this._callbacks = null;
      this._contexts = null;
    }
    assign(CallbackQueue.prototype, {
      enqueue: function(callback, context) {
        this._callbacks = this._callbacks || [];
        this._contexts = this._contexts || [];
        this._callbacks.push(callback);
        this._contexts.push(context);
      },
      notifyAll: function() {
        var callbacks = this._callbacks;
        var contexts = this._contexts;
        if (callbacks) {
          ("production" !== process.env.NODE_ENV ? invariant(callbacks.length === contexts.length, "Mismatched list of contexts in callback queue") : invariant(callbacks.length === contexts.length));
          this._callbacks = null;
          this._contexts = null;
          for (var i = 0,
              l = callbacks.length; i < l; i++) {
            callbacks[i].call(contexts[i]);
          }
          callbacks.length = 0;
          contexts.length = 0;
        }
      },
      reset: function() {
        this._callbacks = null;
        this._contexts = null;
      },
      destructor: function() {
        this.reset();
      }
    });
    PooledClass.addPoolingTo(CallbackQueue);
    module.exports = CallbackQueue;
  })(require("github:jspm/nodelibs-process@0.1.1"));
  global.define = __define;
  return module.exports;
});



System.register("npm:react@0.12.2/lib/ReactPerf", ["github:jspm/nodelibs-process@0.1.1"], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  (function(process) {
    "use strict";
    var ReactPerf = {
      enableMeasure: false,
      storedMeasure: _noMeasure,
      measure: function(objName, fnName, func) {
        if ("production" !== process.env.NODE_ENV) {
          var measuredFunc = null;
          var wrapper = function() {
            if (ReactPerf.enableMeasure) {
              if (!measuredFunc) {
                measuredFunc = ReactPerf.storedMeasure(objName, fnName, func);
              }
              return measuredFunc.apply(this, arguments);
            }
            return func.apply(this, arguments);
          };
          wrapper.displayName = objName + '_' + fnName;
          return wrapper;
        }
        return func;
      },
      injection: {injectMeasure: function(measure) {
          ReactPerf.storedMeasure = measure;
        }}
    };
    function _noMeasure(objName, fnName, func) {
      return func;
    }
    module.exports = ReactPerf;
  })(require("github:jspm/nodelibs-process@0.1.1"));
  global.define = __define;
  return module.exports;
});



System.register("npm:react@0.12.2/lib/Transaction", ["npm:react@0.12.2/lib/invariant", "github:jspm/nodelibs-process@0.1.1"], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  (function(process) {
    "use strict";
    var invariant = require("npm:react@0.12.2/lib/invariant");
    var Mixin = {
      reinitializeTransaction: function() {
        this.transactionWrappers = this.getTransactionWrappers();
        if (!this.wrapperInitData) {
          this.wrapperInitData = [];
        } else {
          this.wrapperInitData.length = 0;
        }
        this._isInTransaction = false;
      },
      _isInTransaction: false,
      getTransactionWrappers: null,
      isInTransaction: function() {
        return !!this._isInTransaction;
      },
      perform: function(method, scope, a, b, c, d, e, f) {
        ("production" !== process.env.NODE_ENV ? invariant(!this.isInTransaction(), 'Transaction.perform(...): Cannot initialize a transaction when there ' + 'is already an outstanding transaction.') : invariant(!this.isInTransaction()));
        var errorThrown;
        var ret;
        try {
          this._isInTransaction = true;
          errorThrown = true;
          this.initializeAll(0);
          ret = method.call(scope, a, b, c, d, e, f);
          errorThrown = false;
        } finally {
          try {
            if (errorThrown) {
              try {
                this.closeAll(0);
              } catch (err) {}
            } else {
              this.closeAll(0);
            }
          } finally {
            this._isInTransaction = false;
          }
        }
        return ret;
      },
      initializeAll: function(startIndex) {
        var transactionWrappers = this.transactionWrappers;
        for (var i = startIndex; i < transactionWrappers.length; i++) {
          var wrapper = transactionWrappers[i];
          try {
            this.wrapperInitData[i] = Transaction.OBSERVED_ERROR;
            this.wrapperInitData[i] = wrapper.initialize ? wrapper.initialize.call(this) : null;
          } finally {
            if (this.wrapperInitData[i] === Transaction.OBSERVED_ERROR) {
              try {
                this.initializeAll(i + 1);
              } catch (err) {}
            }
          }
        }
      },
      closeAll: function(startIndex) {
        ("production" !== process.env.NODE_ENV ? invariant(this.isInTransaction(), 'Transaction.closeAll(): Cannot close transaction when none are open.') : invariant(this.isInTransaction()));
        var transactionWrappers = this.transactionWrappers;
        for (var i = startIndex; i < transactionWrappers.length; i++) {
          var wrapper = transactionWrappers[i];
          var initData = this.wrapperInitData[i];
          var errorThrown;
          try {
            errorThrown = true;
            if (initData !== Transaction.OBSERVED_ERROR) {
              wrapper.close && wrapper.close.call(this, initData);
            }
            errorThrown = false;
          } finally {
            if (errorThrown) {
              try {
                this.closeAll(i + 1);
              } catch (e) {}
            }
          }
        }
        this.wrapperInitData.length = 0;
      }
    };
    var Transaction = {
      Mixin: Mixin,
      OBSERVED_ERROR: {}
    };
    module.exports = Transaction;
  })(require("github:jspm/nodelibs-process@0.1.1"));
  global.define = __define;
  return module.exports;
});



System.register("npm:react@0.12.2/lib/ReactPropTypeLocations", ["npm:react@0.12.2/lib/keyMirror"], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  "use strict";
  var keyMirror = require("npm:react@0.12.2/lib/keyMirror");
  var ReactPropTypeLocations = keyMirror({
    prop: null,
    context: null,
    childContext: null
  });
  module.exports = ReactPropTypeLocations;
  global.define = __define;
  return module.exports;
});



System.register("npm:react@0.12.2/lib/monitorCodeUse", ["npm:react@0.12.2/lib/invariant", "github:jspm/nodelibs-process@0.1.1"], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  (function(process) {
    "use strict";
    var invariant = require("npm:react@0.12.2/lib/invariant");
    function monitorCodeUse(eventName, data) {
      ("production" !== process.env.NODE_ENV ? invariant(eventName && !/[^a-z0-9_]/.test(eventName), 'You must provide an eventName using only the characters [a-z0-9_]') : invariant(eventName && !/[^a-z0-9_]/.test(eventName)));
    }
    module.exports = monitorCodeUse;
  })(require("github:jspm/nodelibs-process@0.1.1"));
  global.define = __define;
  return module.exports;
});



System.register("npm:react@0.12.2/lib/ReactEmptyComponent", ["npm:react@0.12.2/lib/ReactElement", "npm:react@0.12.2/lib/invariant", "github:jspm/nodelibs-process@0.1.1"], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  (function(process) {
    "use strict";
    var ReactElement = require("npm:react@0.12.2/lib/ReactElement");
    var invariant = require("npm:react@0.12.2/lib/invariant");
    var component;
    var nullComponentIdsRegistry = {};
    var ReactEmptyComponentInjection = {injectEmptyComponent: function(emptyComponent) {
        component = ReactElement.createFactory(emptyComponent);
      }};
    function getEmptyComponent() {
      ("production" !== process.env.NODE_ENV ? invariant(component, 'Trying to return null from a render, but no null placeholder component ' + 'was injected.') : invariant(component));
      return component();
    }
    function registerNullComponentID(id) {
      nullComponentIdsRegistry[id] = true;
    }
    function deregisterNullComponentID(id) {
      delete nullComponentIdsRegistry[id];
    }
    function isNullComponentID(id) {
      return nullComponentIdsRegistry[id];
    }
    var ReactEmptyComponent = {
      deregisterNullComponentID: deregisterNullComponentID,
      getEmptyComponent: getEmptyComponent,
      injection: ReactEmptyComponentInjection,
      isNullComponentID: isNullComponentID,
      registerNullComponentID: registerNullComponentID
    };
    module.exports = ReactEmptyComponent;
  })(require("github:jspm/nodelibs-process@0.1.1"));
  global.define = __define;
  return module.exports;
});



System.register("npm:react@0.12.2/lib/ReactErrorUtils", [], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  "use strict";
  var ReactErrorUtils = {guard: function(func, name) {
      return func;
    }};
  module.exports = ReactErrorUtils;
  global.define = __define;
  return module.exports;
});



System.register("npm:react@0.12.2/lib/ReactLegacyElement", ["npm:react@0.12.2/lib/ReactCurrentOwner", "npm:react@0.12.2/lib/invariant", "npm:react@0.12.2/lib/monitorCodeUse", "npm:react@0.12.2/lib/warning", "github:jspm/nodelibs-process@0.1.1"], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  (function(process) {
    "use strict";
    var ReactCurrentOwner = require("npm:react@0.12.2/lib/ReactCurrentOwner");
    var invariant = require("npm:react@0.12.2/lib/invariant");
    var monitorCodeUse = require("npm:react@0.12.2/lib/monitorCodeUse");
    var warning = require("npm:react@0.12.2/lib/warning");
    var legacyFactoryLogs = {};
    function warnForLegacyFactoryCall() {
      if (!ReactLegacyElementFactory._isLegacyCallWarningEnabled) {
        return ;
      }
      var owner = ReactCurrentOwner.current;
      var name = owner && owner.constructor ? owner.constructor.displayName : '';
      if (!name) {
        name = 'Something';
      }
      if (legacyFactoryLogs.hasOwnProperty(name)) {
        return ;
      }
      legacyFactoryLogs[name] = true;
      ("production" !== process.env.NODE_ENV ? warning(false, name + ' is calling a React component directly. ' + 'Use a factory or JSX instead. See: http://fb.me/react-legacyfactory') : null);
      monitorCodeUse('react_legacy_factory_call', {
        version: 3,
        name: name
      });
    }
    function warnForPlainFunctionType(type) {
      var isReactClass = type.prototype && typeof type.prototype.mountComponent === 'function' && typeof type.prototype.receiveComponent === 'function';
      if (isReactClass) {
        ("production" !== process.env.NODE_ENV ? warning(false, 'Did not expect to get a React class here. Use `Component` instead ' + 'of `Component.type` or `this.constructor`.') : null);
      } else {
        if (!type._reactWarnedForThisType) {
          try {
            type._reactWarnedForThisType = true;
          } catch (x) {}
          monitorCodeUse('react_non_component_in_jsx', {
            version: 3,
            name: type.name
          });
        }
        ("production" !== process.env.NODE_ENV ? warning(false, 'This JSX uses a plain function. Only React components are ' + 'valid in React\'s JSX transform.') : null);
      }
    }
    function warnForNonLegacyFactory(type) {
      ("production" !== process.env.NODE_ENV ? warning(false, 'Do not pass React.DOM.' + type.type + ' to JSX or createFactory. ' + 'Use the string "' + type.type + '" instead.') : null);
    }
    function proxyStaticMethods(target, source) {
      if (typeof source !== 'function') {
        return ;
      }
      for (var key in source) {
        if (source.hasOwnProperty(key)) {
          var value = source[key];
          if (typeof value === 'function') {
            var bound = value.bind(source);
            for (var k in value) {
              if (value.hasOwnProperty(k)) {
                bound[k] = value[k];
              }
            }
            target[key] = bound;
          } else {
            target[key] = value;
          }
        }
      }
    }
    var LEGACY_MARKER = {};
    var NON_LEGACY_MARKER = {};
    var ReactLegacyElementFactory = {};
    ReactLegacyElementFactory.wrapCreateFactory = function(createFactory) {
      var legacyCreateFactory = function(type) {
        if (typeof type !== 'function') {
          return createFactory(type);
        }
        if (type.isReactNonLegacyFactory) {
          if ("production" !== process.env.NODE_ENV) {
            warnForNonLegacyFactory(type);
          }
          return createFactory(type.type);
        }
        if (type.isReactLegacyFactory) {
          return createFactory(type.type);
        }
        if ("production" !== process.env.NODE_ENV) {
          warnForPlainFunctionType(type);
        }
        return type;
      };
      return legacyCreateFactory;
    };
    ReactLegacyElementFactory.wrapCreateElement = function(createElement) {
      var legacyCreateElement = function(type, props, children) {
        if (typeof type !== 'function') {
          return createElement.apply(this, arguments);
        }
        var args;
        if (type.isReactNonLegacyFactory) {
          if ("production" !== process.env.NODE_ENV) {
            warnForNonLegacyFactory(type);
          }
          args = Array.prototype.slice.call(arguments, 0);
          args[0] = type.type;
          return createElement.apply(this, args);
        }
        if (type.isReactLegacyFactory) {
          if (type._isMockFunction) {
            type.type._mockedReactClassConstructor = type;
          }
          args = Array.prototype.slice.call(arguments, 0);
          args[0] = type.type;
          return createElement.apply(this, args);
        }
        if ("production" !== process.env.NODE_ENV) {
          warnForPlainFunctionType(type);
        }
        return type.apply(null, Array.prototype.slice.call(arguments, 1));
      };
      return legacyCreateElement;
    };
    ReactLegacyElementFactory.wrapFactory = function(factory) {
      ("production" !== process.env.NODE_ENV ? invariant(typeof factory === 'function', 'This is suppose to accept a element factory') : invariant(typeof factory === 'function'));
      var legacyElementFactory = function(config, children) {
        if ("production" !== process.env.NODE_ENV) {
          warnForLegacyFactoryCall();
        }
        return factory.apply(this, arguments);
      };
      proxyStaticMethods(legacyElementFactory, factory.type);
      legacyElementFactory.isReactLegacyFactory = LEGACY_MARKER;
      legacyElementFactory.type = factory.type;
      return legacyElementFactory;
    };
    ReactLegacyElementFactory.markNonLegacyFactory = function(factory) {
      factory.isReactNonLegacyFactory = NON_LEGACY_MARKER;
      return factory;
    };
    ReactLegacyElementFactory.isValidFactory = function(factory) {
      return typeof factory === 'function' && factory.isReactLegacyFactory === LEGACY_MARKER;
    };
    ReactLegacyElementFactory.isValidClass = function(factory) {
      if ("production" !== process.env.NODE_ENV) {
        ("production" !== process.env.NODE_ENV ? warning(false, 'isValidClass is deprecated and will be removed in a future release. ' + 'Use a more specific validator instead.') : null);
      }
      return ReactLegacyElementFactory.isValidFactory(factory);
    };
    ReactLegacyElementFactory._isLegacyCallWarningEnabled = true;
    module.exports = ReactLegacyElementFactory;
  })(require("github:jspm/nodelibs-process@0.1.1"));
  global.define = __define;
  return module.exports;
});



System.register("npm:react@0.12.2/lib/joinClasses", [], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  "use strict";
  function joinClasses(className) {
    if (!className) {
      className = '';
    }
    var nextClass;
    var argLength = arguments.length;
    if (argLength > 1) {
      for (var ii = 1; ii < argLength; ii++) {
        nextClass = arguments[ii];
        if (nextClass) {
          className = (className ? className + ' ' : '') + nextClass;
        }
      }
    }
    return className;
  }
  module.exports = joinClasses;
  global.define = __define;
  return module.exports;
});



System.register("npm:react@0.12.2/lib/ReactPropTypeLocationNames", ["github:jspm/nodelibs-process@0.1.1"], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  (function(process) {
    "use strict";
    var ReactPropTypeLocationNames = {};
    if ("production" !== process.env.NODE_ENV) {
      ReactPropTypeLocationNames = {
        prop: 'prop',
        context: 'context',
        childContext: 'child context'
      };
    }
    module.exports = ReactPropTypeLocationNames;
  })(require("github:jspm/nodelibs-process@0.1.1"));
  global.define = __define;
  return module.exports;
});



System.register("npm:react@0.12.2/lib/ReactNativeComponent", ["npm:react@0.12.2/lib/Object.assign", "npm:react@0.12.2/lib/invariant", "github:jspm/nodelibs-process@0.1.1"], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  (function(process) {
    "use strict";
    var assign = require("npm:react@0.12.2/lib/Object.assign");
    var invariant = require("npm:react@0.12.2/lib/invariant");
    var genericComponentClass = null;
    var tagToComponentClass = {};
    var ReactNativeComponentInjection = {
      injectGenericComponentClass: function(componentClass) {
        genericComponentClass = componentClass;
      },
      injectComponentClasses: function(componentClasses) {
        assign(tagToComponentClass, componentClasses);
      }
    };
    function createInstanceForTag(tag, props, parentType) {
      var componentClass = tagToComponentClass[tag];
      if (componentClass == null) {
        ("production" !== process.env.NODE_ENV ? invariant(genericComponentClass, 'There is no registered component for the tag %s', tag) : invariant(genericComponentClass));
        return new genericComponentClass(tag, props);
      }
      if (parentType === tag) {
        ("production" !== process.env.NODE_ENV ? invariant(genericComponentClass, 'There is no registered component for the tag %s', tag) : invariant(genericComponentClass));
        return new genericComponentClass(tag, props);
      }
      return new componentClass.type(props);
    }
    var ReactNativeComponent = {
      createInstanceForTag: createInstanceForTag,
      injection: ReactNativeComponentInjection
    };
    module.exports = ReactNativeComponent;
  })(require("github:jspm/nodelibs-process@0.1.1"));
  global.define = __define;
  return module.exports;
});



System.register("npm:react@0.12.2/lib/keyOf", [], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  var keyOf = function(oneKeyObj) {
    var key;
    for (key in oneKeyObj) {
      if (!oneKeyObj.hasOwnProperty(key)) {
        continue;
      }
      return key;
    }
    return null;
  };
  module.exports = keyOf;
  global.define = __define;
  return module.exports;
});



System.register("npm:react@0.12.2/lib/mapObject", [], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  'use strict';
  var hasOwnProperty = Object.prototype.hasOwnProperty;
  function mapObject(object, callback, context) {
    if (!object) {
      return null;
    }
    var result = {};
    for (var name in object) {
      if (hasOwnProperty.call(object, name)) {
        result[name] = callback.call(context, object[name], name, object);
      }
    }
    return result;
  }
  module.exports = mapObject;
  global.define = __define;
  return module.exports;
});



System.register("npm:react@0.12.2/lib/shouldUpdateReactComponent", [], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  "use strict";
  function shouldUpdateReactComponent(prevElement, nextElement) {
    if (prevElement && nextElement && prevElement.type === nextElement.type && prevElement.key === nextElement.key && prevElement._owner === nextElement._owner) {
      return true;
    }
    return false;
  }
  module.exports = shouldUpdateReactComponent;
  global.define = __define;
  return module.exports;
});



System.register("npm:react@0.12.2/lib/ReactDOM", ["npm:react@0.12.2/lib/ReactElement", "npm:react@0.12.2/lib/ReactElementValidator", "npm:react@0.12.2/lib/ReactLegacyElement", "npm:react@0.12.2/lib/mapObject", "github:jspm/nodelibs-process@0.1.1"], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  (function(process) {
    "use strict";
    var ReactElement = require("npm:react@0.12.2/lib/ReactElement");
    var ReactElementValidator = require("npm:react@0.12.2/lib/ReactElementValidator");
    var ReactLegacyElement = require("npm:react@0.12.2/lib/ReactLegacyElement");
    var mapObject = require("npm:react@0.12.2/lib/mapObject");
    function createDOMFactory(tag) {
      if ("production" !== process.env.NODE_ENV) {
        return ReactLegacyElement.markNonLegacyFactory(ReactElementValidator.createFactory(tag));
      }
      return ReactLegacyElement.markNonLegacyFactory(ReactElement.createFactory(tag));
    }
    var ReactDOM = mapObject({
      a: 'a',
      abbr: 'abbr',
      address: 'address',
      area: 'area',
      article: 'article',
      aside: 'aside',
      audio: 'audio',
      b: 'b',
      base: 'base',
      bdi: 'bdi',
      bdo: 'bdo',
      big: 'big',
      blockquote: 'blockquote',
      body: 'body',
      br: 'br',
      button: 'button',
      canvas: 'canvas',
      caption: 'caption',
      cite: 'cite',
      code: 'code',
      col: 'col',
      colgroup: 'colgroup',
      data: 'data',
      datalist: 'datalist',
      dd: 'dd',
      del: 'del',
      details: 'details',
      dfn: 'dfn',
      dialog: 'dialog',
      div: 'div',
      dl: 'dl',
      dt: 'dt',
      em: 'em',
      embed: 'embed',
      fieldset: 'fieldset',
      figcaption: 'figcaption',
      figure: 'figure',
      footer: 'footer',
      form: 'form',
      h1: 'h1',
      h2: 'h2',
      h3: 'h3',
      h4: 'h4',
      h5: 'h5',
      h6: 'h6',
      head: 'head',
      header: 'header',
      hr: 'hr',
      html: 'html',
      i: 'i',
      iframe: 'iframe',
      img: 'img',
      input: 'input',
      ins: 'ins',
      kbd: 'kbd',
      keygen: 'keygen',
      label: 'label',
      legend: 'legend',
      li: 'li',
      link: 'link',
      main: 'main',
      map: 'map',
      mark: 'mark',
      menu: 'menu',
      menuitem: 'menuitem',
      meta: 'meta',
      meter: 'meter',
      nav: 'nav',
      noscript: 'noscript',
      object: 'object',
      ol: 'ol',
      optgroup: 'optgroup',
      option: 'option',
      output: 'output',
      p: 'p',
      param: 'param',
      picture: 'picture',
      pre: 'pre',
      progress: 'progress',
      q: 'q',
      rp: 'rp',
      rt: 'rt',
      ruby: 'ruby',
      s: 's',
      samp: 'samp',
      script: 'script',
      section: 'section',
      select: 'select',
      small: 'small',
      source: 'source',
      span: 'span',
      strong: 'strong',
      style: 'style',
      sub: 'sub',
      summary: 'summary',
      sup: 'sup',
      table: 'table',
      tbody: 'tbody',
      td: 'td',
      textarea: 'textarea',
      tfoot: 'tfoot',
      th: 'th',
      thead: 'thead',
      time: 'time',
      title: 'title',
      tr: 'tr',
      track: 'track',
      u: 'u',
      ul: 'ul',
      'var': 'var',
      video: 'video',
      wbr: 'wbr',
      circle: 'circle',
      defs: 'defs',
      ellipse: 'ellipse',
      g: 'g',
      line: 'line',
      linearGradient: 'linearGradient',
      mask: 'mask',
      path: 'path',
      pattern: 'pattern',
      polygon: 'polygon',
      polyline: 'polyline',
      radialGradient: 'radialGradient',
      rect: 'rect',
      stop: 'stop',
      svg: 'svg',
      text: 'text',
      tspan: 'tspan'
    }, createDOMFactory);
    module.exports = ReactDOM;
  })(require("github:jspm/nodelibs-process@0.1.1"));
  global.define = __define;
  return module.exports;
});



System.register("npm:react@0.12.2/lib/CSSProperty", [], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  "use strict";
  var isUnitlessNumber = {
    columnCount: true,
    flex: true,
    flexGrow: true,
    flexShrink: true,
    fontWeight: true,
    lineClamp: true,
    lineHeight: true,
    opacity: true,
    order: true,
    orphans: true,
    widows: true,
    zIndex: true,
    zoom: true,
    fillOpacity: true,
    strokeOpacity: true
  };
  function prefixKey(prefix, key) {
    return prefix + key.charAt(0).toUpperCase() + key.substring(1);
  }
  var prefixes = ['Webkit', 'ms', 'Moz', 'O'];
  Object.keys(isUnitlessNumber).forEach(function(prop) {
    prefixes.forEach(function(prefix) {
      isUnitlessNumber[prefixKey(prefix, prop)] = isUnitlessNumber[prop];
    });
  });
  var shorthandPropertyExpansions = {
    background: {
      backgroundImage: true,
      backgroundPosition: true,
      backgroundRepeat: true,
      backgroundColor: true
    },
    border: {
      borderWidth: true,
      borderStyle: true,
      borderColor: true
    },
    borderBottom: {
      borderBottomWidth: true,
      borderBottomStyle: true,
      borderBottomColor: true
    },
    borderLeft: {
      borderLeftWidth: true,
      borderLeftStyle: true,
      borderLeftColor: true
    },
    borderRight: {
      borderRightWidth: true,
      borderRightStyle: true,
      borderRightColor: true
    },
    borderTop: {
      borderTopWidth: true,
      borderTopStyle: true,
      borderTopColor: true
    },
    font: {
      fontStyle: true,
      fontVariant: true,
      fontWeight: true,
      fontSize: true,
      lineHeight: true,
      fontFamily: true
    }
  };
  var CSSProperty = {
    isUnitlessNumber: isUnitlessNumber,
    shorthandPropertyExpansions: shorthandPropertyExpansions
  };
  module.exports = CSSProperty;
  global.define = __define;
  return module.exports;
});



System.register("npm:react@0.12.2/lib/ExecutionEnvironment", [], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  "use strict";
  var canUseDOM = !!(typeof window !== 'undefined' && window.document && window.document.createElement);
  var ExecutionEnvironment = {
    canUseDOM: canUseDOM,
    canUseWorkers: typeof Worker !== 'undefined',
    canUseEventListeners: canUseDOM && !!(window.addEventListener || window.attachEvent),
    canUseViewport: canUseDOM && !!window.screen,
    isInWorker: !canUseDOM
  };
  module.exports = ExecutionEnvironment;
  global.define = __define;
  return module.exports;
});



System.register("npm:react@0.12.2/lib/camelize", [], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  var _hyphenPattern = /-(.)/g;
  function camelize(string) {
    return string.replace(_hyphenPattern, function(_, character) {
      return character.toUpperCase();
    });
  }
  module.exports = camelize;
  global.define = __define;
  return module.exports;
});



System.register("npm:react@0.12.2/lib/dangerousStyleValue", ["npm:react@0.12.2/lib/CSSProperty"], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  "use strict";
  var CSSProperty = require("npm:react@0.12.2/lib/CSSProperty");
  var isUnitlessNumber = CSSProperty.isUnitlessNumber;
  function dangerousStyleValue(name, value) {
    var isEmpty = value == null || typeof value === 'boolean' || value === '';
    if (isEmpty) {
      return '';
    }
    var isNonNumeric = isNaN(value);
    if (isNonNumeric || value === 0 || isUnitlessNumber.hasOwnProperty(name) && isUnitlessNumber[name]) {
      return '' + value;
    }
    if (typeof value === 'string') {
      value = value.trim();
    }
    return value + 'px';
  }
  module.exports = dangerousStyleValue;
  global.define = __define;
  return module.exports;
});



System.register("npm:react@0.12.2/lib/hyphenate", [], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  var _uppercasePattern = /([A-Z])/g;
  function hyphenate(string) {
    return string.replace(_uppercasePattern, '-$1').toLowerCase();
  }
  module.exports = hyphenate;
  global.define = __define;
  return module.exports;
});



System.register("npm:react@0.12.2/lib/EventPluginRegistry", ["npm:react@0.12.2/lib/invariant", "github:jspm/nodelibs-process@0.1.1"], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  (function(process) {
    "use strict";
    var invariant = require("npm:react@0.12.2/lib/invariant");
    var EventPluginOrder = null;
    var namesToPlugins = {};
    function recomputePluginOrdering() {
      if (!EventPluginOrder) {
        return ;
      }
      for (var pluginName in namesToPlugins) {
        var PluginModule = namesToPlugins[pluginName];
        var pluginIndex = EventPluginOrder.indexOf(pluginName);
        ("production" !== process.env.NODE_ENV ? invariant(pluginIndex > -1, 'EventPluginRegistry: Cannot inject event plugins that do not exist in ' + 'the plugin ordering, `%s`.', pluginName) : invariant(pluginIndex > -1));
        if (EventPluginRegistry.plugins[pluginIndex]) {
          continue;
        }
        ("production" !== process.env.NODE_ENV ? invariant(PluginModule.extractEvents, 'EventPluginRegistry: Event plugins must implement an `extractEvents` ' + 'method, but `%s` does not.', pluginName) : invariant(PluginModule.extractEvents));
        EventPluginRegistry.plugins[pluginIndex] = PluginModule;
        var publishedEvents = PluginModule.eventTypes;
        for (var eventName in publishedEvents) {
          ("production" !== process.env.NODE_ENV ? invariant(publishEventForPlugin(publishedEvents[eventName], PluginModule, eventName), 'EventPluginRegistry: Failed to publish event `%s` for plugin `%s`.', eventName, pluginName) : invariant(publishEventForPlugin(publishedEvents[eventName], PluginModule, eventName)));
        }
      }
    }
    function publishEventForPlugin(dispatchConfig, PluginModule, eventName) {
      ("production" !== process.env.NODE_ENV ? invariant(!EventPluginRegistry.eventNameDispatchConfigs.hasOwnProperty(eventName), 'EventPluginHub: More than one plugin attempted to publish the same ' + 'event name, `%s`.', eventName) : invariant(!EventPluginRegistry.eventNameDispatchConfigs.hasOwnProperty(eventName)));
      EventPluginRegistry.eventNameDispatchConfigs[eventName] = dispatchConfig;
      var phasedRegistrationNames = dispatchConfig.phasedRegistrationNames;
      if (phasedRegistrationNames) {
        for (var phaseName in phasedRegistrationNames) {
          if (phasedRegistrationNames.hasOwnProperty(phaseName)) {
            var phasedRegistrationName = phasedRegistrationNames[phaseName];
            publishRegistrationName(phasedRegistrationName, PluginModule, eventName);
          }
        }
        return true;
      } else if (dispatchConfig.registrationName) {
        publishRegistrationName(dispatchConfig.registrationName, PluginModule, eventName);
        return true;
      }
      return false;
    }
    function publishRegistrationName(registrationName, PluginModule, eventName) {
      ("production" !== process.env.NODE_ENV ? invariant(!EventPluginRegistry.registrationNameModules[registrationName], 'EventPluginHub: More than one plugin attempted to publish the same ' + 'registration name, `%s`.', registrationName) : invariant(!EventPluginRegistry.registrationNameModules[registrationName]));
      EventPluginRegistry.registrationNameModules[registrationName] = PluginModule;
      EventPluginRegistry.registrationNameDependencies[registrationName] = PluginModule.eventTypes[eventName].dependencies;
    }
    var EventPluginRegistry = {
      plugins: [],
      eventNameDispatchConfigs: {},
      registrationNameModules: {},
      registrationNameDependencies: {},
      injectEventPluginOrder: function(InjectedEventPluginOrder) {
        ("production" !== process.env.NODE_ENV ? invariant(!EventPluginOrder, 'EventPluginRegistry: Cannot inject event plugin ordering more than ' + 'once. You are likely trying to load more than one copy of React.') : invariant(!EventPluginOrder));
        EventPluginOrder = Array.prototype.slice.call(InjectedEventPluginOrder);
        recomputePluginOrdering();
      },
      injectEventPluginsByName: function(injectedNamesToPlugins) {
        var isOrderingDirty = false;
        for (var pluginName in injectedNamesToPlugins) {
          if (!injectedNamesToPlugins.hasOwnProperty(pluginName)) {
            continue;
          }
          var PluginModule = injectedNamesToPlugins[pluginName];
          if (!namesToPlugins.hasOwnProperty(pluginName) || namesToPlugins[pluginName] !== PluginModule) {
            ("production" !== process.env.NODE_ENV ? invariant(!namesToPlugins[pluginName], 'EventPluginRegistry: Cannot inject two different event plugins ' + 'using the same name, `%s`.', pluginName) : invariant(!namesToPlugins[pluginName]));
            namesToPlugins[pluginName] = PluginModule;
            isOrderingDirty = true;
          }
        }
        if (isOrderingDirty) {
          recomputePluginOrdering();
        }
      },
      getPluginModuleForEvent: function(event) {
        var dispatchConfig = event.dispatchConfig;
        if (dispatchConfig.registrationName) {
          return EventPluginRegistry.registrationNameModules[dispatchConfig.registrationName] || null;
        }
        for (var phase in dispatchConfig.phasedRegistrationNames) {
          if (!dispatchConfig.phasedRegistrationNames.hasOwnProperty(phase)) {
            continue;
          }
          var PluginModule = EventPluginRegistry.registrationNameModules[dispatchConfig.phasedRegistrationNames[phase]];
          if (PluginModule) {
            return PluginModule;
          }
        }
        return null;
      },
      _resetEventPlugins: function() {
        EventPluginOrder = null;
        for (var pluginName in namesToPlugins) {
          if (namesToPlugins.hasOwnProperty(pluginName)) {
            delete namesToPlugins[pluginName];
          }
        }
        EventPluginRegistry.plugins.length = 0;
        var eventNameDispatchConfigs = EventPluginRegistry.eventNameDispatchConfigs;
        for (var eventName in eventNameDispatchConfigs) {
          if (eventNameDispatchConfigs.hasOwnProperty(eventName)) {
            delete eventNameDispatchConfigs[eventName];
          }
        }
        var registrationNameModules = EventPluginRegistry.registrationNameModules;
        for (var registrationName in registrationNameModules) {
          if (registrationNameModules.hasOwnProperty(registrationName)) {
            delete registrationNameModules[registrationName];
          }
        }
      }
    };
    module.exports = EventPluginRegistry;
  })(require("github:jspm/nodelibs-process@0.1.1"));
  global.define = __define;
  return module.exports;
});



System.register("npm:react@0.12.2/lib/accumulateInto", ["npm:react@0.12.2/lib/invariant", "github:jspm/nodelibs-process@0.1.1"], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  (function(process) {
    "use strict";
    var invariant = require("npm:react@0.12.2/lib/invariant");
    function accumulateInto(current, next) {
      ("production" !== process.env.NODE_ENV ? invariant(next != null, 'accumulateInto(...): Accumulated items must not be null or undefined.') : invariant(next != null));
      if (current == null) {
        return next;
      }
      var currentIsArray = Array.isArray(current);
      var nextIsArray = Array.isArray(next);
      if (currentIsArray && nextIsArray) {
        current.push.apply(current, next);
        return current;
      }
      if (currentIsArray) {
        current.push(next);
        return current;
      }
      if (nextIsArray) {
        return [current].concat(next);
      }
      return [current, next];
    }
    module.exports = accumulateInto;
  })(require("github:jspm/nodelibs-process@0.1.1"));
  global.define = __define;
  return module.exports;
});



System.register("npm:react@0.12.2/lib/forEachAccumulated", [], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  "use strict";
  var forEachAccumulated = function(arr, cb, scope) {
    if (Array.isArray(arr)) {
      arr.forEach(cb, scope);
    } else if (arr) {
      cb.call(scope, arr);
    }
  };
  module.exports = forEachAccumulated;
  global.define = __define;
  return module.exports;
});



System.register("npm:react@0.12.2/lib/ReactEventEmitterMixin", ["npm:react@0.12.2/lib/EventPluginHub"], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  "use strict";
  var EventPluginHub = require("npm:react@0.12.2/lib/EventPluginHub");
  function runEventQueueInBatch(events) {
    EventPluginHub.enqueueEvents(events);
    EventPluginHub.processEventQueue();
  }
  var ReactEventEmitterMixin = {handleTopLevel: function(topLevelType, topLevelTarget, topLevelTargetID, nativeEvent) {
      var events = EventPluginHub.extractEvents(topLevelType, topLevelTarget, topLevelTargetID, nativeEvent);
      runEventQueueInBatch(events);
    }};
  module.exports = ReactEventEmitterMixin;
  global.define = __define;
  return module.exports;
});



System.register("npm:react@0.12.2/lib/getUnboundedScrollPosition", [], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  "use strict";
  function getUnboundedScrollPosition(scrollable) {
    if (scrollable === window) {
      return {
        x: window.pageXOffset || document.documentElement.scrollLeft,
        y: window.pageYOffset || document.documentElement.scrollTop
      };
    }
    return {
      x: scrollable.scrollLeft,
      y: scrollable.scrollTop
    };
  }
  module.exports = getUnboundedScrollPosition;
  global.define = __define;
  return module.exports;
});



System.register("npm:react@0.12.2/lib/isEventSupported", ["npm:react@0.12.2/lib/ExecutionEnvironment"], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  "use strict";
  var ExecutionEnvironment = require("npm:react@0.12.2/lib/ExecutionEnvironment");
  var useHasFeature;
  if (ExecutionEnvironment.canUseDOM) {
    useHasFeature = document.implementation && document.implementation.hasFeature && document.implementation.hasFeature('', '') !== true;
  }
  function isEventSupported(eventNameSuffix, capture) {
    if (!ExecutionEnvironment.canUseDOM || capture && !('addEventListener' in document)) {
      return false;
    }
    var eventName = 'on' + eventNameSuffix;
    var isSupported = eventName in document;
    if (!isSupported) {
      var element = document.createElement('div');
      element.setAttribute(eventName, 'return;');
      isSupported = typeof element[eventName] === 'function';
    }
    if (!isSupported && useHasFeature && eventNameSuffix === 'wheel') {
      isSupported = document.implementation.hasFeature('Events.wheel', '3.0');
    }
    return isSupported;
  }
  module.exports = isEventSupported;
  global.define = __define;
  return module.exports;
});



System.register("npm:react@0.12.2/lib/isNode", [], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  function isNode(object) {
    return !!(object && (typeof Node === 'function' ? object instanceof Node : typeof object === 'object' && typeof object.nodeType === 'number' && typeof object.nodeName === 'string'));
  }
  module.exports = isNode;
  global.define = __define;
  return module.exports;
});



System.register("npm:react@0.12.2/lib/deprecated", ["npm:react@0.12.2/lib/Object.assign", "npm:react@0.12.2/lib/warning", "github:jspm/nodelibs-process@0.1.1"], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  (function(process) {
    var assign = require("npm:react@0.12.2/lib/Object.assign");
    var warning = require("npm:react@0.12.2/lib/warning");
    function deprecated(namespace, oldName, newName, ctx, fn) {
      var warned = false;
      if ("production" !== process.env.NODE_ENV) {
        var newFn = function() {
          ("production" !== process.env.NODE_ENV ? warning(warned, (namespace + "." + oldName + " will be deprecated in a future version. ") + ("Use " + namespace + "." + newName + " instead.")) : null);
          warned = true;
          return fn.apply(ctx, arguments);
        };
        newFn.displayName = (namespace + "_" + oldName);
        return assign(newFn, fn);
      }
      return fn;
    }
    module.exports = deprecated;
  })(require("github:jspm/nodelibs-process@0.1.1"));
  global.define = __define;
  return module.exports;
});



System.register("npm:react@0.12.2/lib/getReactRootElementInContainer", [], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  "use strict";
  var DOC_NODE_TYPE = 9;
  function getReactRootElementInContainer(container) {
    if (!container) {
      return null;
    }
    if (container.nodeType === DOC_NODE_TYPE) {
      return container.documentElement;
    } else {
      return container.firstChild;
    }
  }
  module.exports = getReactRootElementInContainer;
  global.define = __define;
  return module.exports;
});



System.register("npm:react@0.12.2/lib/ReactMultiChildUpdateTypes", ["npm:react@0.12.2/lib/keyMirror"], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  "use strict";
  var keyMirror = require("npm:react@0.12.2/lib/keyMirror");
  var ReactMultiChildUpdateTypes = keyMirror({
    INSERT_MARKUP: null,
    MOVE_EXISTING: null,
    REMOVE_NODE: null,
    TEXT_CONTENT: null
  });
  module.exports = ReactMultiChildUpdateTypes;
  global.define = __define;
  return module.exports;
});



System.register("npm:react@0.12.2/lib/ReactTextComponent", ["npm:react@0.12.2/lib/DOMPropertyOperations", "npm:react@0.12.2/lib/ReactComponent", "npm:react@0.12.2/lib/ReactElement", "npm:react@0.12.2/lib/Object.assign", "npm:react@0.12.2/lib/escapeTextForBrowser"], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  "use strict";
  var DOMPropertyOperations = require("npm:react@0.12.2/lib/DOMPropertyOperations");
  var ReactComponent = require("npm:react@0.12.2/lib/ReactComponent");
  var ReactElement = require("npm:react@0.12.2/lib/ReactElement");
  var assign = require("npm:react@0.12.2/lib/Object.assign");
  var escapeTextForBrowser = require("npm:react@0.12.2/lib/escapeTextForBrowser");
  var ReactTextComponent = function(props) {};
  assign(ReactTextComponent.prototype, ReactComponent.Mixin, {
    mountComponent: function(rootID, transaction, mountDepth) {
      ReactComponent.Mixin.mountComponent.call(this, rootID, transaction, mountDepth);
      var escapedText = escapeTextForBrowser(this.props);
      if (transaction.renderToStaticMarkup) {
        return escapedText;
      }
      return ('<span ' + DOMPropertyOperations.createMarkupForID(rootID) + '>' + escapedText + '</span>');
    },
    receiveComponent: function(nextComponent, transaction) {
      var nextProps = nextComponent.props;
      if (nextProps !== this.props) {
        this.props = nextProps;
        ReactComponent.BackendIDOperations.updateTextContentByID(this._rootNodeID, nextProps);
      }
    }
  });
  var ReactTextComponentFactory = function(text) {
    return new ReactElement(ReactTextComponent, null, null, null, null, text);
  };
  ReactTextComponentFactory.type = ReactTextComponent;
  module.exports = ReactTextComponentFactory;
  global.define = __define;
  return module.exports;
});



System.register("npm:react@0.12.2/lib/EventPropagators", ["npm:react@0.12.2/lib/EventConstants", "npm:react@0.12.2/lib/EventPluginHub", "npm:react@0.12.2/lib/accumulateInto", "npm:react@0.12.2/lib/forEachAccumulated", "github:jspm/nodelibs-process@0.1.1"], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  (function(process) {
    "use strict";
    var EventConstants = require("npm:react@0.12.2/lib/EventConstants");
    var EventPluginHub = require("npm:react@0.12.2/lib/EventPluginHub");
    var accumulateInto = require("npm:react@0.12.2/lib/accumulateInto");
    var forEachAccumulated = require("npm:react@0.12.2/lib/forEachAccumulated");
    var PropagationPhases = EventConstants.PropagationPhases;
    var getListener = EventPluginHub.getListener;
    function listenerAtPhase(id, event, propagationPhase) {
      var registrationName = event.dispatchConfig.phasedRegistrationNames[propagationPhase];
      return getListener(id, registrationName);
    }
    function accumulateDirectionalDispatches(domID, upwards, event) {
      if ("production" !== process.env.NODE_ENV) {
        if (!domID) {
          throw new Error('Dispatching id must not be null');
        }
      }
      var phase = upwards ? PropagationPhases.bubbled : PropagationPhases.captured;
      var listener = listenerAtPhase(domID, event, phase);
      if (listener) {
        event._dispatchListeners = accumulateInto(event._dispatchListeners, listener);
        event._dispatchIDs = accumulateInto(event._dispatchIDs, domID);
      }
    }
    function accumulateTwoPhaseDispatchesSingle(event) {
      if (event && event.dispatchConfig.phasedRegistrationNames) {
        EventPluginHub.injection.getInstanceHandle().traverseTwoPhase(event.dispatchMarker, accumulateDirectionalDispatches, event);
      }
    }
    function accumulateDispatches(id, ignoredDirection, event) {
      if (event && event.dispatchConfig.registrationName) {
        var registrationName = event.dispatchConfig.registrationName;
        var listener = getListener(id, registrationName);
        if (listener) {
          event._dispatchListeners = accumulateInto(event._dispatchListeners, listener);
          event._dispatchIDs = accumulateInto(event._dispatchIDs, id);
        }
      }
    }
    function accumulateDirectDispatchesSingle(event) {
      if (event && event.dispatchConfig.registrationName) {
        accumulateDispatches(event.dispatchMarker, null, event);
      }
    }
    function accumulateTwoPhaseDispatches(events) {
      forEachAccumulated(events, accumulateTwoPhaseDispatchesSingle);
    }
    function accumulateEnterLeaveDispatches(leave, enter, fromID, toID) {
      EventPluginHub.injection.getInstanceHandle().traverseEnterLeave(fromID, toID, accumulateDispatches, leave, enter);
    }
    function accumulateDirectDispatches(events) {
      forEachAccumulated(events, accumulateDirectDispatchesSingle);
    }
    var EventPropagators = {
      accumulateTwoPhaseDispatches: accumulateTwoPhaseDispatches,
      accumulateDirectDispatches: accumulateDirectDispatches,
      accumulateEnterLeaveDispatches: accumulateEnterLeaveDispatches
    };
    module.exports = EventPropagators;
  })(require("github:jspm/nodelibs-process@0.1.1"));
  global.define = __define;
  return module.exports;
});



System.register("npm:react@0.12.2/lib/getEventTarget", [], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  "use strict";
  function getEventTarget(nativeEvent) {
    var target = nativeEvent.target || nativeEvent.srcElement || window;
    return target.nodeType === 3 ? target.parentNode : target;
  }
  module.exports = getEventTarget;
  global.define = __define;
  return module.exports;
});



System.register("npm:react@0.12.2/lib/isTextInputElement", [], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  "use strict";
  var supportedInputTypes = {
    'color': true,
    'date': true,
    'datetime': true,
    'datetime-local': true,
    'email': true,
    'month': true,
    'number': true,
    'password': true,
    'range': true,
    'search': true,
    'tel': true,
    'text': true,
    'time': true,
    'url': true,
    'week': true
  };
  function isTextInputElement(elem) {
    return elem && ((elem.nodeName === 'INPUT' && supportedInputTypes[elem.type]) || elem.nodeName === 'TEXTAREA');
  }
  module.exports = isTextInputElement;
  global.define = __define;
  return module.exports;
});



System.register("npm:react@0.12.2/lib/ClientReactRootIndex", [], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  "use strict";
  var nextReactRootIndex = 0;
  var ClientReactRootIndex = {createReactRootIndex: function() {
      return nextReactRootIndex++;
    }};
  module.exports = ClientReactRootIndex;
  global.define = __define;
  return module.exports;
});



System.register("npm:react@0.12.2/lib/getNodeForCharacterOffset", [], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  "use strict";
  function getLeafNode(node) {
    while (node && node.firstChild) {
      node = node.firstChild;
    }
    return node;
  }
  function getSiblingNode(node) {
    while (node) {
      if (node.nextSibling) {
        return node.nextSibling;
      }
      node = node.parentNode;
    }
  }
  function getNodeForCharacterOffset(root, offset) {
    var node = getLeafNode(root);
    var nodeStart = 0;
    var nodeEnd = 0;
    while (node) {
      if (node.nodeType == 3) {
        nodeEnd = nodeStart + node.textContent.length;
        if (nodeStart <= offset && nodeEnd >= offset) {
          return {
            node: node,
            offset: offset - nodeStart
          };
        }
        nodeStart = nodeEnd;
      }
      node = getLeafNode(getSiblingNode(node));
    }
  }
  module.exports = getNodeForCharacterOffset;
  global.define = __define;
  return module.exports;
});



System.register("npm:react@0.12.2/lib/getTextContentAccessor", ["npm:react@0.12.2/lib/ExecutionEnvironment"], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  "use strict";
  var ExecutionEnvironment = require("npm:react@0.12.2/lib/ExecutionEnvironment");
  var contentKey = null;
  function getTextContentAccessor() {
    if (!contentKey && ExecutionEnvironment.canUseDOM) {
      contentKey = 'textContent' in document.documentElement ? 'textContent' : 'innerText';
    }
    return contentKey;
  }
  module.exports = getTextContentAccessor;
  global.define = __define;
  return module.exports;
});



System.register("npm:react@0.12.2/lib/focusNode", [], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  "use strict";
  function focusNode(node) {
    try {
      node.focus();
    } catch (e) {}
  }
  module.exports = focusNode;
  global.define = __define;
  return module.exports;
});



System.register("npm:react@0.12.2/lib/getActiveElement", [], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  function getActiveElement() {
    try {
      return document.activeElement || document.body;
    } catch (e) {
      return document.body;
    }
  }
  module.exports = getActiveElement;
  global.define = __define;
  return module.exports;
});



System.register("npm:react@0.12.2/lib/SyntheticCompositionEvent", ["npm:react@0.12.2/lib/SyntheticEvent"], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  "use strict";
  var SyntheticEvent = require("npm:react@0.12.2/lib/SyntheticEvent");
  var CompositionEventInterface = {data: null};
  function SyntheticCompositionEvent(dispatchConfig, dispatchMarker, nativeEvent) {
    SyntheticEvent.call(this, dispatchConfig, dispatchMarker, nativeEvent);
  }
  SyntheticEvent.augmentClass(SyntheticCompositionEvent, CompositionEventInterface);
  module.exports = SyntheticCompositionEvent;
  global.define = __define;
  return module.exports;
});



System.register("npm:react@0.12.2/lib/DefaultEventPluginOrder", ["npm:react@0.12.2/lib/keyOf"], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  "use strict";
  var keyOf = require("npm:react@0.12.2/lib/keyOf");
  var DefaultEventPluginOrder = [keyOf({ResponderEventPlugin: null}), keyOf({SimpleEventPlugin: null}), keyOf({TapEventPlugin: null}), keyOf({EnterLeaveEventPlugin: null}), keyOf({ChangeEventPlugin: null}), keyOf({SelectEventPlugin: null}), keyOf({CompositionEventPlugin: null}), keyOf({BeforeInputEventPlugin: null}), keyOf({AnalyticsEventPlugin: null}), keyOf({MobileSafariClickEventPlugin: null})];
  module.exports = DefaultEventPluginOrder;
  global.define = __define;
  return module.exports;
});



System.register("npm:react@0.12.2/lib/SyntheticUIEvent", ["npm:react@0.12.2/lib/SyntheticEvent", "npm:react@0.12.2/lib/getEventTarget"], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  "use strict";
  var SyntheticEvent = require("npm:react@0.12.2/lib/SyntheticEvent");
  var getEventTarget = require("npm:react@0.12.2/lib/getEventTarget");
  var UIEventInterface = {
    view: function(event) {
      if (event.view) {
        return event.view;
      }
      var target = getEventTarget(event);
      if (target != null && target.window === target) {
        return target;
      }
      var doc = target.ownerDocument;
      if (doc) {
        return doc.defaultView || doc.parentWindow;
      } else {
        return window;
      }
    },
    detail: function(event) {
      return event.detail || 0;
    }
  };
  function SyntheticUIEvent(dispatchConfig, dispatchMarker, nativeEvent) {
    SyntheticEvent.call(this, dispatchConfig, dispatchMarker, nativeEvent);
  }
  SyntheticEvent.augmentClass(SyntheticUIEvent, UIEventInterface);
  module.exports = SyntheticUIEvent;
  global.define = __define;
  return module.exports;
});



System.register("npm:react@0.12.2/lib/getEventModifierState", [], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  "use strict";
  var modifierKeyToProp = {
    'Alt': 'altKey',
    'Control': 'ctrlKey',
    'Meta': 'metaKey',
    'Shift': 'shiftKey'
  };
  function modifierStateGetter(keyArg) {
    var syntheticEvent = this;
    var nativeEvent = syntheticEvent.nativeEvent;
    if (nativeEvent.getModifierState) {
      return nativeEvent.getModifierState(keyArg);
    }
    var keyProp = modifierKeyToProp[keyArg];
    return keyProp ? !!nativeEvent[keyProp] : false;
  }
  function getEventModifierState(nativeEvent) {
    return modifierStateGetter;
  }
  module.exports = getEventModifierState;
  global.define = __define;
  return module.exports;
});



System.register("npm:react@0.12.2/lib/HTMLDOMPropertyConfig", ["npm:react@0.12.2/lib/DOMProperty", "npm:react@0.12.2/lib/ExecutionEnvironment"], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  "use strict";
  var DOMProperty = require("npm:react@0.12.2/lib/DOMProperty");
  var ExecutionEnvironment = require("npm:react@0.12.2/lib/ExecutionEnvironment");
  var MUST_USE_ATTRIBUTE = DOMProperty.injection.MUST_USE_ATTRIBUTE;
  var MUST_USE_PROPERTY = DOMProperty.injection.MUST_USE_PROPERTY;
  var HAS_BOOLEAN_VALUE = DOMProperty.injection.HAS_BOOLEAN_VALUE;
  var HAS_SIDE_EFFECTS = DOMProperty.injection.HAS_SIDE_EFFECTS;
  var HAS_NUMERIC_VALUE = DOMProperty.injection.HAS_NUMERIC_VALUE;
  var HAS_POSITIVE_NUMERIC_VALUE = DOMProperty.injection.HAS_POSITIVE_NUMERIC_VALUE;
  var HAS_OVERLOADED_BOOLEAN_VALUE = DOMProperty.injection.HAS_OVERLOADED_BOOLEAN_VALUE;
  var hasSVG;
  if (ExecutionEnvironment.canUseDOM) {
    var implementation = document.implementation;
    hasSVG = (implementation && implementation.hasFeature && implementation.hasFeature('http://www.w3.org/TR/SVG11/feature#BasicStructure', '1.1'));
  }
  var HTMLDOMPropertyConfig = {
    isCustomAttribute: RegExp.prototype.test.bind(/^(data|aria)-[a-z_][a-z\d_.\-]*$/),
    Properties: {
      accept: null,
      acceptCharset: null,
      accessKey: null,
      action: null,
      allowFullScreen: MUST_USE_ATTRIBUTE | HAS_BOOLEAN_VALUE,
      allowTransparency: MUST_USE_ATTRIBUTE,
      alt: null,
      async: HAS_BOOLEAN_VALUE,
      autoComplete: null,
      autoPlay: HAS_BOOLEAN_VALUE,
      cellPadding: null,
      cellSpacing: null,
      charSet: MUST_USE_ATTRIBUTE,
      checked: MUST_USE_PROPERTY | HAS_BOOLEAN_VALUE,
      classID: MUST_USE_ATTRIBUTE,
      className: hasSVG ? MUST_USE_ATTRIBUTE : MUST_USE_PROPERTY,
      cols: MUST_USE_ATTRIBUTE | HAS_POSITIVE_NUMERIC_VALUE,
      colSpan: null,
      content: null,
      contentEditable: null,
      contextMenu: MUST_USE_ATTRIBUTE,
      controls: MUST_USE_PROPERTY | HAS_BOOLEAN_VALUE,
      coords: null,
      crossOrigin: null,
      data: null,
      dateTime: MUST_USE_ATTRIBUTE,
      defer: HAS_BOOLEAN_VALUE,
      dir: null,
      disabled: MUST_USE_ATTRIBUTE | HAS_BOOLEAN_VALUE,
      download: HAS_OVERLOADED_BOOLEAN_VALUE,
      draggable: null,
      encType: null,
      form: MUST_USE_ATTRIBUTE,
      formAction: MUST_USE_ATTRIBUTE,
      formEncType: MUST_USE_ATTRIBUTE,
      formMethod: MUST_USE_ATTRIBUTE,
      formNoValidate: HAS_BOOLEAN_VALUE,
      formTarget: MUST_USE_ATTRIBUTE,
      frameBorder: MUST_USE_ATTRIBUTE,
      height: MUST_USE_ATTRIBUTE,
      hidden: MUST_USE_ATTRIBUTE | HAS_BOOLEAN_VALUE,
      href: null,
      hrefLang: null,
      htmlFor: null,
      httpEquiv: null,
      icon: null,
      id: MUST_USE_PROPERTY,
      label: null,
      lang: null,
      list: MUST_USE_ATTRIBUTE,
      loop: MUST_USE_PROPERTY | HAS_BOOLEAN_VALUE,
      manifest: MUST_USE_ATTRIBUTE,
      marginHeight: null,
      marginWidth: null,
      max: null,
      maxLength: MUST_USE_ATTRIBUTE,
      media: MUST_USE_ATTRIBUTE,
      mediaGroup: null,
      method: null,
      min: null,
      multiple: MUST_USE_PROPERTY | HAS_BOOLEAN_VALUE,
      muted: MUST_USE_PROPERTY | HAS_BOOLEAN_VALUE,
      name: null,
      noValidate: HAS_BOOLEAN_VALUE,
      open: null,
      pattern: null,
      placeholder: null,
      poster: null,
      preload: null,
      radioGroup: null,
      readOnly: MUST_USE_PROPERTY | HAS_BOOLEAN_VALUE,
      rel: null,
      required: HAS_BOOLEAN_VALUE,
      role: MUST_USE_ATTRIBUTE,
      rows: MUST_USE_ATTRIBUTE | HAS_POSITIVE_NUMERIC_VALUE,
      rowSpan: null,
      sandbox: null,
      scope: null,
      scrolling: null,
      seamless: MUST_USE_ATTRIBUTE | HAS_BOOLEAN_VALUE,
      selected: MUST_USE_PROPERTY | HAS_BOOLEAN_VALUE,
      shape: null,
      size: MUST_USE_ATTRIBUTE | HAS_POSITIVE_NUMERIC_VALUE,
      sizes: MUST_USE_ATTRIBUTE,
      span: HAS_POSITIVE_NUMERIC_VALUE,
      spellCheck: null,
      src: null,
      srcDoc: MUST_USE_PROPERTY,
      srcSet: MUST_USE_ATTRIBUTE,
      start: HAS_NUMERIC_VALUE,
      step: null,
      style: null,
      tabIndex: null,
      target: null,
      title: null,
      type: null,
      useMap: null,
      value: MUST_USE_PROPERTY | HAS_SIDE_EFFECTS,
      width: MUST_USE_ATTRIBUTE,
      wmode: MUST_USE_ATTRIBUTE,
      autoCapitalize: null,
      autoCorrect: null,
      itemProp: MUST_USE_ATTRIBUTE,
      itemScope: MUST_USE_ATTRIBUTE | HAS_BOOLEAN_VALUE,
      itemType: MUST_USE_ATTRIBUTE,
      property: null
    },
    DOMAttributeNames: {
      acceptCharset: 'accept-charset',
      className: 'class',
      htmlFor: 'for',
      httpEquiv: 'http-equiv'
    },
    DOMPropertyNames: {
      autoCapitalize: 'autocapitalize',
      autoComplete: 'autocomplete',
      autoCorrect: 'autocorrect',
      autoFocus: 'autofocus',
      autoPlay: 'autoplay',
      encType: 'enctype',
      hrefLang: 'hreflang',
      radioGroup: 'radiogroup',
      spellCheck: 'spellcheck',
      srcDoc: 'srcdoc',
      srcSet: 'srcset'
    }
  };
  module.exports = HTMLDOMPropertyConfig;
  global.define = __define;
  return module.exports;
});



System.register("npm:react@0.12.2/lib/MobileSafariClickEventPlugin", ["npm:react@0.12.2/lib/EventConstants", "npm:react@0.12.2/lib/emptyFunction"], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  "use strict";
  var EventConstants = require("npm:react@0.12.2/lib/EventConstants");
  var emptyFunction = require("npm:react@0.12.2/lib/emptyFunction");
  var topLevelTypes = EventConstants.topLevelTypes;
  var MobileSafariClickEventPlugin = {
    eventTypes: null,
    extractEvents: function(topLevelType, topLevelTarget, topLevelTargetID, nativeEvent) {
      if (topLevelType === topLevelTypes.topTouchStart) {
        var target = nativeEvent.target;
        if (target && !target.onclick) {
          target.onclick = emptyFunction;
        }
      }
    }
  };
  module.exports = MobileSafariClickEventPlugin;
  global.define = __define;
  return module.exports;
});



System.register("npm:react@0.12.2/lib/toArray", ["npm:react@0.12.2/lib/invariant", "github:jspm/nodelibs-process@0.1.1"], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  (function(process) {
    var invariant = require("npm:react@0.12.2/lib/invariant");
    function toArray(obj) {
      var length = obj.length;
      ("production" !== process.env.NODE_ENV ? invariant(!Array.isArray(obj) && (typeof obj === 'object' || typeof obj === 'function'), 'toArray: Array-like object expected') : invariant(!Array.isArray(obj) && (typeof obj === 'object' || typeof obj === 'function')));
      ("production" !== process.env.NODE_ENV ? invariant(typeof length === 'number', 'toArray: Object needs a length property') : invariant(typeof length === 'number'));
      ("production" !== process.env.NODE_ENV ? invariant(length === 0 || (length - 1) in obj, 'toArray: Object should have keys for indices') : invariant(length === 0 || (length - 1) in obj));
      if (obj.hasOwnProperty) {
        try {
          return Array.prototype.slice.call(obj);
        } catch (e) {}
      }
      var ret = Array(length);
      for (var ii = 0; ii < length; ii++) {
        ret[ii] = obj[ii];
      }
      return ret;
    }
    module.exports = toArray;
  })(require("github:jspm/nodelibs-process@0.1.1"));
  global.define = __define;
  return module.exports;
});



System.register("npm:react@0.12.2/lib/getMarkupWrap", ["npm:react@0.12.2/lib/ExecutionEnvironment", "npm:react@0.12.2/lib/invariant", "github:jspm/nodelibs-process@0.1.1"], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  (function(process) {
    var ExecutionEnvironment = require("npm:react@0.12.2/lib/ExecutionEnvironment");
    var invariant = require("npm:react@0.12.2/lib/invariant");
    var dummyNode = ExecutionEnvironment.canUseDOM ? document.createElement('div') : null;
    var shouldWrap = {
      'circle': true,
      'defs': true,
      'ellipse': true,
      'g': true,
      'line': true,
      'linearGradient': true,
      'path': true,
      'polygon': true,
      'polyline': true,
      'radialGradient': true,
      'rect': true,
      'stop': true,
      'text': true
    };
    var selectWrap = [1, '<select multiple="true">', '</select>'];
    var tableWrap = [1, '<table>', '</table>'];
    var trWrap = [3, '<table><tbody><tr>', '</tr></tbody></table>'];
    var svgWrap = [1, '<svg>', '</svg>'];
    var markupWrap = {
      '*': [1, '?<div>', '</div>'],
      'area': [1, '<map>', '</map>'],
      'col': [2, '<table><tbody></tbody><colgroup>', '</colgroup></table>'],
      'legend': [1, '<fieldset>', '</fieldset>'],
      'param': [1, '<object>', '</object>'],
      'tr': [2, '<table><tbody>', '</tbody></table>'],
      'optgroup': selectWrap,
      'option': selectWrap,
      'caption': tableWrap,
      'colgroup': tableWrap,
      'tbody': tableWrap,
      'tfoot': tableWrap,
      'thead': tableWrap,
      'td': trWrap,
      'th': trWrap,
      'circle': svgWrap,
      'defs': svgWrap,
      'ellipse': svgWrap,
      'g': svgWrap,
      'line': svgWrap,
      'linearGradient': svgWrap,
      'path': svgWrap,
      'polygon': svgWrap,
      'polyline': svgWrap,
      'radialGradient': svgWrap,
      'rect': svgWrap,
      'stop': svgWrap,
      'text': svgWrap
    };
    function getMarkupWrap(nodeName) {
      ("production" !== process.env.NODE_ENV ? invariant(!!dummyNode, 'Markup wrapping node not initialized') : invariant(!!dummyNode));
      if (!markupWrap.hasOwnProperty(nodeName)) {
        nodeName = '*';
      }
      if (!shouldWrap.hasOwnProperty(nodeName)) {
        if (nodeName === '*') {
          dummyNode.innerHTML = '<link />';
        } else {
          dummyNode.innerHTML = '<' + nodeName + '></' + nodeName + '>';
        }
        shouldWrap[nodeName] = !dummyNode.firstChild;
      }
      return shouldWrap[nodeName] ? markupWrap[nodeName] : null;
    }
    module.exports = getMarkupWrap;
  })(require("github:jspm/nodelibs-process@0.1.1"));
  global.define = __define;
  return module.exports;
});



System.register("npm:react@0.12.2/lib/setInnerHTML", ["npm:react@0.12.2/lib/ExecutionEnvironment", "github:jspm/nodelibs-process@0.1.1"], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  (function(process) {
    "use strict";
    var ExecutionEnvironment = require("npm:react@0.12.2/lib/ExecutionEnvironment");
    var WHITESPACE_TEST = /^[ \r\n\t\f]/;
    var NONVISIBLE_TEST = /<(!--|link|noscript|meta|script|style)[ \r\n\t\f\/>]/;
    var setInnerHTML = function(node, html) {
      node.innerHTML = html;
    };
    if (ExecutionEnvironment.canUseDOM) {
      var testElement = document.createElement('div');
      testElement.innerHTML = ' ';
      if (testElement.innerHTML === '') {
        setInnerHTML = function(node, html) {
          if (node.parentNode) {
            node.parentNode.replaceChild(node, node);
          }
          if (WHITESPACE_TEST.test(html) || html[0] === '<' && NONVISIBLE_TEST.test(html)) {
            node.innerHTML = '\uFEFF' + html;
            var textNode = node.firstChild;
            if (textNode.data.length === 1) {
              node.removeChild(textNode);
            } else {
              textNode.deleteData(0, 1);
            }
          } else {
            node.innerHTML = html;
          }
        };
      }
    }
    module.exports = setInnerHTML;
  })(require("github:jspm/nodelibs-process@0.1.1"));
  global.define = __define;
  return module.exports;
});



System.register("npm:react@0.12.2/lib/adler32", [], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  "use strict";
  var MOD = 65521;
  function adler32(data) {
    var a = 1;
    var b = 0;
    for (var i = 0; i < data.length; i++) {
      a = (a + data.charCodeAt(i)) % MOD;
      b = (b + a) % MOD;
    }
    return a | (b << 16);
  }
  module.exports = adler32;
  global.define = __define;
  return module.exports;
});



System.register("npm:react@0.12.2/lib/ReactPutListenerQueue", ["npm:react@0.12.2/lib/PooledClass", "npm:react@0.12.2/lib/ReactBrowserEventEmitter", "npm:react@0.12.2/lib/Object.assign"], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  "use strict";
  var PooledClass = require("npm:react@0.12.2/lib/PooledClass");
  var ReactBrowserEventEmitter = require("npm:react@0.12.2/lib/ReactBrowserEventEmitter");
  var assign = require("npm:react@0.12.2/lib/Object.assign");
  function ReactPutListenerQueue() {
    this.listenersToPut = [];
  }
  assign(ReactPutListenerQueue.prototype, {
    enqueuePutListener: function(rootNodeID, propKey, propValue) {
      this.listenersToPut.push({
        rootNodeID: rootNodeID,
        propKey: propKey,
        propValue: propValue
      });
    },
    putListeners: function() {
      for (var i = 0; i < this.listenersToPut.length; i++) {
        var listenerToPut = this.listenersToPut[i];
        ReactBrowserEventEmitter.putListener(listenerToPut.rootNodeID, listenerToPut.propKey, listenerToPut.propValue);
      }
    },
    reset: function() {
      this.listenersToPut.length = 0;
    },
    destructor: function() {
      this.reset();
    }
  });
  PooledClass.addPoolingTo(ReactPutListenerQueue);
  module.exports = ReactPutListenerQueue;
  global.define = __define;
  return module.exports;
});



System.register("npm:react@0.12.2/lib/ReactDefaultBatchingStrategy", ["npm:react@0.12.2/lib/ReactUpdates", "npm:react@0.12.2/lib/Transaction", "npm:react@0.12.2/lib/Object.assign", "npm:react@0.12.2/lib/emptyFunction"], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  "use strict";
  var ReactUpdates = require("npm:react@0.12.2/lib/ReactUpdates");
  var Transaction = require("npm:react@0.12.2/lib/Transaction");
  var assign = require("npm:react@0.12.2/lib/Object.assign");
  var emptyFunction = require("npm:react@0.12.2/lib/emptyFunction");
  var RESET_BATCHED_UPDATES = {
    initialize: emptyFunction,
    close: function() {
      ReactDefaultBatchingStrategy.isBatchingUpdates = false;
    }
  };
  var FLUSH_BATCHED_UPDATES = {
    initialize: emptyFunction,
    close: ReactUpdates.flushBatchedUpdates.bind(ReactUpdates)
  };
  var TRANSACTION_WRAPPERS = [FLUSH_BATCHED_UPDATES, RESET_BATCHED_UPDATES];
  function ReactDefaultBatchingStrategyTransaction() {
    this.reinitializeTransaction();
  }
  assign(ReactDefaultBatchingStrategyTransaction.prototype, Transaction.Mixin, {getTransactionWrappers: function() {
      return TRANSACTION_WRAPPERS;
    }});
  var transaction = new ReactDefaultBatchingStrategyTransaction();
  var ReactDefaultBatchingStrategy = {
    isBatchingUpdates: false,
    batchedUpdates: function(callback, a, b) {
      var alreadyBatchingUpdates = ReactDefaultBatchingStrategy.isBatchingUpdates;
      ReactDefaultBatchingStrategy.isBatchingUpdates = true;
      if (alreadyBatchingUpdates) {
        callback(a, b);
      } else {
        transaction.perform(callback, null, a, b);
      }
    }
  };
  module.exports = ReactDefaultBatchingStrategy;
  global.define = __define;
  return module.exports;
});



System.register("npm:react@0.12.2/lib/AutoFocusMixin", ["npm:react@0.12.2/lib/focusNode"], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  "use strict";
  var focusNode = require("npm:react@0.12.2/lib/focusNode");
  var AutoFocusMixin = {componentDidMount: function() {
      if (this.props.autoFocus) {
        focusNode(this.getDOMNode());
      }
    }};
  module.exports = AutoFocusMixin;
  global.define = __define;
  return module.exports;
});



System.register("npm:react@0.12.2/lib/LocalEventTrapMixin", ["npm:react@0.12.2/lib/ReactBrowserEventEmitter", "npm:react@0.12.2/lib/accumulateInto", "npm:react@0.12.2/lib/forEachAccumulated", "npm:react@0.12.2/lib/invariant", "github:jspm/nodelibs-process@0.1.1"], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  (function(process) {
    "use strict";
    var ReactBrowserEventEmitter = require("npm:react@0.12.2/lib/ReactBrowserEventEmitter");
    var accumulateInto = require("npm:react@0.12.2/lib/accumulateInto");
    var forEachAccumulated = require("npm:react@0.12.2/lib/forEachAccumulated");
    var invariant = require("npm:react@0.12.2/lib/invariant");
    function remove(event) {
      event.remove();
    }
    var LocalEventTrapMixin = {
      trapBubbledEvent: function(topLevelType, handlerBaseName) {
        ("production" !== process.env.NODE_ENV ? invariant(this.isMounted(), 'Must be mounted to trap events') : invariant(this.isMounted()));
        var listener = ReactBrowserEventEmitter.trapBubbledEvent(topLevelType, handlerBaseName, this.getDOMNode());
        this._localEventListeners = accumulateInto(this._localEventListeners, listener);
      },
      componentWillUnmount: function() {
        if (this._localEventListeners) {
          forEachAccumulated(this._localEventListeners, remove);
        }
      }
    };
    module.exports = LocalEventTrapMixin;
  })(require("github:jspm/nodelibs-process@0.1.1"));
  global.define = __define;
  return module.exports;
});



System.register("npm:react@0.12.2/lib/ReactDOMImg", ["npm:react@0.12.2/lib/EventConstants", "npm:react@0.12.2/lib/LocalEventTrapMixin", "npm:react@0.12.2/lib/ReactBrowserComponentMixin", "npm:react@0.12.2/lib/ReactCompositeComponent", "npm:react@0.12.2/lib/ReactElement", "npm:react@0.12.2/lib/ReactDOM"], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  "use strict";
  var EventConstants = require("npm:react@0.12.2/lib/EventConstants");
  var LocalEventTrapMixin = require("npm:react@0.12.2/lib/LocalEventTrapMixin");
  var ReactBrowserComponentMixin = require("npm:react@0.12.2/lib/ReactBrowserComponentMixin");
  var ReactCompositeComponent = require("npm:react@0.12.2/lib/ReactCompositeComponent");
  var ReactElement = require("npm:react@0.12.2/lib/ReactElement");
  var ReactDOM = require("npm:react@0.12.2/lib/ReactDOM");
  var img = ReactElement.createFactory(ReactDOM.img.type);
  var ReactDOMImg = ReactCompositeComponent.createClass({
    displayName: 'ReactDOMImg',
    tagName: 'IMG',
    mixins: [ReactBrowserComponentMixin, LocalEventTrapMixin],
    render: function() {
      return img(this.props);
    },
    componentDidMount: function() {
      this.trapBubbledEvent(EventConstants.topLevelTypes.topLoad, 'load');
      this.trapBubbledEvent(EventConstants.topLevelTypes.topError, 'error');
    }
  });
  module.exports = ReactDOMImg;
  global.define = __define;
  return module.exports;
});



System.register("npm:react@0.12.2/lib/ReactPropTypes", ["npm:react@0.12.2/lib/ReactElement", "npm:react@0.12.2/lib/ReactPropTypeLocationNames", "npm:react@0.12.2/lib/deprecated", "npm:react@0.12.2/lib/emptyFunction"], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  "use strict";
  var ReactElement = require("npm:react@0.12.2/lib/ReactElement");
  var ReactPropTypeLocationNames = require("npm:react@0.12.2/lib/ReactPropTypeLocationNames");
  var deprecated = require("npm:react@0.12.2/lib/deprecated");
  var emptyFunction = require("npm:react@0.12.2/lib/emptyFunction");
  var ANONYMOUS = '<<anonymous>>';
  var elementTypeChecker = createElementTypeChecker();
  var nodeTypeChecker = createNodeChecker();
  var ReactPropTypes = {
    array: createPrimitiveTypeChecker('array'),
    bool: createPrimitiveTypeChecker('boolean'),
    func: createPrimitiveTypeChecker('function'),
    number: createPrimitiveTypeChecker('number'),
    object: createPrimitiveTypeChecker('object'),
    string: createPrimitiveTypeChecker('string'),
    any: createAnyTypeChecker(),
    arrayOf: createArrayOfTypeChecker,
    element: elementTypeChecker,
    instanceOf: createInstanceTypeChecker,
    node: nodeTypeChecker,
    objectOf: createObjectOfTypeChecker,
    oneOf: createEnumTypeChecker,
    oneOfType: createUnionTypeChecker,
    shape: createShapeTypeChecker,
    component: deprecated('React.PropTypes', 'component', 'element', this, elementTypeChecker),
    renderable: deprecated('React.PropTypes', 'renderable', 'node', this, nodeTypeChecker)
  };
  function createChainableTypeChecker(validate) {
    function checkType(isRequired, props, propName, componentName, location) {
      componentName = componentName || ANONYMOUS;
      if (props[propName] == null) {
        var locationName = ReactPropTypeLocationNames[location];
        if (isRequired) {
          return new Error(("Required " + locationName + " `" + propName + "` was not specified in ") + ("`" + componentName + "`."));
        }
      } else {
        return validate(props, propName, componentName, location);
      }
    }
    var chainedCheckType = checkType.bind(null, false);
    chainedCheckType.isRequired = checkType.bind(null, true);
    return chainedCheckType;
  }
  function createPrimitiveTypeChecker(expectedType) {
    function validate(props, propName, componentName, location) {
      var propValue = props[propName];
      var propType = getPropType(propValue);
      if (propType !== expectedType) {
        var locationName = ReactPropTypeLocationNames[location];
        var preciseType = getPreciseType(propValue);
        return new Error(("Invalid " + locationName + " `" + propName + "` of type `" + preciseType + "` ") + ("supplied to `" + componentName + "`, expected `" + expectedType + "`."));
      }
    }
    return createChainableTypeChecker(validate);
  }
  function createAnyTypeChecker() {
    return createChainableTypeChecker(emptyFunction.thatReturns());
  }
  function createArrayOfTypeChecker(typeChecker) {
    function validate(props, propName, componentName, location) {
      var propValue = props[propName];
      if (!Array.isArray(propValue)) {
        var locationName = ReactPropTypeLocationNames[location];
        var propType = getPropType(propValue);
        return new Error(("Invalid " + locationName + " `" + propName + "` of type ") + ("`" + propType + "` supplied to `" + componentName + "`, expected an array."));
      }
      for (var i = 0; i < propValue.length; i++) {
        var error = typeChecker(propValue, i, componentName, location);
        if (error instanceof Error) {
          return error;
        }
      }
    }
    return createChainableTypeChecker(validate);
  }
  function createElementTypeChecker() {
    function validate(props, propName, componentName, location) {
      if (!ReactElement.isValidElement(props[propName])) {
        var locationName = ReactPropTypeLocationNames[location];
        return new Error(("Invalid " + locationName + " `" + propName + "` supplied to ") + ("`" + componentName + "`, expected a ReactElement."));
      }
    }
    return createChainableTypeChecker(validate);
  }
  function createInstanceTypeChecker(expectedClass) {
    function validate(props, propName, componentName, location) {
      if (!(props[propName] instanceof expectedClass)) {
        var locationName = ReactPropTypeLocationNames[location];
        var expectedClassName = expectedClass.name || ANONYMOUS;
        return new Error(("Invalid " + locationName + " `" + propName + "` supplied to ") + ("`" + componentName + "`, expected instance of `" + expectedClassName + "`."));
      }
    }
    return createChainableTypeChecker(validate);
  }
  function createEnumTypeChecker(expectedValues) {
    function validate(props, propName, componentName, location) {
      var propValue = props[propName];
      for (var i = 0; i < expectedValues.length; i++) {
        if (propValue === expectedValues[i]) {
          return ;
        }
      }
      var locationName = ReactPropTypeLocationNames[location];
      var valuesString = JSON.stringify(expectedValues);
      return new Error(("Invalid " + locationName + " `" + propName + "` of value `" + propValue + "` ") + ("supplied to `" + componentName + "`, expected one of " + valuesString + "."));
    }
    return createChainableTypeChecker(validate);
  }
  function createObjectOfTypeChecker(typeChecker) {
    function validate(props, propName, componentName, location) {
      var propValue = props[propName];
      var propType = getPropType(propValue);
      if (propType !== 'object') {
        var locationName = ReactPropTypeLocationNames[location];
        return new Error(("Invalid " + locationName + " `" + propName + "` of type ") + ("`" + propType + "` supplied to `" + componentName + "`, expected an object."));
      }
      for (var key in propValue) {
        if (propValue.hasOwnProperty(key)) {
          var error = typeChecker(propValue, key, componentName, location);
          if (error instanceof Error) {
            return error;
          }
        }
      }
    }
    return createChainableTypeChecker(validate);
  }
  function createUnionTypeChecker(arrayOfTypeCheckers) {
    function validate(props, propName, componentName, location) {
      for (var i = 0; i < arrayOfTypeCheckers.length; i++) {
        var checker = arrayOfTypeCheckers[i];
        if (checker(props, propName, componentName, location) == null) {
          return ;
        }
      }
      var locationName = ReactPropTypeLocationNames[location];
      return new Error(("Invalid " + locationName + " `" + propName + "` supplied to ") + ("`" + componentName + "`."));
    }
    return createChainableTypeChecker(validate);
  }
  function createNodeChecker() {
    function validate(props, propName, componentName, location) {
      if (!isNode(props[propName])) {
        var locationName = ReactPropTypeLocationNames[location];
        return new Error(("Invalid " + locationName + " `" + propName + "` supplied to ") + ("`" + componentName + "`, expected a ReactNode."));
      }
    }
    return createChainableTypeChecker(validate);
  }
  function createShapeTypeChecker(shapeTypes) {
    function validate(props, propName, componentName, location) {
      var propValue = props[propName];
      var propType = getPropType(propValue);
      if (propType !== 'object') {
        var locationName = ReactPropTypeLocationNames[location];
        return new Error(("Invalid " + locationName + " `" + propName + "` of type `" + propType + "` ") + ("supplied to `" + componentName + "`, expected `object`."));
      }
      for (var key in shapeTypes) {
        var checker = shapeTypes[key];
        if (!checker) {
          continue;
        }
        var error = checker(propValue, key, componentName, location);
        if (error) {
          return error;
        }
      }
    }
    return createChainableTypeChecker(validate, 'expected `object`');
  }
  function isNode(propValue) {
    switch (typeof propValue) {
      case 'number':
      case 'string':
        return true;
      case 'boolean':
        return !propValue;
      case 'object':
        if (Array.isArray(propValue)) {
          return propValue.every(isNode);
        }
        if (ReactElement.isValidElement(propValue)) {
          return true;
        }
        for (var k in propValue) {
          if (!isNode(propValue[k])) {
            return false;
          }
        }
        return true;
      default:
        return false;
    }
  }
  function getPropType(propValue) {
    var propType = typeof propValue;
    if (Array.isArray(propValue)) {
      return 'array';
    }
    if (propValue instanceof RegExp) {
      return 'object';
    }
    return propType;
  }
  function getPreciseType(propValue) {
    var propType = getPropType(propValue);
    if (propType === 'object') {
      if (propValue instanceof Date) {
        return 'date';
      } else if (propValue instanceof RegExp) {
        return 'regexp';
      }
    }
    return propType;
  }
  module.exports = ReactPropTypes;
  global.define = __define;
  return module.exports;
});



System.register("npm:react@0.12.2/lib/ReactDOMOption", ["npm:react@0.12.2/lib/ReactBrowserComponentMixin", "npm:react@0.12.2/lib/ReactCompositeComponent", "npm:react@0.12.2/lib/ReactElement", "npm:react@0.12.2/lib/ReactDOM", "npm:react@0.12.2/lib/warning", "github:jspm/nodelibs-process@0.1.1"], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  (function(process) {
    "use strict";
    var ReactBrowserComponentMixin = require("npm:react@0.12.2/lib/ReactBrowserComponentMixin");
    var ReactCompositeComponent = require("npm:react@0.12.2/lib/ReactCompositeComponent");
    var ReactElement = require("npm:react@0.12.2/lib/ReactElement");
    var ReactDOM = require("npm:react@0.12.2/lib/ReactDOM");
    var warning = require("npm:react@0.12.2/lib/warning");
    var option = ReactElement.createFactory(ReactDOM.option.type);
    var ReactDOMOption = ReactCompositeComponent.createClass({
      displayName: 'ReactDOMOption',
      mixins: [ReactBrowserComponentMixin],
      componentWillMount: function() {
        if ("production" !== process.env.NODE_ENV) {
          ("production" !== process.env.NODE_ENV ? warning(this.props.selected == null, 'Use the `defaultValue` or `value` props on <select> instead of ' + 'setting `selected` on <option>.') : null);
        }
      },
      render: function() {
        return option(this.props, this.props.children);
      }
    });
    module.exports = ReactDOMOption;
  })(require("github:jspm/nodelibs-process@0.1.1"));
  global.define = __define;
  return module.exports;
});



System.register("npm:react@0.12.2/lib/ReactDOMSelect", ["npm:react@0.12.2/lib/AutoFocusMixin", "npm:react@0.12.2/lib/LinkedValueUtils", "npm:react@0.12.2/lib/ReactBrowserComponentMixin", "npm:react@0.12.2/lib/ReactCompositeComponent", "npm:react@0.12.2/lib/ReactElement", "npm:react@0.12.2/lib/ReactDOM", "npm:react@0.12.2/lib/ReactUpdates", "npm:react@0.12.2/lib/Object.assign"], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  "use strict";
  var AutoFocusMixin = require("npm:react@0.12.2/lib/AutoFocusMixin");
  var LinkedValueUtils = require("npm:react@0.12.2/lib/LinkedValueUtils");
  var ReactBrowserComponentMixin = require("npm:react@0.12.2/lib/ReactBrowserComponentMixin");
  var ReactCompositeComponent = require("npm:react@0.12.2/lib/ReactCompositeComponent");
  var ReactElement = require("npm:react@0.12.2/lib/ReactElement");
  var ReactDOM = require("npm:react@0.12.2/lib/ReactDOM");
  var ReactUpdates = require("npm:react@0.12.2/lib/ReactUpdates");
  var assign = require("npm:react@0.12.2/lib/Object.assign");
  var select = ReactElement.createFactory(ReactDOM.select.type);
  function updateWithPendingValueIfMounted() {
    if (this.isMounted()) {
      this.setState({value: this._pendingValue});
      this._pendingValue = 0;
    }
  }
  function selectValueType(props, propName, componentName) {
    if (props[propName] == null) {
      return ;
    }
    if (props.multiple) {
      if (!Array.isArray(props[propName])) {
        return new Error(("The `" + propName + "` prop supplied to <select> must be an array if ") + ("`multiple` is true."));
      }
    } else {
      if (Array.isArray(props[propName])) {
        return new Error(("The `" + propName + "` prop supplied to <select> must be a scalar ") + ("value if `multiple` is false."));
      }
    }
  }
  function updateOptions(component, propValue) {
    var multiple = component.props.multiple;
    var value = propValue != null ? propValue : component.state.value;
    var options = component.getDOMNode().options;
    var selectedValue,
        i,
        l;
    if (multiple) {
      selectedValue = {};
      for (i = 0, l = value.length; i < l; ++i) {
        selectedValue['' + value[i]] = true;
      }
    } else {
      selectedValue = '' + value;
    }
    for (i = 0, l = options.length; i < l; i++) {
      var selected = multiple ? selectedValue.hasOwnProperty(options[i].value) : options[i].value === selectedValue;
      if (selected !== options[i].selected) {
        options[i].selected = selected;
      }
    }
  }
  var ReactDOMSelect = ReactCompositeComponent.createClass({
    displayName: 'ReactDOMSelect',
    mixins: [AutoFocusMixin, LinkedValueUtils.Mixin, ReactBrowserComponentMixin],
    propTypes: {
      defaultValue: selectValueType,
      value: selectValueType
    },
    getInitialState: function() {
      return {value: this.props.defaultValue || (this.props.multiple ? [] : '')};
    },
    componentWillMount: function() {
      this._pendingValue = null;
    },
    componentWillReceiveProps: function(nextProps) {
      if (!this.props.multiple && nextProps.multiple) {
        this.setState({value: [this.state.value]});
      } else if (this.props.multiple && !nextProps.multiple) {
        this.setState({value: this.state.value[0]});
      }
    },
    render: function() {
      var props = assign({}, this.props);
      props.onChange = this._handleChange;
      props.value = null;
      return select(props, this.props.children);
    },
    componentDidMount: function() {
      updateOptions(this, LinkedValueUtils.getValue(this));
    },
    componentDidUpdate: function(prevProps) {
      var value = LinkedValueUtils.getValue(this);
      var prevMultiple = !!prevProps.multiple;
      var multiple = !!this.props.multiple;
      if (value != null || prevMultiple !== multiple) {
        updateOptions(this, value);
      }
    },
    _handleChange: function(event) {
      var returnValue;
      var onChange = LinkedValueUtils.getOnChange(this);
      if (onChange) {
        returnValue = onChange.call(this, event);
      }
      var selectedValue;
      if (this.props.multiple) {
        selectedValue = [];
        var options = event.target.options;
        for (var i = 0,
            l = options.length; i < l; i++) {
          if (options[i].selected) {
            selectedValue.push(options[i].value);
          }
        }
      } else {
        selectedValue = event.target.value;
      }
      this._pendingValue = selectedValue;
      ReactUpdates.asap(updateWithPendingValueIfMounted, this);
      return returnValue;
    }
  });
  module.exports = ReactDOMSelect;
  global.define = __define;
  return module.exports;
});



System.register("npm:react@0.12.2/lib/ReactDOMTextarea", ["npm:react@0.12.2/lib/AutoFocusMixin", "npm:react@0.12.2/lib/DOMPropertyOperations", "npm:react@0.12.2/lib/LinkedValueUtils", "npm:react@0.12.2/lib/ReactBrowserComponentMixin", "npm:react@0.12.2/lib/ReactCompositeComponent", "npm:react@0.12.2/lib/ReactElement", "npm:react@0.12.2/lib/ReactDOM", "npm:react@0.12.2/lib/ReactUpdates", "npm:react@0.12.2/lib/Object.assign", "npm:react@0.12.2/lib/invariant", "npm:react@0.12.2/lib/warning", "github:jspm/nodelibs-process@0.1.1"], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  (function(process) {
    "use strict";
    var AutoFocusMixin = require("npm:react@0.12.2/lib/AutoFocusMixin");
    var DOMPropertyOperations = require("npm:react@0.12.2/lib/DOMPropertyOperations");
    var LinkedValueUtils = require("npm:react@0.12.2/lib/LinkedValueUtils");
    var ReactBrowserComponentMixin = require("npm:react@0.12.2/lib/ReactBrowserComponentMixin");
    var ReactCompositeComponent = require("npm:react@0.12.2/lib/ReactCompositeComponent");
    var ReactElement = require("npm:react@0.12.2/lib/ReactElement");
    var ReactDOM = require("npm:react@0.12.2/lib/ReactDOM");
    var ReactUpdates = require("npm:react@0.12.2/lib/ReactUpdates");
    var assign = require("npm:react@0.12.2/lib/Object.assign");
    var invariant = require("npm:react@0.12.2/lib/invariant");
    var warning = require("npm:react@0.12.2/lib/warning");
    var textarea = ReactElement.createFactory(ReactDOM.textarea.type);
    function forceUpdateIfMounted() {
      if (this.isMounted()) {
        this.forceUpdate();
      }
    }
    var ReactDOMTextarea = ReactCompositeComponent.createClass({
      displayName: 'ReactDOMTextarea',
      mixins: [AutoFocusMixin, LinkedValueUtils.Mixin, ReactBrowserComponentMixin],
      getInitialState: function() {
        var defaultValue = this.props.defaultValue;
        var children = this.props.children;
        if (children != null) {
          if ("production" !== process.env.NODE_ENV) {
            ("production" !== process.env.NODE_ENV ? warning(false, 'Use the `defaultValue` or `value` props instead of setting ' + 'children on <textarea>.') : null);
          }
          ("production" !== process.env.NODE_ENV ? invariant(defaultValue == null, 'If you supply `defaultValue` on a <textarea>, do not pass children.') : invariant(defaultValue == null));
          if (Array.isArray(children)) {
            ("production" !== process.env.NODE_ENV ? invariant(children.length <= 1, '<textarea> can only have at most one child.') : invariant(children.length <= 1));
            children = children[0];
          }
          defaultValue = '' + children;
        }
        if (defaultValue == null) {
          defaultValue = '';
        }
        var value = LinkedValueUtils.getValue(this);
        return {initialValue: '' + (value != null ? value : defaultValue)};
      },
      render: function() {
        var props = assign({}, this.props);
        ("production" !== process.env.NODE_ENV ? invariant(props.dangerouslySetInnerHTML == null, '`dangerouslySetInnerHTML` does not make sense on <textarea>.') : invariant(props.dangerouslySetInnerHTML == null));
        props.defaultValue = null;
        props.value = null;
        props.onChange = this._handleChange;
        return textarea(props, this.state.initialValue);
      },
      componentDidUpdate: function(prevProps, prevState, prevContext) {
        var value = LinkedValueUtils.getValue(this);
        if (value != null) {
          var rootNode = this.getDOMNode();
          DOMPropertyOperations.setValueForProperty(rootNode, 'value', '' + value);
        }
      },
      _handleChange: function(event) {
        var returnValue;
        var onChange = LinkedValueUtils.getOnChange(this);
        if (onChange) {
          returnValue = onChange.call(this, event);
        }
        ReactUpdates.asap(forceUpdateIfMounted, this);
        return returnValue;
      }
    });
    module.exports = ReactDOMTextarea;
  })(require("github:jspm/nodelibs-process@0.1.1"));
  global.define = __define;
  return module.exports;
});



System.register("npm:react@0.12.2/lib/EventListener", ["npm:react@0.12.2/lib/emptyFunction", "github:jspm/nodelibs-process@0.1.1"], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  (function(process) {
    var emptyFunction = require("npm:react@0.12.2/lib/emptyFunction");
    var EventListener = {
      listen: function(target, eventType, callback) {
        if (target.addEventListener) {
          target.addEventListener(eventType, callback, false);
          return {remove: function() {
              target.removeEventListener(eventType, callback, false);
            }};
        } else if (target.attachEvent) {
          target.attachEvent('on' + eventType, callback);
          return {remove: function() {
              target.detachEvent('on' + eventType, callback);
            }};
        }
      },
      capture: function(target, eventType, callback) {
        if (!target.addEventListener) {
          if ("production" !== process.env.NODE_ENV) {
            console.error('Attempted to listen to events during the capture phase on a ' + 'browser that does not support the capture phase. Your application ' + 'will not receive some events.');
          }
          return {remove: emptyFunction};
        } else {
          target.addEventListener(eventType, callback, true);
          return {remove: function() {
              target.removeEventListener(eventType, callback, true);
            }};
        }
      },
      registerDefault: function() {}
    };
    module.exports = EventListener;
  })(require("github:jspm/nodelibs-process@0.1.1"));
  global.define = __define;
  return module.exports;
});



System.register("npm:react@0.12.2/lib/ReactInjection", ["npm:react@0.12.2/lib/DOMProperty", "npm:react@0.12.2/lib/EventPluginHub", "npm:react@0.12.2/lib/ReactComponent", "npm:react@0.12.2/lib/ReactCompositeComponent", "npm:react@0.12.2/lib/ReactEmptyComponent", "npm:react@0.12.2/lib/ReactBrowserEventEmitter", "npm:react@0.12.2/lib/ReactNativeComponent", "npm:react@0.12.2/lib/ReactPerf", "npm:react@0.12.2/lib/ReactRootIndex", "npm:react@0.12.2/lib/ReactUpdates"], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  "use strict";
  var DOMProperty = require("npm:react@0.12.2/lib/DOMProperty");
  var EventPluginHub = require("npm:react@0.12.2/lib/EventPluginHub");
  var ReactComponent = require("npm:react@0.12.2/lib/ReactComponent");
  var ReactCompositeComponent = require("npm:react@0.12.2/lib/ReactCompositeComponent");
  var ReactEmptyComponent = require("npm:react@0.12.2/lib/ReactEmptyComponent");
  var ReactBrowserEventEmitter = require("npm:react@0.12.2/lib/ReactBrowserEventEmitter");
  var ReactNativeComponent = require("npm:react@0.12.2/lib/ReactNativeComponent");
  var ReactPerf = require("npm:react@0.12.2/lib/ReactPerf");
  var ReactRootIndex = require("npm:react@0.12.2/lib/ReactRootIndex");
  var ReactUpdates = require("npm:react@0.12.2/lib/ReactUpdates");
  var ReactInjection = {
    Component: ReactComponent.injection,
    CompositeComponent: ReactCompositeComponent.injection,
    DOMProperty: DOMProperty.injection,
    EmptyComponent: ReactEmptyComponent.injection,
    EventPluginHub: EventPluginHub.injection,
    EventEmitter: ReactBrowserEventEmitter.injection,
    NativeComponent: ReactNativeComponent.injection,
    Perf: ReactPerf.injection,
    RootIndex: ReactRootIndex.injection,
    Updates: ReactUpdates.injection
  };
  module.exports = ReactInjection;
  global.define = __define;
  return module.exports;
});



System.register("npm:react@0.12.2/lib/shallowEqual", [], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  "use strict";
  function shallowEqual(objA, objB) {
    if (objA === objB) {
      return true;
    }
    var key;
    for (key in objA) {
      if (objA.hasOwnProperty(key) && (!objB.hasOwnProperty(key) || objA[key] !== objB[key])) {
        return false;
      }
    }
    for (key in objB) {
      if (objB.hasOwnProperty(key) && !objA.hasOwnProperty(key)) {
        return false;
      }
    }
    return true;
  }
  module.exports = shallowEqual;
  global.define = __define;
  return module.exports;
});



System.register("npm:react@0.12.2/lib/ServerReactRootIndex", [], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  "use strict";
  var GLOBAL_MOUNT_POINT_MAX = Math.pow(2, 53);
  var ServerReactRootIndex = {createReactRootIndex: function() {
      return Math.ceil(Math.random() * GLOBAL_MOUNT_POINT_MAX);
    }};
  module.exports = ServerReactRootIndex;
  global.define = __define;
  return module.exports;
});



System.register("npm:react@0.12.2/lib/SyntheticClipboardEvent", ["npm:react@0.12.2/lib/SyntheticEvent"], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  "use strict";
  var SyntheticEvent = require("npm:react@0.12.2/lib/SyntheticEvent");
  var ClipboardEventInterface = {clipboardData: function(event) {
      return ('clipboardData' in event ? event.clipboardData : window.clipboardData);
    }};
  function SyntheticClipboardEvent(dispatchConfig, dispatchMarker, nativeEvent) {
    SyntheticEvent.call(this, dispatchConfig, dispatchMarker, nativeEvent);
  }
  SyntheticEvent.augmentClass(SyntheticClipboardEvent, ClipboardEventInterface);
  module.exports = SyntheticClipboardEvent;
  global.define = __define;
  return module.exports;
});



System.register("npm:react@0.12.2/lib/SyntheticFocusEvent", ["npm:react@0.12.2/lib/SyntheticUIEvent"], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  "use strict";
  var SyntheticUIEvent = require("npm:react@0.12.2/lib/SyntheticUIEvent");
  var FocusEventInterface = {relatedTarget: null};
  function SyntheticFocusEvent(dispatchConfig, dispatchMarker, nativeEvent) {
    SyntheticUIEvent.call(this, dispatchConfig, dispatchMarker, nativeEvent);
  }
  SyntheticUIEvent.augmentClass(SyntheticFocusEvent, FocusEventInterface);
  module.exports = SyntheticFocusEvent;
  global.define = __define;
  return module.exports;
});



System.register("npm:react@0.12.2/lib/getEventCharCode", [], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  "use strict";
  function getEventCharCode(nativeEvent) {
    var charCode;
    var keyCode = nativeEvent.keyCode;
    if ('charCode' in nativeEvent) {
      charCode = nativeEvent.charCode;
      if (charCode === 0 && keyCode === 13) {
        charCode = 13;
      }
    } else {
      charCode = keyCode;
    }
    if (charCode >= 32 || charCode === 13) {
      return charCode;
    }
    return 0;
  }
  module.exports = getEventCharCode;
  global.define = __define;
  return module.exports;
});



System.register("npm:react@0.12.2/lib/getEventKey", ["npm:react@0.12.2/lib/getEventCharCode"], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  "use strict";
  var getEventCharCode = require("npm:react@0.12.2/lib/getEventCharCode");
  var normalizeKey = {
    'Esc': 'Escape',
    'Spacebar': ' ',
    'Left': 'ArrowLeft',
    'Up': 'ArrowUp',
    'Right': 'ArrowRight',
    'Down': 'ArrowDown',
    'Del': 'Delete',
    'Win': 'OS',
    'Menu': 'ContextMenu',
    'Apps': 'ContextMenu',
    'Scroll': 'ScrollLock',
    'MozPrintableKey': 'Unidentified'
  };
  var translateToKey = {
    8: 'Backspace',
    9: 'Tab',
    12: 'Clear',
    13: 'Enter',
    16: 'Shift',
    17: 'Control',
    18: 'Alt',
    19: 'Pause',
    20: 'CapsLock',
    27: 'Escape',
    32: ' ',
    33: 'PageUp',
    34: 'PageDown',
    35: 'End',
    36: 'Home',
    37: 'ArrowLeft',
    38: 'ArrowUp',
    39: 'ArrowRight',
    40: 'ArrowDown',
    45: 'Insert',
    46: 'Delete',
    112: 'F1',
    113: 'F2',
    114: 'F3',
    115: 'F4',
    116: 'F5',
    117: 'F6',
    118: 'F7',
    119: 'F8',
    120: 'F9',
    121: 'F10',
    122: 'F11',
    123: 'F12',
    144: 'NumLock',
    145: 'ScrollLock',
    224: 'Meta'
  };
  function getEventKey(nativeEvent) {
    if (nativeEvent.key) {
      var key = normalizeKey[nativeEvent.key] || nativeEvent.key;
      if (key !== 'Unidentified') {
        return key;
      }
    }
    if (nativeEvent.type === 'keypress') {
      var charCode = getEventCharCode(nativeEvent);
      return charCode === 13 ? 'Enter' : String.fromCharCode(charCode);
    }
    if (nativeEvent.type === 'keydown' || nativeEvent.type === 'keyup') {
      return translateToKey[nativeEvent.keyCode] || 'Unidentified';
    }
    return '';
  }
  module.exports = getEventKey;
  global.define = __define;
  return module.exports;
});



System.register("npm:react@0.12.2/lib/SyntheticDragEvent", ["npm:react@0.12.2/lib/SyntheticMouseEvent"], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  "use strict";
  var SyntheticMouseEvent = require("npm:react@0.12.2/lib/SyntheticMouseEvent");
  var DragEventInterface = {dataTransfer: null};
  function SyntheticDragEvent(dispatchConfig, dispatchMarker, nativeEvent) {
    SyntheticMouseEvent.call(this, dispatchConfig, dispatchMarker, nativeEvent);
  }
  SyntheticMouseEvent.augmentClass(SyntheticDragEvent, DragEventInterface);
  module.exports = SyntheticDragEvent;
  global.define = __define;
  return module.exports;
});



System.register("npm:react@0.12.2/lib/SyntheticTouchEvent", ["npm:react@0.12.2/lib/SyntheticUIEvent", "npm:react@0.12.2/lib/getEventModifierState"], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  "use strict";
  var SyntheticUIEvent = require("npm:react@0.12.2/lib/SyntheticUIEvent");
  var getEventModifierState = require("npm:react@0.12.2/lib/getEventModifierState");
  var TouchEventInterface = {
    touches: null,
    targetTouches: null,
    changedTouches: null,
    altKey: null,
    metaKey: null,
    ctrlKey: null,
    shiftKey: null,
    getModifierState: getEventModifierState
  };
  function SyntheticTouchEvent(dispatchConfig, dispatchMarker, nativeEvent) {
    SyntheticUIEvent.call(this, dispatchConfig, dispatchMarker, nativeEvent);
  }
  SyntheticUIEvent.augmentClass(SyntheticTouchEvent, TouchEventInterface);
  module.exports = SyntheticTouchEvent;
  global.define = __define;
  return module.exports;
});



System.register("npm:react@0.12.2/lib/SyntheticWheelEvent", ["npm:react@0.12.2/lib/SyntheticMouseEvent"], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  "use strict";
  var SyntheticMouseEvent = require("npm:react@0.12.2/lib/SyntheticMouseEvent");
  var WheelEventInterface = {
    deltaX: function(event) {
      return ('deltaX' in event ? event.deltaX : 'wheelDeltaX' in event ? -event.wheelDeltaX : 0);
    },
    deltaY: function(event) {
      return ('deltaY' in event ? event.deltaY : 'wheelDeltaY' in event ? -event.wheelDeltaY : 'wheelDelta' in event ? -event.wheelDelta : 0);
    },
    deltaZ: null,
    deltaMode: null
  };
  function SyntheticWheelEvent(dispatchConfig, dispatchMarker, nativeEvent) {
    SyntheticMouseEvent.call(this, dispatchConfig, dispatchMarker, nativeEvent);
  }
  SyntheticMouseEvent.augmentClass(SyntheticWheelEvent, WheelEventInterface);
  module.exports = SyntheticWheelEvent;
  global.define = __define;
  return module.exports;
});



System.register("npm:react@0.12.2/lib/SVGDOMPropertyConfig", ["npm:react@0.12.2/lib/DOMProperty"], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  "use strict";
  var DOMProperty = require("npm:react@0.12.2/lib/DOMProperty");
  var MUST_USE_ATTRIBUTE = DOMProperty.injection.MUST_USE_ATTRIBUTE;
  var SVGDOMPropertyConfig = {
    Properties: {
      cx: MUST_USE_ATTRIBUTE,
      cy: MUST_USE_ATTRIBUTE,
      d: MUST_USE_ATTRIBUTE,
      dx: MUST_USE_ATTRIBUTE,
      dy: MUST_USE_ATTRIBUTE,
      fill: MUST_USE_ATTRIBUTE,
      fillOpacity: MUST_USE_ATTRIBUTE,
      fontFamily: MUST_USE_ATTRIBUTE,
      fontSize: MUST_USE_ATTRIBUTE,
      fx: MUST_USE_ATTRIBUTE,
      fy: MUST_USE_ATTRIBUTE,
      gradientTransform: MUST_USE_ATTRIBUTE,
      gradientUnits: MUST_USE_ATTRIBUTE,
      markerEnd: MUST_USE_ATTRIBUTE,
      markerMid: MUST_USE_ATTRIBUTE,
      markerStart: MUST_USE_ATTRIBUTE,
      offset: MUST_USE_ATTRIBUTE,
      opacity: MUST_USE_ATTRIBUTE,
      patternContentUnits: MUST_USE_ATTRIBUTE,
      patternUnits: MUST_USE_ATTRIBUTE,
      points: MUST_USE_ATTRIBUTE,
      preserveAspectRatio: MUST_USE_ATTRIBUTE,
      r: MUST_USE_ATTRIBUTE,
      rx: MUST_USE_ATTRIBUTE,
      ry: MUST_USE_ATTRIBUTE,
      spreadMethod: MUST_USE_ATTRIBUTE,
      stopColor: MUST_USE_ATTRIBUTE,
      stopOpacity: MUST_USE_ATTRIBUTE,
      stroke: MUST_USE_ATTRIBUTE,
      strokeDasharray: MUST_USE_ATTRIBUTE,
      strokeLinecap: MUST_USE_ATTRIBUTE,
      strokeOpacity: MUST_USE_ATTRIBUTE,
      strokeWidth: MUST_USE_ATTRIBUTE,
      textAnchor: MUST_USE_ATTRIBUTE,
      transform: MUST_USE_ATTRIBUTE,
      version: MUST_USE_ATTRIBUTE,
      viewBox: MUST_USE_ATTRIBUTE,
      x1: MUST_USE_ATTRIBUTE,
      x2: MUST_USE_ATTRIBUTE,
      x: MUST_USE_ATTRIBUTE,
      y1: MUST_USE_ATTRIBUTE,
      y2: MUST_USE_ATTRIBUTE,
      y: MUST_USE_ATTRIBUTE
    },
    DOMAttributeNames: {
      fillOpacity: 'fill-opacity',
      fontFamily: 'font-family',
      fontSize: 'font-size',
      gradientTransform: 'gradientTransform',
      gradientUnits: 'gradientUnits',
      markerEnd: 'marker-end',
      markerMid: 'marker-mid',
      markerStart: 'marker-start',
      patternContentUnits: 'patternContentUnits',
      patternUnits: 'patternUnits',
      preserveAspectRatio: 'preserveAspectRatio',
      spreadMethod: 'spreadMethod',
      stopColor: 'stop-color',
      stopOpacity: 'stop-opacity',
      strokeDasharray: 'stroke-dasharray',
      strokeLinecap: 'stroke-linecap',
      strokeOpacity: 'stroke-opacity',
      strokeWidth: 'stroke-width',
      textAnchor: 'text-anchor',
      viewBox: 'viewBox'
    }
  };
  module.exports = SVGDOMPropertyConfig;
  global.define = __define;
  return module.exports;
});



System.register("npm:react@0.12.2/lib/createFullPageComponent", ["npm:react@0.12.2/lib/ReactCompositeComponent", "npm:react@0.12.2/lib/ReactElement", "npm:react@0.12.2/lib/invariant", "github:jspm/nodelibs-process@0.1.1"], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  (function(process) {
    "use strict";
    var ReactCompositeComponent = require("npm:react@0.12.2/lib/ReactCompositeComponent");
    var ReactElement = require("npm:react@0.12.2/lib/ReactElement");
    var invariant = require("npm:react@0.12.2/lib/invariant");
    function createFullPageComponent(tag) {
      var elementFactory = ReactElement.createFactory(tag);
      var FullPageComponent = ReactCompositeComponent.createClass({
        displayName: 'ReactFullPageComponent' + tag,
        componentWillUnmount: function() {
          ("production" !== process.env.NODE_ENV ? invariant(false, '%s tried to unmount. Because of cross-browser quirks it is ' + 'impossible to unmount some top-level components (eg <html>, <head>, ' + 'and <body>) reliably and efficiently. To fix this, have a single ' + 'top-level component that never unmounts render these elements.', this.constructor.displayName) : invariant(false));
        },
        render: function() {
          return elementFactory(this.props);
        }
      });
      return FullPageComponent;
    }
    module.exports = createFullPageComponent;
  })(require("github:jspm/nodelibs-process@0.1.1"));
  global.define = __define;
  return module.exports;
});



System.register("npm:react@0.12.2/lib/ReactDefaultPerfAnalysis", ["npm:react@0.12.2/lib/Object.assign"], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  var assign = require("npm:react@0.12.2/lib/Object.assign");
  var DONT_CARE_THRESHOLD = 1.2;
  var DOM_OPERATION_TYPES = {
    'mountImageIntoNode': 'set innerHTML',
    INSERT_MARKUP: 'set innerHTML',
    MOVE_EXISTING: 'move',
    REMOVE_NODE: 'remove',
    TEXT_CONTENT: 'set textContent',
    'updatePropertyByID': 'update attribute',
    'deletePropertyByID': 'delete attribute',
    'updateStylesByID': 'update styles',
    'updateInnerHTMLByID': 'set innerHTML',
    'dangerouslyReplaceNodeWithMarkupByID': 'replace'
  };
  function getTotalTime(measurements) {
    var totalTime = 0;
    for (var i = 0; i < measurements.length; i++) {
      var measurement = measurements[i];
      totalTime += measurement.totalTime;
    }
    return totalTime;
  }
  function getDOMSummary(measurements) {
    var items = [];
    for (var i = 0; i < measurements.length; i++) {
      var measurement = measurements[i];
      var id;
      for (id in measurement.writes) {
        measurement.writes[id].forEach(function(write) {
          items.push({
            id: id,
            type: DOM_OPERATION_TYPES[write.type] || write.type,
            args: write.args
          });
        });
      }
    }
    return items;
  }
  function getExclusiveSummary(measurements) {
    var candidates = {};
    var displayName;
    for (var i = 0; i < measurements.length; i++) {
      var measurement = measurements[i];
      var allIDs = assign({}, measurement.exclusive, measurement.inclusive);
      for (var id in allIDs) {
        displayName = measurement.displayNames[id].current;
        candidates[displayName] = candidates[displayName] || {
          componentName: displayName,
          inclusive: 0,
          exclusive: 0,
          render: 0,
          count: 0
        };
        if (measurement.render[id]) {
          candidates[displayName].render += measurement.render[id];
        }
        if (measurement.exclusive[id]) {
          candidates[displayName].exclusive += measurement.exclusive[id];
        }
        if (measurement.inclusive[id]) {
          candidates[displayName].inclusive += measurement.inclusive[id];
        }
        if (measurement.counts[id]) {
          candidates[displayName].count += measurement.counts[id];
        }
      }
    }
    var arr = [];
    for (displayName in candidates) {
      if (candidates[displayName].exclusive >= DONT_CARE_THRESHOLD) {
        arr.push(candidates[displayName]);
      }
    }
    arr.sort(function(a, b) {
      return b.exclusive - a.exclusive;
    });
    return arr;
  }
  function getInclusiveSummary(measurements, onlyClean) {
    var candidates = {};
    var inclusiveKey;
    for (var i = 0; i < measurements.length; i++) {
      var measurement = measurements[i];
      var allIDs = assign({}, measurement.exclusive, measurement.inclusive);
      var cleanComponents;
      if (onlyClean) {
        cleanComponents = getUnchangedComponents(measurement);
      }
      for (var id in allIDs) {
        if (onlyClean && !cleanComponents[id]) {
          continue;
        }
        var displayName = measurement.displayNames[id];
        inclusiveKey = displayName.owner + ' > ' + displayName.current;
        candidates[inclusiveKey] = candidates[inclusiveKey] || {
          componentName: inclusiveKey,
          time: 0,
          count: 0
        };
        if (measurement.inclusive[id]) {
          candidates[inclusiveKey].time += measurement.inclusive[id];
        }
        if (measurement.counts[id]) {
          candidates[inclusiveKey].count += measurement.counts[id];
        }
      }
    }
    var arr = [];
    for (inclusiveKey in candidates) {
      if (candidates[inclusiveKey].time >= DONT_CARE_THRESHOLD) {
        arr.push(candidates[inclusiveKey]);
      }
    }
    arr.sort(function(a, b) {
      return b.time - a.time;
    });
    return arr;
  }
  function getUnchangedComponents(measurement) {
    var cleanComponents = {};
    var dirtyLeafIDs = Object.keys(measurement.writes);
    var allIDs = assign({}, measurement.exclusive, measurement.inclusive);
    for (var id in allIDs) {
      var isDirty = false;
      for (var i = 0; i < dirtyLeafIDs.length; i++) {
        if (dirtyLeafIDs[i].indexOf(id) === 0) {
          isDirty = true;
          break;
        }
      }
      if (!isDirty && measurement.counts[id] > 0) {
        cleanComponents[id] = true;
      }
    }
    return cleanComponents;
  }
  var ReactDefaultPerfAnalysis = {
    getExclusiveSummary: getExclusiveSummary,
    getInclusiveSummary: getInclusiveSummary,
    getDOMSummary: getDOMSummary,
    getTotalTime: getTotalTime
  };
  module.exports = ReactDefaultPerfAnalysis;
  global.define = __define;
  return module.exports;
});



System.register("npm:react@0.12.2/lib/performance", ["npm:react@0.12.2/lib/ExecutionEnvironment"], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  "use strict";
  var ExecutionEnvironment = require("npm:react@0.12.2/lib/ExecutionEnvironment");
  var performance;
  if (ExecutionEnvironment.canUseDOM) {
    performance = window.performance || window.msPerformance || window.webkitPerformance;
  }
  module.exports = performance || {};
  global.define = __define;
  return module.exports;
});



System.register("npm:react@0.12.2/lib/ReactServerRenderingTransaction", ["npm:react@0.12.2/lib/PooledClass", "npm:react@0.12.2/lib/CallbackQueue", "npm:react@0.12.2/lib/ReactPutListenerQueue", "npm:react@0.12.2/lib/Transaction", "npm:react@0.12.2/lib/Object.assign", "npm:react@0.12.2/lib/emptyFunction"], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  "use strict";
  var PooledClass = require("npm:react@0.12.2/lib/PooledClass");
  var CallbackQueue = require("npm:react@0.12.2/lib/CallbackQueue");
  var ReactPutListenerQueue = require("npm:react@0.12.2/lib/ReactPutListenerQueue");
  var Transaction = require("npm:react@0.12.2/lib/Transaction");
  var assign = require("npm:react@0.12.2/lib/Object.assign");
  var emptyFunction = require("npm:react@0.12.2/lib/emptyFunction");
  var ON_DOM_READY_QUEUEING = {
    initialize: function() {
      this.reactMountReady.reset();
    },
    close: emptyFunction
  };
  var PUT_LISTENER_QUEUEING = {
    initialize: function() {
      this.putListenerQueue.reset();
    },
    close: emptyFunction
  };
  var TRANSACTION_WRAPPERS = [PUT_LISTENER_QUEUEING, ON_DOM_READY_QUEUEING];
  function ReactServerRenderingTransaction(renderToStaticMarkup) {
    this.reinitializeTransaction();
    this.renderToStaticMarkup = renderToStaticMarkup;
    this.reactMountReady = CallbackQueue.getPooled(null);
    this.putListenerQueue = ReactPutListenerQueue.getPooled();
  }
  var Mixin = {
    getTransactionWrappers: function() {
      return TRANSACTION_WRAPPERS;
    },
    getReactMountReady: function() {
      return this.reactMountReady;
    },
    getPutListenerQueue: function() {
      return this.putListenerQueue;
    },
    destructor: function() {
      CallbackQueue.release(this.reactMountReady);
      this.reactMountReady = null;
      ReactPutListenerQueue.release(this.putListenerQueue);
      this.putListenerQueue = null;
    }
  };
  assign(ReactServerRenderingTransaction.prototype, Transaction.Mixin, Mixin);
  PooledClass.addPoolingTo(ReactServerRenderingTransaction);
  module.exports = ReactServerRenderingTransaction;
  global.define = __define;
  return module.exports;
});



System.register("npm:react@0.12.2/lib/onlyChild", ["npm:react@0.12.2/lib/ReactElement", "npm:react@0.12.2/lib/invariant", "github:jspm/nodelibs-process@0.1.1"], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  (function(process) {
    "use strict";
    var ReactElement = require("npm:react@0.12.2/lib/ReactElement");
    var invariant = require("npm:react@0.12.2/lib/invariant");
    function onlyChild(children) {
      ("production" !== process.env.NODE_ENV ? invariant(ReactElement.isValidElement(children), 'onlyChild must be passed a children with exactly one child.') : invariant(ReactElement.isValidElement(children)));
      return children;
    }
    module.exports = onlyChild;
  })(require("github:jspm/nodelibs-process@0.1.1"));
  global.define = __define;
  return module.exports;
});



System.register("npm:es5-ext@0.10.6/object/assign/is-implemented", [], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  'use strict';
  module.exports = function() {
    var assign = Object.assign,
        obj;
    if (typeof assign !== 'function')
      return false;
    obj = {foo: 'raz'};
    assign(obj, {bar: 'dwa'}, {trzy: 'trzy'});
    return (obj.foo + obj.bar + obj.trzy) === 'razdwatrzy';
  };
  global.define = __define;
  return module.exports;
});



System.register("npm:es5-ext@0.10.6/object/keys/is-implemented", [], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  'use strict';
  module.exports = function() {
    try {
      Object.keys('primitive');
      return true;
    } catch (e) {
      return false;
    }
  };
  global.define = __define;
  return module.exports;
});



System.register("npm:es5-ext@0.10.6/object/keys/shim", [], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  'use strict';
  var keys = Object.keys;
  module.exports = function(object) {
    return keys(object == null ? object : Object(object));
  };
  global.define = __define;
  return module.exports;
});



System.register("npm:es5-ext@0.10.6/object/valid-value", [], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  'use strict';
  module.exports = function(value) {
    if (value == null)
      throw new TypeError("Cannot use null or undefined");
    return value;
  };
  global.define = __define;
  return module.exports;
});



System.register("npm:es5-ext@0.10.6/object/normalize-options", ["github:jspm/nodelibs-process@0.1.1"], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  (function(process) {
    'use strict';
    var forEach = Array.prototype.forEach,
        create = Object.create;
    var process = function(src, obj) {
      var key;
      for (key in src)
        obj[key] = src[key];
    };
    module.exports = function(options) {
      var result = create(null);
      forEach.call(arguments, function(options) {
        if (options == null)
          return ;
        process(Object(options), result);
      });
      return result;
    };
  })(require("github:jspm/nodelibs-process@0.1.1"));
  global.define = __define;
  return module.exports;
});



System.register("npm:es5-ext@0.10.6/object/is-callable", [], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  'use strict';
  module.exports = function(obj) {
    return typeof obj === 'function';
  };
  global.define = __define;
  return module.exports;
});



System.register("npm:es5-ext@0.10.6/string/#/contains/is-implemented", [], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  'use strict';
  var str = 'razdwatrzy';
  module.exports = function() {
    if (typeof str.contains !== 'function')
      return false;
    return ((str.contains('dwa') === true) && (str.contains('foo') === false));
  };
  global.define = __define;
  return module.exports;
});



System.register("npm:es5-ext@0.10.6/string/#/contains/shim", [], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  'use strict';
  var indexOf = String.prototype.indexOf;
  module.exports = function(searchString) {
    return indexOf.call(this, searchString, arguments[1]) > -1;
  };
  global.define = __define;
  return module.exports;
});



System.register("npm:es5-ext@0.10.6/object/valid-callable", [], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  'use strict';
  module.exports = function(fn) {
    if (typeof fn !== 'function')
      throw new TypeError(fn + " is not a function");
    return fn;
  };
  global.define = __define;
  return module.exports;
});



System.register("app/about-text.html!github:systemjs/plugin-text@0.0.2", [], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  module.exports = "<h2>ReactJS AST Viewer</h2>\n\n<p>Built using the following:</p>\n\n<ul>\n  <li>ReactJS</li>\n  <li>ES6 Modules with jspm and SystemJS</li>\n  <li>Esprima</li>\n  <li>The ACE Code Editor</li>\n</ul>\n";
  global.define = __define;
  return module.exports;
});



System.register("npm:w3c-blob@0.0.1/browser", [], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  module.exports = get_blob();
  function get_blob() {
    if (global.Blob) {
      try {
        new Blob(['asdf'], {type: 'text/plain'});
        return Blob;
      } catch (err) {}
    }
    var Builder = global.WebKitBlobBuilder || global.MozBlobBuilder || global.MSBlobBuilder;
    return function(parts, bag) {
      var builder = new Builder,
          endings = bag.endings,
          type = bag.type;
      if (endings)
        for (var i = 0,
            len = parts.length; i < len; ++i) {
          builder.append(parts[i], endings);
        }
      else
        for (var i = 0,
            len = parts.length; i < len; ++i) {
          builder.append(parts[i]);
        }
      return type ? builder.getBlob(type) : builder.getBlob();
    };
  }
  global.define = __define;
  return module.exports;
});



System.register("npm:base64-js@0.0.8/lib/b64", [], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  var lookup = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';
  ;
  (function(exports) {
    'use strict';
    var Arr = (typeof Uint8Array !== 'undefined') ? Uint8Array : Array;
    var PLUS = '+'.charCodeAt(0);
    var SLASH = '/'.charCodeAt(0);
    var NUMBER = '0'.charCodeAt(0);
    var LOWER = 'a'.charCodeAt(0);
    var UPPER = 'A'.charCodeAt(0);
    var PLUS_URL_SAFE = '-'.charCodeAt(0);
    var SLASH_URL_SAFE = '_'.charCodeAt(0);
    function decode(elt) {
      var code = elt.charCodeAt(0);
      if (code === PLUS || code === PLUS_URL_SAFE)
        return 62;
      if (code === SLASH || code === SLASH_URL_SAFE)
        return 63;
      if (code < NUMBER)
        return -1;
      if (code < NUMBER + 10)
        return code - NUMBER + 26 + 26;
      if (code < UPPER + 26)
        return code - UPPER;
      if (code < LOWER + 26)
        return code - LOWER + 26;
    }
    function b64ToByteArray(b64) {
      var i,
          j,
          l,
          tmp,
          placeHolders,
          arr;
      if (b64.length % 4 > 0) {
        throw new Error('Invalid string. Length must be a multiple of 4');
      }
      var len = b64.length;
      placeHolders = '=' === b64.charAt(len - 2) ? 2 : '=' === b64.charAt(len - 1) ? 1 : 0;
      arr = new Arr(b64.length * 3 / 4 - placeHolders);
      l = placeHolders > 0 ? b64.length - 4 : b64.length;
      var L = 0;
      function push(v) {
        arr[L++] = v;
      }
      for (i = 0, j = 0; i < l; i += 4, j += 3) {
        tmp = (decode(b64.charAt(i)) << 18) | (decode(b64.charAt(i + 1)) << 12) | (decode(b64.charAt(i + 2)) << 6) | decode(b64.charAt(i + 3));
        push((tmp & 0xFF0000) >> 16);
        push((tmp & 0xFF00) >> 8);
        push(tmp & 0xFF);
      }
      if (placeHolders === 2) {
        tmp = (decode(b64.charAt(i)) << 2) | (decode(b64.charAt(i + 1)) >> 4);
        push(tmp & 0xFF);
      } else if (placeHolders === 1) {
        tmp = (decode(b64.charAt(i)) << 10) | (decode(b64.charAt(i + 1)) << 4) | (decode(b64.charAt(i + 2)) >> 2);
        push((tmp >> 8) & 0xFF);
        push(tmp & 0xFF);
      }
      return arr;
    }
    function uint8ToBase64(uint8) {
      var i,
          extraBytes = uint8.length % 3,
          output = "",
          temp,
          length;
      function encode(num) {
        return lookup.charAt(num);
      }
      function tripletToBase64(num) {
        return encode(num >> 18 & 0x3F) + encode(num >> 12 & 0x3F) + encode(num >> 6 & 0x3F) + encode(num & 0x3F);
      }
      for (i = 0, length = uint8.length - extraBytes; i < length; i += 3) {
        temp = (uint8[i] << 16) + (uint8[i + 1] << 8) + (uint8[i + 2]);
        output += tripletToBase64(temp);
      }
      switch (extraBytes) {
        case 1:
          temp = uint8[uint8.length - 1];
          output += encode(temp >> 2);
          output += encode((temp << 4) & 0x3F);
          output += '==';
          break;
        case 2:
          temp = (uint8[uint8.length - 2] << 8) + (uint8[uint8.length - 1]);
          output += encode(temp >> 10);
          output += encode((temp >> 4) & 0x3F);
          output += encode((temp << 2) & 0x3F);
          output += '=';
          break;
      }
      return output;
    }
    exports.toByteArray = b64ToByteArray;
    exports.fromByteArray = uint8ToBase64;
  }(typeof exports === 'undefined' ? (this.base64js = {}) : exports));
  global.define = __define;
  return module.exports;
});



System.register("npm:ieee754@1.1.4/index", [], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  exports.read = function(buffer, offset, isLE, mLen, nBytes) {
    var e,
        m,
        eLen = nBytes * 8 - mLen - 1,
        eMax = (1 << eLen) - 1,
        eBias = eMax >> 1,
        nBits = -7,
        i = isLE ? (nBytes - 1) : 0,
        d = isLE ? -1 : 1,
        s = buffer[offset + i];
    i += d;
    e = s & ((1 << (-nBits)) - 1);
    s >>= (-nBits);
    nBits += eLen;
    for (; nBits > 0; e = e * 256 + buffer[offset + i], i += d, nBits -= 8)
      ;
    m = e & ((1 << (-nBits)) - 1);
    e >>= (-nBits);
    nBits += mLen;
    for (; nBits > 0; m = m * 256 + buffer[offset + i], i += d, nBits -= 8)
      ;
    if (e === 0) {
      e = 1 - eBias;
    } else if (e === eMax) {
      return m ? NaN : ((s ? -1 : 1) * Infinity);
    } else {
      m = m + Math.pow(2, mLen);
      e = e - eBias;
    }
    return (s ? -1 : 1) * m * Math.pow(2, e - mLen);
  };
  exports.write = function(buffer, value, offset, isLE, mLen, nBytes) {
    var e,
        m,
        c,
        eLen = nBytes * 8 - mLen - 1,
        eMax = (1 << eLen) - 1,
        eBias = eMax >> 1,
        rt = (mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0),
        i = isLE ? 0 : (nBytes - 1),
        d = isLE ? 1 : -1,
        s = value < 0 || (value === 0 && 1 / value < 0) ? 1 : 0;
    value = Math.abs(value);
    if (isNaN(value) || value === Infinity) {
      m = isNaN(value) ? 1 : 0;
      e = eMax;
    } else {
      e = Math.floor(Math.log(value) / Math.LN2);
      if (value * (c = Math.pow(2, -e)) < 1) {
        e--;
        c *= 2;
      }
      if (e + eBias >= 1) {
        value += rt / c;
      } else {
        value += rt * Math.pow(2, 1 - eBias);
      }
      if (value * c >= 2) {
        e++;
        c /= 2;
      }
      if (e + eBias >= eMax) {
        m = 0;
        e = eMax;
      } else if (e + eBias >= 1) {
        m = (value * c - 1) * Math.pow(2, mLen);
        e = e + eBias;
      } else {
        m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen);
        e = 0;
      }
    }
    for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8)
      ;
    e = (e << mLen) | m;
    eLen += mLen;
    for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8)
      ;
    buffer[offset + i - d] |= s * 128;
  };
  global.define = __define;
  return module.exports;
});



System.register("npm:is-array@1.0.1/index", [], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  var isArray = Array.isArray;
  var str = Object.prototype.toString;
  module.exports = isArray || function(val) {
    return !!val && '[object Array]' == str.call(val);
  };
  global.define = __define;
  return module.exports;
});



System.register("npm:esprima@2.0.0/esprima", ["github:jspm/nodelibs-process@0.1.1"], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  "format cjs";
  (function(process) {
    (function(root, factory) {
      'use strict';
      if (typeof define === 'function' && define.amd) {
        define(["exports"], factory);
      } else if (typeof exports !== 'undefined') {
        factory(exports);
      } else {
        factory((root.esprima = {}));
      }
    }(this, function(exports) {
      'use strict';
      var Token,
          TokenName,
          FnExprTokens,
          Syntax,
          PlaceHolders,
          PropertyKind,
          Messages,
          Regex,
          source,
          strict,
          index,
          lineNumber,
          lineStart,
          length,
          lookahead,
          state,
          extra;
      Token = {
        BooleanLiteral: 1,
        EOF: 2,
        Identifier: 3,
        Keyword: 4,
        NullLiteral: 5,
        NumericLiteral: 6,
        Punctuator: 7,
        StringLiteral: 8,
        RegularExpression: 9
      };
      TokenName = {};
      TokenName[Token.BooleanLiteral] = 'Boolean';
      TokenName[Token.EOF] = '<end>';
      TokenName[Token.Identifier] = 'Identifier';
      TokenName[Token.Keyword] = 'Keyword';
      TokenName[Token.NullLiteral] = 'Null';
      TokenName[Token.NumericLiteral] = 'Numeric';
      TokenName[Token.Punctuator] = 'Punctuator';
      TokenName[Token.StringLiteral] = 'String';
      TokenName[Token.RegularExpression] = 'RegularExpression';
      FnExprTokens = ['(', '{', '[', 'in', 'typeof', 'instanceof', 'new', 'return', 'case', 'delete', 'throw', 'void', '=', '+=', '-=', '*=', '/=', '%=', '<<=', '>>=', '>>>=', '&=', '|=', '^=', ',', '+', '-', '*', '/', '%', '++', '--', '<<', '>>', '>>>', '&', '|', '^', '!', '~', '&&', '||', '?', ':', '===', '==', '>=', '<=', '<', '>', '!=', '!=='];
      Syntax = {
        AssignmentExpression: 'AssignmentExpression',
        ArrayExpression: 'ArrayExpression',
        ArrowFunctionExpression: 'ArrowFunctionExpression',
        BlockStatement: 'BlockStatement',
        BinaryExpression: 'BinaryExpression',
        BreakStatement: 'BreakStatement',
        CallExpression: 'CallExpression',
        CatchClause: 'CatchClause',
        ConditionalExpression: 'ConditionalExpression',
        ContinueStatement: 'ContinueStatement',
        DoWhileStatement: 'DoWhileStatement',
        DebuggerStatement: 'DebuggerStatement',
        EmptyStatement: 'EmptyStatement',
        ExpressionStatement: 'ExpressionStatement',
        ForStatement: 'ForStatement',
        ForInStatement: 'ForInStatement',
        FunctionDeclaration: 'FunctionDeclaration',
        FunctionExpression: 'FunctionExpression',
        Identifier: 'Identifier',
        IfStatement: 'IfStatement',
        Literal: 'Literal',
        LabeledStatement: 'LabeledStatement',
        LogicalExpression: 'LogicalExpression',
        MemberExpression: 'MemberExpression',
        NewExpression: 'NewExpression',
        ObjectExpression: 'ObjectExpression',
        Program: 'Program',
        Property: 'Property',
        ReturnStatement: 'ReturnStatement',
        SequenceExpression: 'SequenceExpression',
        SwitchStatement: 'SwitchStatement',
        SwitchCase: 'SwitchCase',
        ThisExpression: 'ThisExpression',
        ThrowStatement: 'ThrowStatement',
        TryStatement: 'TryStatement',
        UnaryExpression: 'UnaryExpression',
        UpdateExpression: 'UpdateExpression',
        VariableDeclaration: 'VariableDeclaration',
        VariableDeclarator: 'VariableDeclarator',
        WhileStatement: 'WhileStatement',
        WithStatement: 'WithStatement'
      };
      PlaceHolders = {ArrowParameterPlaceHolder: {type: 'ArrowParameterPlaceHolder'}};
      PropertyKind = {
        Data: 1,
        Get: 2,
        Set: 4
      };
      Messages = {
        UnexpectedToken: 'Unexpected token %0',
        UnexpectedNumber: 'Unexpected number',
        UnexpectedString: 'Unexpected string',
        UnexpectedIdentifier: 'Unexpected identifier',
        UnexpectedReserved: 'Unexpected reserved word',
        UnexpectedEOS: 'Unexpected end of input',
        NewlineAfterThrow: 'Illegal newline after throw',
        InvalidRegExp: 'Invalid regular expression',
        UnterminatedRegExp: 'Invalid regular expression: missing /',
        InvalidLHSInAssignment: 'Invalid left-hand side in assignment',
        InvalidLHSInForIn: 'Invalid left-hand side in for-in',
        MultipleDefaultsInSwitch: 'More than one default clause in switch statement',
        NoCatchOrFinally: 'Missing catch or finally after try',
        UnknownLabel: 'Undefined label \'%0\'',
        Redeclaration: '%0 \'%1\' has already been declared',
        IllegalContinue: 'Illegal continue statement',
        IllegalBreak: 'Illegal break statement',
        IllegalReturn: 'Illegal return statement',
        StrictModeWith: 'Strict mode code may not include a with statement',
        StrictCatchVariable: 'Catch variable may not be eval or arguments in strict mode',
        StrictVarName: 'Variable name may not be eval or arguments in strict mode',
        StrictParamName: 'Parameter name eval or arguments is not allowed in strict mode',
        StrictParamDupe: 'Strict mode function may not have duplicate parameter names',
        StrictFunctionName: 'Function name may not be eval or arguments in strict mode',
        StrictOctalLiteral: 'Octal literals are not allowed in strict mode.',
        StrictDelete: 'Delete of an unqualified identifier in strict mode.',
        StrictDuplicateProperty: 'Duplicate data property in object literal not allowed in strict mode',
        AccessorDataProperty: 'Object literal may not have data and accessor property with the same name',
        AccessorGetSet: 'Object literal may not have multiple get/set accessors with the same name',
        StrictLHSAssignment: 'Assignment to eval or arguments is not allowed in strict mode',
        StrictLHSPostfix: 'Postfix increment/decrement may not have eval or arguments operand in strict mode',
        StrictLHSPrefix: 'Prefix increment/decrement may not have eval or arguments operand in strict mode',
        StrictReservedWord: 'Use of future reserved word in strict mode'
      };
      Regex = {
        NonAsciiIdentifierStart: new RegExp('[\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0370-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u048A-\u052F\u0531-\u0556\u0559\u0561-\u0587\u05D0-\u05EA\u05F0-\u05F2\u0620-\u064A\u066E\u066F\u0671-\u06D3\u06D5\u06E5\u06E6\u06EE\u06EF\u06FA-\u06FC\u06FF\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07CA-\u07EA\u07F4\u07F5\u07FA\u0800-\u0815\u081A\u0824\u0828\u0840-\u0858\u08A0-\u08B2\u0904-\u0939\u093D\u0950\u0958-\u0961\u0971-\u0980\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BD\u09CE\u09DC\u09DD\u09DF-\u09E1\u09F0\u09F1\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A59-\u0A5C\u0A5E\u0A72-\u0A74\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD\u0AD0\u0AE0\u0AE1\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D\u0B5C\u0B5D\u0B5F-\u0B61\u0B71\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BD0\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D\u0C58\u0C59\u0C60\u0C61\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBD\u0CDE\u0CE0\u0CE1\u0CF1\u0CF2\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D\u0D4E\u0D60\u0D61\u0D7A-\u0D7F\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0E01-\u0E30\u0E32\u0E33\u0E40-\u0E46\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB0\u0EB2\u0EB3\u0EBD\u0EC0-\u0EC4\u0EC6\u0EDC-\u0EDF\u0F00\u0F40-\u0F47\u0F49-\u0F6C\u0F88-\u0F8C\u1000-\u102A\u103F\u1050-\u1055\u105A-\u105D\u1061\u1065\u1066\u106E-\u1070\u1075-\u1081\u108E\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u1380-\u138F\u13A0-\u13F4\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u170C\u170E-\u1711\u1720-\u1731\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17D7\u17DC\u1820-\u1877\u1880-\u18A8\u18AA\u18B0-\u18F5\u1900-\u191E\u1950-\u196D\u1970-\u1974\u1980-\u19AB\u19C1-\u19C7\u1A00-\u1A16\u1A20-\u1A54\u1AA7\u1B05-\u1B33\u1B45-\u1B4B\u1B83-\u1BA0\u1BAE\u1BAF\u1BBA-\u1BE5\u1C00-\u1C23\u1C4D-\u1C4F\u1C5A-\u1C7D\u1CE9-\u1CEC\u1CEE-\u1CF1\u1CF5\u1CF6\u1D00-\u1DBF\u1E00-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u2071\u207F\u2090-\u209C\u2102\u2107\u210A-\u2113\u2115\u2119-\u211D\u2124\u2126\u2128\u212A-\u212D\u212F-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CEE\u2CF2\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u2E2F\u3005-\u3007\u3021-\u3029\u3031-\u3035\u3038-\u303C\u3041-\u3096\u309D-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312D\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FCC\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA61F\uA62A\uA62B\uA640-\uA66E\uA67F-\uA69D\uA6A0-\uA6EF\uA717-\uA71F\uA722-\uA788\uA78B-\uA78E\uA790-\uA7AD\uA7B0\uA7B1\uA7F7-\uA801\uA803-\uA805\uA807-\uA80A\uA80C-\uA822\uA840-\uA873\uA882-\uA8B3\uA8F2-\uA8F7\uA8FB\uA90A-\uA925\uA930-\uA946\uA960-\uA97C\uA984-\uA9B2\uA9CF\uA9E0-\uA9E4\uA9E6-\uA9EF\uA9FA-\uA9FE\uAA00-\uAA28\uAA40-\uAA42\uAA44-\uAA4B\uAA60-\uAA76\uAA7A\uAA7E-\uAAAF\uAAB1\uAAB5\uAAB6\uAAB9-\uAABD\uAAC0\uAAC2\uAADB-\uAADD\uAAE0-\uAAEA\uAAF2-\uAAF4\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB5F\uAB64\uAB65\uABC0-\uABE2\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE70-\uFE74\uFE76-\uFEFC\uFF21-\uFF3A\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]'),
        NonAsciiIdentifierPart: new RegExp('[\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0300-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u0483-\u0487\u048A-\u052F\u0531-\u0556\u0559\u0561-\u0587\u0591-\u05BD\u05BF\u05C1\u05C2\u05C4\u05C5\u05C7\u05D0-\u05EA\u05F0-\u05F2\u0610-\u061A\u0620-\u0669\u066E-\u06D3\u06D5-\u06DC\u06DF-\u06E8\u06EA-\u06FC\u06FF\u0710-\u074A\u074D-\u07B1\u07C0-\u07F5\u07FA\u0800-\u082D\u0840-\u085B\u08A0-\u08B2\u08E4-\u0963\u0966-\u096F\u0971-\u0983\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BC-\u09C4\u09C7\u09C8\u09CB-\u09CE\u09D7\u09DC\u09DD\u09DF-\u09E3\u09E6-\u09F1\u0A01-\u0A03\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A3C\u0A3E-\u0A42\u0A47\u0A48\u0A4B-\u0A4D\u0A51\u0A59-\u0A5C\u0A5E\u0A66-\u0A75\u0A81-\u0A83\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABC-\u0AC5\u0AC7-\u0AC9\u0ACB-\u0ACD\u0AD0\u0AE0-\u0AE3\u0AE6-\u0AEF\u0B01-\u0B03\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3C-\u0B44\u0B47\u0B48\u0B4B-\u0B4D\u0B56\u0B57\u0B5C\u0B5D\u0B5F-\u0B63\u0B66-\u0B6F\u0B71\u0B82\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BBE-\u0BC2\u0BC6-\u0BC8\u0BCA-\u0BCD\u0BD0\u0BD7\u0BE6-\u0BEF\u0C00-\u0C03\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D-\u0C44\u0C46-\u0C48\u0C4A-\u0C4D\u0C55\u0C56\u0C58\u0C59\u0C60-\u0C63\u0C66-\u0C6F\u0C81-\u0C83\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBC-\u0CC4\u0CC6-\u0CC8\u0CCA-\u0CCD\u0CD5\u0CD6\u0CDE\u0CE0-\u0CE3\u0CE6-\u0CEF\u0CF1\u0CF2\u0D01-\u0D03\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D-\u0D44\u0D46-\u0D48\u0D4A-\u0D4E\u0D57\u0D60-\u0D63\u0D66-\u0D6F\u0D7A-\u0D7F\u0D82\u0D83\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0DCA\u0DCF-\u0DD4\u0DD6\u0DD8-\u0DDF\u0DE6-\u0DEF\u0DF2\u0DF3\u0E01-\u0E3A\u0E40-\u0E4E\u0E50-\u0E59\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB9\u0EBB-\u0EBD\u0EC0-\u0EC4\u0EC6\u0EC8-\u0ECD\u0ED0-\u0ED9\u0EDC-\u0EDF\u0F00\u0F18\u0F19\u0F20-\u0F29\u0F35\u0F37\u0F39\u0F3E-\u0F47\u0F49-\u0F6C\u0F71-\u0F84\u0F86-\u0F97\u0F99-\u0FBC\u0FC6\u1000-\u1049\u1050-\u109D\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u135D-\u135F\u1380-\u138F\u13A0-\u13F4\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u170C\u170E-\u1714\u1720-\u1734\u1740-\u1753\u1760-\u176C\u176E-\u1770\u1772\u1773\u1780-\u17D3\u17D7\u17DC\u17DD\u17E0-\u17E9\u180B-\u180D\u1810-\u1819\u1820-\u1877\u1880-\u18AA\u18B0-\u18F5\u1900-\u191E\u1920-\u192B\u1930-\u193B\u1946-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u19D0-\u19D9\u1A00-\u1A1B\u1A20-\u1A5E\u1A60-\u1A7C\u1A7F-\u1A89\u1A90-\u1A99\u1AA7\u1AB0-\u1ABD\u1B00-\u1B4B\u1B50-\u1B59\u1B6B-\u1B73\u1B80-\u1BF3\u1C00-\u1C37\u1C40-\u1C49\u1C4D-\u1C7D\u1CD0-\u1CD2\u1CD4-\u1CF6\u1CF8\u1CF9\u1D00-\u1DF5\u1DFC-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u200C\u200D\u203F\u2040\u2054\u2071\u207F\u2090-\u209C\u20D0-\u20DC\u20E1\u20E5-\u20F0\u2102\u2107\u210A-\u2113\u2115\u2119-\u211D\u2124\u2126\u2128\u212A-\u212D\u212F-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D7F-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u2DE0-\u2DFF\u2E2F\u3005-\u3007\u3021-\u302F\u3031-\u3035\u3038-\u303C\u3041-\u3096\u3099\u309A\u309D-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312D\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FCC\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA62B\uA640-\uA66F\uA674-\uA67D\uA67F-\uA69D\uA69F-\uA6F1\uA717-\uA71F\uA722-\uA788\uA78B-\uA78E\uA790-\uA7AD\uA7B0\uA7B1\uA7F7-\uA827\uA840-\uA873\uA880-\uA8C4\uA8D0-\uA8D9\uA8E0-\uA8F7\uA8FB\uA900-\uA92D\uA930-\uA953\uA960-\uA97C\uA980-\uA9C0\uA9CF-\uA9D9\uA9E0-\uA9FE\uAA00-\uAA36\uAA40-\uAA4D\uAA50-\uAA59\uAA60-\uAA76\uAA7A-\uAAC2\uAADB-\uAADD\uAAE0-\uAAEF\uAAF2-\uAAF6\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB5F\uAB64\uAB65\uABC0-\uABEA\uABEC\uABED\uABF0-\uABF9\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE00-\uFE0F\uFE20-\uFE2D\uFE33\uFE34\uFE4D-\uFE4F\uFE70-\uFE74\uFE76-\uFEFC\uFF10-\uFF19\uFF21-\uFF3A\uFF3F\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]')
      };
      function assert(condition, message) {
        if (!condition) {
          throw new Error('ASSERT: ' + message);
        }
      }
      function isDecimalDigit(ch) {
        return (ch >= 0x30 && ch <= 0x39);
      }
      function isHexDigit(ch) {
        return '0123456789abcdefABCDEF'.indexOf(ch) >= 0;
      }
      function isOctalDigit(ch) {
        return '01234567'.indexOf(ch) >= 0;
      }
      function isWhiteSpace(ch) {
        return (ch === 0x20) || (ch === 0x09) || (ch === 0x0B) || (ch === 0x0C) || (ch === 0xA0) || (ch >= 0x1680 && [0x1680, 0x180E, 0x2000, 0x2001, 0x2002, 0x2003, 0x2004, 0x2005, 0x2006, 0x2007, 0x2008, 0x2009, 0x200A, 0x202F, 0x205F, 0x3000, 0xFEFF].indexOf(ch) >= 0);
      }
      function isLineTerminator(ch) {
        return (ch === 0x0A) || (ch === 0x0D) || (ch === 0x2028) || (ch === 0x2029);
      }
      function isIdentifierStart(ch) {
        return (ch === 0x24) || (ch === 0x5F) || (ch >= 0x41 && ch <= 0x5A) || (ch >= 0x61 && ch <= 0x7A) || (ch === 0x5C) || ((ch >= 0x80) && Regex.NonAsciiIdentifierStart.test(String.fromCharCode(ch)));
      }
      function isIdentifierPart(ch) {
        return (ch === 0x24) || (ch === 0x5F) || (ch >= 0x41 && ch <= 0x5A) || (ch >= 0x61 && ch <= 0x7A) || (ch >= 0x30 && ch <= 0x39) || (ch === 0x5C) || ((ch >= 0x80) && Regex.NonAsciiIdentifierPart.test(String.fromCharCode(ch)));
      }
      function isFutureReservedWord(id) {
        switch (id) {
          case 'class':
          case 'enum':
          case 'export':
          case 'extends':
          case 'import':
          case 'super':
            return true;
          default:
            return false;
        }
      }
      function isStrictModeReservedWord(id) {
        switch (id) {
          case 'implements':
          case 'interface':
          case 'package':
          case 'private':
          case 'protected':
          case 'public':
          case 'static':
          case 'yield':
          case 'let':
            return true;
          default:
            return false;
        }
      }
      function isRestrictedWord(id) {
        return id === 'eval' || id === 'arguments';
      }
      function isKeyword(id) {
        if (strict && isStrictModeReservedWord(id)) {
          return true;
        }
        switch (id.length) {
          case 2:
            return (id === 'if') || (id === 'in') || (id === 'do');
          case 3:
            return (id === 'var') || (id === 'for') || (id === 'new') || (id === 'try') || (id === 'let');
          case 4:
            return (id === 'this') || (id === 'else') || (id === 'case') || (id === 'void') || (id === 'with') || (id === 'enum');
          case 5:
            return (id === 'while') || (id === 'break') || (id === 'catch') || (id === 'throw') || (id === 'const') || (id === 'yield') || (id === 'class') || (id === 'super');
          case 6:
            return (id === 'return') || (id === 'typeof') || (id === 'delete') || (id === 'switch') || (id === 'export') || (id === 'import');
          case 7:
            return (id === 'default') || (id === 'finally') || (id === 'extends');
          case 8:
            return (id === 'function') || (id === 'continue') || (id === 'debugger');
          case 10:
            return (id === 'instanceof');
          default:
            return false;
        }
      }
      function addComment(type, value, start, end, loc) {
        var comment;
        assert(typeof start === 'number', 'Comment must have valid position');
        if (state.lastCommentStart >= start) {
          return ;
        }
        state.lastCommentStart = start;
        comment = {
          type: type,
          value: value
        };
        if (extra.range) {
          comment.range = [start, end];
        }
        if (extra.loc) {
          comment.loc = loc;
        }
        extra.comments.push(comment);
        if (extra.attachComment) {
          extra.leadingComments.push(comment);
          extra.trailingComments.push(comment);
        }
      }
      function skipSingleLineComment(offset) {
        var start,
            loc,
            ch,
            comment;
        start = index - offset;
        loc = {start: {
            line: lineNumber,
            column: index - lineStart - offset
          }};
        while (index < length) {
          ch = source.charCodeAt(index);
          ++index;
          if (isLineTerminator(ch)) {
            if (extra.comments) {
              comment = source.slice(start + offset, index - 1);
              loc.end = {
                line: lineNumber,
                column: index - lineStart - 1
              };
              addComment('Line', comment, start, index - 1, loc);
            }
            if (ch === 13 && source.charCodeAt(index) === 10) {
              ++index;
            }
            ++lineNumber;
            lineStart = index;
            return ;
          }
        }
        if (extra.comments) {
          comment = source.slice(start + offset, index);
          loc.end = {
            line: lineNumber,
            column: index - lineStart
          };
          addComment('Line', comment, start, index, loc);
        }
      }
      function skipMultiLineComment() {
        var start,
            loc,
            ch,
            comment;
        if (extra.comments) {
          start = index - 2;
          loc = {start: {
              line: lineNumber,
              column: index - lineStart - 2
            }};
        }
        while (index < length) {
          ch = source.charCodeAt(index);
          if (isLineTerminator(ch)) {
            if (ch === 0x0D && source.charCodeAt(index + 1) === 0x0A) {
              ++index;
            }
            ++lineNumber;
            ++index;
            lineStart = index;
            if (index >= length) {
              throwUnexpectedToken();
            }
          } else if (ch === 0x2A) {
            if (source.charCodeAt(index + 1) === 0x2F) {
              ++index;
              ++index;
              if (extra.comments) {
                comment = source.slice(start + 2, index - 2);
                loc.end = {
                  line: lineNumber,
                  column: index - lineStart
                };
                addComment('Block', comment, start, index, loc);
              }
              return ;
            }
            ++index;
          } else {
            ++index;
          }
        }
        throwUnexpectedToken();
      }
      function skipComment() {
        var ch,
            start;
        start = (index === 0);
        while (index < length) {
          ch = source.charCodeAt(index);
          if (isWhiteSpace(ch)) {
            ++index;
          } else if (isLineTerminator(ch)) {
            ++index;
            if (ch === 0x0D && source.charCodeAt(index) === 0x0A) {
              ++index;
            }
            ++lineNumber;
            lineStart = index;
            start = true;
          } else if (ch === 0x2F) {
            ch = source.charCodeAt(index + 1);
            if (ch === 0x2F) {
              ++index;
              ++index;
              skipSingleLineComment(2);
              start = true;
            } else if (ch === 0x2A) {
              ++index;
              ++index;
              skipMultiLineComment();
            } else {
              break;
            }
          } else if (start && ch === 0x2D) {
            if ((source.charCodeAt(index + 1) === 0x2D) && (source.charCodeAt(index + 2) === 0x3E)) {
              index += 3;
              skipSingleLineComment(3);
            } else {
              break;
            }
          } else if (ch === 0x3C) {
            if (source.slice(index + 1, index + 4) === '!--') {
              ++index;
              ++index;
              ++index;
              ++index;
              skipSingleLineComment(4);
            } else {
              break;
            }
          } else {
            break;
          }
        }
      }
      function scanHexEscape(prefix) {
        var i,
            len,
            ch,
            code = 0;
        len = (prefix === 'u') ? 4 : 2;
        for (i = 0; i < len; ++i) {
          if (index < length && isHexDigit(source[index])) {
            ch = source[index++];
            code = code * 16 + '0123456789abcdef'.indexOf(ch.toLowerCase());
          } else {
            return '';
          }
        }
        return String.fromCharCode(code);
      }
      function scanUnicodeCodePointEscape() {
        var ch,
            code,
            cu1,
            cu2;
        ch = source[index];
        code = 0;
        if (ch === '}') {
          throwUnexpectedToken();
        }
        while (index < length) {
          ch = source[index++];
          if (!isHexDigit(ch)) {
            break;
          }
          code = code * 16 + '0123456789abcdef'.indexOf(ch.toLowerCase());
        }
        if (code > 0x10FFFF || ch !== '}') {
          throwUnexpectedToken();
        }
        if (code <= 0xFFFF) {
          return String.fromCharCode(code);
        }
        cu1 = ((code - 0x10000) >> 10) + 0xD800;
        cu2 = ((code - 0x10000) & 1023) + 0xDC00;
        return String.fromCharCode(cu1, cu2);
      }
      function getEscapedIdentifier() {
        var ch,
            id;
        ch = source.charCodeAt(index++);
        id = String.fromCharCode(ch);
        if (ch === 0x5C) {
          if (source.charCodeAt(index) !== 0x75) {
            throwUnexpectedToken();
          }
          ++index;
          ch = scanHexEscape('u');
          if (!ch || ch === '\\' || !isIdentifierStart(ch.charCodeAt(0))) {
            throwUnexpectedToken();
          }
          id = ch;
        }
        while (index < length) {
          ch = source.charCodeAt(index);
          if (!isIdentifierPart(ch)) {
            break;
          }
          ++index;
          id += String.fromCharCode(ch);
          if (ch === 0x5C) {
            id = id.substr(0, id.length - 1);
            if (source.charCodeAt(index) !== 0x75) {
              throwUnexpectedToken();
            }
            ++index;
            ch = scanHexEscape('u');
            if (!ch || ch === '\\' || !isIdentifierPart(ch.charCodeAt(0))) {
              throwUnexpectedToken();
            }
            id += ch;
          }
        }
        return id;
      }
      function getIdentifier() {
        var start,
            ch;
        start = index++;
        while (index < length) {
          ch = source.charCodeAt(index);
          if (ch === 0x5C) {
            index = start;
            return getEscapedIdentifier();
          }
          if (isIdentifierPart(ch)) {
            ++index;
          } else {
            break;
          }
        }
        return source.slice(start, index);
      }
      function scanIdentifier() {
        var start,
            id,
            type;
        start = index;
        id = (source.charCodeAt(index) === 0x5C) ? getEscapedIdentifier() : getIdentifier();
        if (id.length === 1) {
          type = Token.Identifier;
        } else if (isKeyword(id)) {
          type = Token.Keyword;
        } else if (id === 'null') {
          type = Token.NullLiteral;
        } else if (id === 'true' || id === 'false') {
          type = Token.BooleanLiteral;
        } else {
          type = Token.Identifier;
        }
        return {
          type: type,
          value: id,
          lineNumber: lineNumber,
          lineStart: lineStart,
          start: start,
          end: index
        };
      }
      function scanPunctuator() {
        var start = index,
            code = source.charCodeAt(index),
            code2,
            ch1 = source[index],
            ch2,
            ch3,
            ch4;
        switch (code) {
          case 0x2E:
          case 0x28:
          case 0x29:
          case 0x3B:
          case 0x2C:
          case 0x7B:
          case 0x7D:
          case 0x5B:
          case 0x5D:
          case 0x3A:
          case 0x3F:
          case 0x7E:
            ++index;
            if (extra.tokenize) {
              if (code === 0x28) {
                extra.openParenToken = extra.tokens.length;
              } else if (code === 0x7B) {
                extra.openCurlyToken = extra.tokens.length;
              }
            }
            return {
              type: Token.Punctuator,
              value: String.fromCharCode(code),
              lineNumber: lineNumber,
              lineStart: lineStart,
              start: start,
              end: index
            };
          default:
            code2 = source.charCodeAt(index + 1);
            if (code2 === 0x3D) {
              switch (code) {
                case 0x2B:
                case 0x2D:
                case 0x2F:
                case 0x3C:
                case 0x3E:
                case 0x5E:
                case 0x7C:
                case 0x25:
                case 0x26:
                case 0x2A:
                  index += 2;
                  return {
                    type: Token.Punctuator,
                    value: String.fromCharCode(code) + String.fromCharCode(code2),
                    lineNumber: lineNumber,
                    lineStart: lineStart,
                    start: start,
                    end: index
                  };
                case 0x21:
                case 0x3D:
                  index += 2;
                  if (source.charCodeAt(index) === 0x3D) {
                    ++index;
                  }
                  return {
                    type: Token.Punctuator,
                    value: source.slice(start, index),
                    lineNumber: lineNumber,
                    lineStart: lineStart,
                    start: start,
                    end: index
                  };
              }
            }
        }
        ch4 = source.substr(index, 4);
        if (ch4 === '>>>=') {
          index += 4;
          return {
            type: Token.Punctuator,
            value: ch4,
            lineNumber: lineNumber,
            lineStart: lineStart,
            start: start,
            end: index
          };
        }
        ch3 = ch4.substr(0, 3);
        if (ch3 === '>>>' || ch3 === '<<=' || ch3 === '>>=') {
          index += 3;
          return {
            type: Token.Punctuator,
            value: ch3,
            lineNumber: lineNumber,
            lineStart: lineStart,
            start: start,
            end: index
          };
        }
        ch2 = ch3.substr(0, 2);
        if ((ch1 === ch2[1] && ('+-<>&|'.indexOf(ch1) >= 0)) || ch2 === '=>') {
          index += 2;
          return {
            type: Token.Punctuator,
            value: ch2,
            lineNumber: lineNumber,
            lineStart: lineStart,
            start: start,
            end: index
          };
        }
        if ('<>=!+-*%&|^/'.indexOf(ch1) >= 0) {
          ++index;
          return {
            type: Token.Punctuator,
            value: ch1,
            lineNumber: lineNumber,
            lineStart: lineStart,
            start: start,
            end: index
          };
        }
        throwUnexpectedToken();
      }
      function scanHexLiteral(start) {
        var number = '';
        while (index < length) {
          if (!isHexDigit(source[index])) {
            break;
          }
          number += source[index++];
        }
        if (number.length === 0) {
          throwUnexpectedToken();
        }
        if (isIdentifierStart(source.charCodeAt(index))) {
          throwUnexpectedToken();
        }
        return {
          type: Token.NumericLiteral,
          value: parseInt('0x' + number, 16),
          lineNumber: lineNumber,
          lineStart: lineStart,
          start: start,
          end: index
        };
      }
      function scanBinaryLiteral(start) {
        var ch,
            number;
        number = '';
        while (index < length) {
          ch = source[index];
          if (ch !== '0' && ch !== '1') {
            break;
          }
          number += source[index++];
        }
        if (number.length === 0) {
          throwUnexpectedToken();
        }
        if (index < length) {
          ch = source.charCodeAt(index);
          if (isIdentifierStart(ch) || isDecimalDigit(ch)) {
            throwUnexpectedToken();
          }
        }
        return {
          type: Token.NumericLiteral,
          value: parseInt(number, 2),
          lineNumber: lineNumber,
          lineStart: lineStart,
          start: start,
          end: index
        };
      }
      function scanOctalLiteral(prefix, start) {
        var number,
            octal;
        if (isOctalDigit(prefix)) {
          octal = true;
          number = '0' + source[index++];
        } else {
          octal = false;
          ++index;
          number = '';
        }
        while (index < length) {
          if (!isOctalDigit(source[index])) {
            break;
          }
          number += source[index++];
        }
        if (!octal && number.length === 0) {
          throwUnexpectedToken();
        }
        if (isIdentifierStart(source.charCodeAt(index)) || isDecimalDigit(source.charCodeAt(index))) {
          throwUnexpectedToken();
        }
        return {
          type: Token.NumericLiteral,
          value: parseInt(number, 8),
          octal: octal,
          lineNumber: lineNumber,
          lineStart: lineStart,
          start: start,
          end: index
        };
      }
      function isImplicitOctalLiteral() {
        var i,
            ch;
        for (i = index + 1; i < length; ++i) {
          ch = source[i];
          if (ch === '8' || ch === '9') {
            return false;
          }
          if (!isOctalDigit(ch)) {
            return true;
          }
        }
        return true;
      }
      function scanNumericLiteral() {
        var number,
            start,
            ch;
        ch = source[index];
        assert(isDecimalDigit(ch.charCodeAt(0)) || (ch === '.'), 'Numeric literal must start with a decimal digit or a decimal point');
        start = index;
        number = '';
        if (ch !== '.') {
          number = source[index++];
          ch = source[index];
          if (number === '0') {
            if (ch === 'x' || ch === 'X') {
              ++index;
              return scanHexLiteral(start);
            }
            if (ch === 'b' || ch === 'B') {
              ++index;
              return scanBinaryLiteral(start);
            }
            if (ch === 'o' || ch === 'O') {
              return scanOctalLiteral(ch, start);
            }
            if (isOctalDigit(ch)) {
              if (isImplicitOctalLiteral()) {
                return scanOctalLiteral(ch, start);
              }
            }
          }
          while (isDecimalDigit(source.charCodeAt(index))) {
            number += source[index++];
          }
          ch = source[index];
        }
        if (ch === '.') {
          number += source[index++];
          while (isDecimalDigit(source.charCodeAt(index))) {
            number += source[index++];
          }
          ch = source[index];
        }
        if (ch === 'e' || ch === 'E') {
          number += source[index++];
          ch = source[index];
          if (ch === '+' || ch === '-') {
            number += source[index++];
          }
          if (isDecimalDigit(source.charCodeAt(index))) {
            while (isDecimalDigit(source.charCodeAt(index))) {
              number += source[index++];
            }
          } else {
            throwUnexpectedToken();
          }
        }
        if (isIdentifierStart(source.charCodeAt(index))) {
          throwUnexpectedToken();
        }
        return {
          type: Token.NumericLiteral,
          value: parseFloat(number),
          lineNumber: lineNumber,
          lineStart: lineStart,
          start: start,
          end: index
        };
      }
      function scanStringLiteral() {
        var str = '',
            quote,
            start,
            ch,
            code,
            unescaped,
            restore,
            octal = false,
            startLineNumber,
            startLineStart;
        startLineNumber = lineNumber;
        startLineStart = lineStart;
        quote = source[index];
        assert((quote === '\'' || quote === '"'), 'String literal must starts with a quote');
        start = index;
        ++index;
        while (index < length) {
          ch = source[index++];
          if (ch === quote) {
            quote = '';
            break;
          } else if (ch === '\\') {
            ch = source[index++];
            if (!ch || !isLineTerminator(ch.charCodeAt(0))) {
              switch (ch) {
                case 'u':
                case 'x':
                  if (source[index] === '{') {
                    ++index;
                    str += scanUnicodeCodePointEscape();
                  } else {
                    restore = index;
                    unescaped = scanHexEscape(ch);
                    if (unescaped) {
                      str += unescaped;
                    } else {
                      index = restore;
                      str += ch;
                    }
                  }
                  break;
                case 'n':
                  str += '\n';
                  break;
                case 'r':
                  str += '\r';
                  break;
                case 't':
                  str += '\t';
                  break;
                case 'b':
                  str += '\b';
                  break;
                case 'f':
                  str += '\f';
                  break;
                case 'v':
                  str += '\x0B';
                  break;
                default:
                  if (isOctalDigit(ch)) {
                    code = '01234567'.indexOf(ch);
                    if (code !== 0) {
                      octal = true;
                    }
                    if (index < length && isOctalDigit(source[index])) {
                      octal = true;
                      code = code * 8 + '01234567'.indexOf(source[index++]);
                      if ('0123'.indexOf(ch) >= 0 && index < length && isOctalDigit(source[index])) {
                        code = code * 8 + '01234567'.indexOf(source[index++]);
                      }
                    }
                    str += String.fromCharCode(code);
                  } else {
                    str += ch;
                  }
                  break;
              }
            } else {
              ++lineNumber;
              if (ch === '\r' && source[index] === '\n') {
                ++index;
              }
              lineStart = index;
            }
          } else if (isLineTerminator(ch.charCodeAt(0))) {
            break;
          } else {
            str += ch;
          }
        }
        if (quote !== '') {
          throwUnexpectedToken();
        }
        return {
          type: Token.StringLiteral,
          value: str,
          octal: octal,
          startLineNumber: startLineNumber,
          startLineStart: startLineStart,
          lineNumber: lineNumber,
          lineStart: lineStart,
          start: start,
          end: index
        };
      }
      function testRegExp(pattern, flags) {
        var tmp = pattern,
            value;
        if (flags.indexOf('u') >= 0) {
          tmp = tmp.replace(/\\u\{([0-9a-fA-F]+)\}/g, function($0, $1) {
            if (parseInt($1, 16) <= 0x10FFFF) {
              return 'x';
            }
            throwError(Messages.InvalidRegExp);
          }).replace(/[\uD800-\uDBFF][\uDC00-\uDFFF]/g, 'x');
        }
        try {
          value = new RegExp(tmp);
        } catch (e) {
          throwError(Messages.InvalidRegExp);
        }
        try {
          return new RegExp(pattern, flags);
        } catch (exception) {
          return null;
        }
      }
      function scanRegExpBody() {
        var ch,
            str,
            classMarker,
            terminated,
            body;
        ch = source[index];
        assert(ch === '/', 'Regular expression literal must start with a slash');
        str = source[index++];
        classMarker = false;
        terminated = false;
        while (index < length) {
          ch = source[index++];
          str += ch;
          if (ch === '\\') {
            ch = source[index++];
            if (isLineTerminator(ch.charCodeAt(0))) {
              throwError(Messages.UnterminatedRegExp);
            }
            str += ch;
          } else if (isLineTerminator(ch.charCodeAt(0))) {
            throwError(Messages.UnterminatedRegExp);
          } else if (classMarker) {
            if (ch === ']') {
              classMarker = false;
            }
          } else {
            if (ch === '/') {
              terminated = true;
              break;
            } else if (ch === '[') {
              classMarker = true;
            }
          }
        }
        if (!terminated) {
          throwError(Messages.UnterminatedRegExp);
        }
        body = str.substr(1, str.length - 2);
        return {
          value: body,
          literal: str
        };
      }
      function scanRegExpFlags() {
        var ch,
            str,
            flags,
            restore;
        str = '';
        flags = '';
        while (index < length) {
          ch = source[index];
          if (!isIdentifierPart(ch.charCodeAt(0))) {
            break;
          }
          ++index;
          if (ch === '\\' && index < length) {
            ch = source[index];
            if (ch === 'u') {
              ++index;
              restore = index;
              ch = scanHexEscape('u');
              if (ch) {
                flags += ch;
                for (str += '\\u'; restore < index; ++restore) {
                  str += source[restore];
                }
              } else {
                index = restore;
                flags += 'u';
                str += '\\u';
              }
              tolerateUnexpectedToken();
            } else {
              str += '\\';
              tolerateUnexpectedToken();
            }
          } else {
            flags += ch;
            str += ch;
          }
        }
        return {
          value: flags,
          literal: str
        };
      }
      function scanRegExp() {
        var start,
            body,
            flags,
            value;
        lookahead = null;
        skipComment();
        start = index;
        body = scanRegExpBody();
        flags = scanRegExpFlags();
        value = testRegExp(body.value, flags.value);
        if (extra.tokenize) {
          return {
            type: Token.RegularExpression,
            value: value,
            regex: {
              pattern: body.value,
              flags: flags.value
            },
            lineNumber: lineNumber,
            lineStart: lineStart,
            start: start,
            end: index
          };
        }
        return {
          literal: body.literal + flags.literal,
          value: value,
          regex: {
            pattern: body.value,
            flags: flags.value
          },
          start: start,
          end: index
        };
      }
      function collectRegex() {
        var pos,
            loc,
            regex,
            token;
        skipComment();
        pos = index;
        loc = {start: {
            line: lineNumber,
            column: index - lineStart
          }};
        regex = scanRegExp();
        loc.end = {
          line: lineNumber,
          column: index - lineStart
        };
        if (!extra.tokenize) {
          if (extra.tokens.length > 0) {
            token = extra.tokens[extra.tokens.length - 1];
            if (token.range[0] === pos && token.type === 'Punctuator') {
              if (token.value === '/' || token.value === '/=') {
                extra.tokens.pop();
              }
            }
          }
          extra.tokens.push({
            type: 'RegularExpression',
            value: regex.literal,
            regex: regex.regex,
            range: [pos, index],
            loc: loc
          });
        }
        return regex;
      }
      function isIdentifierName(token) {
        return token.type === Token.Identifier || token.type === Token.Keyword || token.type === Token.BooleanLiteral || token.type === Token.NullLiteral;
      }
      function advanceSlash() {
        var prevToken,
            checkToken;
        prevToken = extra.tokens[extra.tokens.length - 1];
        if (!prevToken) {
          return collectRegex();
        }
        if (prevToken.type === 'Punctuator') {
          if (prevToken.value === ']') {
            return scanPunctuator();
          }
          if (prevToken.value === ')') {
            checkToken = extra.tokens[extra.openParenToken - 1];
            if (checkToken && checkToken.type === 'Keyword' && (checkToken.value === 'if' || checkToken.value === 'while' || checkToken.value === 'for' || checkToken.value === 'with')) {
              return collectRegex();
            }
            return scanPunctuator();
          }
          if (prevToken.value === '}') {
            if (extra.tokens[extra.openCurlyToken - 3] && extra.tokens[extra.openCurlyToken - 3].type === 'Keyword') {
              checkToken = extra.tokens[extra.openCurlyToken - 4];
              if (!checkToken) {
                return scanPunctuator();
              }
            } else if (extra.tokens[extra.openCurlyToken - 4] && extra.tokens[extra.openCurlyToken - 4].type === 'Keyword') {
              checkToken = extra.tokens[extra.openCurlyToken - 5];
              if (!checkToken) {
                return collectRegex();
              }
            } else {
              return scanPunctuator();
            }
            if (FnExprTokens.indexOf(checkToken.value) >= 0) {
              return scanPunctuator();
            }
            return collectRegex();
          }
          return collectRegex();
        }
        if (prevToken.type === 'Keyword' && prevToken.value !== 'this') {
          return collectRegex();
        }
        return scanPunctuator();
      }
      function advance() {
        var ch;
        skipComment();
        if (index >= length) {
          return {
            type: Token.EOF,
            lineNumber: lineNumber,
            lineStart: lineStart,
            start: index,
            end: index
          };
        }
        ch = source.charCodeAt(index);
        if (isIdentifierStart(ch)) {
          return scanIdentifier();
        }
        if (ch === 0x28 || ch === 0x29 || ch === 0x3B) {
          return scanPunctuator();
        }
        if (ch === 0x27 || ch === 0x22) {
          return scanStringLiteral();
        }
        if (ch === 0x2E) {
          if (isDecimalDigit(source.charCodeAt(index + 1))) {
            return scanNumericLiteral();
          }
          return scanPunctuator();
        }
        if (isDecimalDigit(ch)) {
          return scanNumericLiteral();
        }
        if (extra.tokenize && ch === 0x2F) {
          return advanceSlash();
        }
        return scanPunctuator();
      }
      function collectToken() {
        var loc,
            token,
            value,
            entry;
        skipComment();
        loc = {start: {
            line: lineNumber,
            column: index - lineStart
          }};
        token = advance();
        loc.end = {
          line: lineNumber,
          column: index - lineStart
        };
        if (token.type !== Token.EOF) {
          value = source.slice(token.start, token.end);
          entry = {
            type: TokenName[token.type],
            value: value,
            range: [token.start, token.end],
            loc: loc
          };
          if (token.regex) {
            entry.regex = {
              pattern: token.regex.pattern,
              flags: token.regex.flags
            };
          }
          extra.tokens.push(entry);
        }
        return token;
      }
      function lex() {
        var token;
        token = lookahead;
        index = token.end;
        lineNumber = token.lineNumber;
        lineStart = token.lineStart;
        lookahead = (typeof extra.tokens !== 'undefined') ? collectToken() : advance();
        index = token.end;
        lineNumber = token.lineNumber;
        lineStart = token.lineStart;
        return token;
      }
      function peek() {
        var pos,
            line,
            start;
        pos = index;
        line = lineNumber;
        start = lineStart;
        lookahead = (typeof extra.tokens !== 'undefined') ? collectToken() : advance();
        index = pos;
        lineNumber = line;
        lineStart = start;
      }
      function Position() {
        this.line = lineNumber;
        this.column = index - lineStart;
      }
      function SourceLocation() {
        this.start = new Position();
        this.end = null;
      }
      function WrappingSourceLocation(startToken) {
        if (startToken.type === Token.StringLiteral) {
          this.start = {
            line: startToken.startLineNumber,
            column: startToken.start - startToken.startLineStart
          };
        } else {
          this.start = {
            line: startToken.lineNumber,
            column: startToken.start - startToken.lineStart
          };
        }
        this.end = null;
      }
      function Node() {
        index = lookahead.start;
        if (lookahead.type === Token.StringLiteral) {
          lineNumber = lookahead.startLineNumber;
          lineStart = lookahead.startLineStart;
        } else {
          lineNumber = lookahead.lineNumber;
          lineStart = lookahead.lineStart;
        }
        if (extra.range) {
          this.range = [index, 0];
        }
        if (extra.loc) {
          this.loc = new SourceLocation();
        }
      }
      function WrappingNode(startToken) {
        if (extra.range) {
          this.range = [startToken.start, 0];
        }
        if (extra.loc) {
          this.loc = new WrappingSourceLocation(startToken);
        }
      }
      WrappingNode.prototype = Node.prototype = {
        processComment: function() {
          var lastChild,
              leadingComments,
              trailingComments,
              bottomRight = extra.bottomRightStack,
              i,
              comment,
              last = bottomRight[bottomRight.length - 1];
          if (this.type === Syntax.Program) {
            if (this.body.length > 0) {
              return ;
            }
          }
          if (extra.trailingComments.length > 0) {
            trailingComments = [];
            for (i = extra.trailingComments.length - 1; i >= 0; --i) {
              comment = extra.trailingComments[i];
              if (comment.range[0] >= this.range[1]) {
                trailingComments.unshift(comment);
                extra.trailingComments.splice(i, 1);
              }
            }
            extra.trailingComments = [];
          } else {
            if (last && last.trailingComments && last.trailingComments[0].range[0] >= this.range[1]) {
              trailingComments = last.trailingComments;
              delete last.trailingComments;
            }
          }
          if (last) {
            while (last && last.range[0] >= this.range[0]) {
              lastChild = last;
              last = bottomRight.pop();
            }
          }
          if (lastChild) {
            if (lastChild.leadingComments && lastChild.leadingComments[lastChild.leadingComments.length - 1].range[1] <= this.range[0]) {
              this.leadingComments = lastChild.leadingComments;
              lastChild.leadingComments = undefined;
            }
          } else if (extra.leadingComments.length > 0) {
            leadingComments = [];
            for (i = extra.leadingComments.length - 1; i >= 0; --i) {
              comment = extra.leadingComments[i];
              if (comment.range[1] <= this.range[0]) {
                leadingComments.unshift(comment);
                extra.leadingComments.splice(i, 1);
              }
            }
          }
          if (leadingComments && leadingComments.length > 0) {
            this.leadingComments = leadingComments;
          }
          if (trailingComments && trailingComments.length > 0) {
            this.trailingComments = trailingComments;
          }
          bottomRight.push(this);
        },
        finish: function() {
          if (extra.range) {
            this.range[1] = index;
          }
          if (extra.loc) {
            this.loc.end = new Position();
            if (extra.source) {
              this.loc.source = extra.source;
            }
          }
          if (extra.attachComment) {
            this.processComment();
          }
        },
        finishArrayExpression: function(elements) {
          this.type = Syntax.ArrayExpression;
          this.elements = elements;
          this.finish();
          return this;
        },
        finishArrowFunctionExpression: function(params, defaults, body, expression) {
          this.type = Syntax.ArrowFunctionExpression;
          this.id = null;
          this.params = params;
          this.defaults = defaults;
          this.body = body;
          this.rest = null;
          this.generator = false;
          this.expression = expression;
          this.finish();
          return this;
        },
        finishAssignmentExpression: function(operator, left, right) {
          this.type = Syntax.AssignmentExpression;
          this.operator = operator;
          this.left = left;
          this.right = right;
          this.finish();
          return this;
        },
        finishBinaryExpression: function(operator, left, right) {
          this.type = (operator === '||' || operator === '&&') ? Syntax.LogicalExpression : Syntax.BinaryExpression;
          this.operator = operator;
          this.left = left;
          this.right = right;
          this.finish();
          return this;
        },
        finishBlockStatement: function(body) {
          this.type = Syntax.BlockStatement;
          this.body = body;
          this.finish();
          return this;
        },
        finishBreakStatement: function(label) {
          this.type = Syntax.BreakStatement;
          this.label = label;
          this.finish();
          return this;
        },
        finishCallExpression: function(callee, args) {
          this.type = Syntax.CallExpression;
          this.callee = callee;
          this.arguments = args;
          this.finish();
          return this;
        },
        finishCatchClause: function(param, body) {
          this.type = Syntax.CatchClause;
          this.param = param;
          this.body = body;
          this.finish();
          return this;
        },
        finishConditionalExpression: function(test, consequent, alternate) {
          this.type = Syntax.ConditionalExpression;
          this.test = test;
          this.consequent = consequent;
          this.alternate = alternate;
          this.finish();
          return this;
        },
        finishContinueStatement: function(label) {
          this.type = Syntax.ContinueStatement;
          this.label = label;
          this.finish();
          return this;
        },
        finishDebuggerStatement: function() {
          this.type = Syntax.DebuggerStatement;
          this.finish();
          return this;
        },
        finishDoWhileStatement: function(body, test) {
          this.type = Syntax.DoWhileStatement;
          this.body = body;
          this.test = test;
          this.finish();
          return this;
        },
        finishEmptyStatement: function() {
          this.type = Syntax.EmptyStatement;
          this.finish();
          return this;
        },
        finishExpressionStatement: function(expression) {
          this.type = Syntax.ExpressionStatement;
          this.expression = expression;
          this.finish();
          return this;
        },
        finishForStatement: function(init, test, update, body) {
          this.type = Syntax.ForStatement;
          this.init = init;
          this.test = test;
          this.update = update;
          this.body = body;
          this.finish();
          return this;
        },
        finishForInStatement: function(left, right, body) {
          this.type = Syntax.ForInStatement;
          this.left = left;
          this.right = right;
          this.body = body;
          this.each = false;
          this.finish();
          return this;
        },
        finishFunctionDeclaration: function(id, params, defaults, body) {
          this.type = Syntax.FunctionDeclaration;
          this.id = id;
          this.params = params;
          this.defaults = defaults;
          this.body = body;
          this.rest = null;
          this.generator = false;
          this.expression = false;
          this.finish();
          return this;
        },
        finishFunctionExpression: function(id, params, defaults, body) {
          this.type = Syntax.FunctionExpression;
          this.id = id;
          this.params = params;
          this.defaults = defaults;
          this.body = body;
          this.rest = null;
          this.generator = false;
          this.expression = false;
          this.finish();
          return this;
        },
        finishIdentifier: function(name) {
          this.type = Syntax.Identifier;
          this.name = name;
          this.finish();
          return this;
        },
        finishIfStatement: function(test, consequent, alternate) {
          this.type = Syntax.IfStatement;
          this.test = test;
          this.consequent = consequent;
          this.alternate = alternate;
          this.finish();
          return this;
        },
        finishLabeledStatement: function(label, body) {
          this.type = Syntax.LabeledStatement;
          this.label = label;
          this.body = body;
          this.finish();
          return this;
        },
        finishLiteral: function(token) {
          this.type = Syntax.Literal;
          this.value = token.value;
          this.raw = source.slice(token.start, token.end);
          if (token.regex) {
            this.regex = token.regex;
          }
          this.finish();
          return this;
        },
        finishMemberExpression: function(accessor, object, property) {
          this.type = Syntax.MemberExpression;
          this.computed = accessor === '[';
          this.object = object;
          this.property = property;
          this.finish();
          return this;
        },
        finishNewExpression: function(callee, args) {
          this.type = Syntax.NewExpression;
          this.callee = callee;
          this.arguments = args;
          this.finish();
          return this;
        },
        finishObjectExpression: function(properties) {
          this.type = Syntax.ObjectExpression;
          this.properties = properties;
          this.finish();
          return this;
        },
        finishPostfixExpression: function(operator, argument) {
          this.type = Syntax.UpdateExpression;
          this.operator = operator;
          this.argument = argument;
          this.prefix = false;
          this.finish();
          return this;
        },
        finishProgram: function(body) {
          this.type = Syntax.Program;
          this.body = body;
          this.finish();
          return this;
        },
        finishProperty: function(kind, key, value, method, shorthand) {
          this.type = Syntax.Property;
          this.key = key;
          this.value = value;
          this.kind = kind;
          this.method = method;
          this.shorthand = shorthand;
          this.finish();
          return this;
        },
        finishReturnStatement: function(argument) {
          this.type = Syntax.ReturnStatement;
          this.argument = argument;
          this.finish();
          return this;
        },
        finishSequenceExpression: function(expressions) {
          this.type = Syntax.SequenceExpression;
          this.expressions = expressions;
          this.finish();
          return this;
        },
        finishSwitchCase: function(test, consequent) {
          this.type = Syntax.SwitchCase;
          this.test = test;
          this.consequent = consequent;
          this.finish();
          return this;
        },
        finishSwitchStatement: function(discriminant, cases) {
          this.type = Syntax.SwitchStatement;
          this.discriminant = discriminant;
          this.cases = cases;
          this.finish();
          return this;
        },
        finishThisExpression: function() {
          this.type = Syntax.ThisExpression;
          this.finish();
          return this;
        },
        finishThrowStatement: function(argument) {
          this.type = Syntax.ThrowStatement;
          this.argument = argument;
          this.finish();
          return this;
        },
        finishTryStatement: function(block, guardedHandlers, handlers, finalizer) {
          this.type = Syntax.TryStatement;
          this.block = block;
          this.guardedHandlers = guardedHandlers;
          this.handlers = handlers;
          this.finalizer = finalizer;
          this.finish();
          return this;
        },
        finishUnaryExpression: function(operator, argument) {
          this.type = (operator === '++' || operator === '--') ? Syntax.UpdateExpression : Syntax.UnaryExpression;
          this.operator = operator;
          this.argument = argument;
          this.prefix = true;
          this.finish();
          return this;
        },
        finishVariableDeclaration: function(declarations, kind) {
          this.type = Syntax.VariableDeclaration;
          this.declarations = declarations;
          this.kind = kind;
          this.finish();
          return this;
        },
        finishVariableDeclarator: function(id, init) {
          this.type = Syntax.VariableDeclarator;
          this.id = id;
          this.init = init;
          this.finish();
          return this;
        },
        finishWhileStatement: function(test, body) {
          this.type = Syntax.WhileStatement;
          this.test = test;
          this.body = body;
          this.finish();
          return this;
        },
        finishWithStatement: function(object, body) {
          this.type = Syntax.WithStatement;
          this.object = object;
          this.body = body;
          this.finish();
          return this;
        }
      };
      function peekLineTerminator() {
        var pos,
            line,
            start,
            found;
        pos = index;
        line = lineNumber;
        start = lineStart;
        skipComment();
        found = lineNumber !== line;
        index = pos;
        lineNumber = line;
        lineStart = start;
        return found;
      }
      function createError(line, pos, description) {
        var error = new Error('Line ' + line + ': ' + description);
        error.index = pos;
        error.lineNumber = line;
        error.column = pos - lineStart + 1;
        error.description = description;
        return error;
      }
      function throwError(messageFormat) {
        var args,
            msg;
        args = Array.prototype.slice.call(arguments, 1);
        msg = messageFormat.replace(/%(\d)/g, function(whole, idx) {
          assert(idx < args.length, 'Message reference must be in range');
          return args[idx];
        });
        throw createError(lineNumber, index, msg);
      }
      function tolerateError(messageFormat) {
        var args,
            msg,
            error;
        args = Array.prototype.slice.call(arguments, 1);
        msg = messageFormat.replace(/%(\d)/g, function(whole, idx) {
          assert(idx < args.length, 'Message reference must be in range');
          return args[idx];
        });
        error = createError(lineNumber, index, msg);
        if (extra.errors) {
          extra.errors.push(error);
        } else {
          throw error;
        }
      }
      function unexpectedTokenError(token, message) {
        var msg = Messages.UnexpectedToken;
        if (token) {
          msg = message ? message : (token.type === Token.EOF) ? Messages.UnexpectedEOS : (token.type === Token.Identifier) ? Messages.UnexpectedIdentifier : (token.type === Token.NumericLiteral) ? Messages.UnexpectedNumber : (token.type === Token.StringLiteral) ? Messages.UnexpectedString : Messages.UnexpectedToken;
          if (token.type === Token.Keyword) {
            if (isFutureReservedWord(token.value)) {
              msg = Messages.UnexpectedReserved;
            } else if (strict && isStrictModeReservedWord(token.value)) {
              msg = Messages.StrictReservedWord;
            }
          }
        }
        msg = msg.replace('%0', token ? token.value : 'ILLEGAL');
        return (token && typeof token.lineNumber === 'number') ? createError(token.lineNumber, token.start, msg) : createError(lineNumber, index, msg);
      }
      function throwUnexpectedToken(token, message) {
        throw unexpectedTokenError(token, message);
      }
      function tolerateUnexpectedToken(token, message) {
        var error = unexpectedTokenError(token, message);
        if (extra.errors) {
          extra.errors.push(error);
        } else {
          throw error;
        }
      }
      function expect(value) {
        var token = lex();
        if (token.type !== Token.Punctuator || token.value !== value) {
          throwUnexpectedToken(token);
        }
      }
      function expectCommaSeparator() {
        var token;
        if (extra.errors) {
          token = lookahead;
          if (token.type === Token.Punctuator && token.value === ',') {
            lex();
          } else if (token.type === Token.Punctuator && token.value === ';') {
            lex();
            tolerateUnexpectedToken(token);
          } else {
            tolerateUnexpectedToken(token, Messages.UnexpectedToken);
          }
        } else {
          expect(',');
        }
      }
      function expectKeyword(keyword) {
        var token = lex();
        if (token.type !== Token.Keyword || token.value !== keyword) {
          throwUnexpectedToken(token);
        }
      }
      function match(value) {
        return lookahead.type === Token.Punctuator && lookahead.value === value;
      }
      function matchKeyword(keyword) {
        return lookahead.type === Token.Keyword && lookahead.value === keyword;
      }
      function matchAssign() {
        var op;
        if (lookahead.type !== Token.Punctuator) {
          return false;
        }
        op = lookahead.value;
        return op === '=' || op === '*=' || op === '/=' || op === '%=' || op === '+=' || op === '-=' || op === '<<=' || op === '>>=' || op === '>>>=' || op === '&=' || op === '^=' || op === '|=';
      }
      function consumeSemicolon() {
        var line,
            oldIndex = index,
            oldLineNumber = lineNumber,
            oldLineStart = lineStart,
            oldLookahead = lookahead;
        if (source.charCodeAt(index) === 0x3B || match(';')) {
          lex();
          return ;
        }
        line = lineNumber;
        skipComment();
        if (lineNumber !== line) {
          index = oldIndex;
          lineNumber = oldLineNumber;
          lineStart = oldLineStart;
          lookahead = oldLookahead;
          return ;
        }
        if (lookahead.type !== Token.EOF && !match('}')) {
          throwUnexpectedToken(lookahead);
        }
      }
      function isLeftHandSide(expr) {
        return expr.type === Syntax.Identifier || expr.type === Syntax.MemberExpression;
      }
      function parseArrayInitialiser() {
        var elements = [],
            node = new Node();
        expect('[');
        while (!match(']')) {
          if (match(',')) {
            lex();
            elements.push(null);
          } else {
            elements.push(parseAssignmentExpression());
            if (!match(']')) {
              expect(',');
            }
          }
        }
        lex();
        return node.finishArrayExpression(elements);
      }
      function parsePropertyFunction(param, first) {
        var previousStrict,
            body,
            node = new Node();
        previousStrict = strict;
        body = parseFunctionSourceElements();
        if (first && strict && isRestrictedWord(param[0].name)) {
          tolerateUnexpectedToken(first, Messages.StrictParamName);
        }
        strict = previousStrict;
        return node.finishFunctionExpression(null, param, [], body);
      }
      function parsePropertyMethodFunction() {
        var previousStrict,
            param,
            method;
        previousStrict = strict;
        strict = true;
        param = parseParams();
        method = parsePropertyFunction(param.params);
        strict = previousStrict;
        return method;
      }
      function parseObjectPropertyKey() {
        var token,
            node = new Node();
        token = lex();
        if (token.type === Token.StringLiteral || token.type === Token.NumericLiteral) {
          if (strict && token.octal) {
            tolerateUnexpectedToken(token, Messages.StrictOctalLiteral);
          }
          return node.finishLiteral(token);
        }
        return node.finishIdentifier(token.value);
      }
      function parseObjectProperty() {
        var token,
            key,
            id,
            value,
            param,
            node = new Node();
        token = lookahead;
        if (token.type === Token.Identifier) {
          id = parseObjectPropertyKey();
          if (token.value === 'get' && !(match(':') || match('('))) {
            key = parseObjectPropertyKey();
            expect('(');
            expect(')');
            value = parsePropertyFunction([]);
            return node.finishProperty('get', key, value, false, false);
          }
          if (token.value === 'set' && !(match(':') || match('('))) {
            key = parseObjectPropertyKey();
            expect('(');
            token = lookahead;
            if (token.type !== Token.Identifier) {
              expect(')');
              tolerateUnexpectedToken(token);
              value = parsePropertyFunction([]);
            } else {
              param = [parseVariableIdentifier()];
              expect(')');
              value = parsePropertyFunction(param, token);
            }
            return node.finishProperty('set', key, value, false, false);
          }
          if (match(':')) {
            lex();
            value = parseAssignmentExpression();
            return node.finishProperty('init', id, value, false, false);
          }
          if (match('(')) {
            value = parsePropertyMethodFunction();
            return node.finishProperty('init', id, value, true, false);
          }
          value = id;
          return node.finishProperty('init', id, value, false, true);
        }
        if (token.type === Token.EOF || token.type === Token.Punctuator) {
          throwUnexpectedToken(token);
        } else {
          key = parseObjectPropertyKey();
          if (match(':')) {
            lex();
            value = parseAssignmentExpression();
            return node.finishProperty('init', key, value, false, false);
          }
          if (match('(')) {
            value = parsePropertyMethodFunction();
            return node.finishProperty('init', key, value, true, false);
          }
          throwUnexpectedToken(lex());
        }
      }
      function parseObjectInitialiser() {
        var properties = [],
            property,
            name,
            key,
            kind,
            map = {},
            toString = String,
            node = new Node();
        expect('{');
        while (!match('}')) {
          property = parseObjectProperty();
          if (property.key.type === Syntax.Identifier) {
            name = property.key.name;
          } else {
            name = toString(property.key.value);
          }
          kind = (property.kind === 'init') ? PropertyKind.Data : (property.kind === 'get') ? PropertyKind.Get : PropertyKind.Set;
          key = '$' + name;
          if (Object.prototype.hasOwnProperty.call(map, key)) {
            if (map[key] === PropertyKind.Data) {
              if (strict && kind === PropertyKind.Data) {
                tolerateError(Messages.StrictDuplicateProperty);
              } else if (kind !== PropertyKind.Data) {
                tolerateError(Messages.AccessorDataProperty);
              }
            } else {
              if (kind === PropertyKind.Data) {
                tolerateError(Messages.AccessorDataProperty);
              } else if (map[key] & kind) {
                tolerateError(Messages.AccessorGetSet);
              }
            }
            map[key] |= kind;
          } else {
            map[key] = kind;
          }
          properties.push(property);
          if (!match('}')) {
            expectCommaSeparator();
          }
        }
        expect('}');
        return node.finishObjectExpression(properties);
      }
      function parseGroupExpression() {
        var expr;
        expect('(');
        if (match(')')) {
          lex();
          return PlaceHolders.ArrowParameterPlaceHolder;
        }
        ++state.parenthesisCount;
        expr = parseExpression();
        expect(')');
        return expr;
      }
      function parsePrimaryExpression() {
        var type,
            token,
            expr,
            node;
        if (match('(')) {
          return parseGroupExpression();
        }
        if (match('[')) {
          return parseArrayInitialiser();
        }
        if (match('{')) {
          return parseObjectInitialiser();
        }
        type = lookahead.type;
        node = new Node();
        if (type === Token.Identifier) {
          expr = node.finishIdentifier(lex().value);
        } else if (type === Token.StringLiteral || type === Token.NumericLiteral) {
          if (strict && lookahead.octal) {
            tolerateUnexpectedToken(lookahead, Messages.StrictOctalLiteral);
          }
          expr = node.finishLiteral(lex());
        } else if (type === Token.Keyword) {
          if (matchKeyword('function')) {
            return parseFunctionExpression();
          }
          if (matchKeyword('this')) {
            lex();
            expr = node.finishThisExpression();
          } else {
            throwUnexpectedToken(lex());
          }
        } else if (type === Token.BooleanLiteral) {
          token = lex();
          token.value = (token.value === 'true');
          expr = node.finishLiteral(token);
        } else if (type === Token.NullLiteral) {
          token = lex();
          token.value = null;
          expr = node.finishLiteral(token);
        } else if (match('/') || match('/=')) {
          if (typeof extra.tokens !== 'undefined') {
            expr = node.finishLiteral(collectRegex());
          } else {
            expr = node.finishLiteral(scanRegExp());
          }
          peek();
        } else {
          throwUnexpectedToken(lex());
        }
        return expr;
      }
      function parseArguments() {
        var args = [];
        expect('(');
        if (!match(')')) {
          while (index < length) {
            args.push(parseAssignmentExpression());
            if (match(')')) {
              break;
            }
            expectCommaSeparator();
          }
        }
        expect(')');
        return args;
      }
      function parseNonComputedProperty() {
        var token,
            node = new Node();
        token = lex();
        if (!isIdentifierName(token)) {
          throwUnexpectedToken(token);
        }
        return node.finishIdentifier(token.value);
      }
      function parseNonComputedMember() {
        expect('.');
        return parseNonComputedProperty();
      }
      function parseComputedMember() {
        var expr;
        expect('[');
        expr = parseExpression();
        expect(']');
        return expr;
      }
      function parseNewExpression() {
        var callee,
            args,
            node = new Node();
        expectKeyword('new');
        callee = parseLeftHandSideExpression();
        args = match('(') ? parseArguments() : [];
        return node.finishNewExpression(callee, args);
      }
      function parseLeftHandSideExpressionAllowCall() {
        var expr,
            args,
            property,
            startToken,
            previousAllowIn = state.allowIn;
        startToken = lookahead;
        state.allowIn = true;
        expr = matchKeyword('new') ? parseNewExpression() : parsePrimaryExpression();
        for (; ; ) {
          if (match('.')) {
            property = parseNonComputedMember();
            expr = new WrappingNode(startToken).finishMemberExpression('.', expr, property);
          } else if (match('(')) {
            args = parseArguments();
            expr = new WrappingNode(startToken).finishCallExpression(expr, args);
          } else if (match('[')) {
            property = parseComputedMember();
            expr = new WrappingNode(startToken).finishMemberExpression('[', expr, property);
          } else {
            break;
          }
        }
        state.allowIn = previousAllowIn;
        return expr;
      }
      function parseLeftHandSideExpression() {
        var expr,
            property,
            startToken;
        assert(state.allowIn, 'callee of new expression always allow in keyword.');
        startToken = lookahead;
        expr = matchKeyword('new') ? parseNewExpression() : parsePrimaryExpression();
        for (; ; ) {
          if (match('[')) {
            property = parseComputedMember();
            expr = new WrappingNode(startToken).finishMemberExpression('[', expr, property);
          } else if (match('.')) {
            property = parseNonComputedMember();
            expr = new WrappingNode(startToken).finishMemberExpression('.', expr, property);
          } else {
            break;
          }
        }
        return expr;
      }
      function parsePostfixExpression() {
        var expr,
            token,
            startToken = lookahead;
        expr = parseLeftHandSideExpressionAllowCall();
        if (lookahead.type === Token.Punctuator) {
          if ((match('++') || match('--')) && !peekLineTerminator()) {
            if (strict && expr.type === Syntax.Identifier && isRestrictedWord(expr.name)) {
              tolerateError(Messages.StrictLHSPostfix);
            }
            if (!isLeftHandSide(expr)) {
              tolerateError(Messages.InvalidLHSInAssignment);
            }
            token = lex();
            expr = new WrappingNode(startToken).finishPostfixExpression(token.value, expr);
          }
        }
        return expr;
      }
      function parseUnaryExpression() {
        var token,
            expr,
            startToken;
        if (lookahead.type !== Token.Punctuator && lookahead.type !== Token.Keyword) {
          expr = parsePostfixExpression();
        } else if (match('++') || match('--')) {
          startToken = lookahead;
          token = lex();
          expr = parseUnaryExpression();
          if (strict && expr.type === Syntax.Identifier && isRestrictedWord(expr.name)) {
            tolerateError(Messages.StrictLHSPrefix);
          }
          if (!isLeftHandSide(expr)) {
            tolerateError(Messages.InvalidLHSInAssignment);
          }
          expr = new WrappingNode(startToken).finishUnaryExpression(token.value, expr);
        } else if (match('+') || match('-') || match('~') || match('!')) {
          startToken = lookahead;
          token = lex();
          expr = parseUnaryExpression();
          expr = new WrappingNode(startToken).finishUnaryExpression(token.value, expr);
        } else if (matchKeyword('delete') || matchKeyword('void') || matchKeyword('typeof')) {
          startToken = lookahead;
          token = lex();
          expr = parseUnaryExpression();
          expr = new WrappingNode(startToken).finishUnaryExpression(token.value, expr);
          if (strict && expr.operator === 'delete' && expr.argument.type === Syntax.Identifier) {
            tolerateError(Messages.StrictDelete);
          }
        } else {
          expr = parsePostfixExpression();
        }
        return expr;
      }
      function binaryPrecedence(token, allowIn) {
        var prec = 0;
        if (token.type !== Token.Punctuator && token.type !== Token.Keyword) {
          return 0;
        }
        switch (token.value) {
          case '||':
            prec = 1;
            break;
          case '&&':
            prec = 2;
            break;
          case '|':
            prec = 3;
            break;
          case '^':
            prec = 4;
            break;
          case '&':
            prec = 5;
            break;
          case '==':
          case '!=':
          case '===':
          case '!==':
            prec = 6;
            break;
          case '<':
          case '>':
          case '<=':
          case '>=':
          case 'instanceof':
            prec = 7;
            break;
          case 'in':
            prec = allowIn ? 7 : 0;
            break;
          case '<<':
          case '>>':
          case '>>>':
            prec = 8;
            break;
          case '+':
          case '-':
            prec = 9;
            break;
          case '*':
          case '/':
          case '%':
            prec = 11;
            break;
          default:
            break;
        }
        return prec;
      }
      function parseBinaryExpression() {
        var marker,
            markers,
            expr,
            token,
            prec,
            stack,
            right,
            operator,
            left,
            i;
        marker = lookahead;
        left = parseUnaryExpression();
        if (left === PlaceHolders.ArrowParameterPlaceHolder) {
          return left;
        }
        token = lookahead;
        prec = binaryPrecedence(token, state.allowIn);
        if (prec === 0) {
          return left;
        }
        token.prec = prec;
        lex();
        markers = [marker, lookahead];
        right = parseUnaryExpression();
        stack = [left, token, right];
        while ((prec = binaryPrecedence(lookahead, state.allowIn)) > 0) {
          while ((stack.length > 2) && (prec <= stack[stack.length - 2].prec)) {
            right = stack.pop();
            operator = stack.pop().value;
            left = stack.pop();
            markers.pop();
            expr = new WrappingNode(markers[markers.length - 1]).finishBinaryExpression(operator, left, right);
            stack.push(expr);
          }
          token = lex();
          token.prec = prec;
          stack.push(token);
          markers.push(lookahead);
          expr = parseUnaryExpression();
          stack.push(expr);
        }
        i = stack.length - 1;
        expr = stack[i];
        markers.pop();
        while (i > 1) {
          expr = new WrappingNode(markers.pop()).finishBinaryExpression(stack[i - 1].value, stack[i - 2], expr);
          i -= 2;
        }
        return expr;
      }
      function parseConditionalExpression() {
        var expr,
            previousAllowIn,
            consequent,
            alternate,
            startToken;
        startToken = lookahead;
        expr = parseBinaryExpression();
        if (expr === PlaceHolders.ArrowParameterPlaceHolder) {
          return expr;
        }
        if (match('?')) {
          lex();
          previousAllowIn = state.allowIn;
          state.allowIn = true;
          consequent = parseAssignmentExpression();
          state.allowIn = previousAllowIn;
          expect(':');
          alternate = parseAssignmentExpression();
          expr = new WrappingNode(startToken).finishConditionalExpression(expr, consequent, alternate);
        }
        return expr;
      }
      function parseConciseBody() {
        if (match('{')) {
          return parseFunctionSourceElements();
        }
        return parseAssignmentExpression();
      }
      function reinterpretAsCoverFormalsList(expressions) {
        var i,
            len,
            param,
            params,
            defaults,
            defaultCount,
            options,
            rest,
            token;
        params = [];
        defaults = [];
        defaultCount = 0;
        rest = null;
        options = {paramSet: {}};
        for (i = 0, len = expressions.length; i < len; i += 1) {
          param = expressions[i];
          if (param.type === Syntax.Identifier) {
            params.push(param);
            defaults.push(null);
            validateParam(options, param, param.name);
          } else if (param.type === Syntax.AssignmentExpression) {
            params.push(param.left);
            defaults.push(param.right);
            ++defaultCount;
            validateParam(options, param.left, param.left.name);
          } else {
            return null;
          }
        }
        if (options.message === Messages.StrictParamDupe) {
          token = strict ? options.stricted : options.firstRestricted;
          throwUnexpectedToken(token, options.message);
        }
        if (defaultCount === 0) {
          defaults = [];
        }
        return {
          params: params,
          defaults: defaults,
          rest: rest,
          stricted: options.stricted,
          firstRestricted: options.firstRestricted,
          message: options.message
        };
      }
      function parseArrowFunctionExpression(options, node) {
        var previousStrict,
            body;
        expect('=>');
        previousStrict = strict;
        body = parseConciseBody();
        if (strict && options.firstRestricted) {
          throwUnexpectedToken(options.firstRestricted, options.message);
        }
        if (strict && options.stricted) {
          tolerateUnexpectedToken(options.stricted, options.message);
        }
        strict = previousStrict;
        return node.finishArrowFunctionExpression(options.params, options.defaults, body, body.type !== Syntax.BlockStatement);
      }
      function parseAssignmentExpression() {
        var oldParenthesisCount,
            token,
            expr,
            right,
            list,
            startToken;
        oldParenthesisCount = state.parenthesisCount;
        startToken = lookahead;
        token = lookahead;
        expr = parseConditionalExpression();
        if (expr === PlaceHolders.ArrowParameterPlaceHolder || match('=>')) {
          if (state.parenthesisCount === oldParenthesisCount || state.parenthesisCount === (oldParenthesisCount + 1)) {
            if (expr.type === Syntax.Identifier) {
              list = reinterpretAsCoverFormalsList([expr]);
            } else if (expr.type === Syntax.AssignmentExpression) {
              list = reinterpretAsCoverFormalsList([expr]);
            } else if (expr.type === Syntax.SequenceExpression) {
              list = reinterpretAsCoverFormalsList(expr.expressions);
            } else if (expr === PlaceHolders.ArrowParameterPlaceHolder) {
              list = reinterpretAsCoverFormalsList([]);
            }
            if (list) {
              return parseArrowFunctionExpression(list, new WrappingNode(startToken));
            }
          }
        }
        if (matchAssign()) {
          if (!isLeftHandSide(expr)) {
            tolerateError(Messages.InvalidLHSInAssignment);
          }
          if (strict && expr.type === Syntax.Identifier && isRestrictedWord(expr.name)) {
            tolerateUnexpectedToken(token, Messages.StrictLHSAssignment);
          }
          token = lex();
          right = parseAssignmentExpression();
          expr = new WrappingNode(startToken).finishAssignmentExpression(token.value, expr, right);
        }
        return expr;
      }
      function parseExpression() {
        var expr,
            startToken = lookahead,
            expressions;
        expr = parseAssignmentExpression();
        if (match(',')) {
          expressions = [expr];
          while (index < length) {
            if (!match(',')) {
              break;
            }
            lex();
            expressions.push(parseAssignmentExpression());
          }
          expr = new WrappingNode(startToken).finishSequenceExpression(expressions);
        }
        return expr;
      }
      function parseStatementList() {
        var list = [],
            statement;
        while (index < length) {
          if (match('}')) {
            break;
          }
          statement = parseSourceElement();
          if (typeof statement === 'undefined') {
            break;
          }
          list.push(statement);
        }
        return list;
      }
      function parseBlock() {
        var block,
            node = new Node();
        expect('{');
        block = parseStatementList();
        expect('}');
        return node.finishBlockStatement(block);
      }
      function parseVariableIdentifier() {
        var token,
            node = new Node();
        token = lex();
        if (token.type !== Token.Identifier) {
          if (strict && token.type === Token.Keyword && isStrictModeReservedWord(token.value)) {
            tolerateUnexpectedToken(token, Messages.StrictReservedWord);
          } else {
            throwUnexpectedToken(token);
          }
        }
        return node.finishIdentifier(token.value);
      }
      function parseVariableDeclaration(kind) {
        var init = null,
            id,
            node = new Node();
        id = parseVariableIdentifier();
        if (strict && isRestrictedWord(id.name)) {
          tolerateError(Messages.StrictVarName);
        }
        if (kind === 'const') {
          expect('=');
          init = parseAssignmentExpression();
        } else if (match('=')) {
          lex();
          init = parseAssignmentExpression();
        }
        return node.finishVariableDeclarator(id, init);
      }
      function parseVariableDeclarationList(kind) {
        var list = [];
        do {
          list.push(parseVariableDeclaration(kind));
          if (!match(',')) {
            break;
          }
          lex();
        } while (index < length);
        return list;
      }
      function parseVariableStatement(node) {
        var declarations;
        expectKeyword('var');
        declarations = parseVariableDeclarationList();
        consumeSemicolon();
        return node.finishVariableDeclaration(declarations, 'var');
      }
      function parseConstLetDeclaration(kind) {
        var declarations,
            node = new Node();
        expectKeyword(kind);
        declarations = parseVariableDeclarationList(kind);
        consumeSemicolon();
        return node.finishVariableDeclaration(declarations, kind);
      }
      function parseEmptyStatement() {
        var node = new Node();
        expect(';');
        return node.finishEmptyStatement();
      }
      function parseExpressionStatement(node) {
        var expr = parseExpression();
        consumeSemicolon();
        return node.finishExpressionStatement(expr);
      }
      function parseIfStatement(node) {
        var test,
            consequent,
            alternate;
        expectKeyword('if');
        expect('(');
        test = parseExpression();
        expect(')');
        consequent = parseStatement();
        if (matchKeyword('else')) {
          lex();
          alternate = parseStatement();
        } else {
          alternate = null;
        }
        return node.finishIfStatement(test, consequent, alternate);
      }
      function parseDoWhileStatement(node) {
        var body,
            test,
            oldInIteration;
        expectKeyword('do');
        oldInIteration = state.inIteration;
        state.inIteration = true;
        body = parseStatement();
        state.inIteration = oldInIteration;
        expectKeyword('while');
        expect('(');
        test = parseExpression();
        expect(')');
        if (match(';')) {
          lex();
        }
        return node.finishDoWhileStatement(body, test);
      }
      function parseWhileStatement(node) {
        var test,
            body,
            oldInIteration;
        expectKeyword('while');
        expect('(');
        test = parseExpression();
        expect(')');
        oldInIteration = state.inIteration;
        state.inIteration = true;
        body = parseStatement();
        state.inIteration = oldInIteration;
        return node.finishWhileStatement(test, body);
      }
      function parseForVariableDeclaration() {
        var token,
            declarations,
            node = new Node();
        token = lex();
        declarations = parseVariableDeclarationList();
        return node.finishVariableDeclaration(declarations, token.value);
      }
      function parseForStatement(node) {
        var init,
            test,
            update,
            left,
            right,
            body,
            oldInIteration,
            previousAllowIn = state.allowIn;
        init = test = update = null;
        expectKeyword('for');
        expect('(');
        if (match(';')) {
          lex();
        } else {
          if (matchKeyword('var') || matchKeyword('let')) {
            state.allowIn = false;
            init = parseForVariableDeclaration();
            state.allowIn = previousAllowIn;
            if (init.declarations.length === 1 && matchKeyword('in')) {
              lex();
              left = init;
              right = parseExpression();
              init = null;
            }
          } else {
            state.allowIn = false;
            init = parseExpression();
            state.allowIn = previousAllowIn;
            if (matchKeyword('in')) {
              if (!isLeftHandSide(init)) {
                tolerateError(Messages.InvalidLHSInForIn);
              }
              lex();
              left = init;
              right = parseExpression();
              init = null;
            }
          }
          if (typeof left === 'undefined') {
            expect(';');
          }
        }
        if (typeof left === 'undefined') {
          if (!match(';')) {
            test = parseExpression();
          }
          expect(';');
          if (!match(')')) {
            update = parseExpression();
          }
        }
        expect(')');
        oldInIteration = state.inIteration;
        state.inIteration = true;
        body = parseStatement();
        state.inIteration = oldInIteration;
        return (typeof left === 'undefined') ? node.finishForStatement(init, test, update, body) : node.finishForInStatement(left, right, body);
      }
      function parseContinueStatement(node) {
        var label = null,
            key;
        expectKeyword('continue');
        if (source.charCodeAt(index) === 0x3B) {
          lex();
          if (!state.inIteration) {
            throwError(Messages.IllegalContinue);
          }
          return node.finishContinueStatement(null);
        }
        if (peekLineTerminator()) {
          if (!state.inIteration) {
            throwError(Messages.IllegalContinue);
          }
          return node.finishContinueStatement(null);
        }
        if (lookahead.type === Token.Identifier) {
          label = parseVariableIdentifier();
          key = '$' + label.name;
          if (!Object.prototype.hasOwnProperty.call(state.labelSet, key)) {
            throwError(Messages.UnknownLabel, label.name);
          }
        }
        consumeSemicolon();
        if (label === null && !state.inIteration) {
          throwError(Messages.IllegalContinue);
        }
        return node.finishContinueStatement(label);
      }
      function parseBreakStatement(node) {
        var label = null,
            key;
        expectKeyword('break');
        if (source.charCodeAt(index) === 0x3B) {
          lex();
          if (!(state.inIteration || state.inSwitch)) {
            throwError(Messages.IllegalBreak);
          }
          return node.finishBreakStatement(null);
        }
        if (peekLineTerminator()) {
          if (!(state.inIteration || state.inSwitch)) {
            throwError(Messages.IllegalBreak);
          }
          return node.finishBreakStatement(null);
        }
        if (lookahead.type === Token.Identifier) {
          label = parseVariableIdentifier();
          key = '$' + label.name;
          if (!Object.prototype.hasOwnProperty.call(state.labelSet, key)) {
            throwError(Messages.UnknownLabel, label.name);
          }
        }
        consumeSemicolon();
        if (label === null && !(state.inIteration || state.inSwitch)) {
          throwError(Messages.IllegalBreak);
        }
        return node.finishBreakStatement(label);
      }
      function parseReturnStatement(node) {
        var argument = null;
        expectKeyword('return');
        if (!state.inFunctionBody) {
          tolerateError(Messages.IllegalReturn);
        }
        if (source.charCodeAt(index) === 0x20) {
          if (isIdentifierStart(source.charCodeAt(index + 1))) {
            argument = parseExpression();
            consumeSemicolon();
            return node.finishReturnStatement(argument);
          }
        }
        if (peekLineTerminator()) {
          return node.finishReturnStatement(null);
        }
        if (!match(';')) {
          if (!match('}') && lookahead.type !== Token.EOF) {
            argument = parseExpression();
          }
        }
        consumeSemicolon();
        return node.finishReturnStatement(argument);
      }
      function parseWithStatement(node) {
        var object,
            body;
        if (strict) {
          skipComment();
          tolerateError(Messages.StrictModeWith);
        }
        expectKeyword('with');
        expect('(');
        object = parseExpression();
        expect(')');
        body = parseStatement();
        return node.finishWithStatement(object, body);
      }
      function parseSwitchCase() {
        var test,
            consequent = [],
            statement,
            node = new Node();
        if (matchKeyword('default')) {
          lex();
          test = null;
        } else {
          expectKeyword('case');
          test = parseExpression();
        }
        expect(':');
        while (index < length) {
          if (match('}') || matchKeyword('default') || matchKeyword('case')) {
            break;
          }
          statement = parseStatement();
          consequent.push(statement);
        }
        return node.finishSwitchCase(test, consequent);
      }
      function parseSwitchStatement(node) {
        var discriminant,
            cases,
            clause,
            oldInSwitch,
            defaultFound;
        expectKeyword('switch');
        expect('(');
        discriminant = parseExpression();
        expect(')');
        expect('{');
        cases = [];
        if (match('}')) {
          lex();
          return node.finishSwitchStatement(discriminant, cases);
        }
        oldInSwitch = state.inSwitch;
        state.inSwitch = true;
        defaultFound = false;
        while (index < length) {
          if (match('}')) {
            break;
          }
          clause = parseSwitchCase();
          if (clause.test === null) {
            if (defaultFound) {
              throwError(Messages.MultipleDefaultsInSwitch);
            }
            defaultFound = true;
          }
          cases.push(clause);
        }
        state.inSwitch = oldInSwitch;
        expect('}');
        return node.finishSwitchStatement(discriminant, cases);
      }
      function parseThrowStatement(node) {
        var argument;
        expectKeyword('throw');
        if (peekLineTerminator()) {
          throwError(Messages.NewlineAfterThrow);
        }
        argument = parseExpression();
        consumeSemicolon();
        return node.finishThrowStatement(argument);
      }
      function parseCatchClause() {
        var param,
            body,
            node = new Node();
        expectKeyword('catch');
        expect('(');
        if (match(')')) {
          throwUnexpectedToken(lookahead);
        }
        param = parseVariableIdentifier();
        if (strict && isRestrictedWord(param.name)) {
          tolerateError(Messages.StrictCatchVariable);
        }
        expect(')');
        body = parseBlock();
        return node.finishCatchClause(param, body);
      }
      function parseTryStatement(node) {
        var block,
            handlers = [],
            finalizer = null;
        expectKeyword('try');
        block = parseBlock();
        if (matchKeyword('catch')) {
          handlers.push(parseCatchClause());
        }
        if (matchKeyword('finally')) {
          lex();
          finalizer = parseBlock();
        }
        if (handlers.length === 0 && !finalizer) {
          throwError(Messages.NoCatchOrFinally);
        }
        return node.finishTryStatement(block, [], handlers, finalizer);
      }
      function parseDebuggerStatement(node) {
        expectKeyword('debugger');
        consumeSemicolon();
        return node.finishDebuggerStatement();
      }
      function parseStatement() {
        var type = lookahead.type,
            expr,
            labeledBody,
            key,
            node;
        if (type === Token.EOF) {
          throwUnexpectedToken(lookahead);
        }
        if (type === Token.Punctuator && lookahead.value === '{') {
          return parseBlock();
        }
        node = new Node();
        if (type === Token.Punctuator) {
          switch (lookahead.value) {
            case ';':
              return parseEmptyStatement(node);
            case '(':
              return parseExpressionStatement(node);
            default:
              break;
          }
        } else if (type === Token.Keyword) {
          switch (lookahead.value) {
            case 'break':
              return parseBreakStatement(node);
            case 'continue':
              return parseContinueStatement(node);
            case 'debugger':
              return parseDebuggerStatement(node);
            case 'do':
              return parseDoWhileStatement(node);
            case 'for':
              return parseForStatement(node);
            case 'function':
              return parseFunctionDeclaration(node);
            case 'if':
              return parseIfStatement(node);
            case 'return':
              return parseReturnStatement(node);
            case 'switch':
              return parseSwitchStatement(node);
            case 'throw':
              return parseThrowStatement(node);
            case 'try':
              return parseTryStatement(node);
            case 'var':
              return parseVariableStatement(node);
            case 'while':
              return parseWhileStatement(node);
            case 'with':
              return parseWithStatement(node);
            default:
              break;
          }
        }
        expr = parseExpression();
        if ((expr.type === Syntax.Identifier) && match(':')) {
          lex();
          key = '$' + expr.name;
          if (Object.prototype.hasOwnProperty.call(state.labelSet, key)) {
            throwError(Messages.Redeclaration, 'Label', expr.name);
          }
          state.labelSet[key] = true;
          labeledBody = parseStatement();
          delete state.labelSet[key];
          return node.finishLabeledStatement(expr, labeledBody);
        }
        consumeSemicolon();
        return node.finishExpressionStatement(expr);
      }
      function parseFunctionSourceElements() {
        var sourceElement,
            sourceElements = [],
            token,
            directive,
            firstRestricted,
            oldLabelSet,
            oldInIteration,
            oldInSwitch,
            oldInFunctionBody,
            oldParenthesisCount,
            node = new Node();
        expect('{');
        while (index < length) {
          if (lookahead.type !== Token.StringLiteral) {
            break;
          }
          token = lookahead;
          sourceElement = parseSourceElement();
          sourceElements.push(sourceElement);
          if (sourceElement.expression.type !== Syntax.Literal) {
            break;
          }
          directive = source.slice(token.start + 1, token.end - 1);
          if (directive === 'use strict') {
            strict = true;
            if (firstRestricted) {
              tolerateUnexpectedToken(firstRestricted, Messages.StrictOctalLiteral);
            }
          } else {
            if (!firstRestricted && token.octal) {
              firstRestricted = token;
            }
          }
        }
        oldLabelSet = state.labelSet;
        oldInIteration = state.inIteration;
        oldInSwitch = state.inSwitch;
        oldInFunctionBody = state.inFunctionBody;
        oldParenthesisCount = state.parenthesizedCount;
        state.labelSet = {};
        state.inIteration = false;
        state.inSwitch = false;
        state.inFunctionBody = true;
        state.parenthesizedCount = 0;
        while (index < length) {
          if (match('}')) {
            break;
          }
          sourceElement = parseSourceElement();
          if (typeof sourceElement === 'undefined') {
            break;
          }
          sourceElements.push(sourceElement);
        }
        expect('}');
        state.labelSet = oldLabelSet;
        state.inIteration = oldInIteration;
        state.inSwitch = oldInSwitch;
        state.inFunctionBody = oldInFunctionBody;
        state.parenthesizedCount = oldParenthesisCount;
        return node.finishBlockStatement(sourceElements);
      }
      function validateParam(options, param, name) {
        var key = '$' + name;
        if (strict) {
          if (isRestrictedWord(name)) {
            options.stricted = param;
            options.message = Messages.StrictParamName;
          }
          if (Object.prototype.hasOwnProperty.call(options.paramSet, key)) {
            options.stricted = param;
            options.message = Messages.StrictParamDupe;
          }
        } else if (!options.firstRestricted) {
          if (isRestrictedWord(name)) {
            options.firstRestricted = param;
            options.message = Messages.StrictParamName;
          } else if (isStrictModeReservedWord(name)) {
            options.firstRestricted = param;
            options.message = Messages.StrictReservedWord;
          } else if (Object.prototype.hasOwnProperty.call(options.paramSet, key)) {
            options.firstRestricted = param;
            options.message = Messages.StrictParamDupe;
          }
        }
        options.paramSet[key] = true;
      }
      function parseParam(options) {
        var token,
            param,
            def;
        token = lookahead;
        param = parseVariableIdentifier();
        validateParam(options, token, token.value);
        if (match('=')) {
          lex();
          def = parseAssignmentExpression();
          ++options.defaultCount;
        }
        options.params.push(param);
        options.defaults.push(def);
        return !match(')');
      }
      function parseParams(firstRestricted) {
        var options;
        options = {
          params: [],
          defaultCount: 0,
          defaults: [],
          firstRestricted: firstRestricted
        };
        expect('(');
        if (!match(')')) {
          options.paramSet = {};
          while (index < length) {
            if (!parseParam(options)) {
              break;
            }
            expect(',');
          }
        }
        expect(')');
        if (options.defaultCount === 0) {
          options.defaults = [];
        }
        return {
          params: options.params,
          defaults: options.defaults,
          stricted: options.stricted,
          firstRestricted: options.firstRestricted,
          message: options.message
        };
      }
      function parseFunctionDeclaration() {
        var id,
            params = [],
            defaults = [],
            body,
            token,
            stricted,
            tmp,
            firstRestricted,
            message,
            previousStrict,
            node = new Node();
        expectKeyword('function');
        token = lookahead;
        id = parseVariableIdentifier();
        if (strict) {
          if (isRestrictedWord(token.value)) {
            tolerateUnexpectedToken(token, Messages.StrictFunctionName);
          }
        } else {
          if (isRestrictedWord(token.value)) {
            firstRestricted = token;
            message = Messages.StrictFunctionName;
          } else if (isStrictModeReservedWord(token.value)) {
            firstRestricted = token;
            message = Messages.StrictReservedWord;
          }
        }
        tmp = parseParams(firstRestricted);
        params = tmp.params;
        defaults = tmp.defaults;
        stricted = tmp.stricted;
        firstRestricted = tmp.firstRestricted;
        if (tmp.message) {
          message = tmp.message;
        }
        previousStrict = strict;
        body = parseFunctionSourceElements();
        if (strict && firstRestricted) {
          throwUnexpectedToken(firstRestricted, message);
        }
        if (strict && stricted) {
          tolerateUnexpectedToken(stricted, message);
        }
        strict = previousStrict;
        return node.finishFunctionDeclaration(id, params, defaults, body);
      }
      function parseFunctionExpression() {
        var token,
            id = null,
            stricted,
            firstRestricted,
            message,
            tmp,
            params = [],
            defaults = [],
            body,
            previousStrict,
            node = new Node();
        expectKeyword('function');
        if (!match('(')) {
          token = lookahead;
          id = parseVariableIdentifier();
          if (strict) {
            if (isRestrictedWord(token.value)) {
              tolerateUnexpectedToken(token, Messages.StrictFunctionName);
            }
          } else {
            if (isRestrictedWord(token.value)) {
              firstRestricted = token;
              message = Messages.StrictFunctionName;
            } else if (isStrictModeReservedWord(token.value)) {
              firstRestricted = token;
              message = Messages.StrictReservedWord;
            }
          }
        }
        tmp = parseParams(firstRestricted);
        params = tmp.params;
        defaults = tmp.defaults;
        stricted = tmp.stricted;
        firstRestricted = tmp.firstRestricted;
        if (tmp.message) {
          message = tmp.message;
        }
        previousStrict = strict;
        body = parseFunctionSourceElements();
        if (strict && firstRestricted) {
          throwUnexpectedToken(firstRestricted, message);
        }
        if (strict && stricted) {
          tolerateUnexpectedToken(stricted, message);
        }
        strict = previousStrict;
        return node.finishFunctionExpression(id, params, defaults, body);
      }
      function parseSourceElement() {
        if (lookahead.type === Token.Keyword) {
          switch (lookahead.value) {
            case 'const':
            case 'let':
              return parseConstLetDeclaration(lookahead.value);
            case 'function':
              return parseFunctionDeclaration();
            default:
              return parseStatement();
          }
        }
        if (lookahead.type !== Token.EOF) {
          return parseStatement();
        }
      }
      function parseSourceElements() {
        var sourceElement,
            sourceElements = [],
            token,
            directive,
            firstRestricted;
        while (index < length) {
          token = lookahead;
          if (token.type !== Token.StringLiteral) {
            break;
          }
          sourceElement = parseSourceElement();
          sourceElements.push(sourceElement);
          if (sourceElement.expression.type !== Syntax.Literal) {
            break;
          }
          directive = source.slice(token.start + 1, token.end - 1);
          if (directive === 'use strict') {
            strict = true;
            if (firstRestricted) {
              tolerateUnexpectedToken(firstRestricted, Messages.StrictOctalLiteral);
            }
          } else {
            if (!firstRestricted && token.octal) {
              firstRestricted = token;
            }
          }
        }
        while (index < length) {
          sourceElement = parseSourceElement();
          if (typeof sourceElement === 'undefined') {
            break;
          }
          sourceElements.push(sourceElement);
        }
        return sourceElements;
      }
      function parseProgram() {
        var body,
            node;
        skipComment();
        peek();
        node = new Node();
        strict = false;
        body = parseSourceElements();
        return node.finishProgram(body);
      }
      function filterTokenLocation() {
        var i,
            entry,
            token,
            tokens = [];
        for (i = 0; i < extra.tokens.length; ++i) {
          entry = extra.tokens[i];
          token = {
            type: entry.type,
            value: entry.value
          };
          if (entry.regex) {
            token.regex = {
              pattern: entry.regex.pattern,
              flags: entry.regex.flags
            };
          }
          if (extra.range) {
            token.range = entry.range;
          }
          if (extra.loc) {
            token.loc = entry.loc;
          }
          tokens.push(token);
        }
        extra.tokens = tokens;
      }
      function tokenize(code, options) {
        var toString,
            tokens;
        toString = String;
        if (typeof code !== 'string' && !(code instanceof String)) {
          code = toString(code);
        }
        source = code;
        index = 0;
        lineNumber = (source.length > 0) ? 1 : 0;
        lineStart = 0;
        length = source.length;
        lookahead = null;
        state = {
          allowIn: true,
          labelSet: {},
          inFunctionBody: false,
          inIteration: false,
          inSwitch: false,
          lastCommentStart: -1
        };
        extra = {};
        options = options || {};
        options.tokens = true;
        extra.tokens = [];
        extra.tokenize = true;
        extra.openParenToken = -1;
        extra.openCurlyToken = -1;
        extra.range = (typeof options.range === 'boolean') && options.range;
        extra.loc = (typeof options.loc === 'boolean') && options.loc;
        if (typeof options.comment === 'boolean' && options.comment) {
          extra.comments = [];
        }
        if (typeof options.tolerant === 'boolean' && options.tolerant) {
          extra.errors = [];
        }
        try {
          peek();
          if (lookahead.type === Token.EOF) {
            return extra.tokens;
          }
          lex();
          while (lookahead.type !== Token.EOF) {
            try {
              lex();
            } catch (lexError) {
              if (extra.errors) {
                extra.errors.push(lexError);
                break;
              } else {
                throw lexError;
              }
            }
          }
          filterTokenLocation();
          tokens = extra.tokens;
          if (typeof extra.comments !== 'undefined') {
            tokens.comments = extra.comments;
          }
          if (typeof extra.errors !== 'undefined') {
            tokens.errors = extra.errors;
          }
        } catch (e) {
          throw e;
        } finally {
          extra = {};
        }
        return tokens;
      }
      function parse(code, options) {
        var program,
            toString;
        toString = String;
        if (typeof code !== 'string' && !(code instanceof String)) {
          code = toString(code);
        }
        source = code;
        index = 0;
        lineNumber = (source.length > 0) ? 1 : 0;
        lineStart = 0;
        length = source.length;
        lookahead = null;
        state = {
          allowIn: true,
          labelSet: {},
          parenthesisCount: 0,
          inFunctionBody: false,
          inIteration: false,
          inSwitch: false,
          lastCommentStart: -1
        };
        extra = {};
        if (typeof options !== 'undefined') {
          extra.range = (typeof options.range === 'boolean') && options.range;
          extra.loc = (typeof options.loc === 'boolean') && options.loc;
          extra.attachComment = (typeof options.attachComment === 'boolean') && options.attachComment;
          if (extra.loc && options.source !== null && options.source !== undefined) {
            extra.source = toString(options.source);
          }
          if (typeof options.tokens === 'boolean' && options.tokens) {
            extra.tokens = [];
          }
          if (typeof options.comment === 'boolean' && options.comment) {
            extra.comments = [];
          }
          if (typeof options.tolerant === 'boolean' && options.tolerant) {
            extra.errors = [];
          }
          if (extra.attachComment) {
            extra.range = true;
            extra.comments = [];
            extra.bottomRightStack = [];
            extra.trailingComments = [];
            extra.leadingComments = [];
          }
        }
        try {
          program = parseProgram();
          if (typeof extra.comments !== 'undefined') {
            program.comments = extra.comments;
          }
          if (typeof extra.tokens !== 'undefined') {
            filterTokenLocation();
            program.tokens = extra.tokens;
          }
          if (typeof extra.errors !== 'undefined') {
            program.errors = extra.errors;
          }
        } catch (e) {
          throw e;
        } finally {
          extra = {};
        }
        return program;
      }
      exports.version = '2.0.0';
      exports.tokenize = tokenize;
      exports.parse = parse;
      exports.Syntax = (function() {
        var name,
            types = {};
        if (typeof Object.create === 'function') {
          types = Object.create(null);
        }
        for (name in Syntax) {
          if (Syntax.hasOwnProperty(name)) {
            types[name] = Syntax[name];
          }
        }
        if (typeof Object.freeze === 'function') {
          Object.freeze(types);
        }
        return types;
      }());
    }));
  })(require("github:jspm/nodelibs-process@0.1.1"));
  global.define = __define;
  return module.exports;
});



System.register("npm:lodash@3.3.1/index", ["github:jspm/nodelibs-process@0.1.1"], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  "format cjs";
  (function(process) {
    ;
    (function() {
      var undefined;
      var VERSION = '3.3.1';
      var BIND_FLAG = 1,
          BIND_KEY_FLAG = 2,
          CURRY_BOUND_FLAG = 4,
          CURRY_FLAG = 8,
          CURRY_RIGHT_FLAG = 16,
          PARTIAL_FLAG = 32,
          PARTIAL_RIGHT_FLAG = 64,
          REARG_FLAG = 128,
          ARY_FLAG = 256;
      var DEFAULT_TRUNC_LENGTH = 30,
          DEFAULT_TRUNC_OMISSION = '...';
      var HOT_COUNT = 150,
          HOT_SPAN = 16;
      var LAZY_FILTER_FLAG = 0,
          LAZY_MAP_FLAG = 1,
          LAZY_WHILE_FLAG = 2;
      var FUNC_ERROR_TEXT = 'Expected a function';
      var PLACEHOLDER = '__lodash_placeholder__';
      var argsTag = '[object Arguments]',
          arrayTag = '[object Array]',
          boolTag = '[object Boolean]',
          dateTag = '[object Date]',
          errorTag = '[object Error]',
          funcTag = '[object Function]',
          mapTag = '[object Map]',
          numberTag = '[object Number]',
          objectTag = '[object Object]',
          regexpTag = '[object RegExp]',
          setTag = '[object Set]',
          stringTag = '[object String]',
          weakMapTag = '[object WeakMap]';
      var arrayBufferTag = '[object ArrayBuffer]',
          float32Tag = '[object Float32Array]',
          float64Tag = '[object Float64Array]',
          int8Tag = '[object Int8Array]',
          int16Tag = '[object Int16Array]',
          int32Tag = '[object Int32Array]',
          uint8Tag = '[object Uint8Array]',
          uint8ClampedTag = '[object Uint8ClampedArray]',
          uint16Tag = '[object Uint16Array]',
          uint32Tag = '[object Uint32Array]';
      var reEmptyStringLeading = /\b__p \+= '';/g,
          reEmptyStringMiddle = /\b(__p \+=) '' \+/g,
          reEmptyStringTrailing = /(__e\(.*?\)|\b__t\)) \+\n'';/g;
      var reEscapedHtml = /&(?:amp|lt|gt|quot|#39|#96);/g,
          reUnescapedHtml = /[&<>"'`]/g,
          reHasEscapedHtml = RegExp(reEscapedHtml.source),
          reHasUnescapedHtml = RegExp(reUnescapedHtml.source);
      var reEscape = /<%-([\s\S]+?)%>/g,
          reEvaluate = /<%([\s\S]+?)%>/g,
          reInterpolate = /<%=([\s\S]+?)%>/g;
      var reEsTemplate = /\$\{([^\\}]*(?:\\.[^\\}]*)*)\}/g;
      var reFlags = /\w*$/;
      var reFuncName = /^\s*function[ \n\r\t]+\w/;
      var reHexPrefix = /^0[xX]/;
      var reHostCtor = /^\[object .+?Constructor\]$/;
      var reLatin1 = /[\xc0-\xd6\xd8-\xde\xdf-\xf6\xf8-\xff]/g;
      var reNoMatch = /($^)/;
      var reRegExpChars = /[.*+?^${}()|[\]\/\\]/g,
          reHasRegExpChars = RegExp(reRegExpChars.source);
      var reThis = /\bthis\b/;
      var reUnescapedString = /['\n\r\u2028\u2029\\]/g;
      var reWords = (function() {
        var upper = '[A-Z\\xc0-\\xd6\\xd8-\\xde]',
            lower = '[a-z\\xdf-\\xf6\\xf8-\\xff]+';
        return RegExp(upper + '{2,}(?=' + upper + lower + ')|' + upper + '?' + lower + '|' + upper + '+|[0-9]+', 'g');
      }());
      var whitespace = (' \t\x0b\f\xa0\ufeff' + '\n\r\u2028\u2029' + '\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000');
      var contextProps = ['Array', 'ArrayBuffer', 'Date', 'Error', 'Float32Array', 'Float64Array', 'Function', 'Int8Array', 'Int16Array', 'Int32Array', 'Math', 'Number', 'Object', 'RegExp', 'Set', 'String', '_', 'clearTimeout', 'document', 'isFinite', 'parseInt', 'setTimeout', 'TypeError', 'Uint8Array', 'Uint8ClampedArray', 'Uint16Array', 'Uint32Array', 'WeakMap', 'window', 'WinRTError'];
      var templateCounter = -1;
      var typedArrayTags = {};
      typedArrayTags[float32Tag] = typedArrayTags[float64Tag] = typedArrayTags[int8Tag] = typedArrayTags[int16Tag] = typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] = typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] = typedArrayTags[uint32Tag] = true;
      typedArrayTags[argsTag] = typedArrayTags[arrayTag] = typedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] = typedArrayTags[dateTag] = typedArrayTags[errorTag] = typedArrayTags[funcTag] = typedArrayTags[mapTag] = typedArrayTags[numberTag] = typedArrayTags[objectTag] = typedArrayTags[regexpTag] = typedArrayTags[setTag] = typedArrayTags[stringTag] = typedArrayTags[weakMapTag] = false;
      var cloneableTags = {};
      cloneableTags[argsTag] = cloneableTags[arrayTag] = cloneableTags[arrayBufferTag] = cloneableTags[boolTag] = cloneableTags[dateTag] = cloneableTags[float32Tag] = cloneableTags[float64Tag] = cloneableTags[int8Tag] = cloneableTags[int16Tag] = cloneableTags[int32Tag] = cloneableTags[numberTag] = cloneableTags[objectTag] = cloneableTags[regexpTag] = cloneableTags[stringTag] = cloneableTags[uint8Tag] = cloneableTags[uint8ClampedTag] = cloneableTags[uint16Tag] = cloneableTags[uint32Tag] = true;
      cloneableTags[errorTag] = cloneableTags[funcTag] = cloneableTags[mapTag] = cloneableTags[setTag] = cloneableTags[weakMapTag] = false;
      var debounceOptions = {
        'leading': false,
        'maxWait': 0,
        'trailing': false
      };
      var deburredLetters = {
        '\xc0': 'A',
        '\xc1': 'A',
        '\xc2': 'A',
        '\xc3': 'A',
        '\xc4': 'A',
        '\xc5': 'A',
        '\xe0': 'a',
        '\xe1': 'a',
        '\xe2': 'a',
        '\xe3': 'a',
        '\xe4': 'a',
        '\xe5': 'a',
        '\xc7': 'C',
        '\xe7': 'c',
        '\xd0': 'D',
        '\xf0': 'd',
        '\xc8': 'E',
        '\xc9': 'E',
        '\xca': 'E',
        '\xcb': 'E',
        '\xe8': 'e',
        '\xe9': 'e',
        '\xea': 'e',
        '\xeb': 'e',
        '\xcC': 'I',
        '\xcd': 'I',
        '\xce': 'I',
        '\xcf': 'I',
        '\xeC': 'i',
        '\xed': 'i',
        '\xee': 'i',
        '\xef': 'i',
        '\xd1': 'N',
        '\xf1': 'n',
        '\xd2': 'O',
        '\xd3': 'O',
        '\xd4': 'O',
        '\xd5': 'O',
        '\xd6': 'O',
        '\xd8': 'O',
        '\xf2': 'o',
        '\xf3': 'o',
        '\xf4': 'o',
        '\xf5': 'o',
        '\xf6': 'o',
        '\xf8': 'o',
        '\xd9': 'U',
        '\xda': 'U',
        '\xdb': 'U',
        '\xdc': 'U',
        '\xf9': 'u',
        '\xfa': 'u',
        '\xfb': 'u',
        '\xfc': 'u',
        '\xdd': 'Y',
        '\xfd': 'y',
        '\xff': 'y',
        '\xc6': 'Ae',
        '\xe6': 'ae',
        '\xde': 'Th',
        '\xfe': 'th',
        '\xdf': 'ss'
      };
      var htmlEscapes = {
        '&': '&amp;',
        '<': '&lt;',
        '>': '&gt;',
        '"': '&quot;',
        "'": '&#39;',
        '`': '&#96;'
      };
      var htmlUnescapes = {
        '&amp;': '&',
        '&lt;': '<',
        '&gt;': '>',
        '&quot;': '"',
        '&#39;': "'",
        '&#96;': '`'
      };
      var objectTypes = {
        'function': true,
        'object': true
      };
      var stringEscapes = {
        '\\': '\\',
        "'": "'",
        '\n': 'n',
        '\r': 'r',
        '\u2028': 'u2028',
        '\u2029': 'u2029'
      };
      var root = (objectTypes[typeof window] && window !== (this && this.window)) ? window : this;
      var freeExports = objectTypes[typeof exports] && exports && !exports.nodeType && exports;
      var freeModule = objectTypes[typeof module] && module && !module.nodeType && module;
      var freeGlobal = freeExports && freeModule && typeof global == 'object' && global;
      if (freeGlobal && (freeGlobal.global === freeGlobal || freeGlobal.window === freeGlobal || freeGlobal.self === freeGlobal)) {
        root = freeGlobal;
      }
      var moduleExports = freeModule && freeModule.exports === freeExports && freeExports;
      function baseCompareAscending(value, other) {
        if (value !== other) {
          var valIsReflexive = value === value,
              othIsReflexive = other === other;
          if (value > other || !valIsReflexive || (typeof value == 'undefined' && othIsReflexive)) {
            return 1;
          }
          if (value < other || !othIsReflexive || (typeof other == 'undefined' && valIsReflexive)) {
            return -1;
          }
        }
        return 0;
      }
      function baseIndexOf(array, value, fromIndex) {
        if (value !== value) {
          return indexOfNaN(array, fromIndex);
        }
        var index = (fromIndex || 0) - 1,
            length = array.length;
        while (++index < length) {
          if (array[index] === value) {
            return index;
          }
        }
        return -1;
      }
      function baseIsFunction(value) {
        return typeof value == 'function' || false;
      }
      function baseSortBy(array, comparer) {
        var length = array.length;
        array.sort(comparer);
        while (length--) {
          array[length] = array[length].value;
        }
        return array;
      }
      function baseToString(value) {
        if (typeof value == 'string') {
          return value;
        }
        return value == null ? '' : (value + '');
      }
      function charAtCallback(string) {
        return string.charCodeAt(0);
      }
      function charsLeftIndex(string, chars) {
        var index = -1,
            length = string.length;
        while (++index < length && chars.indexOf(string.charAt(index)) > -1) {}
        return index;
      }
      function charsRightIndex(string, chars) {
        var index = string.length;
        while (index-- && chars.indexOf(string.charAt(index)) > -1) {}
        return index;
      }
      function compareAscending(object, other) {
        return baseCompareAscending(object.criteria, other.criteria) || (object.index - other.index);
      }
      function compareMultipleAscending(object, other) {
        var index = -1,
            objCriteria = object.criteria,
            othCriteria = other.criteria,
            length = objCriteria.length;
        while (++index < length) {
          var result = baseCompareAscending(objCriteria[index], othCriteria[index]);
          if (result) {
            return result;
          }
        }
        return object.index - other.index;
      }
      function deburrLetter(letter) {
        return deburredLetters[letter];
      }
      function escapeHtmlChar(chr) {
        return htmlEscapes[chr];
      }
      function escapeStringChar(chr) {
        return '\\' + stringEscapes[chr];
      }
      function indexOfNaN(array, fromIndex, fromRight) {
        var length = array.length,
            index = fromRight ? (fromIndex || length) : ((fromIndex || 0) - 1);
        while ((fromRight ? index-- : ++index < length)) {
          var other = array[index];
          if (other !== other) {
            return index;
          }
        }
        return -1;
      }
      function isObjectLike(value) {
        return (value && typeof value == 'object') || false;
      }
      function isSpace(charCode) {
        return ((charCode <= 160 && (charCode >= 9 && charCode <= 13) || charCode == 32 || charCode == 160) || charCode == 5760 || charCode == 6158 || (charCode >= 8192 && (charCode <= 8202 || charCode == 8232 || charCode == 8233 || charCode == 8239 || charCode == 8287 || charCode == 12288 || charCode == 65279)));
      }
      function replaceHolders(array, placeholder) {
        var index = -1,
            length = array.length,
            resIndex = -1,
            result = [];
        while (++index < length) {
          if (array[index] === placeholder) {
            array[index] = PLACEHOLDER;
            result[++resIndex] = index;
          }
        }
        return result;
      }
      function sortedUniq(array, iteratee) {
        var seen,
            index = -1,
            length = array.length,
            resIndex = -1,
            result = [];
        while (++index < length) {
          var value = array[index],
              computed = iteratee ? iteratee(value, index, array) : value;
          if (!index || seen !== computed) {
            seen = computed;
            result[++resIndex] = value;
          }
        }
        return result;
      }
      function trimmedLeftIndex(string) {
        var index = -1,
            length = string.length;
        while (++index < length && isSpace(string.charCodeAt(index))) {}
        return index;
      }
      function trimmedRightIndex(string) {
        var index = string.length;
        while (index-- && isSpace(string.charCodeAt(index))) {}
        return index;
      }
      function unescapeHtmlChar(chr) {
        return htmlUnescapes[chr];
      }
      function runInContext(context) {
        context = context ? _.defaults(root.Object(), context, _.pick(root, contextProps)) : root;
        var Array = context.Array,
            Date = context.Date,
            Error = context.Error,
            Function = context.Function,
            Math = context.Math,
            Number = context.Number,
            Object = context.Object,
            RegExp = context.RegExp,
            String = context.String,
            TypeError = context.TypeError;
        var arrayProto = Array.prototype,
            objectProto = Object.prototype;
        var document = (document = context.window) && document.document;
        var fnToString = Function.prototype.toString;
        var getLength = baseProperty('length');
        var hasOwnProperty = objectProto.hasOwnProperty;
        var idCounter = 0;
        var objToString = objectProto.toString;
        var oldDash = context._;
        var reNative = RegExp('^' + escapeRegExp(objToString).replace(/toString|(function).*?(?=\\\()| for .+?(?=\\\])/g, '$1.*?') + '$');
        var ArrayBuffer = isNative(ArrayBuffer = context.ArrayBuffer) && ArrayBuffer,
            bufferSlice = isNative(bufferSlice = ArrayBuffer && new ArrayBuffer(0).slice) && bufferSlice,
            ceil = Math.ceil,
            clearTimeout = context.clearTimeout,
            floor = Math.floor,
            getPrototypeOf = isNative(getPrototypeOf = Object.getPrototypeOf) && getPrototypeOf,
            push = arrayProto.push,
            propertyIsEnumerable = objectProto.propertyIsEnumerable,
            Set = isNative(Set = context.Set) && Set,
            setTimeout = context.setTimeout,
            splice = arrayProto.splice,
            Uint8Array = isNative(Uint8Array = context.Uint8Array) && Uint8Array,
            WeakMap = isNative(WeakMap = context.WeakMap) && WeakMap;
        var Float64Array = (function() {
          try {
            var func = isNative(func = context.Float64Array) && func,
                result = new func(new ArrayBuffer(10), 0, 1) && func;
          } catch (e) {}
          return result;
        }());
        var nativeIsArray = isNative(nativeIsArray = Array.isArray) && nativeIsArray,
            nativeCreate = isNative(nativeCreate = Object.create) && nativeCreate,
            nativeIsFinite = context.isFinite,
            nativeKeys = isNative(nativeKeys = Object.keys) && nativeKeys,
            nativeMax = Math.max,
            nativeMin = Math.min,
            nativeNow = isNative(nativeNow = Date.now) && nativeNow,
            nativeNumIsFinite = isNative(nativeNumIsFinite = Number.isFinite) && nativeNumIsFinite,
            nativeParseInt = context.parseInt,
            nativeRandom = Math.random;
        var NEGATIVE_INFINITY = Number.NEGATIVE_INFINITY,
            POSITIVE_INFINITY = Number.POSITIVE_INFINITY;
        var MAX_ARRAY_LENGTH = Math.pow(2, 32) - 1,
            MAX_ARRAY_INDEX = MAX_ARRAY_LENGTH - 1,
            HALF_MAX_ARRAY_LENGTH = MAX_ARRAY_LENGTH >>> 1;
        var FLOAT64_BYTES_PER_ELEMENT = Float64Array ? Float64Array.BYTES_PER_ELEMENT : 0;
        var MAX_SAFE_INTEGER = Math.pow(2, 53) - 1;
        var metaMap = WeakMap && new WeakMap;
        function lodash(value) {
          if (isObjectLike(value) && !isArray(value) && !(value instanceof LazyWrapper)) {
            if (value instanceof LodashWrapper) {
              return value;
            }
            if (hasOwnProperty.call(value, '__chain__') && hasOwnProperty.call(value, '__wrapped__')) {
              return wrapperClone(value);
            }
          }
          return new LodashWrapper(value);
        }
        function baseLodash() {}
        function LodashWrapper(value, chainAll, actions) {
          this.__wrapped__ = value;
          this.__actions__ = actions || [];
          this.__chain__ = !!chainAll;
        }
        var support = lodash.support = {};
        (function(x) {
          support.funcDecomp = !isNative(context.WinRTError) && reThis.test(runInContext);
          support.funcNames = typeof Function.name == 'string';
          try {
            support.dom = document.createDocumentFragment().nodeType === 11;
          } catch (e) {
            support.dom = false;
          }
          try {
            support.nonEnumArgs = !propertyIsEnumerable.call(arguments, 1);
          } catch (e) {
            support.nonEnumArgs = true;
          }
        }(0, 0));
        lodash.templateSettings = {
          'escape': reEscape,
          'evaluate': reEvaluate,
          'interpolate': reInterpolate,
          'variable': '',
          'imports': {'_': lodash}
        };
        function LazyWrapper(value) {
          this.__wrapped__ = value;
          this.__actions__ = null;
          this.__dir__ = 1;
          this.__dropCount__ = 0;
          this.__filtered__ = false;
          this.__iteratees__ = null;
          this.__takeCount__ = POSITIVE_INFINITY;
          this.__views__ = null;
        }
        function lazyClone() {
          var actions = this.__actions__,
              iteratees = this.__iteratees__,
              views = this.__views__,
              result = new LazyWrapper(this.__wrapped__);
          result.__actions__ = actions ? arrayCopy(actions) : null;
          result.__dir__ = this.__dir__;
          result.__dropCount__ = this.__dropCount__;
          result.__filtered__ = this.__filtered__;
          result.__iteratees__ = iteratees ? arrayCopy(iteratees) : null;
          result.__takeCount__ = this.__takeCount__;
          result.__views__ = views ? arrayCopy(views) : null;
          return result;
        }
        function lazyReverse() {
          if (this.__filtered__) {
            var result = new LazyWrapper(this);
            result.__dir__ = -1;
            result.__filtered__ = true;
          } else {
            result = this.clone();
            result.__dir__ *= -1;
          }
          return result;
        }
        function lazyValue() {
          var array = this.__wrapped__.value();
          if (!isArray(array)) {
            return baseWrapperValue(array, this.__actions__);
          }
          var dir = this.__dir__,
              isRight = dir < 0,
              view = getView(0, array.length, this.__views__),
              start = view.start,
              end = view.end,
              length = end - start,
              dropCount = this.__dropCount__,
              takeCount = nativeMin(length, this.__takeCount__),
              index = isRight ? end : start - 1,
              iteratees = this.__iteratees__,
              iterLength = iteratees ? iteratees.length : 0,
              resIndex = 0,
              result = [];
          outer: while (length-- && resIndex < takeCount) {
            index += dir;
            var iterIndex = -1,
                value = array[index];
            while (++iterIndex < iterLength) {
              var data = iteratees[iterIndex],
                  iteratee = data.iteratee,
                  computed = iteratee(value, index, array),
                  type = data.type;
              if (type == LAZY_MAP_FLAG) {
                value = computed;
              } else if (!computed) {
                if (type == LAZY_FILTER_FLAG) {
                  continue outer;
                } else {
                  break outer;
                }
              }
            }
            if (dropCount) {
              dropCount--;
            } else {
              result[resIndex++] = value;
            }
          }
          return result;
        }
        function MapCache() {
          this.__data__ = {};
        }
        function mapDelete(key) {
          return this.has(key) && delete this.__data__[key];
        }
        function mapGet(key) {
          return key == '__proto__' ? undefined : this.__data__[key];
        }
        function mapHas(key) {
          return key != '__proto__' && hasOwnProperty.call(this.__data__, key);
        }
        function mapSet(key, value) {
          if (key != '__proto__') {
            this.__data__[key] = value;
          }
          return this;
        }
        function SetCache(values) {
          var length = values ? values.length : 0;
          this.data = {
            'hash': nativeCreate(null),
            'set': new Set
          };
          while (length--) {
            this.push(values[length]);
          }
        }
        function cacheIndexOf(cache, value) {
          var data = cache.data,
              result = (typeof value == 'string' || isObject(value)) ? data.set.has(value) : data.hash[value];
          return result ? 0 : -1;
        }
        function cachePush(value) {
          var data = this.data;
          if (typeof value == 'string' || isObject(value)) {
            data.set.add(value);
          } else {
            data.hash[value] = true;
          }
        }
        function arrayCopy(source, array) {
          var index = -1,
              length = source.length;
          array || (array = Array(length));
          while (++index < length) {
            array[index] = source[index];
          }
          return array;
        }
        function arrayEach(array, iteratee) {
          var index = -1,
              length = array.length;
          while (++index < length) {
            if (iteratee(array[index], index, array) === false) {
              break;
            }
          }
          return array;
        }
        function arrayEachRight(array, iteratee) {
          var length = array.length;
          while (length--) {
            if (iteratee(array[length], length, array) === false) {
              break;
            }
          }
          return array;
        }
        function arrayEvery(array, predicate) {
          var index = -1,
              length = array.length;
          while (++index < length) {
            if (!predicate(array[index], index, array)) {
              return false;
            }
          }
          return true;
        }
        function arrayFilter(array, predicate) {
          var index = -1,
              length = array.length,
              resIndex = -1,
              result = [];
          while (++index < length) {
            var value = array[index];
            if (predicate(value, index, array)) {
              result[++resIndex] = value;
            }
          }
          return result;
        }
        function arrayMap(array, iteratee) {
          var index = -1,
              length = array.length,
              result = Array(length);
          while (++index < length) {
            result[index] = iteratee(array[index], index, array);
          }
          return result;
        }
        function arrayMax(array) {
          var index = -1,
              length = array.length,
              result = NEGATIVE_INFINITY;
          while (++index < length) {
            var value = array[index];
            if (value > result) {
              result = value;
            }
          }
          return result;
        }
        function arrayMin(array) {
          var index = -1,
              length = array.length,
              result = POSITIVE_INFINITY;
          while (++index < length) {
            var value = array[index];
            if (value < result) {
              result = value;
            }
          }
          return result;
        }
        function arrayReduce(array, iteratee, accumulator, initFromArray) {
          var index = -1,
              length = array.length;
          if (initFromArray && length) {
            accumulator = array[++index];
          }
          while (++index < length) {
            accumulator = iteratee(accumulator, array[index], index, array);
          }
          return accumulator;
        }
        function arrayReduceRight(array, iteratee, accumulator, initFromArray) {
          var length = array.length;
          if (initFromArray && length) {
            accumulator = array[--length];
          }
          while (length--) {
            accumulator = iteratee(accumulator, array[length], length, array);
          }
          return accumulator;
        }
        function arraySome(array, predicate) {
          var index = -1,
              length = array.length;
          while (++index < length) {
            if (predicate(array[index], index, array)) {
              return true;
            }
          }
          return false;
        }
        function assignDefaults(objectValue, sourceValue) {
          return typeof objectValue == 'undefined' ? sourceValue : objectValue;
        }
        function assignOwnDefaults(objectValue, sourceValue, key, object) {
          return (typeof objectValue == 'undefined' || !hasOwnProperty.call(object, key)) ? sourceValue : objectValue;
        }
        function baseAssign(object, source, customizer) {
          var props = keys(source);
          if (!customizer) {
            return baseCopy(source, object, props);
          }
          var index = -1,
              length = props.length;
          while (++index < length) {
            var key = props[index],
                value = object[key],
                result = customizer(value, source[key], key, object, source);
            if ((result === result ? result !== value : value === value) || (typeof value == 'undefined' && !(key in object))) {
              object[key] = result;
            }
          }
          return object;
        }
        function baseAt(collection, props) {
          var index = -1,
              length = collection.length,
              isArr = isLength(length),
              propsLength = props.length,
              result = Array(propsLength);
          while (++index < propsLength) {
            var key = props[index];
            if (isArr) {
              key = parseFloat(key);
              result[index] = isIndex(key, length) ? collection[key] : undefined;
            } else {
              result[index] = collection[key];
            }
          }
          return result;
        }
        function baseCopy(source, object, props) {
          if (!props) {
            props = object;
            object = {};
          }
          var index = -1,
              length = props.length;
          while (++index < length) {
            var key = props[index];
            object[key] = source[key];
          }
          return object;
        }
        function baseBindAll(object, methodNames) {
          var index = -1,
              length = methodNames.length;
          while (++index < length) {
            var key = methodNames[index];
            object[key] = createWrapper(object[key], BIND_FLAG, object);
          }
          return object;
        }
        function baseCallback(func, thisArg, argCount) {
          var type = typeof func;
          if (type == 'function') {
            return (typeof thisArg != 'undefined' && isBindable(func)) ? bindCallback(func, thisArg, argCount) : func;
          }
          if (func == null) {
            return identity;
          }
          if (type == 'object') {
            return baseMatches(func);
          }
          return typeof thisArg == 'undefined' ? baseProperty(func + '') : baseMatchesProperty(func + '', thisArg);
        }
        function baseClone(value, isDeep, customizer, key, object, stackA, stackB) {
          var result;
          if (customizer) {
            result = object ? customizer(value, key, object) : customizer(value);
          }
          if (typeof result != 'undefined') {
            return result;
          }
          if (!isObject(value)) {
            return value;
          }
          var isArr = isArray(value);
          if (isArr) {
            result = initCloneArray(value);
            if (!isDeep) {
              return arrayCopy(value, result);
            }
          } else {
            var tag = objToString.call(value),
                isFunc = tag == funcTag;
            if (tag == objectTag || tag == argsTag || (isFunc && !object)) {
              result = initCloneObject(isFunc ? {} : value);
              if (!isDeep) {
                return baseCopy(value, result, keys(value));
              }
            } else {
              return cloneableTags[tag] ? initCloneByTag(value, tag, isDeep) : (object ? value : {});
            }
          }
          stackA || (stackA = []);
          stackB || (stackB = []);
          var length = stackA.length;
          while (length--) {
            if (stackA[length] == value) {
              return stackB[length];
            }
          }
          stackA.push(value);
          stackB.push(result);
          (isArr ? arrayEach : baseForOwn)(value, function(subValue, key) {
            result[key] = baseClone(subValue, isDeep, customizer, key, value, stackA, stackB);
          });
          return result;
        }
        var baseCreate = (function() {
          function Object() {}
          return function(prototype) {
            if (isObject(prototype)) {
              Object.prototype = prototype;
              var result = new Object;
              Object.prototype = null;
            }
            return result || context.Object();
          };
        }());
        function baseDelay(func, wait, args, fromIndex) {
          if (typeof func != 'function') {
            throw new TypeError(FUNC_ERROR_TEXT);
          }
          return setTimeout(function() {
            func.apply(undefined, baseSlice(args, fromIndex));
          }, wait);
        }
        function baseDifference(array, values) {
          var length = array ? array.length : 0,
              result = [];
          if (!length) {
            return result;
          }
          var index = -1,
              indexOf = getIndexOf(),
              isCommon = indexOf == baseIndexOf,
              cache = (isCommon && values.length >= 200) ? createCache(values) : null,
              valuesLength = values.length;
          if (cache) {
            indexOf = cacheIndexOf;
            isCommon = false;
            values = cache;
          }
          outer: while (++index < length) {
            var value = array[index];
            if (isCommon && value === value) {
              var valuesIndex = valuesLength;
              while (valuesIndex--) {
                if (values[valuesIndex] === value) {
                  continue outer;
                }
              }
              result.push(value);
            } else if (indexOf(values, value) < 0) {
              result.push(value);
            }
          }
          return result;
        }
        function baseEach(collection, iteratee) {
          var length = collection ? collection.length : 0;
          if (!isLength(length)) {
            return baseForOwn(collection, iteratee);
          }
          var index = -1,
              iterable = toObject(collection);
          while (++index < length) {
            if (iteratee(iterable[index], index, iterable) === false) {
              break;
            }
          }
          return collection;
        }
        function baseEachRight(collection, iteratee) {
          var length = collection ? collection.length : 0;
          if (!isLength(length)) {
            return baseForOwnRight(collection, iteratee);
          }
          var iterable = toObject(collection);
          while (length--) {
            if (iteratee(iterable[length], length, iterable) === false) {
              break;
            }
          }
          return collection;
        }
        function baseEvery(collection, predicate) {
          var result = true;
          baseEach(collection, function(value, index, collection) {
            result = !!predicate(value, index, collection);
            return result;
          });
          return result;
        }
        function baseFill(array, value, start, end) {
          var length = array.length;
          start = start == null ? 0 : (+start || 0);
          if (start < 0) {
            start = -start > length ? 0 : (length + start);
          }
          end = (typeof end == 'undefined' || end > length) ? length : (+end || 0);
          if (end < 0) {
            end += length;
          }
          length = start > end ? 0 : end >>> 0;
          start >>>= 0;
          while (start < length) {
            array[start++] = value;
          }
          return array;
        }
        function baseFilter(collection, predicate) {
          var result = [];
          baseEach(collection, function(value, index, collection) {
            if (predicate(value, index, collection)) {
              result.push(value);
            }
          });
          return result;
        }
        function baseFind(collection, predicate, eachFunc, retKey) {
          var result;
          eachFunc(collection, function(value, key, collection) {
            if (predicate(value, key, collection)) {
              result = retKey ? key : value;
              return false;
            }
          });
          return result;
        }
        function baseFlatten(array, isDeep, isStrict, fromIndex) {
          var index = (fromIndex || 0) - 1,
              length = array.length,
              resIndex = -1,
              result = [];
          while (++index < length) {
            var value = array[index];
            if (isObjectLike(value) && isLength(value.length) && (isArray(value) || isArguments(value))) {
              if (isDeep) {
                value = baseFlatten(value, isDeep, isStrict);
              }
              var valIndex = -1,
                  valLength = value.length;
              result.length += valLength;
              while (++valIndex < valLength) {
                result[++resIndex] = value[valIndex];
              }
            } else if (!isStrict) {
              result[++resIndex] = value;
            }
          }
          return result;
        }
        function baseFor(object, iteratee, keysFunc) {
          var index = -1,
              iterable = toObject(object),
              props = keysFunc(object),
              length = props.length;
          while (++index < length) {
            var key = props[index];
            if (iteratee(iterable[key], key, iterable) === false) {
              break;
            }
          }
          return object;
        }
        function baseForRight(object, iteratee, keysFunc) {
          var iterable = toObject(object),
              props = keysFunc(object),
              length = props.length;
          while (length--) {
            var key = props[length];
            if (iteratee(iterable[key], key, iterable) === false) {
              break;
            }
          }
          return object;
        }
        function baseForIn(object, iteratee) {
          return baseFor(object, iteratee, keysIn);
        }
        function baseForOwn(object, iteratee) {
          return baseFor(object, iteratee, keys);
        }
        function baseForOwnRight(object, iteratee) {
          return baseForRight(object, iteratee, keys);
        }
        function baseFunctions(object, props) {
          var index = -1,
              length = props.length,
              resIndex = -1,
              result = [];
          while (++index < length) {
            var key = props[index];
            if (isFunction(object[key])) {
              result[++resIndex] = key;
            }
          }
          return result;
        }
        function baseInvoke(collection, methodName, args) {
          var index = -1,
              isFunc = typeof methodName == 'function',
              length = collection ? collection.length : 0,
              result = isLength(length) ? Array(length) : [];
          baseEach(collection, function(value) {
            var func = isFunc ? methodName : (value != null && value[methodName]);
            result[++index] = func ? func.apply(value, args) : undefined;
          });
          return result;
        }
        function baseIsEqual(value, other, customizer, isWhere, stackA, stackB) {
          if (value === other) {
            return value !== 0 || (1 / value == 1 / other);
          }
          var valType = typeof value,
              othType = typeof other;
          if ((valType != 'function' && valType != 'object' && othType != 'function' && othType != 'object') || value == null || other == null) {
            return value !== value && other !== other;
          }
          return baseIsEqualDeep(value, other, baseIsEqual, customizer, isWhere, stackA, stackB);
        }
        function baseIsEqualDeep(object, other, equalFunc, customizer, isWhere, stackA, stackB) {
          var objIsArr = isArray(object),
              othIsArr = isArray(other),
              objTag = arrayTag,
              othTag = arrayTag;
          if (!objIsArr) {
            objTag = objToString.call(object);
            if (objTag == argsTag) {
              objTag = objectTag;
            } else if (objTag != objectTag) {
              objIsArr = isTypedArray(object);
            }
          }
          if (!othIsArr) {
            othTag = objToString.call(other);
            if (othTag == argsTag) {
              othTag = objectTag;
            } else if (othTag != objectTag) {
              othIsArr = isTypedArray(other);
            }
          }
          var objIsObj = objTag == objectTag,
              othIsObj = othTag == objectTag,
              isSameTag = objTag == othTag;
          if (isSameTag && !(objIsArr || objIsObj)) {
            return equalByTag(object, other, objTag);
          }
          var valWrapped = objIsObj && hasOwnProperty.call(object, '__wrapped__'),
              othWrapped = othIsObj && hasOwnProperty.call(other, '__wrapped__');
          if (valWrapped || othWrapped) {
            return equalFunc(valWrapped ? object.value() : object, othWrapped ? other.value() : other, customizer, isWhere, stackA, stackB);
          }
          if (!isSameTag) {
            return false;
          }
          stackA || (stackA = []);
          stackB || (stackB = []);
          var length = stackA.length;
          while (length--) {
            if (stackA[length] == object) {
              return stackB[length] == other;
            }
          }
          stackA.push(object);
          stackB.push(other);
          var result = (objIsArr ? equalArrays : equalObjects)(object, other, equalFunc, customizer, isWhere, stackA, stackB);
          stackA.pop();
          stackB.pop();
          return result;
        }
        function baseIsMatch(object, props, values, strictCompareFlags, customizer) {
          var length = props.length;
          if (object == null) {
            return !length;
          }
          var index = -1,
              noCustomizer = !customizer;
          while (++index < length) {
            if ((noCustomizer && strictCompareFlags[index]) ? values[index] !== object[props[index]] : !hasOwnProperty.call(object, props[index])) {
              return false;
            }
          }
          index = -1;
          while (++index < length) {
            var key = props[index];
            if (noCustomizer && strictCompareFlags[index]) {
              var result = hasOwnProperty.call(object, key);
            } else {
              var objValue = object[key],
                  srcValue = values[index];
              result = customizer ? customizer(objValue, srcValue, key) : undefined;
              if (typeof result == 'undefined') {
                result = baseIsEqual(srcValue, objValue, customizer, true);
              }
            }
            if (!result) {
              return false;
            }
          }
          return true;
        }
        function baseMap(collection, iteratee) {
          var result = [];
          baseEach(collection, function(value, key, collection) {
            result.push(iteratee(value, key, collection));
          });
          return result;
        }
        function baseMatches(source) {
          var props = keys(source),
              length = props.length;
          if (length == 1) {
            var key = props[0],
                value = source[key];
            if (isStrictComparable(value)) {
              return function(object) {
                return object != null && object[key] === value && hasOwnProperty.call(object, key);
              };
            }
          }
          var values = Array(length),
              strictCompareFlags = Array(length);
          while (length--) {
            value = source[props[length]];
            values[length] = value;
            strictCompareFlags[length] = isStrictComparable(value);
          }
          return function(object) {
            return baseIsMatch(object, props, values, strictCompareFlags);
          };
        }
        function baseMatchesProperty(key, value) {
          if (isStrictComparable(value)) {
            return function(object) {
              return object != null && object[key] === value;
            };
          }
          return function(object) {
            return object != null && baseIsEqual(value, object[key], null, true);
          };
        }
        function baseMerge(object, source, customizer, stackA, stackB) {
          if (!isObject(object)) {
            return object;
          }
          var isSrcArr = isLength(source.length) && (isArray(source) || isTypedArray(source));
          (isSrcArr ? arrayEach : baseForOwn)(source, function(srcValue, key, source) {
            if (isObjectLike(srcValue)) {
              stackA || (stackA = []);
              stackB || (stackB = []);
              return baseMergeDeep(object, source, key, baseMerge, customizer, stackA, stackB);
            }
            var value = object[key],
                result = customizer ? customizer(value, srcValue, key, object, source) : undefined,
                isCommon = typeof result == 'undefined';
            if (isCommon) {
              result = srcValue;
            }
            if ((isSrcArr || typeof result != 'undefined') && (isCommon || (result === result ? result !== value : value === value))) {
              object[key] = result;
            }
          });
          return object;
        }
        function baseMergeDeep(object, source, key, mergeFunc, customizer, stackA, stackB) {
          var length = stackA.length,
              srcValue = source[key];
          while (length--) {
            if (stackA[length] == srcValue) {
              object[key] = stackB[length];
              return ;
            }
          }
          var value = object[key],
              result = customizer ? customizer(value, srcValue, key, object, source) : undefined,
              isCommon = typeof result == 'undefined';
          if (isCommon) {
            result = srcValue;
            if (isLength(srcValue.length) && (isArray(srcValue) || isTypedArray(srcValue))) {
              result = isArray(value) ? value : (value ? arrayCopy(value) : []);
            } else if (isPlainObject(srcValue) || isArguments(srcValue)) {
              result = isArguments(value) ? toPlainObject(value) : (isPlainObject(value) ? value : {});
            } else {
              isCommon = false;
            }
          }
          stackA.push(srcValue);
          stackB.push(result);
          if (isCommon) {
            object[key] = mergeFunc(result, srcValue, customizer, stackA, stackB);
          } else if (result === result ? result !== value : value === value) {
            object[key] = result;
          }
        }
        function baseProperty(key) {
          return function(object) {
            return object == null ? undefined : object[key];
          };
        }
        function basePullAt(array, indexes) {
          var length = indexes.length,
              result = baseAt(array, indexes);
          indexes.sort(baseCompareAscending);
          while (length--) {
            var index = parseFloat(indexes[length]);
            if (index != previous && isIndex(index)) {
              var previous = index;
              splice.call(array, index, 1);
            }
          }
          return result;
        }
        function baseRandom(min, max) {
          return min + floor(nativeRandom() * (max - min + 1));
        }
        function baseReduce(collection, iteratee, accumulator, initFromCollection, eachFunc) {
          eachFunc(collection, function(value, index, collection) {
            accumulator = initFromCollection ? (initFromCollection = false, value) : iteratee(accumulator, value, index, collection);
          });
          return accumulator;
        }
        var baseSetData = !metaMap ? identity : function(func, data) {
          metaMap.set(func, data);
          return func;
        };
        function baseSlice(array, start, end) {
          var index = -1,
              length = array.length;
          start = start == null ? 0 : (+start || 0);
          if (start < 0) {
            start = -start > length ? 0 : (length + start);
          }
          end = (typeof end == 'undefined' || end > length) ? length : (+end || 0);
          if (end < 0) {
            end += length;
          }
          length = start > end ? 0 : (end - start) >>> 0;
          start >>>= 0;
          var result = Array(length);
          while (++index < length) {
            result[index] = array[index + start];
          }
          return result;
        }
        function baseSome(collection, predicate) {
          var result;
          baseEach(collection, function(value, index, collection) {
            result = predicate(value, index, collection);
            return !result;
          });
          return !!result;
        }
        function baseUniq(array, iteratee) {
          var index = -1,
              indexOf = getIndexOf(),
              length = array.length,
              isCommon = indexOf == baseIndexOf,
              isLarge = isCommon && length >= 200,
              seen = isLarge ? createCache() : null,
              result = [];
          if (seen) {
            indexOf = cacheIndexOf;
            isCommon = false;
          } else {
            isLarge = false;
            seen = iteratee ? [] : result;
          }
          outer: while (++index < length) {
            var value = array[index],
                computed = iteratee ? iteratee(value, index, array) : value;
            if (isCommon && value === value) {
              var seenIndex = seen.length;
              while (seenIndex--) {
                if (seen[seenIndex] === computed) {
                  continue outer;
                }
              }
              if (iteratee) {
                seen.push(computed);
              }
              result.push(value);
            } else if (indexOf(seen, computed) < 0) {
              if (iteratee || isLarge) {
                seen.push(computed);
              }
              result.push(value);
            }
          }
          return result;
        }
        function baseValues(object, props) {
          var index = -1,
              length = props.length,
              result = Array(length);
          while (++index < length) {
            result[index] = object[props[index]];
          }
          return result;
        }
        function baseWrapperValue(value, actions) {
          var result = value;
          if (result instanceof LazyWrapper) {
            result = result.value();
          }
          var index = -1,
              length = actions.length;
          while (++index < length) {
            var args = [result],
                action = actions[index];
            push.apply(args, action.args);
            result = action.func.apply(action.thisArg, args);
          }
          return result;
        }
        function binaryIndex(array, value, retHighest) {
          var low = 0,
              high = array ? array.length : low;
          if (typeof value == 'number' && value === value && high <= HALF_MAX_ARRAY_LENGTH) {
            while (low < high) {
              var mid = (low + high) >>> 1,
                  computed = array[mid];
              if (retHighest ? (computed <= value) : (computed < value)) {
                low = mid + 1;
              } else {
                high = mid;
              }
            }
            return high;
          }
          return binaryIndexBy(array, value, identity, retHighest);
        }
        function binaryIndexBy(array, value, iteratee, retHighest) {
          value = iteratee(value);
          var low = 0,
              high = array ? array.length : 0,
              valIsNaN = value !== value,
              valIsUndef = typeof value == 'undefined';
          while (low < high) {
            var mid = floor((low + high) / 2),
                computed = iteratee(array[mid]),
                isReflexive = computed === computed;
            if (valIsNaN) {
              var setLow = isReflexive || retHighest;
            } else if (valIsUndef) {
              setLow = isReflexive && (retHighest || typeof computed != 'undefined');
            } else {
              setLow = retHighest ? (computed <= value) : (computed < value);
            }
            if (setLow) {
              low = mid + 1;
            } else {
              high = mid;
            }
          }
          return nativeMin(high, MAX_ARRAY_INDEX);
        }
        function bindCallback(func, thisArg, argCount) {
          if (typeof func != 'function') {
            return identity;
          }
          if (typeof thisArg == 'undefined') {
            return func;
          }
          switch (argCount) {
            case 1:
              return function(value) {
                return func.call(thisArg, value);
              };
            case 3:
              return function(value, index, collection) {
                return func.call(thisArg, value, index, collection);
              };
            case 4:
              return function(accumulator, value, index, collection) {
                return func.call(thisArg, accumulator, value, index, collection);
              };
            case 5:
              return function(value, other, key, object, source) {
                return func.call(thisArg, value, other, key, object, source);
              };
          }
          return function() {
            return func.apply(thisArg, arguments);
          };
        }
        function bufferClone(buffer) {
          return bufferSlice.call(buffer, 0);
        }
        if (!bufferSlice) {
          bufferClone = !(ArrayBuffer && Uint8Array) ? constant(null) : function(buffer) {
            var byteLength = buffer.byteLength,
                floatLength = Float64Array ? floor(byteLength / FLOAT64_BYTES_PER_ELEMENT) : 0,
                offset = floatLength * FLOAT64_BYTES_PER_ELEMENT,
                result = new ArrayBuffer(byteLength);
            if (floatLength) {
              var view = new Float64Array(result, 0, floatLength);
              view.set(new Float64Array(buffer, 0, floatLength));
            }
            if (byteLength != offset) {
              view = new Uint8Array(result, offset);
              view.set(new Uint8Array(buffer, offset));
            }
            return result;
          };
        }
        function composeArgs(args, partials, holders) {
          var holdersLength = holders.length,
              argsIndex = -1,
              argsLength = nativeMax(args.length - holdersLength, 0),
              leftIndex = -1,
              leftLength = partials.length,
              result = Array(argsLength + leftLength);
          while (++leftIndex < leftLength) {
            result[leftIndex] = partials[leftIndex];
          }
          while (++argsIndex < holdersLength) {
            result[holders[argsIndex]] = args[argsIndex];
          }
          while (argsLength--) {
            result[leftIndex++] = args[argsIndex++];
          }
          return result;
        }
        function composeArgsRight(args, partials, holders) {
          var holdersIndex = -1,
              holdersLength = holders.length,
              argsIndex = -1,
              argsLength = nativeMax(args.length - holdersLength, 0),
              rightIndex = -1,
              rightLength = partials.length,
              result = Array(argsLength + rightLength);
          while (++argsIndex < argsLength) {
            result[argsIndex] = args[argsIndex];
          }
          var pad = argsIndex;
          while (++rightIndex < rightLength) {
            result[pad + rightIndex] = partials[rightIndex];
          }
          while (++holdersIndex < holdersLength) {
            result[pad + holders[holdersIndex]] = args[argsIndex++];
          }
          return result;
        }
        function createAggregator(setter, initializer) {
          return function(collection, iteratee, thisArg) {
            var result = initializer ? initializer() : {};
            iteratee = getCallback(iteratee, thisArg, 3);
            if (isArray(collection)) {
              var index = -1,
                  length = collection.length;
              while (++index < length) {
                var value = collection[index];
                setter(result, value, iteratee(value, index, collection), collection);
              }
            } else {
              baseEach(collection, function(value, key, collection) {
                setter(result, value, iteratee(value, key, collection), collection);
              });
            }
            return result;
          };
        }
        function createAssigner(assigner) {
          return function() {
            var length = arguments.length,
                object = arguments[0];
            if (length < 2 || object == null) {
              return object;
            }
            if (length > 3 && isIterateeCall(arguments[1], arguments[2], arguments[3])) {
              length = 2;
            }
            if (length > 3 && typeof arguments[length - 2] == 'function') {
              var customizer = bindCallback(arguments[--length - 1], arguments[length--], 5);
            } else if (length > 2 && typeof arguments[length - 1] == 'function') {
              customizer = arguments[--length];
            }
            var index = 0;
            while (++index < length) {
              var source = arguments[index];
              if (source) {
                assigner(object, source, customizer);
              }
            }
            return object;
          };
        }
        function createBindWrapper(func, thisArg) {
          var Ctor = createCtorWrapper(func);
          function wrapper() {
            return (this instanceof wrapper ? Ctor : func).apply(thisArg, arguments);
          }
          return wrapper;
        }
        var createCache = !(nativeCreate && Set) ? constant(null) : function(values) {
          return new SetCache(values);
        };
        function createCompounder(callback) {
          return function(string) {
            var index = -1,
                array = words(deburr(string)),
                length = array.length,
                result = '';
            while (++index < length) {
              result = callback(result, array[index], index);
            }
            return result;
          };
        }
        function createCtorWrapper(Ctor) {
          return function() {
            var thisBinding = baseCreate(Ctor.prototype),
                result = Ctor.apply(thisBinding, arguments);
            return isObject(result) ? result : thisBinding;
          };
        }
        function createExtremum(arrayFunc, isMin) {
          return function(collection, iteratee, thisArg) {
            if (thisArg && isIterateeCall(collection, iteratee, thisArg)) {
              iteratee = null;
            }
            var func = getCallback(),
                noIteratee = iteratee == null;
            if (!(func === baseCallback && noIteratee)) {
              noIteratee = false;
              iteratee = func(iteratee, thisArg, 3);
            }
            if (noIteratee) {
              var isArr = isArray(collection);
              if (!isArr && isString(collection)) {
                iteratee = charAtCallback;
              } else {
                return arrayFunc(isArr ? collection : toIterable(collection));
              }
            }
            return extremumBy(collection, iteratee, isMin);
          };
        }
        function createHybridWrapper(func, bitmask, thisArg, partials, holders, partialsRight, holdersRight, argPos, ary, arity) {
          var isAry = bitmask & ARY_FLAG,
              isBind = bitmask & BIND_FLAG,
              isBindKey = bitmask & BIND_KEY_FLAG,
              isCurry = bitmask & CURRY_FLAG,
              isCurryBound = bitmask & CURRY_BOUND_FLAG,
              isCurryRight = bitmask & CURRY_RIGHT_FLAG;
          var Ctor = !isBindKey && createCtorWrapper(func),
              key = func;
          function wrapper() {
            var length = arguments.length,
                index = length,
                args = Array(length);
            while (index--) {
              args[index] = arguments[index];
            }
            if (partials) {
              args = composeArgs(args, partials, holders);
            }
            if (partialsRight) {
              args = composeArgsRight(args, partialsRight, holdersRight);
            }
            if (isCurry || isCurryRight) {
              var placeholder = wrapper.placeholder,
                  argsHolders = replaceHolders(args, placeholder);
              length -= argsHolders.length;
              if (length < arity) {
                var newArgPos = argPos ? arrayCopy(argPos) : null,
                    newArity = nativeMax(arity - length, 0),
                    newsHolders = isCurry ? argsHolders : null,
                    newHoldersRight = isCurry ? null : argsHolders,
                    newPartials = isCurry ? args : null,
                    newPartialsRight = isCurry ? null : args;
                bitmask |= (isCurry ? PARTIAL_FLAG : PARTIAL_RIGHT_FLAG);
                bitmask &= ~(isCurry ? PARTIAL_RIGHT_FLAG : PARTIAL_FLAG);
                if (!isCurryBound) {
                  bitmask &= ~(BIND_FLAG | BIND_KEY_FLAG);
                }
                var result = createHybridWrapper(func, bitmask, thisArg, newPartials, newsHolders, newPartialsRight, newHoldersRight, newArgPos, ary, newArity);
                result.placeholder = placeholder;
                return result;
              }
            }
            var thisBinding = isBind ? thisArg : this;
            if (isBindKey) {
              func = thisBinding[key];
            }
            if (argPos) {
              args = reorder(args, argPos);
            }
            if (isAry && ary < args.length) {
              args.length = ary;
            }
            return (this instanceof wrapper ? (Ctor || createCtorWrapper(func)) : func).apply(thisBinding, args);
          }
          return wrapper;
        }
        function createPad(string, length, chars) {
          var strLength = string.length;
          length = +length;
          if (strLength >= length || !nativeIsFinite(length)) {
            return '';
          }
          var padLength = length - strLength;
          chars = chars == null ? ' ' : (chars + '');
          return repeat(chars, ceil(padLength / chars.length)).slice(0, padLength);
        }
        function createPartialWrapper(func, bitmask, thisArg, partials) {
          var isBind = bitmask & BIND_FLAG,
              Ctor = createCtorWrapper(func);
          function wrapper() {
            var argsIndex = -1,
                argsLength = arguments.length,
                leftIndex = -1,
                leftLength = partials.length,
                args = Array(argsLength + leftLength);
            while (++leftIndex < leftLength) {
              args[leftIndex] = partials[leftIndex];
            }
            while (argsLength--) {
              args[leftIndex++] = arguments[++argsIndex];
            }
            return (this instanceof wrapper ? Ctor : func).apply(isBind ? thisArg : this, args);
          }
          return wrapper;
        }
        function createWrapper(func, bitmask, thisArg, partials, holders, argPos, ary, arity) {
          var isBindKey = bitmask & BIND_KEY_FLAG;
          if (!isBindKey && typeof func != 'function') {
            throw new TypeError(FUNC_ERROR_TEXT);
          }
          var length = partials ? partials.length : 0;
          if (!length) {
            bitmask &= ~(PARTIAL_FLAG | PARTIAL_RIGHT_FLAG);
            partials = holders = null;
          }
          length -= (holders ? holders.length : 0);
          if (bitmask & PARTIAL_RIGHT_FLAG) {
            var partialsRight = partials,
                holdersRight = holders;
            partials = holders = null;
          }
          var data = !isBindKey && getData(func),
              newData = [func, bitmask, thisArg, partials, holders, partialsRight, holdersRight, argPos, ary, arity];
          if (data && data !== true) {
            mergeData(newData, data);
            bitmask = newData[1];
            arity = newData[9];
          }
          newData[9] = arity == null ? (isBindKey ? 0 : func.length) : (nativeMax(arity - length, 0) || 0);
          if (bitmask == BIND_FLAG) {
            var result = createBindWrapper(newData[0], newData[2]);
          } else if ((bitmask == PARTIAL_FLAG || bitmask == (BIND_FLAG | PARTIAL_FLAG)) && !newData[4].length) {
            result = createPartialWrapper.apply(undefined, newData);
          } else {
            result = createHybridWrapper.apply(undefined, newData);
          }
          var setter = data ? baseSetData : setData;
          return setter(result, newData);
        }
        function equalArrays(array, other, equalFunc, customizer, isWhere, stackA, stackB) {
          var index = -1,
              arrLength = array.length,
              othLength = other.length,
              result = true;
          if (arrLength != othLength && !(isWhere && othLength > arrLength)) {
            return false;
          }
          while (result && ++index < arrLength) {
            var arrValue = array[index],
                othValue = other[index];
            result = undefined;
            if (customizer) {
              result = isWhere ? customizer(othValue, arrValue, index) : customizer(arrValue, othValue, index);
            }
            if (typeof result == 'undefined') {
              if (isWhere) {
                var othIndex = othLength;
                while (othIndex--) {
                  othValue = other[othIndex];
                  result = (arrValue && arrValue === othValue) || equalFunc(arrValue, othValue, customizer, isWhere, stackA, stackB);
                  if (result) {
                    break;
                  }
                }
              } else {
                result = (arrValue && arrValue === othValue) || equalFunc(arrValue, othValue, customizer, isWhere, stackA, stackB);
              }
            }
          }
          return !!result;
        }
        function equalByTag(object, other, tag) {
          switch (tag) {
            case boolTag:
            case dateTag:
              return +object == +other;
            case errorTag:
              return object.name == other.name && object.message == other.message;
            case numberTag:
              return (object != +object) ? other != +other : (object == 0 ? ((1 / object) == (1 / other)) : object == +other);
            case regexpTag:
            case stringTag:
              return object == (other + '');
          }
          return false;
        }
        function equalObjects(object, other, equalFunc, customizer, isWhere, stackA, stackB) {
          var objProps = keys(object),
              objLength = objProps.length,
              othProps = keys(other),
              othLength = othProps.length;
          if (objLength != othLength && !isWhere) {
            return false;
          }
          var hasCtor,
              index = -1;
          while (++index < objLength) {
            var key = objProps[index],
                result = hasOwnProperty.call(other, key);
            if (result) {
              var objValue = object[key],
                  othValue = other[key];
              result = undefined;
              if (customizer) {
                result = isWhere ? customizer(othValue, objValue, key) : customizer(objValue, othValue, key);
              }
              if (typeof result == 'undefined') {
                result = (objValue && objValue === othValue) || equalFunc(objValue, othValue, customizer, isWhere, stackA, stackB);
              }
            }
            if (!result) {
              return false;
            }
            hasCtor || (hasCtor = key == 'constructor');
          }
          if (!hasCtor) {
            var objCtor = object.constructor,
                othCtor = other.constructor;
            if (objCtor != othCtor && ('constructor' in object && 'constructor' in other) && !(typeof objCtor == 'function' && objCtor instanceof objCtor && typeof othCtor == 'function' && othCtor instanceof othCtor)) {
              return false;
            }
          }
          return true;
        }
        function extremumBy(collection, iteratee, isMin) {
          var exValue = isMin ? POSITIVE_INFINITY : NEGATIVE_INFINITY,
              computed = exValue,
              result = computed;
          baseEach(collection, function(value, index, collection) {
            var current = iteratee(value, index, collection);
            if ((isMin ? current < computed : current > computed) || (current === exValue && current === result)) {
              computed = current;
              result = value;
            }
          });
          return result;
        }
        function getCallback(func, thisArg, argCount) {
          var result = lodash.callback || callback;
          result = result === callback ? baseCallback : result;
          return argCount ? result(func, thisArg, argCount) : result;
        }
        var getData = !metaMap ? noop : function(func) {
          return metaMap.get(func);
        };
        function getIndexOf(collection, target, fromIndex) {
          var result = lodash.indexOf || indexOf;
          result = result === indexOf ? baseIndexOf : result;
          return collection ? result(collection, target, fromIndex) : result;
        }
        function getView(start, end, transforms) {
          var index = -1,
              length = transforms ? transforms.length : 0;
          while (++index < length) {
            var data = transforms[index],
                size = data.size;
            switch (data.type) {
              case 'drop':
                start += size;
                break;
              case 'dropRight':
                end -= size;
                break;
              case 'take':
                end = nativeMin(end, start + size);
                break;
              case 'takeRight':
                start = nativeMax(start, end - size);
                break;
            }
          }
          return {
            'start': start,
            'end': end
          };
        }
        function initCloneArray(array) {
          var length = array.length,
              result = new array.constructor(length);
          if (length && typeof array[0] == 'string' && hasOwnProperty.call(array, 'index')) {
            result.index = array.index;
            result.input = array.input;
          }
          return result;
        }
        function initCloneObject(object) {
          var Ctor = object.constructor;
          if (!(typeof Ctor == 'function' && Ctor instanceof Ctor)) {
            Ctor = Object;
          }
          return new Ctor;
        }
        function initCloneByTag(object, tag, isDeep) {
          var Ctor = object.constructor;
          switch (tag) {
            case arrayBufferTag:
              return bufferClone(object);
            case boolTag:
            case dateTag:
              return new Ctor(+object);
            case float32Tag:
            case float64Tag:
            case int8Tag:
            case int16Tag:
            case int32Tag:
            case uint8Tag:
            case uint8ClampedTag:
            case uint16Tag:
            case uint32Tag:
              var buffer = object.buffer;
              return new Ctor(isDeep ? bufferClone(buffer) : buffer, object.byteOffset, object.length);
            case numberTag:
            case stringTag:
              return new Ctor(object);
            case regexpTag:
              var result = new Ctor(object.source, reFlags.exec(object));
              result.lastIndex = object.lastIndex;
          }
          return result;
        }
        function isBindable(func) {
          var support = lodash.support,
              result = !(support.funcNames ? func.name : support.funcDecomp);
          if (!result) {
            var source = fnToString.call(func);
            if (!support.funcNames) {
              result = !reFuncName.test(source);
            }
            if (!result) {
              result = reThis.test(source) || isNative(func);
              baseSetData(func, result);
            }
          }
          return result;
        }
        function isIndex(value, length) {
          value = +value;
          length = length == null ? MAX_SAFE_INTEGER : length;
          return value > -1 && value % 1 == 0 && value < length;
        }
        function isIterateeCall(value, index, object) {
          if (!isObject(object)) {
            return false;
          }
          var type = typeof index;
          if (type == 'number') {
            var length = object.length,
                prereq = isLength(length) && isIndex(index, length);
          } else {
            prereq = type == 'string' && index in object;
          }
          if (prereq) {
            var other = object[index];
            return value === value ? value === other : other !== other;
          }
          return false;
        }
        function isLength(value) {
          return typeof value == 'number' && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
        }
        function isStrictComparable(value) {
          return value === value && (value === 0 ? ((1 / value) > 0) : !isObject(value));
        }
        function mergeData(data, source) {
          var bitmask = data[1],
              srcBitmask = source[1],
              newBitmask = bitmask | srcBitmask;
          var arityFlags = ARY_FLAG | REARG_FLAG,
              bindFlags = BIND_FLAG | BIND_KEY_FLAG,
              comboFlags = arityFlags | bindFlags | CURRY_BOUND_FLAG | CURRY_RIGHT_FLAG;
          var isAry = bitmask & ARY_FLAG && !(srcBitmask & ARY_FLAG),
              isRearg = bitmask & REARG_FLAG && !(srcBitmask & REARG_FLAG),
              argPos = (isRearg ? data : source)[7],
              ary = (isAry ? data : source)[8];
          var isCommon = !(bitmask >= REARG_FLAG && srcBitmask > bindFlags) && !(bitmask > bindFlags && srcBitmask >= REARG_FLAG);
          var isCombo = (newBitmask >= arityFlags && newBitmask <= comboFlags) && (bitmask < REARG_FLAG || ((isRearg || isAry) && argPos.length <= ary));
          if (!(isCommon || isCombo)) {
            return data;
          }
          if (srcBitmask & BIND_FLAG) {
            data[2] = source[2];
            newBitmask |= (bitmask & BIND_FLAG) ? 0 : CURRY_BOUND_FLAG;
          }
          var value = source[3];
          if (value) {
            var partials = data[3];
            data[3] = partials ? composeArgs(partials, value, source[4]) : arrayCopy(value);
            data[4] = partials ? replaceHolders(data[3], PLACEHOLDER) : arrayCopy(source[4]);
          }
          value = source[5];
          if (value) {
            partials = data[5];
            data[5] = partials ? composeArgsRight(partials, value, source[6]) : arrayCopy(value);
            data[6] = partials ? replaceHolders(data[5], PLACEHOLDER) : arrayCopy(source[6]);
          }
          value = source[7];
          if (value) {
            data[7] = arrayCopy(value);
          }
          if (srcBitmask & ARY_FLAG) {
            data[8] = data[8] == null ? source[8] : nativeMin(data[8], source[8]);
          }
          if (data[9] == null) {
            data[9] = source[9];
          }
          data[0] = source[0];
          data[1] = newBitmask;
          return data;
        }
        function pickByArray(object, props) {
          object = toObject(object);
          var index = -1,
              length = props.length,
              result = {};
          while (++index < length) {
            var key = props[index];
            if (key in object) {
              result[key] = object[key];
            }
          }
          return result;
        }
        function pickByCallback(object, predicate) {
          var result = {};
          baseForIn(object, function(value, key, object) {
            if (predicate(value, key, object)) {
              result[key] = value;
            }
          });
          return result;
        }
        function reorder(array, indexes) {
          var arrLength = array.length,
              length = nativeMin(indexes.length, arrLength),
              oldArray = arrayCopy(array);
          while (length--) {
            var index = indexes[length];
            array[length] = isIndex(index, arrLength) ? oldArray[index] : undefined;
          }
          return array;
        }
        var setData = (function() {
          var count = 0,
              lastCalled = 0;
          return function(key, value) {
            var stamp = now(),
                remaining = HOT_SPAN - (stamp - lastCalled);
            lastCalled = stamp;
            if (remaining > 0) {
              if (++count >= HOT_COUNT) {
                return key;
              }
            } else {
              count = 0;
            }
            return baseSetData(key, value);
          };
        }());
        function shimIsPlainObject(value) {
          var Ctor,
              support = lodash.support;
          if (!(isObjectLike(value) && objToString.call(value) == objectTag) || (!hasOwnProperty.call(value, 'constructor') && (Ctor = value.constructor, typeof Ctor == 'function' && !(Ctor instanceof Ctor)))) {
            return false;
          }
          var result;
          baseForIn(value, function(subValue, key) {
            result = key;
          });
          return typeof result == 'undefined' || hasOwnProperty.call(value, result);
        }
        function shimKeys(object) {
          var props = keysIn(object),
              propsLength = props.length,
              length = propsLength && object.length,
              support = lodash.support;
          var allowIndexes = length && isLength(length) && (isArray(object) || (support.nonEnumArgs && isArguments(object)));
          var index = -1,
              result = [];
          while (++index < propsLength) {
            var key = props[index];
            if ((allowIndexes && isIndex(key, length)) || hasOwnProperty.call(object, key)) {
              result.push(key);
            }
          }
          return result;
        }
        function toIterable(value) {
          if (value == null) {
            return [];
          }
          if (!isLength(value.length)) {
            return values(value);
          }
          return isObject(value) ? value : Object(value);
        }
        function toObject(value) {
          return isObject(value) ? value : Object(value);
        }
        function wrapperClone(wrapper) {
          return wrapper instanceof LazyWrapper ? wrapper.clone() : new LodashWrapper(wrapper.__wrapped__, wrapper.__chain__, arrayCopy(wrapper.__actions__));
        }
        function chunk(array, size, guard) {
          if (guard ? isIterateeCall(array, size, guard) : size == null) {
            size = 1;
          } else {
            size = nativeMax(+size || 1, 1);
          }
          var index = 0,
              length = array ? array.length : 0,
              resIndex = -1,
              result = Array(ceil(length / size));
          while (index < length) {
            result[++resIndex] = baseSlice(array, index, (index += size));
          }
          return result;
        }
        function compact(array) {
          var index = -1,
              length = array ? array.length : 0,
              resIndex = -1,
              result = [];
          while (++index < length) {
            var value = array[index];
            if (value) {
              result[++resIndex] = value;
            }
          }
          return result;
        }
        function difference() {
          var index = -1,
              length = arguments.length;
          while (++index < length) {
            var value = arguments[index];
            if (isArray(value) || isArguments(value)) {
              break;
            }
          }
          return baseDifference(value, baseFlatten(arguments, false, true, ++index));
        }
        function drop(array, n, guard) {
          var length = array ? array.length : 0;
          if (!length) {
            return [];
          }
          if (guard ? isIterateeCall(array, n, guard) : n == null) {
            n = 1;
          }
          return baseSlice(array, n < 0 ? 0 : n);
        }
        function dropRight(array, n, guard) {
          var length = array ? array.length : 0;
          if (!length) {
            return [];
          }
          if (guard ? isIterateeCall(array, n, guard) : n == null) {
            n = 1;
          }
          n = length - (+n || 0);
          return baseSlice(array, 0, n < 0 ? 0 : n);
        }
        function dropRightWhile(array, predicate, thisArg) {
          var length = array ? array.length : 0;
          if (!length) {
            return [];
          }
          predicate = getCallback(predicate, thisArg, 3);
          while (length-- && predicate(array[length], length, array)) {}
          return baseSlice(array, 0, length + 1);
        }
        function dropWhile(array, predicate, thisArg) {
          var length = array ? array.length : 0;
          if (!length) {
            return [];
          }
          var index = -1;
          predicate = getCallback(predicate, thisArg, 3);
          while (++index < length && predicate(array[index], index, array)) {}
          return baseSlice(array, index);
        }
        function fill(array, value, start, end) {
          var length = array ? array.length : 0;
          if (!length) {
            return [];
          }
          if (start && typeof start != 'number' && isIterateeCall(array, value, start)) {
            start = 0;
            end = length;
          }
          return baseFill(array, value, start, end);
        }
        function findIndex(array, predicate, thisArg) {
          var index = -1,
              length = array ? array.length : 0;
          predicate = getCallback(predicate, thisArg, 3);
          while (++index < length) {
            if (predicate(array[index], index, array)) {
              return index;
            }
          }
          return -1;
        }
        function findLastIndex(array, predicate, thisArg) {
          var length = array ? array.length : 0;
          predicate = getCallback(predicate, thisArg, 3);
          while (length--) {
            if (predicate(array[length], length, array)) {
              return length;
            }
          }
          return -1;
        }
        function first(array) {
          return array ? array[0] : undefined;
        }
        function flatten(array, isDeep, guard) {
          var length = array ? array.length : 0;
          if (guard && isIterateeCall(array, isDeep, guard)) {
            isDeep = false;
          }
          return length ? baseFlatten(array, isDeep) : [];
        }
        function flattenDeep(array) {
          var length = array ? array.length : 0;
          return length ? baseFlatten(array, true) : [];
        }
        function indexOf(array, value, fromIndex) {
          var length = array ? array.length : 0;
          if (!length) {
            return -1;
          }
          if (typeof fromIndex == 'number') {
            fromIndex = fromIndex < 0 ? nativeMax(length + fromIndex, 0) : (fromIndex || 0);
          } else if (fromIndex) {
            var index = binaryIndex(array, value),
                other = array[index];
            return (value === value ? value === other : other !== other) ? index : -1;
          }
          return baseIndexOf(array, value, fromIndex);
        }
        function initial(array) {
          return dropRight(array, 1);
        }
        function intersection() {
          var args = [],
              argsIndex = -1,
              argsLength = arguments.length,
              caches = [],
              indexOf = getIndexOf(),
              isCommon = indexOf == baseIndexOf;
          while (++argsIndex < argsLength) {
            var value = arguments[argsIndex];
            if (isArray(value) || isArguments(value)) {
              args.push(value);
              caches.push((isCommon && value.length >= 120) ? createCache(argsIndex && value) : null);
            }
          }
          argsLength = args.length;
          var array = args[0],
              index = -1,
              length = array ? array.length : 0,
              result = [],
              seen = caches[0];
          outer: while (++index < length) {
            value = array[index];
            if ((seen ? cacheIndexOf(seen, value) : indexOf(result, value)) < 0) {
              argsIndex = argsLength;
              while (--argsIndex) {
                var cache = caches[argsIndex];
                if ((cache ? cacheIndexOf(cache, value) : indexOf(args[argsIndex], value)) < 0) {
                  continue outer;
                }
              }
              if (seen) {
                seen.push(value);
              }
              result.push(value);
            }
          }
          return result;
        }
        function last(array) {
          var length = array ? array.length : 0;
          return length ? array[length - 1] : undefined;
        }
        function lastIndexOf(array, value, fromIndex) {
          var length = array ? array.length : 0;
          if (!length) {
            return -1;
          }
          var index = length;
          if (typeof fromIndex == 'number') {
            index = (fromIndex < 0 ? nativeMax(length + fromIndex, 0) : nativeMin(fromIndex || 0, length - 1)) + 1;
          } else if (fromIndex) {
            index = binaryIndex(array, value, true) - 1;
            var other = array[index];
            return (value === value ? value === other : other !== other) ? index : -1;
          }
          if (value !== value) {
            return indexOfNaN(array, index, true);
          }
          while (index--) {
            if (array[index] === value) {
              return index;
            }
          }
          return -1;
        }
        function pull() {
          var array = arguments[0];
          if (!(array && array.length)) {
            return array;
          }
          var index = 0,
              indexOf = getIndexOf(),
              length = arguments.length;
          while (++index < length) {
            var fromIndex = 0,
                value = arguments[index];
            while ((fromIndex = indexOf(array, value, fromIndex)) > -1) {
              splice.call(array, fromIndex, 1);
            }
          }
          return array;
        }
        function pullAt(array) {
          return basePullAt(array || [], baseFlatten(arguments, false, false, 1));
        }
        function remove(array, predicate, thisArg) {
          var index = -1,
              length = array ? array.length : 0,
              result = [];
          predicate = getCallback(predicate, thisArg, 3);
          while (++index < length) {
            var value = array[index];
            if (predicate(value, index, array)) {
              result.push(value);
              splice.call(array, index--, 1);
              length--;
            }
          }
          return result;
        }
        function rest(array) {
          return drop(array, 1);
        }
        function slice(array, start, end) {
          var length = array ? array.length : 0;
          if (!length) {
            return [];
          }
          if (end && typeof end != 'number' && isIterateeCall(array, start, end)) {
            start = 0;
            end = length;
          }
          return baseSlice(array, start, end);
        }
        function sortedIndex(array, value, iteratee, thisArg) {
          var func = getCallback(iteratee);
          return (func === baseCallback && iteratee == null) ? binaryIndex(array, value) : binaryIndexBy(array, value, func(iteratee, thisArg, 1));
        }
        function sortedLastIndex(array, value, iteratee, thisArg) {
          var func = getCallback(iteratee);
          return (func === baseCallback && iteratee == null) ? binaryIndex(array, value, true) : binaryIndexBy(array, value, func(iteratee, thisArg, 1), true);
        }
        function take(array, n, guard) {
          var length = array ? array.length : 0;
          if (!length) {
            return [];
          }
          if (guard ? isIterateeCall(array, n, guard) : n == null) {
            n = 1;
          }
          return baseSlice(array, 0, n < 0 ? 0 : n);
        }
        function takeRight(array, n, guard) {
          var length = array ? array.length : 0;
          if (!length) {
            return [];
          }
          if (guard ? isIterateeCall(array, n, guard) : n == null) {
            n = 1;
          }
          n = length - (+n || 0);
          return baseSlice(array, n < 0 ? 0 : n);
        }
        function takeRightWhile(array, predicate, thisArg) {
          var length = array ? array.length : 0;
          if (!length) {
            return [];
          }
          predicate = getCallback(predicate, thisArg, 3);
          while (length-- && predicate(array[length], length, array)) {}
          return baseSlice(array, length + 1);
        }
        function takeWhile(array, predicate, thisArg) {
          var length = array ? array.length : 0;
          if (!length) {
            return [];
          }
          var index = -1;
          predicate = getCallback(predicate, thisArg, 3);
          while (++index < length && predicate(array[index], index, array)) {}
          return baseSlice(array, 0, index);
        }
        function union() {
          return baseUniq(baseFlatten(arguments, false, true));
        }
        function uniq(array, isSorted, iteratee, thisArg) {
          var length = array ? array.length : 0;
          if (!length) {
            return [];
          }
          if (isSorted != null && typeof isSorted != 'boolean') {
            thisArg = iteratee;
            iteratee = isIterateeCall(array, isSorted, thisArg) ? null : isSorted;
            isSorted = false;
          }
          var func = getCallback();
          if (!(func === baseCallback && iteratee == null)) {
            iteratee = func(iteratee, thisArg, 3);
          }
          return (isSorted && getIndexOf() == baseIndexOf) ? sortedUniq(array, iteratee) : baseUniq(array, iteratee);
        }
        function unzip(array) {
          var index = -1,
              length = (array && array.length && arrayMax(arrayMap(array, getLength))) >>> 0,
              result = Array(length);
          while (++index < length) {
            result[index] = arrayMap(array, baseProperty(index));
          }
          return result;
        }
        function without(array) {
          return baseDifference(array, baseSlice(arguments, 1));
        }
        function xor() {
          var index = -1,
              length = arguments.length;
          while (++index < length) {
            var array = arguments[index];
            if (isArray(array) || isArguments(array)) {
              var result = result ? baseDifference(result, array).concat(baseDifference(array, result)) : array;
            }
          }
          return result ? baseUniq(result) : [];
        }
        function zip() {
          var length = arguments.length,
              array = Array(length);
          while (length--) {
            array[length] = arguments[length];
          }
          return unzip(array);
        }
        function zipObject(props, values) {
          var index = -1,
              length = props ? props.length : 0,
              result = {};
          if (length && !values && !isArray(props[0])) {
            values = [];
          }
          while (++index < length) {
            var key = props[index];
            if (values) {
              result[key] = values[index];
            } else if (key) {
              result[key[0]] = key[1];
            }
          }
          return result;
        }
        function chain(value) {
          var result = lodash(value);
          result.__chain__ = true;
          return result;
        }
        function tap(value, interceptor, thisArg) {
          interceptor.call(thisArg, value);
          return value;
        }
        function thru(value, interceptor, thisArg) {
          return interceptor.call(thisArg, value);
        }
        function wrapperChain() {
          return chain(this);
        }
        function wrapperCommit() {
          return new LodashWrapper(this.value(), this.__chain__);
        }
        function wrapperPlant(value) {
          var result,
              parent = this;
          while (parent instanceof baseLodash) {
            var clone = wrapperClone(parent);
            if (result) {
              previous.__wrapped__ = clone;
            } else {
              result = clone;
            }
            var previous = clone;
            parent = parent.__wrapped__;
          }
          previous.__wrapped__ = value;
          return result;
        }
        function wrapperReverse() {
          var value = this.__wrapped__;
          if (value instanceof LazyWrapper) {
            if (this.__actions__.length) {
              value = new LazyWrapper(this);
            }
            return new LodashWrapper(value.reverse(), this.__chain__);
          }
          return this.thru(function(value) {
            return value.reverse();
          });
        }
        function wrapperToString() {
          return (this.value() + '');
        }
        function wrapperValue() {
          return baseWrapperValue(this.__wrapped__, this.__actions__);
        }
        function at(collection) {
          var length = collection ? collection.length : 0;
          if (isLength(length)) {
            collection = toIterable(collection);
          }
          return baseAt(collection, baseFlatten(arguments, false, false, 1));
        }
        var countBy = createAggregator(function(result, value, key) {
          hasOwnProperty.call(result, key) ? ++result[key] : (result[key] = 1);
        });
        function every(collection, predicate, thisArg) {
          var func = isArray(collection) ? arrayEvery : baseEvery;
          if (typeof predicate != 'function' || typeof thisArg != 'undefined') {
            predicate = getCallback(predicate, thisArg, 3);
          }
          return func(collection, predicate);
        }
        function filter(collection, predicate, thisArg) {
          var func = isArray(collection) ? arrayFilter : baseFilter;
          predicate = getCallback(predicate, thisArg, 3);
          return func(collection, predicate);
        }
        function find(collection, predicate, thisArg) {
          if (isArray(collection)) {
            var index = findIndex(collection, predicate, thisArg);
            return index > -1 ? collection[index] : undefined;
          }
          predicate = getCallback(predicate, thisArg, 3);
          return baseFind(collection, predicate, baseEach);
        }
        function findLast(collection, predicate, thisArg) {
          predicate = getCallback(predicate, thisArg, 3);
          return baseFind(collection, predicate, baseEachRight);
        }
        function findWhere(collection, source) {
          return find(collection, baseMatches(source));
        }
        function forEach(collection, iteratee, thisArg) {
          return (typeof iteratee == 'function' && typeof thisArg == 'undefined' && isArray(collection)) ? arrayEach(collection, iteratee) : baseEach(collection, bindCallback(iteratee, thisArg, 3));
        }
        function forEachRight(collection, iteratee, thisArg) {
          return (typeof iteratee == 'function' && typeof thisArg == 'undefined' && isArray(collection)) ? arrayEachRight(collection, iteratee) : baseEachRight(collection, bindCallback(iteratee, thisArg, 3));
        }
        var groupBy = createAggregator(function(result, value, key) {
          if (hasOwnProperty.call(result, key)) {
            result[key].push(value);
          } else {
            result[key] = [value];
          }
        });
        function includes(collection, target, fromIndex) {
          var length = collection ? collection.length : 0;
          if (!isLength(length)) {
            collection = values(collection);
            length = collection.length;
          }
          if (!length) {
            return false;
          }
          if (typeof fromIndex == 'number') {
            fromIndex = fromIndex < 0 ? nativeMax(length + fromIndex, 0) : (fromIndex || 0);
          } else {
            fromIndex = 0;
          }
          return (typeof collection == 'string' || !isArray(collection) && isString(collection)) ? (fromIndex < length && collection.indexOf(target, fromIndex) > -1) : (getIndexOf(collection, target, fromIndex) > -1);
        }
        var indexBy = createAggregator(function(result, value, key) {
          result[key] = value;
        });
        function invoke(collection, methodName) {
          return baseInvoke(collection, methodName, baseSlice(arguments, 2));
        }
        function map(collection, iteratee, thisArg) {
          var func = isArray(collection) ? arrayMap : baseMap;
          iteratee = getCallback(iteratee, thisArg, 3);
          return func(collection, iteratee);
        }
        var max = createExtremum(arrayMax);
        var min = createExtremum(arrayMin, true);
        var partition = createAggregator(function(result, value, key) {
          result[key ? 0 : 1].push(value);
        }, function() {
          return [[], []];
        });
        function pluck(collection, key) {
          return map(collection, baseProperty(key));
        }
        function reduce(collection, iteratee, accumulator, thisArg) {
          var func = isArray(collection) ? arrayReduce : baseReduce;
          return func(collection, getCallback(iteratee, thisArg, 4), accumulator, arguments.length < 3, baseEach);
        }
        function reduceRight(collection, iteratee, accumulator, thisArg) {
          var func = isArray(collection) ? arrayReduceRight : baseReduce;
          return func(collection, getCallback(iteratee, thisArg, 4), accumulator, arguments.length < 3, baseEachRight);
        }
        function reject(collection, predicate, thisArg) {
          var func = isArray(collection) ? arrayFilter : baseFilter;
          predicate = getCallback(predicate, thisArg, 3);
          return func(collection, function(value, index, collection) {
            return !predicate(value, index, collection);
          });
        }
        function sample(collection, n, guard) {
          if (guard ? isIterateeCall(collection, n, guard) : n == null) {
            collection = toIterable(collection);
            var length = collection.length;
            return length > 0 ? collection[baseRandom(0, length - 1)] : undefined;
          }
          var result = shuffle(collection);
          result.length = nativeMin(n < 0 ? 0 : (+n || 0), result.length);
          return result;
        }
        function shuffle(collection) {
          collection = toIterable(collection);
          var index = -1,
              length = collection.length,
              result = Array(length);
          while (++index < length) {
            var rand = baseRandom(0, index);
            if (index != rand) {
              result[index] = result[rand];
            }
            result[rand] = collection[index];
          }
          return result;
        }
        function size(collection) {
          var length = collection ? collection.length : 0;
          return isLength(length) ? length : keys(collection).length;
        }
        function some(collection, predicate, thisArg) {
          var func = isArray(collection) ? arraySome : baseSome;
          if (typeof predicate != 'function' || typeof thisArg != 'undefined') {
            predicate = getCallback(predicate, thisArg, 3);
          }
          return func(collection, predicate);
        }
        function sortBy(collection, iteratee, thisArg) {
          var index = -1,
              length = collection ? collection.length : 0,
              result = isLength(length) ? Array(length) : [];
          if (thisArg && isIterateeCall(collection, iteratee, thisArg)) {
            iteratee = null;
          }
          iteratee = getCallback(iteratee, thisArg, 3);
          baseEach(collection, function(value, key, collection) {
            result[++index] = {
              'criteria': iteratee(value, key, collection),
              'index': index,
              'value': value
            };
          });
          return baseSortBy(result, compareAscending);
        }
        function sortByAll(collection) {
          var args = arguments;
          if (args.length > 3 && isIterateeCall(args[1], args[2], args[3])) {
            args = [collection, args[1]];
          }
          var index = -1,
              length = collection ? collection.length : 0,
              props = baseFlatten(args, false, false, 1),
              result = isLength(length) ? Array(length) : [];
          baseEach(collection, function(value) {
            var length = props.length,
                criteria = Array(length);
            while (length--) {
              criteria[length] = value == null ? undefined : value[props[length]];
            }
            result[++index] = {
              'criteria': criteria,
              'index': index,
              'value': value
            };
          });
          return baseSortBy(result, compareMultipleAscending);
        }
        function where(collection, source) {
          return filter(collection, baseMatches(source));
        }
        var now = nativeNow || function() {
          return new Date().getTime();
        };
        function after(n, func) {
          if (typeof func != 'function') {
            if (typeof n == 'function') {
              var temp = n;
              n = func;
              func = temp;
            } else {
              throw new TypeError(FUNC_ERROR_TEXT);
            }
          }
          n = nativeIsFinite(n = +n) ? n : 0;
          return function() {
            if (--n < 1) {
              return func.apply(this, arguments);
            }
          };
        }
        function ary(func, n, guard) {
          if (guard && isIterateeCall(func, n, guard)) {
            n = null;
          }
          n = (func && n == null) ? func.length : nativeMax(+n || 0, 0);
          return createWrapper(func, ARY_FLAG, null, null, null, null, n);
        }
        function before(n, func) {
          var result;
          if (typeof func != 'function') {
            if (typeof n == 'function') {
              var temp = n;
              n = func;
              func = temp;
            } else {
              throw new TypeError(FUNC_ERROR_TEXT);
            }
          }
          return function() {
            if (--n > 0) {
              result = func.apply(this, arguments);
            } else {
              func = null;
            }
            return result;
          };
        }
        function bind(func, thisArg) {
          var bitmask = BIND_FLAG;
          if (arguments.length > 2) {
            var partials = baseSlice(arguments, 2),
                holders = replaceHolders(partials, bind.placeholder);
            bitmask |= PARTIAL_FLAG;
          }
          return createWrapper(func, bitmask, thisArg, partials, holders);
        }
        function bindAll(object) {
          return baseBindAll(object, arguments.length > 1 ? baseFlatten(arguments, false, false, 1) : functions(object));
        }
        function bindKey(object, key) {
          var bitmask = BIND_FLAG | BIND_KEY_FLAG;
          if (arguments.length > 2) {
            var partials = baseSlice(arguments, 2),
                holders = replaceHolders(partials, bindKey.placeholder);
            bitmask |= PARTIAL_FLAG;
          }
          return createWrapper(key, bitmask, object, partials, holders);
        }
        function curry(func, arity, guard) {
          if (guard && isIterateeCall(func, arity, guard)) {
            arity = null;
          }
          var result = createWrapper(func, CURRY_FLAG, null, null, null, null, null, arity);
          result.placeholder = curry.placeholder;
          return result;
        }
        function curryRight(func, arity, guard) {
          if (guard && isIterateeCall(func, arity, guard)) {
            arity = null;
          }
          var result = createWrapper(func, CURRY_RIGHT_FLAG, null, null, null, null, null, arity);
          result.placeholder = curryRight.placeholder;
          return result;
        }
        function debounce(func, wait, options) {
          var args,
              maxTimeoutId,
              result,
              stamp,
              thisArg,
              timeoutId,
              trailingCall,
              lastCalled = 0,
              maxWait = false,
              trailing = true;
          if (typeof func != 'function') {
            throw new TypeError(FUNC_ERROR_TEXT);
          }
          wait = wait < 0 ? 0 : (+wait || 0);
          if (options === true) {
            var leading = true;
            trailing = false;
          } else if (isObject(options)) {
            leading = options.leading;
            maxWait = 'maxWait' in options && nativeMax(+options.maxWait || 0, wait);
            trailing = 'trailing' in options ? options.trailing : trailing;
          }
          function cancel() {
            if (timeoutId) {
              clearTimeout(timeoutId);
            }
            if (maxTimeoutId) {
              clearTimeout(maxTimeoutId);
            }
            maxTimeoutId = timeoutId = trailingCall = undefined;
          }
          function delayed() {
            var remaining = wait - (now() - stamp);
            if (remaining <= 0 || remaining > wait) {
              if (maxTimeoutId) {
                clearTimeout(maxTimeoutId);
              }
              var isCalled = trailingCall;
              maxTimeoutId = timeoutId = trailingCall = undefined;
              if (isCalled) {
                lastCalled = now();
                result = func.apply(thisArg, args);
                if (!timeoutId && !maxTimeoutId) {
                  args = thisArg = null;
                }
              }
            } else {
              timeoutId = setTimeout(delayed, remaining);
            }
          }
          function maxDelayed() {
            if (timeoutId) {
              clearTimeout(timeoutId);
            }
            maxTimeoutId = timeoutId = trailingCall = undefined;
            if (trailing || (maxWait !== wait)) {
              lastCalled = now();
              result = func.apply(thisArg, args);
              if (!timeoutId && !maxTimeoutId) {
                args = thisArg = null;
              }
            }
          }
          function debounced() {
            args = arguments;
            stamp = now();
            thisArg = this;
            trailingCall = trailing && (timeoutId || !leading);
            if (maxWait === false) {
              var leadingCall = leading && !timeoutId;
            } else {
              if (!maxTimeoutId && !leading) {
                lastCalled = stamp;
              }
              var remaining = maxWait - (stamp - lastCalled),
                  isCalled = remaining <= 0 || remaining > maxWait;
              if (isCalled) {
                if (maxTimeoutId) {
                  maxTimeoutId = clearTimeout(maxTimeoutId);
                }
                lastCalled = stamp;
                result = func.apply(thisArg, args);
              } else if (!maxTimeoutId) {
                maxTimeoutId = setTimeout(maxDelayed, remaining);
              }
            }
            if (isCalled && timeoutId) {
              timeoutId = clearTimeout(timeoutId);
            } else if (!timeoutId && wait !== maxWait) {
              timeoutId = setTimeout(delayed, wait);
            }
            if (leadingCall) {
              isCalled = true;
              result = func.apply(thisArg, args);
            }
            if (isCalled && !timeoutId && !maxTimeoutId) {
              args = thisArg = null;
            }
            return result;
          }
          debounced.cancel = cancel;
          return debounced;
        }
        function defer(func) {
          return baseDelay(func, 1, arguments, 1);
        }
        function delay(func, wait) {
          return baseDelay(func, wait, arguments, 2);
        }
        function flow() {
          var funcs = arguments,
              length = funcs.length;
          if (!length) {
            return function() {
              return arguments[0];
            };
          }
          if (!arrayEvery(funcs, baseIsFunction)) {
            throw new TypeError(FUNC_ERROR_TEXT);
          }
          return function() {
            var index = 0,
                result = funcs[index].apply(this, arguments);
            while (++index < length) {
              result = funcs[index].call(this, result);
            }
            return result;
          };
        }
        function flowRight() {
          var funcs = arguments,
              fromIndex = funcs.length - 1;
          if (fromIndex < 0) {
            return function() {
              return arguments[0];
            };
          }
          if (!arrayEvery(funcs, baseIsFunction)) {
            throw new TypeError(FUNC_ERROR_TEXT);
          }
          return function() {
            var index = fromIndex,
                result = funcs[index].apply(this, arguments);
            while (index--) {
              result = funcs[index].call(this, result);
            }
            return result;
          };
        }
        function memoize(func, resolver) {
          if (typeof func != 'function' || (resolver && typeof resolver != 'function')) {
            throw new TypeError(FUNC_ERROR_TEXT);
          }
          var memoized = function() {
            var cache = memoized.cache,
                key = resolver ? resolver.apply(this, arguments) : arguments[0];
            if (cache.has(key)) {
              return cache.get(key);
            }
            var result = func.apply(this, arguments);
            cache.set(key, result);
            return result;
          };
          memoized.cache = new memoize.Cache;
          return memoized;
        }
        function negate(predicate) {
          if (typeof predicate != 'function') {
            throw new TypeError(FUNC_ERROR_TEXT);
          }
          return function() {
            return !predicate.apply(this, arguments);
          };
        }
        function once(func) {
          return before(func, 2);
        }
        function partial(func) {
          var partials = baseSlice(arguments, 1),
              holders = replaceHolders(partials, partial.placeholder);
          return createWrapper(func, PARTIAL_FLAG, null, partials, holders);
        }
        function partialRight(func) {
          var partials = baseSlice(arguments, 1),
              holders = replaceHolders(partials, partialRight.placeholder);
          return createWrapper(func, PARTIAL_RIGHT_FLAG, null, partials, holders);
        }
        function rearg(func) {
          var indexes = baseFlatten(arguments, false, false, 1);
          return createWrapper(func, REARG_FLAG, null, null, null, indexes);
        }
        function spread(func) {
          if (typeof func != 'function') {
            throw new TypeError(FUNC_ERROR_TEXT);
          }
          return function(array) {
            return func.apply(this, array);
          };
        }
        function throttle(func, wait, options) {
          var leading = true,
              trailing = true;
          if (typeof func != 'function') {
            throw new TypeError(FUNC_ERROR_TEXT);
          }
          if (options === false) {
            leading = false;
          } else if (isObject(options)) {
            leading = 'leading' in options ? !!options.leading : leading;
            trailing = 'trailing' in options ? !!options.trailing : trailing;
          }
          debounceOptions.leading = leading;
          debounceOptions.maxWait = +wait;
          debounceOptions.trailing = trailing;
          return debounce(func, wait, debounceOptions);
        }
        function wrap(value, wrapper) {
          wrapper = wrapper == null ? identity : wrapper;
          return createWrapper(wrapper, PARTIAL_FLAG, null, [value], []);
        }
        function clone(value, isDeep, customizer, thisArg) {
          if (isDeep && typeof isDeep != 'boolean' && isIterateeCall(value, isDeep, customizer)) {
            isDeep = false;
          } else if (typeof isDeep == 'function') {
            thisArg = customizer;
            customizer = isDeep;
            isDeep = false;
          }
          customizer = typeof customizer == 'function' && bindCallback(customizer, thisArg, 1);
          return baseClone(value, isDeep, customizer);
        }
        function cloneDeep(value, customizer, thisArg) {
          customizer = typeof customizer == 'function' && bindCallback(customizer, thisArg, 1);
          return baseClone(value, true, customizer);
        }
        function isArguments(value) {
          var length = isObjectLike(value) ? value.length : undefined;
          return (isLength(length) && objToString.call(value) == argsTag) || false;
        }
        var isArray = nativeIsArray || function(value) {
          return (isObjectLike(value) && isLength(value.length) && objToString.call(value) == arrayTag) || false;
        };
        function isBoolean(value) {
          return (value === true || value === false || isObjectLike(value) && objToString.call(value) == boolTag) || false;
        }
        function isDate(value) {
          return (isObjectLike(value) && objToString.call(value) == dateTag) || false;
        }
        function isElement(value) {
          return (value && value.nodeType === 1 && isObjectLike(value) && objToString.call(value).indexOf('Element') > -1) || false;
        }
        if (!support.dom) {
          isElement = function(value) {
            return (value && value.nodeType === 1 && isObjectLike(value) && !isPlainObject(value)) || false;
          };
        }
        function isEmpty(value) {
          if (value == null) {
            return true;
          }
          var length = value.length;
          if (isLength(length) && (isArray(value) || isString(value) || isArguments(value) || (isObjectLike(value) && isFunction(value.splice)))) {
            return !length;
          }
          return !keys(value).length;
        }
        function isEqual(value, other, customizer, thisArg) {
          customizer = typeof customizer == 'function' && bindCallback(customizer, thisArg, 3);
          if (!customizer && isStrictComparable(value) && isStrictComparable(other)) {
            return value === other;
          }
          var result = customizer ? customizer(value, other) : undefined;
          return typeof result == 'undefined' ? baseIsEqual(value, other, customizer) : !!result;
        }
        function isError(value) {
          return (isObjectLike(value) && typeof value.message == 'string' && objToString.call(value) == errorTag) || false;
        }
        var isFinite = nativeNumIsFinite || function(value) {
          return typeof value == 'number' && nativeIsFinite(value);
        };
        var isFunction = !(baseIsFunction(/x/) || (Uint8Array && !baseIsFunction(Uint8Array))) ? baseIsFunction : function(value) {
          return objToString.call(value) == funcTag;
        };
        function isObject(value) {
          var type = typeof value;
          return type == 'function' || (value && type == 'object') || false;
        }
        function isMatch(object, source, customizer, thisArg) {
          var props = keys(source),
              length = props.length;
          customizer = typeof customizer == 'function' && bindCallback(customizer, thisArg, 3);
          if (!customizer && length == 1) {
            var key = props[0],
                value = source[key];
            if (isStrictComparable(value)) {
              return object != null && value === object[key] && hasOwnProperty.call(object, key);
            }
          }
          var values = Array(length),
              strictCompareFlags = Array(length);
          while (length--) {
            value = values[length] = source[props[length]];
            strictCompareFlags[length] = isStrictComparable(value);
          }
          return baseIsMatch(object, props, values, strictCompareFlags, customizer);
        }
        function isNaN(value) {
          return isNumber(value) && value != +value;
        }
        function isNative(value) {
          if (value == null) {
            return false;
          }
          if (objToString.call(value) == funcTag) {
            return reNative.test(fnToString.call(value));
          }
          return (isObjectLike(value) && reHostCtor.test(value)) || false;
        }
        function isNull(value) {
          return value === null;
        }
        function isNumber(value) {
          return typeof value == 'number' || (isObjectLike(value) && objToString.call(value) == numberTag) || false;
        }
        var isPlainObject = !getPrototypeOf ? shimIsPlainObject : function(value) {
          if (!(value && objToString.call(value) == objectTag)) {
            return false;
          }
          var valueOf = value.valueOf,
              objProto = isNative(valueOf) && (objProto = getPrototypeOf(valueOf)) && getPrototypeOf(objProto);
          return objProto ? (value == objProto || getPrototypeOf(value) == objProto) : shimIsPlainObject(value);
        };
        function isRegExp(value) {
          return (isObjectLike(value) && objToString.call(value) == regexpTag) || false;
        }
        function isString(value) {
          return typeof value == 'string' || (isObjectLike(value) && objToString.call(value) == stringTag) || false;
        }
        function isTypedArray(value) {
          return (isObjectLike(value) && isLength(value.length) && typedArrayTags[objToString.call(value)]) || false;
        }
        function isUndefined(value) {
          return typeof value == 'undefined';
        }
        function toArray(value) {
          var length = value ? value.length : 0;
          if (!isLength(length)) {
            return values(value);
          }
          if (!length) {
            return [];
          }
          return arrayCopy(value);
        }
        function toPlainObject(value) {
          return baseCopy(value, keysIn(value));
        }
        var assign = createAssigner(baseAssign);
        function create(prototype, properties, guard) {
          var result = baseCreate(prototype);
          if (guard && isIterateeCall(prototype, properties, guard)) {
            properties = null;
          }
          return properties ? baseCopy(properties, result, keys(properties)) : result;
        }
        function defaults(object) {
          if (object == null) {
            return object;
          }
          var args = arrayCopy(arguments);
          args.push(assignDefaults);
          return assign.apply(undefined, args);
        }
        function findKey(object, predicate, thisArg) {
          predicate = getCallback(predicate, thisArg, 3);
          return baseFind(object, predicate, baseForOwn, true);
        }
        function findLastKey(object, predicate, thisArg) {
          predicate = getCallback(predicate, thisArg, 3);
          return baseFind(object, predicate, baseForOwnRight, true);
        }
        function forIn(object, iteratee, thisArg) {
          if (typeof iteratee != 'function' || typeof thisArg != 'undefined') {
            iteratee = bindCallback(iteratee, thisArg, 3);
          }
          return baseFor(object, iteratee, keysIn);
        }
        function forInRight(object, iteratee, thisArg) {
          iteratee = bindCallback(iteratee, thisArg, 3);
          return baseForRight(object, iteratee, keysIn);
        }
        function forOwn(object, iteratee, thisArg) {
          if (typeof iteratee != 'function' || typeof thisArg != 'undefined') {
            iteratee = bindCallback(iteratee, thisArg, 3);
          }
          return baseForOwn(object, iteratee);
        }
        function forOwnRight(object, iteratee, thisArg) {
          iteratee = bindCallback(iteratee, thisArg, 3);
          return baseForRight(object, iteratee, keys);
        }
        function functions(object) {
          return baseFunctions(object, keysIn(object));
        }
        function has(object, key) {
          return object ? hasOwnProperty.call(object, key) : false;
        }
        function invert(object, multiValue, guard) {
          if (guard && isIterateeCall(object, multiValue, guard)) {
            multiValue = null;
          }
          var index = -1,
              props = keys(object),
              length = props.length,
              result = {};
          while (++index < length) {
            var key = props[index],
                value = object[key];
            if (multiValue) {
              if (hasOwnProperty.call(result, value)) {
                result[value].push(key);
              } else {
                result[value] = [key];
              }
            } else {
              result[value] = key;
            }
          }
          return result;
        }
        var keys = !nativeKeys ? shimKeys : function(object) {
          if (object) {
            var Ctor = object.constructor,
                length = object.length;
          }
          if ((typeof Ctor == 'function' && Ctor.prototype === object) || (typeof object != 'function' && (length && isLength(length)))) {
            return shimKeys(object);
          }
          return isObject(object) ? nativeKeys(object) : [];
        };
        function keysIn(object) {
          if (object == null) {
            return [];
          }
          if (!isObject(object)) {
            object = Object(object);
          }
          var length = object.length;
          length = (length && isLength(length) && (isArray(object) || (support.nonEnumArgs && isArguments(object))) && length) || 0;
          var Ctor = object.constructor,
              index = -1,
              isProto = typeof Ctor == 'function' && Ctor.prototype === object,
              result = Array(length),
              skipIndexes = length > 0;
          while (++index < length) {
            result[index] = (index + '');
          }
          for (var key in object) {
            if (!(skipIndexes && isIndex(key, length)) && !(key == 'constructor' && (isProto || !hasOwnProperty.call(object, key)))) {
              result.push(key);
            }
          }
          return result;
        }
        function mapValues(object, iteratee, thisArg) {
          var result = {};
          iteratee = getCallback(iteratee, thisArg, 3);
          baseForOwn(object, function(value, key, object) {
            result[key] = iteratee(value, key, object);
          });
          return result;
        }
        var merge = createAssigner(baseMerge);
        function omit(object, predicate, thisArg) {
          if (object == null) {
            return {};
          }
          if (typeof predicate != 'function') {
            var props = arrayMap(baseFlatten(arguments, false, false, 1), String);
            return pickByArray(object, baseDifference(keysIn(object), props));
          }
          predicate = bindCallback(predicate, thisArg, 3);
          return pickByCallback(object, function(value, key, object) {
            return !predicate(value, key, object);
          });
        }
        function pairs(object) {
          var index = -1,
              props = keys(object),
              length = props.length,
              result = Array(length);
          while (++index < length) {
            var key = props[index];
            result[index] = [key, object[key]];
          }
          return result;
        }
        function pick(object, predicate, thisArg) {
          if (object == null) {
            return {};
          }
          return typeof predicate == 'function' ? pickByCallback(object, bindCallback(predicate, thisArg, 3)) : pickByArray(object, baseFlatten(arguments, false, false, 1));
        }
        function result(object, key, defaultValue) {
          var value = object == null ? undefined : object[key];
          if (typeof value == 'undefined') {
            value = defaultValue;
          }
          return isFunction(value) ? value.call(object) : value;
        }
        function transform(object, iteratee, accumulator, thisArg) {
          var isArr = isArray(object) || isTypedArray(object);
          iteratee = getCallback(iteratee, thisArg, 4);
          if (accumulator == null) {
            if (isArr || isObject(object)) {
              var Ctor = object.constructor;
              if (isArr) {
                accumulator = isArray(object) ? new Ctor : [];
              } else {
                accumulator = baseCreate(isFunction(Ctor) && Ctor.prototype);
              }
            } else {
              accumulator = {};
            }
          }
          (isArr ? arrayEach : baseForOwn)(object, function(value, index, object) {
            return iteratee(accumulator, value, index, object);
          });
          return accumulator;
        }
        function values(object) {
          return baseValues(object, keys(object));
        }
        function valuesIn(object) {
          return baseValues(object, keysIn(object));
        }
        function inRange(value, start, end) {
          start = +start || 0;
          if (typeof end === 'undefined') {
            end = start;
            start = 0;
          } else {
            end = +end || 0;
          }
          return value >= start && value < end;
        }
        function random(min, max, floating) {
          if (floating && isIterateeCall(min, max, floating)) {
            max = floating = null;
          }
          var noMin = min == null,
              noMax = max == null;
          if (floating == null) {
            if (noMax && typeof min == 'boolean') {
              floating = min;
              min = 1;
            } else if (typeof max == 'boolean') {
              floating = max;
              noMax = true;
            }
          }
          if (noMin && noMax) {
            max = 1;
            noMax = false;
          }
          min = +min || 0;
          if (noMax) {
            max = min;
            min = 0;
          } else {
            max = +max || 0;
          }
          if (floating || min % 1 || max % 1) {
            var rand = nativeRandom();
            return nativeMin(min + (rand * (max - min + parseFloat('1e-' + ((rand + '').length - 1)))), max);
          }
          return baseRandom(min, max);
        }
        var camelCase = createCompounder(function(result, word, index) {
          word = word.toLowerCase();
          return result + (index ? (word.charAt(0).toUpperCase() + word.slice(1)) : word);
        });
        function capitalize(string) {
          string = baseToString(string);
          return string && (string.charAt(0).toUpperCase() + string.slice(1));
        }
        function deburr(string) {
          string = baseToString(string);
          return string && string.replace(reLatin1, deburrLetter);
        }
        function endsWith(string, target, position) {
          string = baseToString(string);
          target = (target + '');
          var length = string.length;
          position = (typeof position == 'undefined' ? length : nativeMin(position < 0 ? 0 : (+position || 0), length)) - target.length;
          return position >= 0 && string.indexOf(target, position) == position;
        }
        function escape(string) {
          string = baseToString(string);
          return (string && reHasUnescapedHtml.test(string)) ? string.replace(reUnescapedHtml, escapeHtmlChar) : string;
        }
        function escapeRegExp(string) {
          string = baseToString(string);
          return (string && reHasRegExpChars.test(string)) ? string.replace(reRegExpChars, '\\$&') : string;
        }
        var kebabCase = createCompounder(function(result, word, index) {
          return result + (index ? '-' : '') + word.toLowerCase();
        });
        function pad(string, length, chars) {
          string = baseToString(string);
          length = +length;
          var strLength = string.length;
          if (strLength >= length || !nativeIsFinite(length)) {
            return string;
          }
          var mid = (length - strLength) / 2,
              leftLength = floor(mid),
              rightLength = ceil(mid);
          chars = createPad('', rightLength, chars);
          return chars.slice(0, leftLength) + string + chars;
        }
        function padLeft(string, length, chars) {
          string = baseToString(string);
          return string && (createPad(string, length, chars) + string);
        }
        function padRight(string, length, chars) {
          string = baseToString(string);
          return string && (string + createPad(string, length, chars));
        }
        function parseInt(string, radix, guard) {
          if (guard && isIterateeCall(string, radix, guard)) {
            radix = 0;
          }
          return nativeParseInt(string, radix);
        }
        if (nativeParseInt(whitespace + '08') != 8) {
          parseInt = function(string, radix, guard) {
            if (guard ? isIterateeCall(string, radix, guard) : radix == null) {
              radix = 0;
            } else if (radix) {
              radix = +radix;
            }
            string = trim(string);
            return nativeParseInt(string, radix || (reHexPrefix.test(string) ? 16 : 10));
          };
        }
        function repeat(string, n) {
          var result = '';
          string = baseToString(string);
          n = +n;
          if (n < 1 || !string || !nativeIsFinite(n)) {
            return result;
          }
          do {
            if (n % 2) {
              result += string;
            }
            n = floor(n / 2);
            string += string;
          } while (n);
          return result;
        }
        var snakeCase = createCompounder(function(result, word, index) {
          return result + (index ? '_' : '') + word.toLowerCase();
        });
        var startCase = createCompounder(function(result, word, index) {
          return result + (index ? ' ' : '') + (word.charAt(0).toUpperCase() + word.slice(1));
        });
        function startsWith(string, target, position) {
          string = baseToString(string);
          position = position == null ? 0 : nativeMin(position < 0 ? 0 : (+position || 0), string.length);
          return string.lastIndexOf(target, position) == position;
        }
        function template(string, options, otherOptions) {
          var settings = lodash.templateSettings;
          if (otherOptions && isIterateeCall(string, options, otherOptions)) {
            options = otherOptions = null;
          }
          string = baseToString(string);
          options = baseAssign(baseAssign({}, otherOptions || options), settings, assignOwnDefaults);
          var imports = baseAssign(baseAssign({}, options.imports), settings.imports, assignOwnDefaults),
              importsKeys = keys(imports),
              importsValues = baseValues(imports, importsKeys);
          var isEscaping,
              isEvaluating,
              index = 0,
              interpolate = options.interpolate || reNoMatch,
              source = "__p += '";
          var reDelimiters = RegExp((options.escape || reNoMatch).source + '|' + interpolate.source + '|' + (interpolate === reInterpolate ? reEsTemplate : reNoMatch).source + '|' + (options.evaluate || reNoMatch).source + '|$', 'g');
          var sourceURL = '//# sourceURL=' + ('sourceURL' in options ? options.sourceURL : ('lodash.templateSources[' + (++templateCounter) + ']')) + '\n';
          string.replace(reDelimiters, function(match, escapeValue, interpolateValue, esTemplateValue, evaluateValue, offset) {
            interpolateValue || (interpolateValue = esTemplateValue);
            source += string.slice(index, offset).replace(reUnescapedString, escapeStringChar);
            if (escapeValue) {
              isEscaping = true;
              source += "' +\n__e(" + escapeValue + ") +\n'";
            }
            if (evaluateValue) {
              isEvaluating = true;
              source += "';\n" + evaluateValue + ";\n__p += '";
            }
            if (interpolateValue) {
              source += "' +\n((__t = (" + interpolateValue + ")) == null ? '' : __t) +\n'";
            }
            index = offset + match.length;
            return match;
          });
          source += "';\n";
          var variable = options.variable;
          if (!variable) {
            source = 'with (obj) {\n' + source + '\n}\n';
          }
          source = (isEvaluating ? source.replace(reEmptyStringLeading, '') : source).replace(reEmptyStringMiddle, '$1').replace(reEmptyStringTrailing, '$1;');
          source = 'function(' + (variable || 'obj') + ') {\n' + (variable ? '' : 'obj || (obj = {});\n') + "var __t, __p = ''" + (isEscaping ? ', __e = _.escape' : '') + (isEvaluating ? ', __j = Array.prototype.join;\n' + "function print() { __p += __j.call(arguments, '') }\n" : ';\n') + source + 'return __p\n}';
          var result = attempt(function() {
            return Function(importsKeys, sourceURL + 'return ' + source).apply(undefined, importsValues);
          });
          result.source = source;
          if (isError(result)) {
            throw result;
          }
          return result;
        }
        function trim(string, chars, guard) {
          var value = string;
          string = baseToString(string);
          if (!string) {
            return string;
          }
          if (guard ? isIterateeCall(value, chars, guard) : chars == null) {
            return string.slice(trimmedLeftIndex(string), trimmedRightIndex(string) + 1);
          }
          chars = (chars + '');
          return string.slice(charsLeftIndex(string, chars), charsRightIndex(string, chars) + 1);
        }
        function trimLeft(string, chars, guard) {
          var value = string;
          string = baseToString(string);
          if (!string) {
            return string;
          }
          if (guard ? isIterateeCall(value, chars, guard) : chars == null) {
            return string.slice(trimmedLeftIndex(string));
          }
          return string.slice(charsLeftIndex(string, (chars + '')));
        }
        function trimRight(string, chars, guard) {
          var value = string;
          string = baseToString(string);
          if (!string) {
            return string;
          }
          if (guard ? isIterateeCall(value, chars, guard) : chars == null) {
            return string.slice(0, trimmedRightIndex(string) + 1);
          }
          return string.slice(0, charsRightIndex(string, (chars + '')) + 1);
        }
        function trunc(string, options, guard) {
          if (guard && isIterateeCall(string, options, guard)) {
            options = null;
          }
          var length = DEFAULT_TRUNC_LENGTH,
              omission = DEFAULT_TRUNC_OMISSION;
          if (options != null) {
            if (isObject(options)) {
              var separator = 'separator' in options ? options.separator : separator;
              length = 'length' in options ? +options.length || 0 : length;
              omission = 'omission' in options ? baseToString(options.omission) : omission;
            } else {
              length = +options || 0;
            }
          }
          string = baseToString(string);
          if (length >= string.length) {
            return string;
          }
          var end = length - omission.length;
          if (end < 1) {
            return omission;
          }
          var result = string.slice(0, end);
          if (separator == null) {
            return result + omission;
          }
          if (isRegExp(separator)) {
            if (string.slice(end).search(separator)) {
              var match,
                  newEnd,
                  substring = string.slice(0, end);
              if (!separator.global) {
                separator = RegExp(separator.source, (reFlags.exec(separator) || '') + 'g');
              }
              separator.lastIndex = 0;
              while ((match = separator.exec(substring))) {
                newEnd = match.index;
              }
              result = result.slice(0, newEnd == null ? end : newEnd);
            }
          } else if (string.indexOf(separator, end) != end) {
            var index = result.lastIndexOf(separator);
            if (index > -1) {
              result = result.slice(0, index);
            }
          }
          return result + omission;
        }
        function unescape(string) {
          string = baseToString(string);
          return (string && reHasEscapedHtml.test(string)) ? string.replace(reEscapedHtml, unescapeHtmlChar) : string;
        }
        function words(string, pattern, guard) {
          if (guard && isIterateeCall(string, pattern, guard)) {
            pattern = null;
          }
          string = baseToString(string);
          return string.match(pattern || reWords) || [];
        }
        function attempt() {
          var length = arguments.length,
              func = arguments[0];
          try {
            var args = Array(length ? length - 1 : 0);
            while (--length > 0) {
              args[length - 1] = arguments[length];
            }
            return func.apply(undefined, args);
          } catch (e) {
            return isError(e) ? e : new Error(e);
          }
        }
        function callback(func, thisArg, guard) {
          if (guard && isIterateeCall(func, thisArg, guard)) {
            thisArg = null;
          }
          return isObjectLike(func) ? matches(func) : baseCallback(func, thisArg);
        }
        function constant(value) {
          return function() {
            return value;
          };
        }
        function identity(value) {
          return value;
        }
        function matches(source) {
          return baseMatches(baseClone(source, true));
        }
        function matchesProperty(key, value) {
          return baseMatchesProperty(key + '', baseClone(value, true));
        }
        function mixin(object, source, options) {
          if (options == null) {
            var isObj = isObject(source),
                props = isObj && keys(source),
                methodNames = props && props.length && baseFunctions(source, props);
            if (!(methodNames ? methodNames.length : isObj)) {
              methodNames = false;
              options = source;
              source = object;
              object = this;
            }
          }
          if (!methodNames) {
            methodNames = baseFunctions(source, keys(source));
          }
          var chain = true,
              index = -1,
              isFunc = isFunction(object),
              length = methodNames.length;
          if (options === false) {
            chain = false;
          } else if (isObject(options) && 'chain' in options) {
            chain = options.chain;
          }
          while (++index < length) {
            var methodName = methodNames[index],
                func = source[methodName];
            object[methodName] = func;
            if (isFunc) {
              object.prototype[methodName] = (function(func) {
                return function() {
                  var chainAll = this.__chain__;
                  if (chain || chainAll) {
                    var result = object(this.__wrapped__);
                    (result.__actions__ = arrayCopy(this.__actions__)).push({
                      'func': func,
                      'args': arguments,
                      'thisArg': object
                    });
                    result.__chain__ = chainAll;
                    return result;
                  }
                  var args = [this.value()];
                  push.apply(args, arguments);
                  return func.apply(object, args);
                };
              }(func));
            }
          }
          return object;
        }
        function noConflict() {
          context._ = oldDash;
          return this;
        }
        function noop() {}
        function property(key) {
          return baseProperty(key + '');
        }
        function propertyOf(object) {
          return function(key) {
            return object == null ? undefined : object[key];
          };
        }
        function range(start, end, step) {
          if (step && isIterateeCall(start, end, step)) {
            end = step = null;
          }
          start = +start || 0;
          step = step == null ? 1 : (+step || 0);
          if (end == null) {
            end = start;
            start = 0;
          } else {
            end = +end || 0;
          }
          var index = -1,
              length = nativeMax(ceil((end - start) / (step || 1)), 0),
              result = Array(length);
          while (++index < length) {
            result[index] = start;
            start += step;
          }
          return result;
        }
        function times(n, iteratee, thisArg) {
          n = +n;
          if (n < 1 || !nativeIsFinite(n)) {
            return [];
          }
          var index = -1,
              result = Array(nativeMin(n, MAX_ARRAY_LENGTH));
          iteratee = bindCallback(iteratee, thisArg, 1);
          while (++index < n) {
            if (index < MAX_ARRAY_LENGTH) {
              result[index] = iteratee(index);
            } else {
              iteratee(index);
            }
          }
          return result;
        }
        function uniqueId(prefix) {
          var id = ++idCounter;
          return baseToString(prefix) + id;
        }
        lodash.prototype = baseLodash.prototype;
        LodashWrapper.prototype = baseCreate(baseLodash.prototype);
        LodashWrapper.prototype.constructor = LodashWrapper;
        LazyWrapper.prototype = baseCreate(baseLodash.prototype);
        LazyWrapper.prototype.constructor = LazyWrapper;
        MapCache.prototype['delete'] = mapDelete;
        MapCache.prototype.get = mapGet;
        MapCache.prototype.has = mapHas;
        MapCache.prototype.set = mapSet;
        SetCache.prototype.push = cachePush;
        memoize.Cache = MapCache;
        lodash.after = after;
        lodash.ary = ary;
        lodash.assign = assign;
        lodash.at = at;
        lodash.before = before;
        lodash.bind = bind;
        lodash.bindAll = bindAll;
        lodash.bindKey = bindKey;
        lodash.callback = callback;
        lodash.chain = chain;
        lodash.chunk = chunk;
        lodash.compact = compact;
        lodash.constant = constant;
        lodash.countBy = countBy;
        lodash.create = create;
        lodash.curry = curry;
        lodash.curryRight = curryRight;
        lodash.debounce = debounce;
        lodash.defaults = defaults;
        lodash.defer = defer;
        lodash.delay = delay;
        lodash.difference = difference;
        lodash.drop = drop;
        lodash.dropRight = dropRight;
        lodash.dropRightWhile = dropRightWhile;
        lodash.dropWhile = dropWhile;
        lodash.fill = fill;
        lodash.filter = filter;
        lodash.flatten = flatten;
        lodash.flattenDeep = flattenDeep;
        lodash.flow = flow;
        lodash.flowRight = flowRight;
        lodash.forEach = forEach;
        lodash.forEachRight = forEachRight;
        lodash.forIn = forIn;
        lodash.forInRight = forInRight;
        lodash.forOwn = forOwn;
        lodash.forOwnRight = forOwnRight;
        lodash.functions = functions;
        lodash.groupBy = groupBy;
        lodash.indexBy = indexBy;
        lodash.initial = initial;
        lodash.intersection = intersection;
        lodash.invert = invert;
        lodash.invoke = invoke;
        lodash.keys = keys;
        lodash.keysIn = keysIn;
        lodash.map = map;
        lodash.mapValues = mapValues;
        lodash.matches = matches;
        lodash.matchesProperty = matchesProperty;
        lodash.memoize = memoize;
        lodash.merge = merge;
        lodash.mixin = mixin;
        lodash.negate = negate;
        lodash.omit = omit;
        lodash.once = once;
        lodash.pairs = pairs;
        lodash.partial = partial;
        lodash.partialRight = partialRight;
        lodash.partition = partition;
        lodash.pick = pick;
        lodash.pluck = pluck;
        lodash.property = property;
        lodash.propertyOf = propertyOf;
        lodash.pull = pull;
        lodash.pullAt = pullAt;
        lodash.range = range;
        lodash.rearg = rearg;
        lodash.reject = reject;
        lodash.remove = remove;
        lodash.rest = rest;
        lodash.shuffle = shuffle;
        lodash.slice = slice;
        lodash.sortBy = sortBy;
        lodash.sortByAll = sortByAll;
        lodash.spread = spread;
        lodash.take = take;
        lodash.takeRight = takeRight;
        lodash.takeRightWhile = takeRightWhile;
        lodash.takeWhile = takeWhile;
        lodash.tap = tap;
        lodash.throttle = throttle;
        lodash.thru = thru;
        lodash.times = times;
        lodash.toArray = toArray;
        lodash.toPlainObject = toPlainObject;
        lodash.transform = transform;
        lodash.union = union;
        lodash.uniq = uniq;
        lodash.unzip = unzip;
        lodash.values = values;
        lodash.valuesIn = valuesIn;
        lodash.where = where;
        lodash.without = without;
        lodash.wrap = wrap;
        lodash.xor = xor;
        lodash.zip = zip;
        lodash.zipObject = zipObject;
        lodash.backflow = flowRight;
        lodash.collect = map;
        lodash.compose = flowRight;
        lodash.each = forEach;
        lodash.eachRight = forEachRight;
        lodash.extend = assign;
        lodash.iteratee = callback;
        lodash.methods = functions;
        lodash.object = zipObject;
        lodash.select = filter;
        lodash.tail = rest;
        lodash.unique = uniq;
        mixin(lodash, lodash);
        lodash.attempt = attempt;
        lodash.camelCase = camelCase;
        lodash.capitalize = capitalize;
        lodash.clone = clone;
        lodash.cloneDeep = cloneDeep;
        lodash.deburr = deburr;
        lodash.endsWith = endsWith;
        lodash.escape = escape;
        lodash.escapeRegExp = escapeRegExp;
        lodash.every = every;
        lodash.find = find;
        lodash.findIndex = findIndex;
        lodash.findKey = findKey;
        lodash.findLast = findLast;
        lodash.findLastIndex = findLastIndex;
        lodash.findLastKey = findLastKey;
        lodash.findWhere = findWhere;
        lodash.first = first;
        lodash.has = has;
        lodash.identity = identity;
        lodash.includes = includes;
        lodash.indexOf = indexOf;
        lodash.inRange = inRange;
        lodash.isArguments = isArguments;
        lodash.isArray = isArray;
        lodash.isBoolean = isBoolean;
        lodash.isDate = isDate;
        lodash.isElement = isElement;
        lodash.isEmpty = isEmpty;
        lodash.isEqual = isEqual;
        lodash.isError = isError;
        lodash.isFinite = isFinite;
        lodash.isFunction = isFunction;
        lodash.isMatch = isMatch;
        lodash.isNaN = isNaN;
        lodash.isNative = isNative;
        lodash.isNull = isNull;
        lodash.isNumber = isNumber;
        lodash.isObject = isObject;
        lodash.isPlainObject = isPlainObject;
        lodash.isRegExp = isRegExp;
        lodash.isString = isString;
        lodash.isTypedArray = isTypedArray;
        lodash.isUndefined = isUndefined;
        lodash.kebabCase = kebabCase;
        lodash.last = last;
        lodash.lastIndexOf = lastIndexOf;
        lodash.max = max;
        lodash.min = min;
        lodash.noConflict = noConflict;
        lodash.noop = noop;
        lodash.now = now;
        lodash.pad = pad;
        lodash.padLeft = padLeft;
        lodash.padRight = padRight;
        lodash.parseInt = parseInt;
        lodash.random = random;
        lodash.reduce = reduce;
        lodash.reduceRight = reduceRight;
        lodash.repeat = repeat;
        lodash.result = result;
        lodash.runInContext = runInContext;
        lodash.size = size;
        lodash.snakeCase = snakeCase;
        lodash.some = some;
        lodash.sortedIndex = sortedIndex;
        lodash.sortedLastIndex = sortedLastIndex;
        lodash.startCase = startCase;
        lodash.startsWith = startsWith;
        lodash.template = template;
        lodash.trim = trim;
        lodash.trimLeft = trimLeft;
        lodash.trimRight = trimRight;
        lodash.trunc = trunc;
        lodash.unescape = unescape;
        lodash.uniqueId = uniqueId;
        lodash.words = words;
        lodash.all = every;
        lodash.any = some;
        lodash.contains = includes;
        lodash.detect = find;
        lodash.foldl = reduce;
        lodash.foldr = reduceRight;
        lodash.head = first;
        lodash.include = includes;
        lodash.inject = reduce;
        mixin(lodash, (function() {
          var source = {};
          baseForOwn(lodash, function(func, methodName) {
            if (!lodash.prototype[methodName]) {
              source[methodName] = func;
            }
          });
          return source;
        }()), false);
        lodash.sample = sample;
        lodash.prototype.sample = function(n) {
          if (!this.__chain__ && n == null) {
            return sample(this.value());
          }
          return this.thru(function(value) {
            return sample(value, n);
          });
        };
        lodash.VERSION = VERSION;
        arrayEach(['bind', 'bindKey', 'curry', 'curryRight', 'partial', 'partialRight'], function(methodName) {
          lodash[methodName].placeholder = lodash;
        });
        arrayEach(['filter', 'map', 'takeWhile'], function(methodName, index) {
          var isFilter = index == LAZY_FILTER_FLAG || index == LAZY_WHILE_FLAG;
          LazyWrapper.prototype[methodName] = function(iteratee, thisArg) {
            var result = this.clone(),
                iteratees = result.__iteratees__ || (result.__iteratees__ = []);
            result.__filtered__ = result.__filtered__ || isFilter;
            iteratees.push({
              'iteratee': getCallback(iteratee, thisArg, 3),
              'type': index
            });
            return result;
          };
        });
        arrayEach(['drop', 'take'], function(methodName, index) {
          var countName = '__' + methodName + 'Count__',
              whileName = methodName + 'While';
          LazyWrapper.prototype[methodName] = function(n) {
            n = n == null ? 1 : nativeMax(floor(n) || 0, 0);
            var result = this.clone();
            if (result.__filtered__) {
              var value = result[countName];
              result[countName] = index ? nativeMin(value, n) : (value + n);
            } else {
              var views = result.__views__ || (result.__views__ = []);
              views.push({
                'size': n,
                'type': methodName + (result.__dir__ < 0 ? 'Right' : '')
              });
            }
            return result;
          };
          LazyWrapper.prototype[methodName + 'Right'] = function(n) {
            return this.reverse()[methodName](n).reverse();
          };
          LazyWrapper.prototype[methodName + 'RightWhile'] = function(predicate, thisArg) {
            return this.reverse()[whileName](predicate, thisArg).reverse();
          };
        });
        arrayEach(['first', 'last'], function(methodName, index) {
          var takeName = 'take' + (index ? 'Right' : '');
          LazyWrapper.prototype[methodName] = function() {
            return this[takeName](1).value()[0];
          };
        });
        arrayEach(['initial', 'rest'], function(methodName, index) {
          var dropName = 'drop' + (index ? '' : 'Right');
          LazyWrapper.prototype[methodName] = function() {
            return this[dropName](1);
          };
        });
        arrayEach(['pluck', 'where'], function(methodName, index) {
          var operationName = index ? 'filter' : 'map',
              createCallback = index ? baseMatches : baseProperty;
          LazyWrapper.prototype[methodName] = function(value) {
            return this[operationName](createCallback(value));
          };
        });
        LazyWrapper.prototype.compact = function() {
          return this.filter(identity);
        };
        LazyWrapper.prototype.dropWhile = function(predicate, thisArg) {
          var done,
              lastIndex,
              isRight = this.__dir__ < 0;
          predicate = getCallback(predicate, thisArg, 3);
          return this.filter(function(value, index, array) {
            done = done && (isRight ? index < lastIndex : index > lastIndex);
            lastIndex = index;
            return done || (done = !predicate(value, index, array));
          });
        };
        LazyWrapper.prototype.reject = function(predicate, thisArg) {
          predicate = getCallback(predicate, thisArg, 3);
          return this.filter(function(value, index, array) {
            return !predicate(value, index, array);
          });
        };
        LazyWrapper.prototype.slice = function(start, end) {
          start = start == null ? 0 : (+start || 0);
          var result = start < 0 ? this.takeRight(-start) : this.drop(start);
          if (typeof end != 'undefined') {
            end = (+end || 0);
            result = end < 0 ? result.dropRight(-end) : result.take(end - start);
          }
          return result;
        };
        LazyWrapper.prototype.toArray = function() {
          return this.drop(0);
        };
        baseForOwn(LazyWrapper.prototype, function(func, methodName) {
          var lodashFunc = lodash[methodName],
              retUnwrapped = /^(?:first|last)$/.test(methodName);
          lodash.prototype[methodName] = function() {
            var value = this.__wrapped__,
                args = arguments,
                chainAll = this.__chain__,
                isHybrid = !!this.__actions__.length,
                isLazy = value instanceof LazyWrapper,
                onlyLazy = isLazy && !isHybrid;
            if (retUnwrapped && !chainAll) {
              return onlyLazy ? func.call(value) : lodashFunc.call(lodash, this.value());
            }
            var interceptor = function(value) {
              var otherArgs = [value];
              push.apply(otherArgs, args);
              return lodashFunc.apply(lodash, otherArgs);
            };
            if (isLazy || isArray(value)) {
              var wrapper = onlyLazy ? value : new LazyWrapper(this),
                  result = func.apply(wrapper, args);
              if (!retUnwrapped && (isHybrid || result.__actions__)) {
                var actions = result.__actions__ || (result.__actions__ = []);
                actions.push({
                  'func': thru,
                  'args': [interceptor],
                  'thisArg': lodash
                });
              }
              return new LodashWrapper(result, chainAll);
            }
            return this.thru(interceptor);
          };
        });
        arrayEach(['concat', 'join', 'pop', 'push', 'shift', 'sort', 'splice', 'unshift'], function(methodName) {
          var func = arrayProto[methodName],
              chainName = /^(?:push|sort|unshift)$/.test(methodName) ? 'tap' : 'thru',
              retUnwrapped = /^(?:join|pop|shift)$/.test(methodName);
          lodash.prototype[methodName] = function() {
            var args = arguments;
            if (retUnwrapped && !this.__chain__) {
              return func.apply(this.value(), args);
            }
            return this[chainName](function(value) {
              return func.apply(value, args);
            });
          };
        });
        LazyWrapper.prototype.clone = lazyClone;
        LazyWrapper.prototype.reverse = lazyReverse;
        LazyWrapper.prototype.value = lazyValue;
        lodash.prototype.chain = wrapperChain;
        lodash.prototype.commit = wrapperCommit;
        lodash.prototype.plant = wrapperPlant;
        lodash.prototype.reverse = wrapperReverse;
        lodash.prototype.toString = wrapperToString;
        lodash.prototype.run = lodash.prototype.toJSON = lodash.prototype.valueOf = lodash.prototype.value = wrapperValue;
        lodash.prototype.collect = lodash.prototype.map;
        lodash.prototype.head = lodash.prototype.first;
        lodash.prototype.select = lodash.prototype.filter;
        lodash.prototype.tail = lodash.prototype.rest;
        return lodash;
      }
      var _ = runInContext();
      if (typeof define == 'function' && typeof define.amd == 'object' && define.amd) {
        root._ = _;
        define(function() {
          return _;
        });
      } else if (freeExports && freeModule) {
        if (moduleExports) {
          (freeModule.exports = _)._ = _;
        } else {
          freeExports._ = _;
        }
      } else {
        root._ = _;
      }
    }.call(this));
  })(require("github:jspm/nodelibs-process@0.1.1"));
  global.define = __define;
  return module.exports;
});



System.register("app/mixins/path", [], function($__export) {
  "use strict";
  var __moduleName = "app/mixins/path";
  return {
    setters: [],
    execute: function() {
      $__export('default', {
        parentPath: function() {
          if (!this.props.parentPath) {
            console.warn('Warning: no parentPath set for', this.props.node);
          }
          return this.props.parentPath || '';
        },
        path: function() {
          return (this.parentPath() + "/" + this.props.node.type);
        },
        arrayPath: function(key, index) {
          return (this.path() + "." + key + "[" + index + "]");
        }
      });
    }
  };
});



System.register("app/mixins/render-node-property.jsx!github:floatdrop/plugin-jsx@0.1.1", ["npm:react@0.12.2", "app/ast-node.jsx!github:floatdrop/plugin-jsx@0.1.1"], function($__export) {
  "use strict";
  var __moduleName = "app/mixins/render-node-property.jsx!github:floatdrop/plugin-jsx@0.1.1";
  var React,
      ASTNode;
  return {
    setters: [function($__m) {
      React = $__m.default;
    }, function($__m) {
      ASTNode = $__m.default;
    }],
    execute: function() {
      $__export('default', {
        renderNode: function(propertyName) {
          var optional = arguments[1] !== (void 0) ? arguments[1] : false;
          if (optional && !this.props.node[propertyName]) {
            return null;
          }
          return (React.createElement("li", null, React.createElement(ASTNode, {
            node: this.props.node[propertyName],
            nodeKey: propertyName,
            parentPath: (this.path() + "." + propertyName)
          })));
        },
        renderProp: function(propertyName) {
          var optional = arguments[1] !== (void 0) ? arguments[1] : false;
          if (optional && !this.props.node[propertyName]) {
            return null;
          }
          return (React.createElement("li", {className: "node-property"}, React.createElement("strong", null, propertyName), this.props.node[propertyName]));
        },
        renderArrayProps: function(propertyName) {
          var optional = arguments[1] !== (void 0) ? arguments[1] : false;
          var $__0 = this;
          var items = this.props.node[propertyName].map((function(item, index) {
            return (React.createElement("li", {key: JSON.stringify(item)}, React.createElement(ASTNode, {
              nodeKey: (propertyName + "[" + index + "]"),
              node: item,
              parentPath: $__0.arrayPath(propertyName, index)
            })));
          }));
          if (optional && !items.length) {
            return null;
          }
          return items;
        }
      });
    }
  };
});



System.register("app/nodes/block-statement.jsx!github:floatdrop/plugin-jsx@0.1.1", ["npm:react@0.12.2", "app/ast-node.jsx!github:floatdrop/plugin-jsx@0.1.1", "app/mixins/path", "app/mixins/render-node-property.jsx!github:floatdrop/plugin-jsx@0.1.1"], function($__export) {
  "use strict";
  var __moduleName = "app/nodes/block-statement.jsx!github:floatdrop/plugin-jsx@0.1.1";
  var React,
      ASTNode,
      PathMixin,
      RenderNodeMixin;
  return {
    setters: [function($__m) {
      React = $__m.default;
    }, function($__m) {
      ASTNode = $__m.default;
    }, function($__m) {
      PathMixin = $__m.default;
    }, function($__m) {
      RenderNodeMixin = $__m.default;
    }],
    execute: function() {
      $__export('default', React.createClass({
        mixins: [PathMixin, RenderNodeMixin],
        render: function() {
          return (React.createElement("ul", null, this.renderArrayProps('body')));
        }
      }));
    }
  };
});



System.register("app/nodes/expression-statement.jsx!github:floatdrop/plugin-jsx@0.1.1", ["npm:react@0.12.2", "app/ast-node.jsx!github:floatdrop/plugin-jsx@0.1.1", "app/mixins/path", "app/mixins/render-node-property.jsx!github:floatdrop/plugin-jsx@0.1.1"], function($__export) {
  "use strict";
  var __moduleName = "app/nodes/expression-statement.jsx!github:floatdrop/plugin-jsx@0.1.1";
  var React,
      ASTNode,
      PathMixin,
      RenderNodeMixin;
  return {
    setters: [function($__m) {
      React = $__m.default;
    }, function($__m) {
      ASTNode = $__m.default;
    }, function($__m) {
      PathMixin = $__m.default;
    }, function($__m) {
      RenderNodeMixin = $__m.default;
    }],
    execute: function() {
      $__export('default', React.createClass({
        mixins: [PathMixin, RenderNodeMixin],
        render: function() {
          return (React.createElement("ul", null, this.renderNode('expression')));
        }
      }));
    }
  };
});



System.register("app/nodes/call-expression.jsx!github:floatdrop/plugin-jsx@0.1.1", ["npm:react@0.12.2", "app/ast-node.jsx!github:floatdrop/plugin-jsx@0.1.1", "app/mixins/path", "app/mixins/render-node-property.jsx!github:floatdrop/plugin-jsx@0.1.1"], function($__export) {
  "use strict";
  var __moduleName = "app/nodes/call-expression.jsx!github:floatdrop/plugin-jsx@0.1.1";
  var React,
      ASTNode,
      PathMixin,
      RenderNodeMixin;
  return {
    setters: [function($__m) {
      React = $__m.default;
    }, function($__m) {
      ASTNode = $__m.default;
    }, function($__m) {
      PathMixin = $__m.default;
    }, function($__m) {
      RenderNodeMixin = $__m.default;
    }],
    execute: function() {
      $__export('default', React.createClass({
        mixins: [PathMixin, RenderNodeMixin],
        render: function() {
          return (React.createElement("ul", null, this.renderNode('callee'), this.renderArrayProps('arguments', true)));
        }
      }));
    }
  };
});



System.register("app/nodes/member-expression.jsx!github:floatdrop/plugin-jsx@0.1.1", ["npm:react@0.12.2", "app/ast-node.jsx!github:floatdrop/plugin-jsx@0.1.1", "app/mixins/path", "app/mixins/render-node-property.jsx!github:floatdrop/plugin-jsx@0.1.1"], function($__export) {
  "use strict";
  var __moduleName = "app/nodes/member-expression.jsx!github:floatdrop/plugin-jsx@0.1.1";
  var React,
      ASTNode,
      PathMixin,
      RenderNodeMixin;
  return {
    setters: [function($__m) {
      React = $__m.default;
    }, function($__m) {
      ASTNode = $__m.default;
    }, function($__m) {
      PathMixin = $__m.default;
    }, function($__m) {
      RenderNodeMixin = $__m.default;
    }],
    execute: function() {
      $__export('default', React.createClass({
        mixins: [PathMixin, RenderNodeMixin],
        render: function() {
          return (React.createElement("ul", null, this.renderNode('object'), this.renderNode('property')));
        }
      }));
    }
  };
});



System.register("app/nodes/literal.jsx!github:floatdrop/plugin-jsx@0.1.1", ["npm:react@0.12.2", "app/mixins/render-node-property.jsx!github:floatdrop/plugin-jsx@0.1.1", "app/mixins/path"], function($__export) {
  "use strict";
  var __moduleName = "app/nodes/literal.jsx!github:floatdrop/plugin-jsx@0.1.1";
  var React,
      RenderNodeMixin,
      PathMixin;
  return {
    setters: [function($__m) {
      React = $__m.default;
    }, function($__m) {
      RenderNodeMixin = $__m.default;
    }, function($__m) {
      PathMixin = $__m.default;
    }],
    execute: function() {
      $__export('default', React.createClass({
        mixins: [PathMixin, RenderNodeMixin],
        render: function() {
          return (React.createElement("ul", null, this.renderProp('value')));
        }
      }));
    }
  };
});



System.register("app/nodes/identifier.jsx!github:floatdrop/plugin-jsx@0.1.1", ["npm:react@0.12.2", "app/mixins/render-node-property.jsx!github:floatdrop/plugin-jsx@0.1.1"], function($__export) {
  "use strict";
  var __moduleName = "app/nodes/identifier.jsx!github:floatdrop/plugin-jsx@0.1.1";
  var React,
      RenderNodeMixin;
  return {
    setters: [function($__m) {
      React = $__m.default;
    }, function($__m) {
      RenderNodeMixin = $__m.default;
    }],
    execute: function() {
      $__export('default', React.createClass({
        mixins: [RenderNodeMixin],
        render: function() {
          return (React.createElement("ul", null, " ", this.renderProp('name')));
        }
      }));
    }
  };
});



System.register("app/nodes/variable-declaration.jsx!github:floatdrop/plugin-jsx@0.1.1", ["npm:react@0.12.2", "app/ast-node.jsx!github:floatdrop/plugin-jsx@0.1.1", "app/mixins/path", "app/mixins/render-node-property.jsx!github:floatdrop/plugin-jsx@0.1.1"], function($__export) {
  "use strict";
  var __moduleName = "app/nodes/variable-declaration.jsx!github:floatdrop/plugin-jsx@0.1.1";
  var React,
      ASTNode,
      PathMixin,
      RenderNodeMixin;
  return {
    setters: [function($__m) {
      React = $__m.default;
    }, function($__m) {
      ASTNode = $__m.default;
    }, function($__m) {
      PathMixin = $__m.default;
    }, function($__m) {
      RenderNodeMixin = $__m.default;
    }],
    execute: function() {
      $__export('default', React.createClass({
        mixins: [PathMixin, RenderNodeMixin],
        getInitialState: function() {
          return {isFocused: false};
        },
        render: function() {
          return (React.createElement("ul", null, this.renderArrayProps('declarations')));
        }
      }));
    }
  };
});



System.register("app/nodes/variable-declarator.jsx!github:floatdrop/plugin-jsx@0.1.1", ["npm:react@0.12.2", "app/ast-node.jsx!github:floatdrop/plugin-jsx@0.1.1", "app/mixins/path", "app/mixins/render-node-property.jsx!github:floatdrop/plugin-jsx@0.1.1"], function($__export) {
  "use strict";
  var __moduleName = "app/nodes/variable-declarator.jsx!github:floatdrop/plugin-jsx@0.1.1";
  var React,
      ASTNode,
      PathMixin,
      RenderNodeMixin;
  return {
    setters: [function($__m) {
      React = $__m.default;
    }, function($__m) {
      ASTNode = $__m.default;
    }, function($__m) {
      PathMixin = $__m.default;
    }, function($__m) {
      RenderNodeMixin = $__m.default;
    }],
    execute: function() {
      $__export('default', React.createClass({
        mixins: [PathMixin, RenderNodeMixin],
        getInitialState: function() {
          return {isFocused: false};
        },
        render: function() {
          return (React.createElement("ul", null, this.renderNode('id'), this.renderNode('init', true)));
        }
      }));
    }
  };
});



System.register("app/nodes/object-expression.jsx!github:floatdrop/plugin-jsx@0.1.1", ["npm:react@0.12.2", "app/ast-node.jsx!github:floatdrop/plugin-jsx@0.1.1", "app/mixins/path", "app/mixins/render-node-property.jsx!github:floatdrop/plugin-jsx@0.1.1"], function($__export) {
  "use strict";
  var __moduleName = "app/nodes/object-expression.jsx!github:floatdrop/plugin-jsx@0.1.1";
  var React,
      ASTNode,
      PathMixin,
      RenderNodeMixin;
  return {
    setters: [function($__m) {
      React = $__m.default;
    }, function($__m) {
      ASTNode = $__m.default;
    }, function($__m) {
      PathMixin = $__m.default;
    }, function($__m) {
      RenderNodeMixin = $__m.default;
    }],
    execute: function() {
      $__export('default', React.createClass({
        mixins: [PathMixin, RenderNodeMixin],
        render: function() {
          return (React.createElement("ul", null, this.renderArrayProps('properties')));
        }
      }));
    }
  };
});



System.register("app/nodes/property.jsx!github:floatdrop/plugin-jsx@0.1.1", ["npm:react@0.12.2", "app/ast-node.jsx!github:floatdrop/plugin-jsx@0.1.1", "app/mixins/path", "app/mixins/render-node-property.jsx!github:floatdrop/plugin-jsx@0.1.1"], function($__export) {
  "use strict";
  var __moduleName = "app/nodes/property.jsx!github:floatdrop/plugin-jsx@0.1.1";
  var React,
      ASTNode,
      PathMixin,
      RenderNodeMixin;
  return {
    setters: [function($__m) {
      React = $__m.default;
    }, function($__m) {
      ASTNode = $__m.default;
    }, function($__m) {
      PathMixin = $__m.default;
    }, function($__m) {
      RenderNodeMixin = $__m.default;
    }],
    execute: function() {
      $__export('default', React.createClass({
        mixins: [PathMixin, RenderNodeMixin],
        render: function() {
          return (React.createElement("ul", null, this.renderNode('key'), this.renderNode('value')));
        }
      }));
    }
  };
});



System.register("app/nodes/function-expression.jsx!github:floatdrop/plugin-jsx@0.1.1", ["npm:react@0.12.2", "app/ast-node.jsx!github:floatdrop/plugin-jsx@0.1.1", "app/mixins/path", "app/mixins/render-node-property.jsx!github:floatdrop/plugin-jsx@0.1.1"], function($__export) {
  "use strict";
  var __moduleName = "app/nodes/function-expression.jsx!github:floatdrop/plugin-jsx@0.1.1";
  var React,
      ASTNode,
      PathMixin,
      RenderNodeMixin;
  return {
    setters: [function($__m) {
      React = $__m.default;
    }, function($__m) {
      ASTNode = $__m.default;
    }, function($__m) {
      PathMixin = $__m.default;
    }, function($__m) {
      RenderNodeMixin = $__m.default;
    }],
    execute: function() {
      $__export('default', React.createClass({
        mixins: [PathMixin, RenderNodeMixin],
        render: function() {
          return (React.createElement("ul", null, this.renderArrayProps('params', true), this.renderNode('body')));
        }
      }));
    }
  };
});



System.register("app/nodes/assignment-expression.jsx!github:floatdrop/plugin-jsx@0.1.1", ["npm:react@0.12.2", "app/ast-node.jsx!github:floatdrop/plugin-jsx@0.1.1", "app/mixins/path", "app/mixins/render-node-property.jsx!github:floatdrop/plugin-jsx@0.1.1"], function($__export) {
  "use strict";
  var __moduleName = "app/nodes/assignment-expression.jsx!github:floatdrop/plugin-jsx@0.1.1";
  var React,
      ASTNode,
      PathMixin,
      RenderNodeMixin;
  return {
    setters: [function($__m) {
      React = $__m.default;
    }, function($__m) {
      ASTNode = $__m.default;
    }, function($__m) {
      PathMixin = $__m.default;
    }, function($__m) {
      RenderNodeMixin = $__m.default;
    }],
    execute: function() {
      $__export('default', React.createClass({
        mixins: [PathMixin, RenderNodeMixin],
        render: function() {
          return (React.createElement("ul", null, this.renderProp('operator'), this.renderNode('left'), this.renderNode('right')));
        }
      }));
    }
  };
});



System.register("app/nodes/this-expression.jsx!github:floatdrop/plugin-jsx@0.1.1", ["npm:react@0.12.2"], function($__export) {
  "use strict";
  var __moduleName = "app/nodes/this-expression.jsx!github:floatdrop/plugin-jsx@0.1.1";
  var React;
  return {
    setters: [function($__m) {
      React = $__m.default;
    }],
    execute: function() {
      $__export('default', React.createClass({render: function() {
          return null;
        }}));
    }
  };
});



System.register("app/nodes/return-statement.jsx!github:floatdrop/plugin-jsx@0.1.1", ["npm:react@0.12.2", "app/ast-node.jsx!github:floatdrop/plugin-jsx@0.1.1", "app/mixins/path", "app/mixins/render-node-property.jsx!github:floatdrop/plugin-jsx@0.1.1"], function($__export) {
  "use strict";
  var __moduleName = "app/nodes/return-statement.jsx!github:floatdrop/plugin-jsx@0.1.1";
  var React,
      ASTNode,
      PathMixin,
      RenderNodeMixin;
  return {
    setters: [function($__m) {
      React = $__m.default;
    }, function($__m) {
      ASTNode = $__m.default;
    }, function($__m) {
      PathMixin = $__m.default;
    }, function($__m) {
      RenderNodeMixin = $__m.default;
    }],
    execute: function() {
      $__export('default', React.createClass({
        mixins: [PathMixin, RenderNodeMixin],
        render: function() {
          return (React.createElement("ul", null, this.renderNode('argument')));
        }
      }));
    }
  };
});



System.register("app/nodes/binary-expression.jsx!github:floatdrop/plugin-jsx@0.1.1", ["npm:react@0.12.2", "app/ast-node.jsx!github:floatdrop/plugin-jsx@0.1.1", "app/mixins/path", "app/mixins/render-node-property.jsx!github:floatdrop/plugin-jsx@0.1.1"], function($__export) {
  "use strict";
  var __moduleName = "app/nodes/binary-expression.jsx!github:floatdrop/plugin-jsx@0.1.1";
  var React,
      ASTNode,
      PathMixin,
      RenderNodeMixin;
  return {
    setters: [function($__m) {
      React = $__m.default;
    }, function($__m) {
      ASTNode = $__m.default;
    }, function($__m) {
      PathMixin = $__m.default;
    }, function($__m) {
      RenderNodeMixin = $__m.default;
    }],
    execute: function() {
      $__export('default', React.createClass({
        mixins: [PathMixin, RenderNodeMixin],
        render: function() {
          return (React.createElement("ul", null, this.renderNode('left'), this.renderNode('right')));
        }
      }));
    }
  };
});



System.register("app/nodes/for-statement.jsx!github:floatdrop/plugin-jsx@0.1.1", ["npm:react@0.12.2", "app/ast-node.jsx!github:floatdrop/plugin-jsx@0.1.1", "app/mixins/path", "app/mixins/render-node-property.jsx!github:floatdrop/plugin-jsx@0.1.1"], function($__export) {
  "use strict";
  var __moduleName = "app/nodes/for-statement.jsx!github:floatdrop/plugin-jsx@0.1.1";
  var React,
      ASTNode,
      PathMixin,
      RenderNodeMixin;
  return {
    setters: [function($__m) {
      React = $__m.default;
    }, function($__m) {
      ASTNode = $__m.default;
    }, function($__m) {
      PathMixin = $__m.default;
    }, function($__m) {
      RenderNodeMixin = $__m.default;
    }],
    execute: function() {
      $__export('default', React.createClass({
        mixins: [PathMixin, RenderNodeMixin],
        render: function() {
          return (React.createElement("ul", null, this.renderNode('init'), this.renderNode('test'), this.renderNode('update'), this.renderNode('body')));
        }
      }));
    }
  };
});



System.register("app/nodes/update-expression.jsx!github:floatdrop/plugin-jsx@0.1.1", ["npm:react@0.12.2", "app/ast-node.jsx!github:floatdrop/plugin-jsx@0.1.1", "app/mixins/path", "app/mixins/render-node-property.jsx!github:floatdrop/plugin-jsx@0.1.1"], function($__export) {
  "use strict";
  var __moduleName = "app/nodes/update-expression.jsx!github:floatdrop/plugin-jsx@0.1.1";
  var React,
      ASTNode,
      PathMixin,
      RenderNodeMixin;
  return {
    setters: [function($__m) {
      React = $__m.default;
    }, function($__m) {
      ASTNode = $__m.default;
    }, function($__m) {
      PathMixin = $__m.default;
    }, function($__m) {
      RenderNodeMixin = $__m.default;
    }],
    execute: function() {
      $__export('default', React.createClass({
        mixins: [PathMixin, RenderNodeMixin],
        render: function() {
          return (React.createElement("ul", null, this.renderProp('operator'), this.renderProp('prefix'), this.renderNode('argument')));
        }
      }));
    }
  };
});



System.register("app/nodes/if-statement.jsx!github:floatdrop/plugin-jsx@0.1.1", ["npm:react@0.12.2", "app/ast-node.jsx!github:floatdrop/plugin-jsx@0.1.1", "app/mixins/path", "app/mixins/render-node-property.jsx!github:floatdrop/plugin-jsx@0.1.1"], function($__export) {
  "use strict";
  var __moduleName = "app/nodes/if-statement.jsx!github:floatdrop/plugin-jsx@0.1.1";
  var React,
      ASTNode,
      PathMixin,
      RenderNodeMixin;
  return {
    setters: [function($__m) {
      React = $__m.default;
    }, function($__m) {
      ASTNode = $__m.default;
    }, function($__m) {
      PathMixin = $__m.default;
    }, function($__m) {
      RenderNodeMixin = $__m.default;
    }],
    execute: function() {
      $__export('default', React.createClass({
        mixins: [PathMixin, RenderNodeMixin],
        render: function() {
          return (React.createElement("ul", null, this.renderNode('test'), this.renderNode('consequent'), this.renderNode('alternate', true)));
        }
      }));
    }
  };
});



System.register("app/nodes/break-statement.jsx!github:floatdrop/plugin-jsx@0.1.1", ["npm:react@0.12.2", "app/mixins/render-node-property.jsx!github:floatdrop/plugin-jsx@0.1.1"], function($__export) {
  "use strict";
  var __moduleName = "app/nodes/break-statement.jsx!github:floatdrop/plugin-jsx@0.1.1";
  var React,
      RenderNodeMixin;
  return {
    setters: [function($__m) {
      React = $__m.default;
    }, function($__m) {
      RenderNodeMixin = $__m.default;
    }],
    execute: function() {
      $__export('default', React.createClass({
        mixins: [RenderNodeMixin],
        render: function() {
          return this.renderProp('label', true);
        }
      }));
    }
  };
});



System.register("app/mixins/toggle", ["app/event"], function($__export) {
  "use strict";
  var __moduleName = "app/mixins/toggle";
  var emitter;
  return {
    setters: [function($__m) {
      emitter = $__m.default;
    }],
    execute: function() {
      $__export('default', {
        onToggleAll: function(data) {
          if (data && data.visible) {
            this.setState({visible: data.visible});
          } else {
            this.setState({visible: !this.state.visible});
          }
        },
        componentWillUnmount: function() {
          emitter.off('toggle-all', this.onToggleAll);
        },
        componentWillMount: function() {
          emitter.on('toggle-all', this.onToggleAll);
        },
        getInitialState: function() {
          return {visible: false};
        },
        onToggleClick: function() {
          this.setState({visible: !this.state.visible});
        }
      });
    }
  };
});



System.register("app/path.jsx!github:floatdrop/plugin-jsx@0.1.1", ["npm:react@0.12.2"], function($__export) {
  "use strict";
  var __moduleName = "app/path.jsx!github:floatdrop/plugin-jsx@0.1.1";
  var React;
  return {
    setters: [function($__m) {
      React = $__m.default;
    }],
    execute: function() {
      $__export('default', React.createClass({render: function() {
          if (!this.props.visible)
            return null;
          return (React.createElement("div", {className: "path"}, React.createElement("code", null, this.props.path)));
        }}));
    }
  };
});



System.register("app/node-location.jsx!github:floatdrop/plugin-jsx@0.1.1", ["npm:react@0.12.2"], function($__export) {
  "use strict";
  var __moduleName = "app/node-location.jsx!github:floatdrop/plugin-jsx@0.1.1";
  var React;
  return {
    setters: [function($__m) {
      React = $__m.default;
    }],
    execute: function() {
      $__export('default', React.createClass({render: function() {
          return (React.createElement("span", {className: "node-location"}, "Lines ", this.props.loc.start.line, " to ", this.props.loc.end.line));
        }}));
    }
  };
});



System.register("app/null-nodes", [], function($__export) {
  "use strict";
  var __moduleName = "app/null-nodes";
  return {
    setters: [],
    execute: function() {
      $__export('default', ['ThisExpression']);
    }
  };
});



System.register("app/starting-code.js!github:systemjs/plugin-text@0.0.2", [], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  module.exports = "var x = obj.init({\n  foo: true,\n  bar: false,\n  x: function() {\n    return 2;\n  }\n});\n\n";
  global.define = __define;
  return module.exports;
});



System.register("npm:process@0.10.1", ["npm:process@0.10.1/browser"], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  module.exports = require("npm:process@0.10.1/browser");
  global.define = __define;
  return module.exports;
});



System.register("npm:react@0.12.2/lib/warning", ["npm:react@0.12.2/lib/emptyFunction", "github:jspm/nodelibs-process@0.1.1"], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  (function(process) {
    "use strict";
    var emptyFunction = require("npm:react@0.12.2/lib/emptyFunction");
    var warning = emptyFunction;
    if ("production" !== process.env.NODE_ENV) {
      warning = function(condition, format) {
        for (var args = [],
            $__0 = 2,
            $__1 = arguments.length; $__0 < $__1; $__0++)
          args.push(arguments[$__0]);
        if (format === undefined) {
          throw new Error('`warning(condition, format, ...args)` requires a warning ' + 'message argument');
        }
        if (!condition) {
          var argIndex = 0;
          console.warn('Warning: ' + format.replace(/%s/g, function() {
            return args[argIndex++];
          }));
        }
      };
    }
    module.exports = warning;
  })(require("github:jspm/nodelibs-process@0.1.1"));
  global.define = __define;
  return module.exports;
});



System.register("npm:react@0.12.2/lib/EventConstants", ["npm:react@0.12.2/lib/keyMirror"], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  "use strict";
  var keyMirror = require("npm:react@0.12.2/lib/keyMirror");
  var PropagationPhases = keyMirror({
    bubbled: null,
    captured: null
  });
  var topLevelTypes = keyMirror({
    topBlur: null,
    topChange: null,
    topClick: null,
    topCompositionEnd: null,
    topCompositionStart: null,
    topCompositionUpdate: null,
    topContextMenu: null,
    topCopy: null,
    topCut: null,
    topDoubleClick: null,
    topDrag: null,
    topDragEnd: null,
    topDragEnter: null,
    topDragExit: null,
    topDragLeave: null,
    topDragOver: null,
    topDragStart: null,
    topDrop: null,
    topError: null,
    topFocus: null,
    topInput: null,
    topKeyDown: null,
    topKeyPress: null,
    topKeyUp: null,
    topLoad: null,
    topMouseDown: null,
    topMouseMove: null,
    topMouseOut: null,
    topMouseOver: null,
    topMouseUp: null,
    topPaste: null,
    topReset: null,
    topScroll: null,
    topSelectionChange: null,
    topSubmit: null,
    topTextInput: null,
    topTouchCancel: null,
    topTouchEnd: null,
    topTouchMove: null,
    topTouchStart: null,
    topWheel: null
  });
  var EventConstants = {
    topLevelTypes: topLevelTypes,
    PropagationPhases: PropagationPhases
  };
  module.exports = EventConstants;
  global.define = __define;
  return module.exports;
});



System.register("npm:react@0.12.2/lib/ReactContext", ["npm:react@0.12.2/lib/Object.assign"], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  "use strict";
  var assign = require("npm:react@0.12.2/lib/Object.assign");
  var ReactContext = {
    current: {},
    withContext: function(newContext, scopedCallback) {
      var result;
      var previousContext = ReactContext.current;
      ReactContext.current = assign({}, previousContext, newContext);
      try {
        result = scopedCallback();
      } finally {
        ReactContext.current = previousContext;
      }
      return result;
    }
  };
  module.exports = ReactContext;
  global.define = __define;
  return module.exports;
});



System.register("npm:react@0.12.2/lib/ReactInstanceHandles", ["npm:react@0.12.2/lib/ReactRootIndex", "npm:react@0.12.2/lib/invariant", "github:jspm/nodelibs-process@0.1.1"], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  (function(process) {
    "use strict";
    var ReactRootIndex = require("npm:react@0.12.2/lib/ReactRootIndex");
    var invariant = require("npm:react@0.12.2/lib/invariant");
    var SEPARATOR = '.';
    var SEPARATOR_LENGTH = SEPARATOR.length;
    var MAX_TREE_DEPTH = 100;
    function getReactRootIDString(index) {
      return SEPARATOR + index.toString(36);
    }
    function isBoundary(id, index) {
      return id.charAt(index) === SEPARATOR || index === id.length;
    }
    function isValidID(id) {
      return id === '' || (id.charAt(0) === SEPARATOR && id.charAt(id.length - 1) !== SEPARATOR);
    }
    function isAncestorIDOf(ancestorID, descendantID) {
      return (descendantID.indexOf(ancestorID) === 0 && isBoundary(descendantID, ancestorID.length));
    }
    function getParentID(id) {
      return id ? id.substr(0, id.lastIndexOf(SEPARATOR)) : '';
    }
    function getNextDescendantID(ancestorID, destinationID) {
      ("production" !== process.env.NODE_ENV ? invariant(isValidID(ancestorID) && isValidID(destinationID), 'getNextDescendantID(%s, %s): Received an invalid React DOM ID.', ancestorID, destinationID) : invariant(isValidID(ancestorID) && isValidID(destinationID)));
      ("production" !== process.env.NODE_ENV ? invariant(isAncestorIDOf(ancestorID, destinationID), 'getNextDescendantID(...): React has made an invalid assumption about ' + 'the DOM hierarchy. Expected `%s` to be an ancestor of `%s`.', ancestorID, destinationID) : invariant(isAncestorIDOf(ancestorID, destinationID)));
      if (ancestorID === destinationID) {
        return ancestorID;
      }
      var start = ancestorID.length + SEPARATOR_LENGTH;
      for (var i = start; i < destinationID.length; i++) {
        if (isBoundary(destinationID, i)) {
          break;
        }
      }
      return destinationID.substr(0, i);
    }
    function getFirstCommonAncestorID(oneID, twoID) {
      var minLength = Math.min(oneID.length, twoID.length);
      if (minLength === 0) {
        return '';
      }
      var lastCommonMarkerIndex = 0;
      for (var i = 0; i <= minLength; i++) {
        if (isBoundary(oneID, i) && isBoundary(twoID, i)) {
          lastCommonMarkerIndex = i;
        } else if (oneID.charAt(i) !== twoID.charAt(i)) {
          break;
        }
      }
      var longestCommonID = oneID.substr(0, lastCommonMarkerIndex);
      ("production" !== process.env.NODE_ENV ? invariant(isValidID(longestCommonID), 'getFirstCommonAncestorID(%s, %s): Expected a valid React DOM ID: %s', oneID, twoID, longestCommonID) : invariant(isValidID(longestCommonID)));
      return longestCommonID;
    }
    function traverseParentPath(start, stop, cb, arg, skipFirst, skipLast) {
      start = start || '';
      stop = stop || '';
      ("production" !== process.env.NODE_ENV ? invariant(start !== stop, 'traverseParentPath(...): Cannot traverse from and to the same ID, `%s`.', start) : invariant(start !== stop));
      var traverseUp = isAncestorIDOf(stop, start);
      ("production" !== process.env.NODE_ENV ? invariant(traverseUp || isAncestorIDOf(start, stop), 'traverseParentPath(%s, %s, ...): Cannot traverse from two IDs that do ' + 'not have a parent path.', start, stop) : invariant(traverseUp || isAncestorIDOf(start, stop)));
      var depth = 0;
      var traverse = traverseUp ? getParentID : getNextDescendantID;
      for (var id = start; ; id = traverse(id, stop)) {
        var ret;
        if ((!skipFirst || id !== start) && (!skipLast || id !== stop)) {
          ret = cb(id, traverseUp, arg);
        }
        if (ret === false || id === stop) {
          break;
        }
        ("production" !== process.env.NODE_ENV ? invariant(depth++ < MAX_TREE_DEPTH, 'traverseParentPath(%s, %s, ...): Detected an infinite loop while ' + 'traversing the React DOM ID tree. This may be due to malformed IDs: %s', start, stop) : invariant(depth++ < MAX_TREE_DEPTH));
      }
    }
    var ReactInstanceHandles = {
      createReactRootID: function() {
        return getReactRootIDString(ReactRootIndex.createReactRootIndex());
      },
      createReactID: function(rootID, name) {
        return rootID + name;
      },
      getReactRootIDFromNodeID: function(id) {
        if (id && id.charAt(0) === SEPARATOR && id.length > 1) {
          var index = id.indexOf(SEPARATOR, 1);
          return index > -1 ? id.substr(0, index) : id;
        }
        return null;
      },
      traverseEnterLeave: function(leaveID, enterID, cb, upArg, downArg) {
        var ancestorID = getFirstCommonAncestorID(leaveID, enterID);
        if (ancestorID !== leaveID) {
          traverseParentPath(leaveID, ancestorID, cb, upArg, false, true);
        }
        if (ancestorID !== enterID) {
          traverseParentPath(ancestorID, enterID, cb, downArg, true, false);
        }
      },
      traverseTwoPhase: function(targetID, cb, arg) {
        if (targetID) {
          traverseParentPath('', targetID, cb, arg, true, false);
          traverseParentPath(targetID, '', cb, arg, false, true);
        }
      },
      traverseAncestors: function(targetID, cb, arg) {
        traverseParentPath('', targetID, cb, arg, true, false);
      },
      _getFirstCommonAncestorID: getFirstCommonAncestorID,
      _getNextDescendantID: getNextDescendantID,
      isAncestorIDOf: isAncestorIDOf,
      SEPARATOR: SEPARATOR
    };
    module.exports = ReactInstanceHandles;
  })(require("github:jspm/nodelibs-process@0.1.1"));
  global.define = __define;
  return module.exports;
});



System.register("npm:react@0.12.2/lib/ReactOwner", ["npm:react@0.12.2/lib/emptyObject", "npm:react@0.12.2/lib/invariant", "github:jspm/nodelibs-process@0.1.1"], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  (function(process) {
    "use strict";
    var emptyObject = require("npm:react@0.12.2/lib/emptyObject");
    var invariant = require("npm:react@0.12.2/lib/invariant");
    var ReactOwner = {
      isValidOwner: function(object) {
        return !!(object && typeof object.attachRef === 'function' && typeof object.detachRef === 'function');
      },
      addComponentAsRefTo: function(component, ref, owner) {
        ("production" !== process.env.NODE_ENV ? invariant(ReactOwner.isValidOwner(owner), 'addComponentAsRefTo(...): Only a ReactOwner can have refs. This ' + 'usually means that you\'re trying to add a ref to a component that ' + 'doesn\'t have an owner (that is, was not created inside of another ' + 'component\'s `render` method). Try rendering this component inside of ' + 'a new top-level component which will hold the ref.') : invariant(ReactOwner.isValidOwner(owner)));
        owner.attachRef(ref, component);
      },
      removeComponentAsRefFrom: function(component, ref, owner) {
        ("production" !== process.env.NODE_ENV ? invariant(ReactOwner.isValidOwner(owner), 'removeComponentAsRefFrom(...): Only a ReactOwner can have refs. This ' + 'usually means that you\'re trying to remove a ref to a component that ' + 'doesn\'t have an owner (that is, was not created inside of another ' + 'component\'s `render` method). Try rendering this component inside of ' + 'a new top-level component which will hold the ref.') : invariant(ReactOwner.isValidOwner(owner)));
        if (owner.refs[ref] === component) {
          owner.detachRef(ref);
        }
      },
      Mixin: {
        construct: function() {
          this.refs = emptyObject;
        },
        attachRef: function(ref, component) {
          ("production" !== process.env.NODE_ENV ? invariant(component.isOwnedBy(this), 'attachRef(%s, ...): Only a component\'s owner can store a ref to it.', ref) : invariant(component.isOwnedBy(this)));
          var refs = this.refs === emptyObject ? (this.refs = {}) : this.refs;
          refs[ref] = component;
        },
        detachRef: function(ref) {
          delete this.refs[ref];
        }
      }
    };
    module.exports = ReactOwner;
  })(require("github:jspm/nodelibs-process@0.1.1"));
  global.define = __define;
  return module.exports;
});



System.register("npm:react@0.12.2/lib/ReactUpdates", ["npm:react@0.12.2/lib/CallbackQueue", "npm:react@0.12.2/lib/PooledClass", "npm:react@0.12.2/lib/ReactCurrentOwner", "npm:react@0.12.2/lib/ReactPerf", "npm:react@0.12.2/lib/Transaction", "npm:react@0.12.2/lib/Object.assign", "npm:react@0.12.2/lib/invariant", "npm:react@0.12.2/lib/warning", "github:jspm/nodelibs-process@0.1.1"], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  (function(process) {
    "use strict";
    var CallbackQueue = require("npm:react@0.12.2/lib/CallbackQueue");
    var PooledClass = require("npm:react@0.12.2/lib/PooledClass");
    var ReactCurrentOwner = require("npm:react@0.12.2/lib/ReactCurrentOwner");
    var ReactPerf = require("npm:react@0.12.2/lib/ReactPerf");
    var Transaction = require("npm:react@0.12.2/lib/Transaction");
    var assign = require("npm:react@0.12.2/lib/Object.assign");
    var invariant = require("npm:react@0.12.2/lib/invariant");
    var warning = require("npm:react@0.12.2/lib/warning");
    var dirtyComponents = [];
    var asapCallbackQueue = CallbackQueue.getPooled();
    var asapEnqueued = false;
    var batchingStrategy = null;
    function ensureInjected() {
      ("production" !== process.env.NODE_ENV ? invariant(ReactUpdates.ReactReconcileTransaction && batchingStrategy, 'ReactUpdates: must inject a reconcile transaction class and batching ' + 'strategy') : invariant(ReactUpdates.ReactReconcileTransaction && batchingStrategy));
    }
    var NESTED_UPDATES = {
      initialize: function() {
        this.dirtyComponentsLength = dirtyComponents.length;
      },
      close: function() {
        if (this.dirtyComponentsLength !== dirtyComponents.length) {
          dirtyComponents.splice(0, this.dirtyComponentsLength);
          flushBatchedUpdates();
        } else {
          dirtyComponents.length = 0;
        }
      }
    };
    var UPDATE_QUEUEING = {
      initialize: function() {
        this.callbackQueue.reset();
      },
      close: function() {
        this.callbackQueue.notifyAll();
      }
    };
    var TRANSACTION_WRAPPERS = [NESTED_UPDATES, UPDATE_QUEUEING];
    function ReactUpdatesFlushTransaction() {
      this.reinitializeTransaction();
      this.dirtyComponentsLength = null;
      this.callbackQueue = CallbackQueue.getPooled();
      this.reconcileTransaction = ReactUpdates.ReactReconcileTransaction.getPooled();
    }
    assign(ReactUpdatesFlushTransaction.prototype, Transaction.Mixin, {
      getTransactionWrappers: function() {
        return TRANSACTION_WRAPPERS;
      },
      destructor: function() {
        this.dirtyComponentsLength = null;
        CallbackQueue.release(this.callbackQueue);
        this.callbackQueue = null;
        ReactUpdates.ReactReconcileTransaction.release(this.reconcileTransaction);
        this.reconcileTransaction = null;
      },
      perform: function(method, scope, a) {
        return Transaction.Mixin.perform.call(this, this.reconcileTransaction.perform, this.reconcileTransaction, method, scope, a);
      }
    });
    PooledClass.addPoolingTo(ReactUpdatesFlushTransaction);
    function batchedUpdates(callback, a, b) {
      ensureInjected();
      batchingStrategy.batchedUpdates(callback, a, b);
    }
    function mountDepthComparator(c1, c2) {
      return c1._mountDepth - c2._mountDepth;
    }
    function runBatchedUpdates(transaction) {
      var len = transaction.dirtyComponentsLength;
      ("production" !== process.env.NODE_ENV ? invariant(len === dirtyComponents.length, 'Expected flush transaction\'s stored dirty-components length (%s) to ' + 'match dirty-components array length (%s).', len, dirtyComponents.length) : invariant(len === dirtyComponents.length));
      dirtyComponents.sort(mountDepthComparator);
      for (var i = 0; i < len; i++) {
        var component = dirtyComponents[i];
        if (component.isMounted()) {
          var callbacks = component._pendingCallbacks;
          component._pendingCallbacks = null;
          component.performUpdateIfNecessary(transaction.reconcileTransaction);
          if (callbacks) {
            for (var j = 0; j < callbacks.length; j++) {
              transaction.callbackQueue.enqueue(callbacks[j], component);
            }
          }
        }
      }
    }
    var flushBatchedUpdates = ReactPerf.measure('ReactUpdates', 'flushBatchedUpdates', function() {
      while (dirtyComponents.length || asapEnqueued) {
        if (dirtyComponents.length) {
          var transaction = ReactUpdatesFlushTransaction.getPooled();
          transaction.perform(runBatchedUpdates, null, transaction);
          ReactUpdatesFlushTransaction.release(transaction);
        }
        if (asapEnqueued) {
          asapEnqueued = false;
          var queue = asapCallbackQueue;
          asapCallbackQueue = CallbackQueue.getPooled();
          queue.notifyAll();
          CallbackQueue.release(queue);
        }
      }
    });
    function enqueueUpdate(component, callback) {
      ("production" !== process.env.NODE_ENV ? invariant(!callback || typeof callback === "function", 'enqueueUpdate(...): You called `setProps`, `replaceProps`, ' + '`setState`, `replaceState`, or `forceUpdate` with a callback that ' + 'isn\'t callable.') : invariant(!callback || typeof callback === "function"));
      ensureInjected();
      ("production" !== process.env.NODE_ENV ? warning(ReactCurrentOwner.current == null, 'enqueueUpdate(): Render methods should be a pure function of props ' + 'and state; triggering nested component updates from render is not ' + 'allowed. If necessary, trigger nested updates in ' + 'componentDidUpdate.') : null);
      if (!batchingStrategy.isBatchingUpdates) {
        batchingStrategy.batchedUpdates(enqueueUpdate, component, callback);
        return ;
      }
      dirtyComponents.push(component);
      if (callback) {
        if (component._pendingCallbacks) {
          component._pendingCallbacks.push(callback);
        } else {
          component._pendingCallbacks = [callback];
        }
      }
    }
    function asap(callback, context) {
      ("production" !== process.env.NODE_ENV ? invariant(batchingStrategy.isBatchingUpdates, 'ReactUpdates.asap: Can\'t enqueue an asap callback in a context where' + 'updates are not being batched.') : invariant(batchingStrategy.isBatchingUpdates));
      asapCallbackQueue.enqueue(callback, context);
      asapEnqueued = true;
    }
    var ReactUpdatesInjection = {
      injectReconcileTransaction: function(ReconcileTransaction) {
        ("production" !== process.env.NODE_ENV ? invariant(ReconcileTransaction, 'ReactUpdates: must provide a reconcile transaction class') : invariant(ReconcileTransaction));
        ReactUpdates.ReactReconcileTransaction = ReconcileTransaction;
      },
      injectBatchingStrategy: function(_batchingStrategy) {
        ("production" !== process.env.NODE_ENV ? invariant(_batchingStrategy, 'ReactUpdates: must provide a batching strategy') : invariant(_batchingStrategy));
        ("production" !== process.env.NODE_ENV ? invariant(typeof _batchingStrategy.batchedUpdates === 'function', 'ReactUpdates: must provide a batchedUpdates() function') : invariant(typeof _batchingStrategy.batchedUpdates === 'function'));
        ("production" !== process.env.NODE_ENV ? invariant(typeof _batchingStrategy.isBatchingUpdates === 'boolean', 'ReactUpdates: must provide an isBatchingUpdates boolean attribute') : invariant(typeof _batchingStrategy.isBatchingUpdates === 'boolean'));
        batchingStrategy = _batchingStrategy;
      }
    };
    var ReactUpdates = {
      ReactReconcileTransaction: null,
      batchedUpdates: batchedUpdates,
      enqueueUpdate: enqueueUpdate,
      flushBatchedUpdates: flushBatchedUpdates,
      injection: ReactUpdatesInjection,
      asap: asap
    };
    module.exports = ReactUpdates;
  })(require("github:jspm/nodelibs-process@0.1.1"));
  global.define = __define;
  return module.exports;
});



System.register("npm:react@0.12.2/lib/ReactElementValidator", ["npm:react@0.12.2/lib/ReactElement", "npm:react@0.12.2/lib/ReactPropTypeLocations", "npm:react@0.12.2/lib/ReactCurrentOwner", "npm:react@0.12.2/lib/monitorCodeUse", "npm:react@0.12.2/lib/warning", "github:jspm/nodelibs-process@0.1.1"], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  (function(process) {
    "use strict";
    var ReactElement = require("npm:react@0.12.2/lib/ReactElement");
    var ReactPropTypeLocations = require("npm:react@0.12.2/lib/ReactPropTypeLocations");
    var ReactCurrentOwner = require("npm:react@0.12.2/lib/ReactCurrentOwner");
    var monitorCodeUse = require("npm:react@0.12.2/lib/monitorCodeUse");
    var warning = require("npm:react@0.12.2/lib/warning");
    var ownerHasKeyUseWarning = {
      'react_key_warning': {},
      'react_numeric_key_warning': {}
    };
    var ownerHasMonitoredObjectMap = {};
    var loggedTypeFailures = {};
    var NUMERIC_PROPERTY_REGEX = /^\d+$/;
    function getCurrentOwnerDisplayName() {
      var current = ReactCurrentOwner.current;
      return current && current.constructor.displayName || undefined;
    }
    function validateExplicitKey(component, parentType) {
      if (component._store.validated || component.key != null) {
        return ;
      }
      component._store.validated = true;
      warnAndMonitorForKeyUse('react_key_warning', 'Each child in an array should have a unique "key" prop.', component, parentType);
    }
    function validatePropertyKey(name, component, parentType) {
      if (!NUMERIC_PROPERTY_REGEX.test(name)) {
        return ;
      }
      warnAndMonitorForKeyUse('react_numeric_key_warning', 'Child objects should have non-numeric keys so ordering is preserved.', component, parentType);
    }
    function warnAndMonitorForKeyUse(warningID, message, component, parentType) {
      var ownerName = getCurrentOwnerDisplayName();
      var parentName = parentType.displayName;
      var useName = ownerName || parentName;
      var memoizer = ownerHasKeyUseWarning[warningID];
      if (memoizer.hasOwnProperty(useName)) {
        return ;
      }
      memoizer[useName] = true;
      message += ownerName ? (" Check the render method of " + ownerName + ".") : (" Check the renderComponent call using <" + parentName + ">.");
      var childOwnerName = null;
      if (component._owner && component._owner !== ReactCurrentOwner.current) {
        childOwnerName = component._owner.constructor.displayName;
        message += (" It was passed a child from " + childOwnerName + ".");
      }
      message += ' See http://fb.me/react-warning-keys for more information.';
      monitorCodeUse(warningID, {
        component: useName,
        componentOwner: childOwnerName
      });
      console.warn(message);
    }
    function monitorUseOfObjectMap() {
      var currentName = getCurrentOwnerDisplayName() || '';
      if (ownerHasMonitoredObjectMap.hasOwnProperty(currentName)) {
        return ;
      }
      ownerHasMonitoredObjectMap[currentName] = true;
      monitorCodeUse('react_object_map_children');
    }
    function validateChildKeys(component, parentType) {
      if (Array.isArray(component)) {
        for (var i = 0; i < component.length; i++) {
          var child = component[i];
          if (ReactElement.isValidElement(child)) {
            validateExplicitKey(child, parentType);
          }
        }
      } else if (ReactElement.isValidElement(component)) {
        component._store.validated = true;
      } else if (component && typeof component === 'object') {
        monitorUseOfObjectMap();
        for (var name in component) {
          validatePropertyKey(name, component[name], parentType);
        }
      }
    }
    function checkPropTypes(componentName, propTypes, props, location) {
      for (var propName in propTypes) {
        if (propTypes.hasOwnProperty(propName)) {
          var error;
          try {
            error = propTypes[propName](props, propName, componentName, location);
          } catch (ex) {
            error = ex;
          }
          if (error instanceof Error && !(error.message in loggedTypeFailures)) {
            loggedTypeFailures[error.message] = true;
            monitorCodeUse('react_failed_descriptor_type_check', {message: error.message});
          }
        }
      }
    }
    var ReactElementValidator = {
      createElement: function(type, props, children) {
        ("production" !== process.env.NODE_ENV ? warning(type != null, 'React.createElement: type should not be null or undefined. It should ' + 'be a string (for DOM elements) or a ReactClass (for composite ' + 'components).') : null);
        var element = ReactElement.createElement.apply(this, arguments);
        if (element == null) {
          return element;
        }
        for (var i = 2; i < arguments.length; i++) {
          validateChildKeys(arguments[i], type);
        }
        if (type) {
          var name = type.displayName;
          if (type.propTypes) {
            checkPropTypes(name, type.propTypes, element.props, ReactPropTypeLocations.prop);
          }
          if (type.contextTypes) {
            checkPropTypes(name, type.contextTypes, element._context, ReactPropTypeLocations.context);
          }
        }
        return element;
      },
      createFactory: function(type) {
        var validatedFactory = ReactElementValidator.createElement.bind(null, type);
        validatedFactory.type = type;
        return validatedFactory;
      }
    };
    module.exports = ReactElementValidator;
  })(require("github:jspm/nodelibs-process@0.1.1"));
  global.define = __define;
  return module.exports;
});



System.register("npm:react@0.12.2/lib/ReactPropTransferer", ["npm:react@0.12.2/lib/Object.assign", "npm:react@0.12.2/lib/emptyFunction", "npm:react@0.12.2/lib/invariant", "npm:react@0.12.2/lib/joinClasses", "npm:react@0.12.2/lib/warning", "github:jspm/nodelibs-process@0.1.1"], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  (function(process) {
    "use strict";
    var assign = require("npm:react@0.12.2/lib/Object.assign");
    var emptyFunction = require("npm:react@0.12.2/lib/emptyFunction");
    var invariant = require("npm:react@0.12.2/lib/invariant");
    var joinClasses = require("npm:react@0.12.2/lib/joinClasses");
    var warning = require("npm:react@0.12.2/lib/warning");
    var didWarn = false;
    function createTransferStrategy(mergeStrategy) {
      return function(props, key, value) {
        if (!props.hasOwnProperty(key)) {
          props[key] = value;
        } else {
          props[key] = mergeStrategy(props[key], value);
        }
      };
    }
    var transferStrategyMerge = createTransferStrategy(function(a, b) {
      return assign({}, b, a);
    });
    var TransferStrategies = {
      children: emptyFunction,
      className: createTransferStrategy(joinClasses),
      style: transferStrategyMerge
    };
    function transferInto(props, newProps) {
      for (var thisKey in newProps) {
        if (!newProps.hasOwnProperty(thisKey)) {
          continue;
        }
        var transferStrategy = TransferStrategies[thisKey];
        if (transferStrategy && TransferStrategies.hasOwnProperty(thisKey)) {
          transferStrategy(props, thisKey, newProps[thisKey]);
        } else if (!props.hasOwnProperty(thisKey)) {
          props[thisKey] = newProps[thisKey];
        }
      }
      return props;
    }
    var ReactPropTransferer = {
      TransferStrategies: TransferStrategies,
      mergeProps: function(oldProps, newProps) {
        return transferInto(assign({}, oldProps), newProps);
      },
      Mixin: {transferPropsTo: function(element) {
          ("production" !== process.env.NODE_ENV ? invariant(element._owner === this, '%s: You can\'t call transferPropsTo() on a component that you ' + 'don\'t own, %s. This usually means you are calling ' + 'transferPropsTo() on a component passed in as props or children.', this.constructor.displayName, typeof element.type === 'string' ? element.type : element.type.displayName) : invariant(element._owner === this));
          if ("production" !== process.env.NODE_ENV) {
            if (!didWarn) {
              didWarn = true;
              ("production" !== process.env.NODE_ENV ? warning(false, 'transferPropsTo is deprecated. ' + 'See http://fb.me/react-transferpropsto for more information.') : null);
            }
          }
          transferInto(element.props, this.props);
          return element;
        }}
    };
    module.exports = ReactPropTransferer;
  })(require("github:jspm/nodelibs-process@0.1.1"));
  global.define = __define;
  return module.exports;
});



System.register("npm:react@0.12.2/lib/instantiateReactComponent", ["npm:react@0.12.2/lib/warning", "npm:react@0.12.2/lib/ReactElement", "npm:react@0.12.2/lib/ReactLegacyElement", "npm:react@0.12.2/lib/ReactNativeComponent", "npm:react@0.12.2/lib/ReactEmptyComponent", "github:jspm/nodelibs-process@0.1.1"], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  (function(process) {
    "use strict";
    var warning = require("npm:react@0.12.2/lib/warning");
    var ReactElement = require("npm:react@0.12.2/lib/ReactElement");
    var ReactLegacyElement = require("npm:react@0.12.2/lib/ReactLegacyElement");
    var ReactNativeComponent = require("npm:react@0.12.2/lib/ReactNativeComponent");
    var ReactEmptyComponent = require("npm:react@0.12.2/lib/ReactEmptyComponent");
    function instantiateReactComponent(element, parentCompositeType) {
      var instance;
      if ("production" !== process.env.NODE_ENV) {
        ("production" !== process.env.NODE_ENV ? warning(element && (typeof element.type === 'function' || typeof element.type === 'string'), 'Only functions or strings can be mounted as React components.') : null);
        if (element.type._mockedReactClassConstructor) {
          ReactLegacyElement._isLegacyCallWarningEnabled = false;
          try {
            instance = new element.type._mockedReactClassConstructor(element.props);
          } finally {
            ReactLegacyElement._isLegacyCallWarningEnabled = true;
          }
          if (ReactElement.isValidElement(instance)) {
            instance = new instance.type(instance.props);
          }
          var render = instance.render;
          if (!render) {
            element = ReactEmptyComponent.getEmptyComponent();
          } else {
            if (render._isMockFunction && !render._getMockImplementation()) {
              render.mockImplementation(ReactEmptyComponent.getEmptyComponent);
            }
            instance.construct(element);
            return instance;
          }
        }
      }
      if (typeof element.type === 'string') {
        instance = ReactNativeComponent.createInstanceForTag(element.type, element.props, parentCompositeType);
      } else {
        instance = new element.type(element.props);
      }
      if ("production" !== process.env.NODE_ENV) {
        ("production" !== process.env.NODE_ENV ? warning(typeof instance.construct === 'function' && typeof instance.mountComponent === 'function' && typeof instance.receiveComponent === 'function', 'Only React Components can be mounted.') : null);
      }
      instance.construct(element);
      return instance;
    }
    module.exports = instantiateReactComponent;
  })(require("github:jspm/nodelibs-process@0.1.1"));
  global.define = __define;
  return module.exports;
});



System.register("npm:react@0.12.2/lib/camelizeStyleName", ["npm:react@0.12.2/lib/camelize"], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  "use strict";
  var camelize = require("npm:react@0.12.2/lib/camelize");
  var msPattern = /^-ms-/;
  function camelizeStyleName(string) {
    return camelize(string.replace(msPattern, 'ms-'));
  }
  module.exports = camelizeStyleName;
  global.define = __define;
  return module.exports;
});



System.register("npm:react@0.12.2/lib/hyphenateStyleName", ["npm:react@0.12.2/lib/hyphenate"], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  "use strict";
  var hyphenate = require("npm:react@0.12.2/lib/hyphenate");
  var msPattern = /^ms-/;
  function hyphenateStyleName(string) {
    return hyphenate(string).replace(msPattern, '-ms-');
  }
  module.exports = hyphenateStyleName;
  global.define = __define;
  return module.exports;
});



System.register("npm:react@0.12.2/lib/EventPluginHub", ["npm:react@0.12.2/lib/EventPluginRegistry", "npm:react@0.12.2/lib/EventPluginUtils", "npm:react@0.12.2/lib/accumulateInto", "npm:react@0.12.2/lib/forEachAccumulated", "npm:react@0.12.2/lib/invariant", "github:jspm/nodelibs-process@0.1.1"], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  (function(process) {
    "use strict";
    var EventPluginRegistry = require("npm:react@0.12.2/lib/EventPluginRegistry");
    var EventPluginUtils = require("npm:react@0.12.2/lib/EventPluginUtils");
    var accumulateInto = require("npm:react@0.12.2/lib/accumulateInto");
    var forEachAccumulated = require("npm:react@0.12.2/lib/forEachAccumulated");
    var invariant = require("npm:react@0.12.2/lib/invariant");
    var listenerBank = {};
    var eventQueue = null;
    var executeDispatchesAndRelease = function(event) {
      if (event) {
        var executeDispatch = EventPluginUtils.executeDispatch;
        var PluginModule = EventPluginRegistry.getPluginModuleForEvent(event);
        if (PluginModule && PluginModule.executeDispatch) {
          executeDispatch = PluginModule.executeDispatch;
        }
        EventPluginUtils.executeDispatchesInOrder(event, executeDispatch);
        if (!event.isPersistent()) {
          event.constructor.release(event);
        }
      }
    };
    var InstanceHandle = null;
    function validateInstanceHandle() {
      var invalid = !InstanceHandle || !InstanceHandle.traverseTwoPhase || !InstanceHandle.traverseEnterLeave;
      if (invalid) {
        throw new Error('InstanceHandle not injected before use!');
      }
    }
    var EventPluginHub = {
      injection: {
        injectMount: EventPluginUtils.injection.injectMount,
        injectInstanceHandle: function(InjectedInstanceHandle) {
          InstanceHandle = InjectedInstanceHandle;
          if ("production" !== process.env.NODE_ENV) {
            validateInstanceHandle();
          }
        },
        getInstanceHandle: function() {
          if ("production" !== process.env.NODE_ENV) {
            validateInstanceHandle();
          }
          return InstanceHandle;
        },
        injectEventPluginOrder: EventPluginRegistry.injectEventPluginOrder,
        injectEventPluginsByName: EventPluginRegistry.injectEventPluginsByName
      },
      eventNameDispatchConfigs: EventPluginRegistry.eventNameDispatchConfigs,
      registrationNameModules: EventPluginRegistry.registrationNameModules,
      putListener: function(id, registrationName, listener) {
        ("production" !== process.env.NODE_ENV ? invariant(!listener || typeof listener === 'function', 'Expected %s listener to be a function, instead got type %s', registrationName, typeof listener) : invariant(!listener || typeof listener === 'function'));
        var bankForRegistrationName = listenerBank[registrationName] || (listenerBank[registrationName] = {});
        bankForRegistrationName[id] = listener;
      },
      getListener: function(id, registrationName) {
        var bankForRegistrationName = listenerBank[registrationName];
        return bankForRegistrationName && bankForRegistrationName[id];
      },
      deleteListener: function(id, registrationName) {
        var bankForRegistrationName = listenerBank[registrationName];
        if (bankForRegistrationName) {
          delete bankForRegistrationName[id];
        }
      },
      deleteAllListeners: function(id) {
        for (var registrationName in listenerBank) {
          delete listenerBank[registrationName][id];
        }
      },
      extractEvents: function(topLevelType, topLevelTarget, topLevelTargetID, nativeEvent) {
        var events;
        var plugins = EventPluginRegistry.plugins;
        for (var i = 0,
            l = plugins.length; i < l; i++) {
          var possiblePlugin = plugins[i];
          if (possiblePlugin) {
            var extractedEvents = possiblePlugin.extractEvents(topLevelType, topLevelTarget, topLevelTargetID, nativeEvent);
            if (extractedEvents) {
              events = accumulateInto(events, extractedEvents);
            }
          }
        }
        return events;
      },
      enqueueEvents: function(events) {
        if (events) {
          eventQueue = accumulateInto(eventQueue, events);
        }
      },
      processEventQueue: function() {
        var processingEventQueue = eventQueue;
        eventQueue = null;
        forEachAccumulated(processingEventQueue, executeDispatchesAndRelease);
        ("production" !== process.env.NODE_ENV ? invariant(!eventQueue, 'processEventQueue(): Additional events were enqueued while processing ' + 'an event queue. Support for this has not yet been implemented.') : invariant(!eventQueue));
      },
      __purge: function() {
        listenerBank = {};
      },
      __getListenerBank: function() {
        return listenerBank;
      }
    };
    module.exports = EventPluginHub;
  })(require("github:jspm/nodelibs-process@0.1.1"));
  global.define = __define;
  return module.exports;
});



System.register("npm:react@0.12.2/lib/ViewportMetrics", ["npm:react@0.12.2/lib/getUnboundedScrollPosition"], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  "use strict";
  var getUnboundedScrollPosition = require("npm:react@0.12.2/lib/getUnboundedScrollPosition");
  var ViewportMetrics = {
    currentScrollLeft: 0,
    currentScrollTop: 0,
    refreshScrollValues: function() {
      var scrollPosition = getUnboundedScrollPosition(window);
      ViewportMetrics.currentScrollLeft = scrollPosition.x;
      ViewportMetrics.currentScrollTop = scrollPosition.y;
    }
  };
  module.exports = ViewportMetrics;
  global.define = __define;
  return module.exports;
});



System.register("npm:react@0.12.2/lib/isTextNode", ["npm:react@0.12.2/lib/isNode"], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  var isNode = require("npm:react@0.12.2/lib/isNode");
  function isTextNode(object) {
    return isNode(object) && object.nodeType == 3;
  }
  module.exports = isTextNode;
  global.define = __define;
  return module.exports;
});



System.register("npm:react@0.12.2/lib/flattenChildren", ["npm:react@0.12.2/lib/ReactTextComponent", "npm:react@0.12.2/lib/traverseAllChildren", "npm:react@0.12.2/lib/warning", "github:jspm/nodelibs-process@0.1.1"], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  (function(process) {
    "use strict";
    var ReactTextComponent = require("npm:react@0.12.2/lib/ReactTextComponent");
    var traverseAllChildren = require("npm:react@0.12.2/lib/traverseAllChildren");
    var warning = require("npm:react@0.12.2/lib/warning");
    function flattenSingleChildIntoContext(traverseContext, child, name) {
      var result = traverseContext;
      var keyUnique = !result.hasOwnProperty(name);
      ("production" !== process.env.NODE_ENV ? warning(keyUnique, 'flattenChildren(...): Encountered two children with the same key, ' + '`%s`. Child keys must be unique; when two children share a key, only ' + 'the first child will be used.', name) : null);
      if (keyUnique && child != null) {
        var type = typeof child;
        var normalizedValue;
        if (type === 'string') {
          normalizedValue = ReactTextComponent(child);
        } else if (type === 'number') {
          normalizedValue = ReactTextComponent('' + child);
        } else {
          normalizedValue = child;
        }
        result[name] = normalizedValue;
      }
    }
    function flattenChildren(children) {
      if (children == null) {
        return children;
      }
      var result = {};
      traverseAllChildren(children, flattenSingleChildIntoContext, result);
      return result;
    }
    module.exports = flattenChildren;
  })(require("github:jspm/nodelibs-process@0.1.1"));
  global.define = __define;
  return module.exports;
});



System.register("npm:react@0.12.2/lib/SyntheticEvent", ["npm:react@0.12.2/lib/PooledClass", "npm:react@0.12.2/lib/Object.assign", "npm:react@0.12.2/lib/emptyFunction", "npm:react@0.12.2/lib/getEventTarget"], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  "use strict";
  var PooledClass = require("npm:react@0.12.2/lib/PooledClass");
  var assign = require("npm:react@0.12.2/lib/Object.assign");
  var emptyFunction = require("npm:react@0.12.2/lib/emptyFunction");
  var getEventTarget = require("npm:react@0.12.2/lib/getEventTarget");
  var EventInterface = {
    type: null,
    target: getEventTarget,
    currentTarget: emptyFunction.thatReturnsNull,
    eventPhase: null,
    bubbles: null,
    cancelable: null,
    timeStamp: function(event) {
      return event.timeStamp || Date.now();
    },
    defaultPrevented: null,
    isTrusted: null
  };
  function SyntheticEvent(dispatchConfig, dispatchMarker, nativeEvent) {
    this.dispatchConfig = dispatchConfig;
    this.dispatchMarker = dispatchMarker;
    this.nativeEvent = nativeEvent;
    var Interface = this.constructor.Interface;
    for (var propName in Interface) {
      if (!Interface.hasOwnProperty(propName)) {
        continue;
      }
      var normalize = Interface[propName];
      if (normalize) {
        this[propName] = normalize(nativeEvent);
      } else {
        this[propName] = nativeEvent[propName];
      }
    }
    var defaultPrevented = nativeEvent.defaultPrevented != null ? nativeEvent.defaultPrevented : nativeEvent.returnValue === false;
    if (defaultPrevented) {
      this.isDefaultPrevented = emptyFunction.thatReturnsTrue;
    } else {
      this.isDefaultPrevented = emptyFunction.thatReturnsFalse;
    }
    this.isPropagationStopped = emptyFunction.thatReturnsFalse;
  }
  assign(SyntheticEvent.prototype, {
    preventDefault: function() {
      this.defaultPrevented = true;
      var event = this.nativeEvent;
      event.preventDefault ? event.preventDefault() : event.returnValue = false;
      this.isDefaultPrevented = emptyFunction.thatReturnsTrue;
    },
    stopPropagation: function() {
      var event = this.nativeEvent;
      event.stopPropagation ? event.stopPropagation() : event.cancelBubble = true;
      this.isPropagationStopped = emptyFunction.thatReturnsTrue;
    },
    persist: function() {
      this.isPersistent = emptyFunction.thatReturnsTrue;
    },
    isPersistent: emptyFunction.thatReturnsFalse,
    destructor: function() {
      var Interface = this.constructor.Interface;
      for (var propName in Interface) {
        this[propName] = null;
      }
      this.dispatchConfig = null;
      this.dispatchMarker = null;
      this.nativeEvent = null;
    }
  });
  SyntheticEvent.Interface = EventInterface;
  SyntheticEvent.augmentClass = function(Class, Interface) {
    var Super = this;
    var prototype = Object.create(Super.prototype);
    assign(prototype, Class.prototype);
    Class.prototype = prototype;
    Class.prototype.constructor = Class;
    Class.Interface = assign({}, Super.Interface, Interface);
    Class.augmentClass = Super.augmentClass;
    PooledClass.addPoolingTo(Class, PooledClass.threeArgumentPooler);
  };
  PooledClass.addPoolingTo(SyntheticEvent, PooledClass.threeArgumentPooler);
  module.exports = SyntheticEvent;
  global.define = __define;
  return module.exports;
});



System.register("npm:react@0.12.2/lib/ChangeEventPlugin", ["npm:react@0.12.2/lib/EventConstants", "npm:react@0.12.2/lib/EventPluginHub", "npm:react@0.12.2/lib/EventPropagators", "npm:react@0.12.2/lib/ExecutionEnvironment", "npm:react@0.12.2/lib/ReactUpdates", "npm:react@0.12.2/lib/SyntheticEvent", "npm:react@0.12.2/lib/isEventSupported", "npm:react@0.12.2/lib/isTextInputElement", "npm:react@0.12.2/lib/keyOf", "github:jspm/nodelibs-process@0.1.1"], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  (function(process) {
    "use strict";
    var EventConstants = require("npm:react@0.12.2/lib/EventConstants");
    var EventPluginHub = require("npm:react@0.12.2/lib/EventPluginHub");
    var EventPropagators = require("npm:react@0.12.2/lib/EventPropagators");
    var ExecutionEnvironment = require("npm:react@0.12.2/lib/ExecutionEnvironment");
    var ReactUpdates = require("npm:react@0.12.2/lib/ReactUpdates");
    var SyntheticEvent = require("npm:react@0.12.2/lib/SyntheticEvent");
    var isEventSupported = require("npm:react@0.12.2/lib/isEventSupported");
    var isTextInputElement = require("npm:react@0.12.2/lib/isTextInputElement");
    var keyOf = require("npm:react@0.12.2/lib/keyOf");
    var topLevelTypes = EventConstants.topLevelTypes;
    var eventTypes = {change: {
        phasedRegistrationNames: {
          bubbled: keyOf({onChange: null}),
          captured: keyOf({onChangeCapture: null})
        },
        dependencies: [topLevelTypes.topBlur, topLevelTypes.topChange, topLevelTypes.topClick, topLevelTypes.topFocus, topLevelTypes.topInput, topLevelTypes.topKeyDown, topLevelTypes.topKeyUp, topLevelTypes.topSelectionChange]
      }};
    var activeElement = null;
    var activeElementID = null;
    var activeElementValue = null;
    var activeElementValueProp = null;
    function shouldUseChangeEvent(elem) {
      return (elem.nodeName === 'SELECT' || (elem.nodeName === 'INPUT' && elem.type === 'file'));
    }
    var doesChangeEventBubble = false;
    if (ExecutionEnvironment.canUseDOM) {
      doesChangeEventBubble = isEventSupported('change') && (!('documentMode' in document) || document.documentMode > 8);
    }
    function manualDispatchChangeEvent(nativeEvent) {
      var event = SyntheticEvent.getPooled(eventTypes.change, activeElementID, nativeEvent);
      EventPropagators.accumulateTwoPhaseDispatches(event);
      ReactUpdates.batchedUpdates(runEventInBatch, event);
    }
    function runEventInBatch(event) {
      EventPluginHub.enqueueEvents(event);
      EventPluginHub.processEventQueue();
    }
    function startWatchingForChangeEventIE8(target, targetID) {
      activeElement = target;
      activeElementID = targetID;
      activeElement.attachEvent('onchange', manualDispatchChangeEvent);
    }
    function stopWatchingForChangeEventIE8() {
      if (!activeElement) {
        return ;
      }
      activeElement.detachEvent('onchange', manualDispatchChangeEvent);
      activeElement = null;
      activeElementID = null;
    }
    function getTargetIDForChangeEvent(topLevelType, topLevelTarget, topLevelTargetID) {
      if (topLevelType === topLevelTypes.topChange) {
        return topLevelTargetID;
      }
    }
    function handleEventsForChangeEventIE8(topLevelType, topLevelTarget, topLevelTargetID) {
      if (topLevelType === topLevelTypes.topFocus) {
        stopWatchingForChangeEventIE8();
        startWatchingForChangeEventIE8(topLevelTarget, topLevelTargetID);
      } else if (topLevelType === topLevelTypes.topBlur) {
        stopWatchingForChangeEventIE8();
      }
    }
    var isInputEventSupported = false;
    if (ExecutionEnvironment.canUseDOM) {
      isInputEventSupported = isEventSupported('input') && (!('documentMode' in document) || document.documentMode > 9);
    }
    var newValueProp = {
      get: function() {
        return activeElementValueProp.get.call(this);
      },
      set: function(val) {
        activeElementValue = '' + val;
        activeElementValueProp.set.call(this, val);
      }
    };
    function startWatchingForValueChange(target, targetID) {
      activeElement = target;
      activeElementID = targetID;
      activeElementValue = target.value;
      activeElementValueProp = Object.getOwnPropertyDescriptor(target.constructor.prototype, 'value');
      Object.defineProperty(activeElement, 'value', newValueProp);
      activeElement.attachEvent('onpropertychange', handlePropertyChange);
    }
    function stopWatchingForValueChange() {
      if (!activeElement) {
        return ;
      }
      delete activeElement.value;
      activeElement.detachEvent('onpropertychange', handlePropertyChange);
      activeElement = null;
      activeElementID = null;
      activeElementValue = null;
      activeElementValueProp = null;
    }
    function handlePropertyChange(nativeEvent) {
      if (nativeEvent.propertyName !== 'value') {
        return ;
      }
      var value = nativeEvent.srcElement.value;
      if (value === activeElementValue) {
        return ;
      }
      activeElementValue = value;
      manualDispatchChangeEvent(nativeEvent);
    }
    function getTargetIDForInputEvent(topLevelType, topLevelTarget, topLevelTargetID) {
      if (topLevelType === topLevelTypes.topInput) {
        return topLevelTargetID;
      }
    }
    function handleEventsForInputEventIE(topLevelType, topLevelTarget, topLevelTargetID) {
      if (topLevelType === topLevelTypes.topFocus) {
        stopWatchingForValueChange();
        startWatchingForValueChange(topLevelTarget, topLevelTargetID);
      } else if (topLevelType === topLevelTypes.topBlur) {
        stopWatchingForValueChange();
      }
    }
    function getTargetIDForInputEventIE(topLevelType, topLevelTarget, topLevelTargetID) {
      if (topLevelType === topLevelTypes.topSelectionChange || topLevelType === topLevelTypes.topKeyUp || topLevelType === topLevelTypes.topKeyDown) {
        if (activeElement && activeElement.value !== activeElementValue) {
          activeElementValue = activeElement.value;
          return activeElementID;
        }
      }
    }
    function shouldUseClickEvent(elem) {
      return (elem.nodeName === 'INPUT' && (elem.type === 'checkbox' || elem.type === 'radio'));
    }
    function getTargetIDForClickEvent(topLevelType, topLevelTarget, topLevelTargetID) {
      if (topLevelType === topLevelTypes.topClick) {
        return topLevelTargetID;
      }
    }
    var ChangeEventPlugin = {
      eventTypes: eventTypes,
      extractEvents: function(topLevelType, topLevelTarget, topLevelTargetID, nativeEvent) {
        var getTargetIDFunc,
            handleEventFunc;
        if (shouldUseChangeEvent(topLevelTarget)) {
          if (doesChangeEventBubble) {
            getTargetIDFunc = getTargetIDForChangeEvent;
          } else {
            handleEventFunc = handleEventsForChangeEventIE8;
          }
        } else if (isTextInputElement(topLevelTarget)) {
          if (isInputEventSupported) {
            getTargetIDFunc = getTargetIDForInputEvent;
          } else {
            getTargetIDFunc = getTargetIDForInputEventIE;
            handleEventFunc = handleEventsForInputEventIE;
          }
        } else if (shouldUseClickEvent(topLevelTarget)) {
          getTargetIDFunc = getTargetIDForClickEvent;
        }
        if (getTargetIDFunc) {
          var targetID = getTargetIDFunc(topLevelType, topLevelTarget, topLevelTargetID);
          if (targetID) {
            var event = SyntheticEvent.getPooled(eventTypes.change, targetID, nativeEvent);
            EventPropagators.accumulateTwoPhaseDispatches(event);
            return event;
          }
        }
        if (handleEventFunc) {
          handleEventFunc(topLevelType, topLevelTarget, topLevelTargetID);
        }
      }
    };
    module.exports = ChangeEventPlugin;
  })(require("github:jspm/nodelibs-process@0.1.1"));
  global.define = __define;
  return module.exports;
});



System.register("npm:react@0.12.2/lib/ReactDOMSelection", ["npm:react@0.12.2/lib/ExecutionEnvironment", "npm:react@0.12.2/lib/getNodeForCharacterOffset", "npm:react@0.12.2/lib/getTextContentAccessor"], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  "use strict";
  var ExecutionEnvironment = require("npm:react@0.12.2/lib/ExecutionEnvironment");
  var getNodeForCharacterOffset = require("npm:react@0.12.2/lib/getNodeForCharacterOffset");
  var getTextContentAccessor = require("npm:react@0.12.2/lib/getTextContentAccessor");
  function isCollapsed(anchorNode, anchorOffset, focusNode, focusOffset) {
    return anchorNode === focusNode && anchorOffset === focusOffset;
  }
  function getIEOffsets(node) {
    var selection = document.selection;
    var selectedRange = selection.createRange();
    var selectedLength = selectedRange.text.length;
    var fromStart = selectedRange.duplicate();
    fromStart.moveToElementText(node);
    fromStart.setEndPoint('EndToStart', selectedRange);
    var startOffset = fromStart.text.length;
    var endOffset = startOffset + selectedLength;
    return {
      start: startOffset,
      end: endOffset
    };
  }
  function getModernOffsets(node) {
    var selection = window.getSelection && window.getSelection();
    if (!selection || selection.rangeCount === 0) {
      return null;
    }
    var anchorNode = selection.anchorNode;
    var anchorOffset = selection.anchorOffset;
    var focusNode = selection.focusNode;
    var focusOffset = selection.focusOffset;
    var currentRange = selection.getRangeAt(0);
    var isSelectionCollapsed = isCollapsed(selection.anchorNode, selection.anchorOffset, selection.focusNode, selection.focusOffset);
    var rangeLength = isSelectionCollapsed ? 0 : currentRange.toString().length;
    var tempRange = currentRange.cloneRange();
    tempRange.selectNodeContents(node);
    tempRange.setEnd(currentRange.startContainer, currentRange.startOffset);
    var isTempRangeCollapsed = isCollapsed(tempRange.startContainer, tempRange.startOffset, tempRange.endContainer, tempRange.endOffset);
    var start = isTempRangeCollapsed ? 0 : tempRange.toString().length;
    var end = start + rangeLength;
    var detectionRange = document.createRange();
    detectionRange.setStart(anchorNode, anchorOffset);
    detectionRange.setEnd(focusNode, focusOffset);
    var isBackward = detectionRange.collapsed;
    return {
      start: isBackward ? end : start,
      end: isBackward ? start : end
    };
  }
  function setIEOffsets(node, offsets) {
    var range = document.selection.createRange().duplicate();
    var start,
        end;
    if (typeof offsets.end === 'undefined') {
      start = offsets.start;
      end = start;
    } else if (offsets.start > offsets.end) {
      start = offsets.end;
      end = offsets.start;
    } else {
      start = offsets.start;
      end = offsets.end;
    }
    range.moveToElementText(node);
    range.moveStart('character', start);
    range.setEndPoint('EndToStart', range);
    range.moveEnd('character', end - start);
    range.select();
  }
  function setModernOffsets(node, offsets) {
    if (!window.getSelection) {
      return ;
    }
    var selection = window.getSelection();
    var length = node[getTextContentAccessor()].length;
    var start = Math.min(offsets.start, length);
    var end = typeof offsets.end === 'undefined' ? start : Math.min(offsets.end, length);
    if (!selection.extend && start > end) {
      var temp = end;
      end = start;
      start = temp;
    }
    var startMarker = getNodeForCharacterOffset(node, start);
    var endMarker = getNodeForCharacterOffset(node, end);
    if (startMarker && endMarker) {
      var range = document.createRange();
      range.setStart(startMarker.node, startMarker.offset);
      selection.removeAllRanges();
      if (start > end) {
        selection.addRange(range);
        selection.extend(endMarker.node, endMarker.offset);
      } else {
        range.setEnd(endMarker.node, endMarker.offset);
        selection.addRange(range);
      }
    }
  }
  var useIEOffsets = ExecutionEnvironment.canUseDOM && document.selection;
  var ReactDOMSelection = {
    getOffsets: useIEOffsets ? getIEOffsets : getModernOffsets,
    setOffsets: useIEOffsets ? setIEOffsets : setModernOffsets
  };
  module.exports = ReactDOMSelection;
  global.define = __define;
  return module.exports;
});



System.register("npm:react@0.12.2/lib/SyntheticMouseEvent", ["npm:react@0.12.2/lib/SyntheticUIEvent", "npm:react@0.12.2/lib/ViewportMetrics", "npm:react@0.12.2/lib/getEventModifierState"], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  "use strict";
  var SyntheticUIEvent = require("npm:react@0.12.2/lib/SyntheticUIEvent");
  var ViewportMetrics = require("npm:react@0.12.2/lib/ViewportMetrics");
  var getEventModifierState = require("npm:react@0.12.2/lib/getEventModifierState");
  var MouseEventInterface = {
    screenX: null,
    screenY: null,
    clientX: null,
    clientY: null,
    ctrlKey: null,
    shiftKey: null,
    altKey: null,
    metaKey: null,
    getModifierState: getEventModifierState,
    button: function(event) {
      var button = event.button;
      if ('which' in event) {
        return button;
      }
      return button === 2 ? 2 : button === 4 ? 1 : 0;
    },
    buttons: null,
    relatedTarget: function(event) {
      return event.relatedTarget || (event.fromElement === event.srcElement ? event.toElement : event.fromElement);
    },
    pageX: function(event) {
      return 'pageX' in event ? event.pageX : event.clientX + ViewportMetrics.currentScrollLeft;
    },
    pageY: function(event) {
      return 'pageY' in event ? event.pageY : event.clientY + ViewportMetrics.currentScrollTop;
    }
  };
  function SyntheticMouseEvent(dispatchConfig, dispatchMarker, nativeEvent) {
    SyntheticUIEvent.call(this, dispatchConfig, dispatchMarker, nativeEvent);
  }
  SyntheticUIEvent.augmentClass(SyntheticMouseEvent, MouseEventInterface);
  module.exports = SyntheticMouseEvent;
  global.define = __define;
  return module.exports;
});



System.register("npm:react@0.12.2/lib/createArrayFrom", ["npm:react@0.12.2/lib/toArray"], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  var toArray = require("npm:react@0.12.2/lib/toArray");
  function hasArrayNature(obj) {
    return (!!obj && (typeof obj == 'object' || typeof obj == 'function') && ('length' in obj) && !('setInterval' in obj) && (typeof obj.nodeType != 'number') && (((Array.isArray(obj) || ('callee' in obj) || 'item' in obj))));
  }
  function createArrayFrom(obj) {
    if (!hasArrayNature(obj)) {
      return [obj];
    } else if (Array.isArray(obj)) {
      return obj.slice();
    } else {
      return toArray(obj);
    }
  }
  module.exports = createArrayFrom;
  global.define = __define;
  return module.exports;
});



System.register("npm:react@0.12.2/lib/ReactMarkupChecksum", ["npm:react@0.12.2/lib/adler32"], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  "use strict";
  var adler32 = require("npm:react@0.12.2/lib/adler32");
  var ReactMarkupChecksum = {
    CHECKSUM_ATTR_NAME: 'data-react-checksum',
    addChecksumToMarkup: function(markup) {
      var checksum = adler32(markup);
      return markup.replace('>', ' ' + ReactMarkupChecksum.CHECKSUM_ATTR_NAME + '="' + checksum + '">');
    },
    canReuseMarkup: function(markup, element) {
      var existingChecksum = element.getAttribute(ReactMarkupChecksum.CHECKSUM_ATTR_NAME);
      existingChecksum = existingChecksum && parseInt(existingChecksum, 10);
      var markupChecksum = adler32(markup);
      return markupChecksum === existingChecksum;
    }
  };
  module.exports = ReactMarkupChecksum;
  global.define = __define;
  return module.exports;
});



System.register("npm:react@0.12.2/lib/ReactReconcileTransaction", ["npm:react@0.12.2/lib/CallbackQueue", "npm:react@0.12.2/lib/PooledClass", "npm:react@0.12.2/lib/ReactBrowserEventEmitter", "npm:react@0.12.2/lib/ReactInputSelection", "npm:react@0.12.2/lib/ReactPutListenerQueue", "npm:react@0.12.2/lib/Transaction", "npm:react@0.12.2/lib/Object.assign"], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  "use strict";
  var CallbackQueue = require("npm:react@0.12.2/lib/CallbackQueue");
  var PooledClass = require("npm:react@0.12.2/lib/PooledClass");
  var ReactBrowserEventEmitter = require("npm:react@0.12.2/lib/ReactBrowserEventEmitter");
  var ReactInputSelection = require("npm:react@0.12.2/lib/ReactInputSelection");
  var ReactPutListenerQueue = require("npm:react@0.12.2/lib/ReactPutListenerQueue");
  var Transaction = require("npm:react@0.12.2/lib/Transaction");
  var assign = require("npm:react@0.12.2/lib/Object.assign");
  var SELECTION_RESTORATION = {
    initialize: ReactInputSelection.getSelectionInformation,
    close: ReactInputSelection.restoreSelection
  };
  var EVENT_SUPPRESSION = {
    initialize: function() {
      var currentlyEnabled = ReactBrowserEventEmitter.isEnabled();
      ReactBrowserEventEmitter.setEnabled(false);
      return currentlyEnabled;
    },
    close: function(previouslyEnabled) {
      ReactBrowserEventEmitter.setEnabled(previouslyEnabled);
    }
  };
  var ON_DOM_READY_QUEUEING = {
    initialize: function() {
      this.reactMountReady.reset();
    },
    close: function() {
      this.reactMountReady.notifyAll();
    }
  };
  var PUT_LISTENER_QUEUEING = {
    initialize: function() {
      this.putListenerQueue.reset();
    },
    close: function() {
      this.putListenerQueue.putListeners();
    }
  };
  var TRANSACTION_WRAPPERS = [PUT_LISTENER_QUEUEING, SELECTION_RESTORATION, EVENT_SUPPRESSION, ON_DOM_READY_QUEUEING];
  function ReactReconcileTransaction() {
    this.reinitializeTransaction();
    this.renderToStaticMarkup = false;
    this.reactMountReady = CallbackQueue.getPooled(null);
    this.putListenerQueue = ReactPutListenerQueue.getPooled();
  }
  var Mixin = {
    getTransactionWrappers: function() {
      return TRANSACTION_WRAPPERS;
    },
    getReactMountReady: function() {
      return this.reactMountReady;
    },
    getPutListenerQueue: function() {
      return this.putListenerQueue;
    },
    destructor: function() {
      CallbackQueue.release(this.reactMountReady);
      this.reactMountReady = null;
      ReactPutListenerQueue.release(this.putListenerQueue);
      this.putListenerQueue = null;
    }
  };
  assign(ReactReconcileTransaction.prototype, Transaction.Mixin, Mixin);
  PooledClass.addPoolingTo(ReactReconcileTransaction);
  module.exports = ReactReconcileTransaction;
  global.define = __define;
  return module.exports;
});



System.register("npm:react@0.12.2/lib/ReactDOMButton", ["npm:react@0.12.2/lib/AutoFocusMixin", "npm:react@0.12.2/lib/ReactBrowserComponentMixin", "npm:react@0.12.2/lib/ReactCompositeComponent", "npm:react@0.12.2/lib/ReactElement", "npm:react@0.12.2/lib/ReactDOM", "npm:react@0.12.2/lib/keyMirror"], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  "use strict";
  var AutoFocusMixin = require("npm:react@0.12.2/lib/AutoFocusMixin");
  var ReactBrowserComponentMixin = require("npm:react@0.12.2/lib/ReactBrowserComponentMixin");
  var ReactCompositeComponent = require("npm:react@0.12.2/lib/ReactCompositeComponent");
  var ReactElement = require("npm:react@0.12.2/lib/ReactElement");
  var ReactDOM = require("npm:react@0.12.2/lib/ReactDOM");
  var keyMirror = require("npm:react@0.12.2/lib/keyMirror");
  var button = ReactElement.createFactory(ReactDOM.button.type);
  var mouseListenerNames = keyMirror({
    onClick: true,
    onDoubleClick: true,
    onMouseDown: true,
    onMouseMove: true,
    onMouseUp: true,
    onClickCapture: true,
    onDoubleClickCapture: true,
    onMouseDownCapture: true,
    onMouseMoveCapture: true,
    onMouseUpCapture: true
  });
  var ReactDOMButton = ReactCompositeComponent.createClass({
    displayName: 'ReactDOMButton',
    mixins: [AutoFocusMixin, ReactBrowserComponentMixin],
    render: function() {
      var props = {};
      for (var key in this.props) {
        if (this.props.hasOwnProperty(key) && (!this.props.disabled || !mouseListenerNames[key])) {
          props[key] = this.props[key];
        }
      }
      return button(props, this.props.children);
    }
  });
  module.exports = ReactDOMButton;
  global.define = __define;
  return module.exports;
});



System.register("npm:react@0.12.2/lib/ReactDOMForm", ["npm:react@0.12.2/lib/EventConstants", "npm:react@0.12.2/lib/LocalEventTrapMixin", "npm:react@0.12.2/lib/ReactBrowserComponentMixin", "npm:react@0.12.2/lib/ReactCompositeComponent", "npm:react@0.12.2/lib/ReactElement", "npm:react@0.12.2/lib/ReactDOM"], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  "use strict";
  var EventConstants = require("npm:react@0.12.2/lib/EventConstants");
  var LocalEventTrapMixin = require("npm:react@0.12.2/lib/LocalEventTrapMixin");
  var ReactBrowserComponentMixin = require("npm:react@0.12.2/lib/ReactBrowserComponentMixin");
  var ReactCompositeComponent = require("npm:react@0.12.2/lib/ReactCompositeComponent");
  var ReactElement = require("npm:react@0.12.2/lib/ReactElement");
  var ReactDOM = require("npm:react@0.12.2/lib/ReactDOM");
  var form = ReactElement.createFactory(ReactDOM.form.type);
  var ReactDOMForm = ReactCompositeComponent.createClass({
    displayName: 'ReactDOMForm',
    mixins: [ReactBrowserComponentMixin, LocalEventTrapMixin],
    render: function() {
      return form(this.props);
    },
    componentDidMount: function() {
      this.trapBubbledEvent(EventConstants.topLevelTypes.topReset, 'reset');
      this.trapBubbledEvent(EventConstants.topLevelTypes.topSubmit, 'submit');
    }
  });
  module.exports = ReactDOMForm;
  global.define = __define;
  return module.exports;
});



System.register("npm:react@0.12.2/lib/LinkedValueUtils", ["npm:react@0.12.2/lib/ReactPropTypes", "npm:react@0.12.2/lib/invariant", "github:jspm/nodelibs-process@0.1.1"], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  (function(process) {
    "use strict";
    var ReactPropTypes = require("npm:react@0.12.2/lib/ReactPropTypes");
    var invariant = require("npm:react@0.12.2/lib/invariant");
    var hasReadOnlyValue = {
      'button': true,
      'checkbox': true,
      'image': true,
      'hidden': true,
      'radio': true,
      'reset': true,
      'submit': true
    };
    function _assertSingleLink(input) {
      ("production" !== process.env.NODE_ENV ? invariant(input.props.checkedLink == null || input.props.valueLink == null, 'Cannot provide a checkedLink and a valueLink. If you want to use ' + 'checkedLink, you probably don\'t want to use valueLink and vice versa.') : invariant(input.props.checkedLink == null || input.props.valueLink == null));
    }
    function _assertValueLink(input) {
      _assertSingleLink(input);
      ("production" !== process.env.NODE_ENV ? invariant(input.props.value == null && input.props.onChange == null, 'Cannot provide a valueLink and a value or onChange event. If you want ' + 'to use value or onChange, you probably don\'t want to use valueLink.') : invariant(input.props.value == null && input.props.onChange == null));
    }
    function _assertCheckedLink(input) {
      _assertSingleLink(input);
      ("production" !== process.env.NODE_ENV ? invariant(input.props.checked == null && input.props.onChange == null, 'Cannot provide a checkedLink and a checked property or onChange event. ' + 'If you want to use checked or onChange, you probably don\'t want to ' + 'use checkedLink') : invariant(input.props.checked == null && input.props.onChange == null));
    }
    function _handleLinkedValueChange(e) {
      this.props.valueLink.requestChange(e.target.value);
    }
    function _handleLinkedCheckChange(e) {
      this.props.checkedLink.requestChange(e.target.checked);
    }
    var LinkedValueUtils = {
      Mixin: {propTypes: {
          value: function(props, propName, componentName) {
            if (!props[propName] || hasReadOnlyValue[props.type] || props.onChange || props.readOnly || props.disabled) {
              return ;
            }
            return new Error('You provided a `value` prop to a form field without an ' + '`onChange` handler. This will render a read-only field. If ' + 'the field should be mutable use `defaultValue`. Otherwise, ' + 'set either `onChange` or `readOnly`.');
          },
          checked: function(props, propName, componentName) {
            if (!props[propName] || props.onChange || props.readOnly || props.disabled) {
              return ;
            }
            return new Error('You provided a `checked` prop to a form field without an ' + '`onChange` handler. This will render a read-only field. If ' + 'the field should be mutable use `defaultChecked`. Otherwise, ' + 'set either `onChange` or `readOnly`.');
          },
          onChange: ReactPropTypes.func
        }},
      getValue: function(input) {
        if (input.props.valueLink) {
          _assertValueLink(input);
          return input.props.valueLink.value;
        }
        return input.props.value;
      },
      getChecked: function(input) {
        if (input.props.checkedLink) {
          _assertCheckedLink(input);
          return input.props.checkedLink.value;
        }
        return input.props.checked;
      },
      getOnChange: function(input) {
        if (input.props.valueLink) {
          _assertValueLink(input);
          return _handleLinkedValueChange;
        } else if (input.props.checkedLink) {
          _assertCheckedLink(input);
          return _handleLinkedCheckChange;
        }
        return input.props.onChange;
      }
    };
    module.exports = LinkedValueUtils;
  })(require("github:jspm/nodelibs-process@0.1.1"));
  global.define = __define;
  return module.exports;
});



System.register("npm:react@0.12.2/lib/ReactEventListener", ["npm:react@0.12.2/lib/EventListener", "npm:react@0.12.2/lib/ExecutionEnvironment", "npm:react@0.12.2/lib/PooledClass", "npm:react@0.12.2/lib/ReactInstanceHandles", "npm:react@0.12.2/lib/ReactMount", "npm:react@0.12.2/lib/ReactUpdates", "npm:react@0.12.2/lib/Object.assign", "npm:react@0.12.2/lib/getEventTarget", "npm:react@0.12.2/lib/getUnboundedScrollPosition", "github:jspm/nodelibs-process@0.1.1"], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  (function(process) {
    "use strict";
    var EventListener = require("npm:react@0.12.2/lib/EventListener");
    var ExecutionEnvironment = require("npm:react@0.12.2/lib/ExecutionEnvironment");
    var PooledClass = require("npm:react@0.12.2/lib/PooledClass");
    var ReactInstanceHandles = require("npm:react@0.12.2/lib/ReactInstanceHandles");
    var ReactMount = require("npm:react@0.12.2/lib/ReactMount");
    var ReactUpdates = require("npm:react@0.12.2/lib/ReactUpdates");
    var assign = require("npm:react@0.12.2/lib/Object.assign");
    var getEventTarget = require("npm:react@0.12.2/lib/getEventTarget");
    var getUnboundedScrollPosition = require("npm:react@0.12.2/lib/getUnboundedScrollPosition");
    function findParent(node) {
      var nodeID = ReactMount.getID(node);
      var rootID = ReactInstanceHandles.getReactRootIDFromNodeID(nodeID);
      var container = ReactMount.findReactContainerForID(rootID);
      var parent = ReactMount.getFirstReactDOM(container);
      return parent;
    }
    function TopLevelCallbackBookKeeping(topLevelType, nativeEvent) {
      this.topLevelType = topLevelType;
      this.nativeEvent = nativeEvent;
      this.ancestors = [];
    }
    assign(TopLevelCallbackBookKeeping.prototype, {destructor: function() {
        this.topLevelType = null;
        this.nativeEvent = null;
        this.ancestors.length = 0;
      }});
    PooledClass.addPoolingTo(TopLevelCallbackBookKeeping, PooledClass.twoArgumentPooler);
    function handleTopLevelImpl(bookKeeping) {
      var topLevelTarget = ReactMount.getFirstReactDOM(getEventTarget(bookKeeping.nativeEvent)) || window;
      var ancestor = topLevelTarget;
      while (ancestor) {
        bookKeeping.ancestors.push(ancestor);
        ancestor = findParent(ancestor);
      }
      for (var i = 0,
          l = bookKeeping.ancestors.length; i < l; i++) {
        topLevelTarget = bookKeeping.ancestors[i];
        var topLevelTargetID = ReactMount.getID(topLevelTarget) || '';
        ReactEventListener._handleTopLevel(bookKeeping.topLevelType, topLevelTarget, topLevelTargetID, bookKeeping.nativeEvent);
      }
    }
    function scrollValueMonitor(cb) {
      var scrollPosition = getUnboundedScrollPosition(window);
      cb(scrollPosition);
    }
    var ReactEventListener = {
      _enabled: true,
      _handleTopLevel: null,
      WINDOW_HANDLE: ExecutionEnvironment.canUseDOM ? window : null,
      setHandleTopLevel: function(handleTopLevel) {
        ReactEventListener._handleTopLevel = handleTopLevel;
      },
      setEnabled: function(enabled) {
        ReactEventListener._enabled = !!enabled;
      },
      isEnabled: function() {
        return ReactEventListener._enabled;
      },
      trapBubbledEvent: function(topLevelType, handlerBaseName, handle) {
        var element = handle;
        if (!element) {
          return ;
        }
        return EventListener.listen(element, handlerBaseName, ReactEventListener.dispatchEvent.bind(null, topLevelType));
      },
      trapCapturedEvent: function(topLevelType, handlerBaseName, handle) {
        var element = handle;
        if (!element) {
          return ;
        }
        return EventListener.capture(element, handlerBaseName, ReactEventListener.dispatchEvent.bind(null, topLevelType));
      },
      monitorScrollValue: function(refresh) {
        var callback = scrollValueMonitor.bind(null, refresh);
        EventListener.listen(window, 'scroll', callback);
        EventListener.listen(window, 'resize', callback);
      },
      dispatchEvent: function(topLevelType, nativeEvent) {
        if (!ReactEventListener._enabled) {
          return ;
        }
        var bookKeeping = TopLevelCallbackBookKeeping.getPooled(topLevelType, nativeEvent);
        try {
          ReactUpdates.batchedUpdates(handleTopLevelImpl, bookKeeping);
        } finally {
          TopLevelCallbackBookKeeping.release(bookKeeping);
        }
      }
    };
    module.exports = ReactEventListener;
  })(require("github:jspm/nodelibs-process@0.1.1"));
  global.define = __define;
  return module.exports;
});



System.register("npm:react@0.12.2/lib/SelectEventPlugin", ["npm:react@0.12.2/lib/EventConstants", "npm:react@0.12.2/lib/EventPropagators", "npm:react@0.12.2/lib/ReactInputSelection", "npm:react@0.12.2/lib/SyntheticEvent", "npm:react@0.12.2/lib/getActiveElement", "npm:react@0.12.2/lib/isTextInputElement", "npm:react@0.12.2/lib/keyOf", "npm:react@0.12.2/lib/shallowEqual"], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  "use strict";
  var EventConstants = require("npm:react@0.12.2/lib/EventConstants");
  var EventPropagators = require("npm:react@0.12.2/lib/EventPropagators");
  var ReactInputSelection = require("npm:react@0.12.2/lib/ReactInputSelection");
  var SyntheticEvent = require("npm:react@0.12.2/lib/SyntheticEvent");
  var getActiveElement = require("npm:react@0.12.2/lib/getActiveElement");
  var isTextInputElement = require("npm:react@0.12.2/lib/isTextInputElement");
  var keyOf = require("npm:react@0.12.2/lib/keyOf");
  var shallowEqual = require("npm:react@0.12.2/lib/shallowEqual");
  var topLevelTypes = EventConstants.topLevelTypes;
  var eventTypes = {select: {
      phasedRegistrationNames: {
        bubbled: keyOf({onSelect: null}),
        captured: keyOf({onSelectCapture: null})
      },
      dependencies: [topLevelTypes.topBlur, topLevelTypes.topContextMenu, topLevelTypes.topFocus, topLevelTypes.topKeyDown, topLevelTypes.topMouseDown, topLevelTypes.topMouseUp, topLevelTypes.topSelectionChange]
    }};
  var activeElement = null;
  var activeElementID = null;
  var lastSelection = null;
  var mouseDown = false;
  function getSelection(node) {
    if ('selectionStart' in node && ReactInputSelection.hasSelectionCapabilities(node)) {
      return {
        start: node.selectionStart,
        end: node.selectionEnd
      };
    } else if (window.getSelection) {
      var selection = window.getSelection();
      return {
        anchorNode: selection.anchorNode,
        anchorOffset: selection.anchorOffset,
        focusNode: selection.focusNode,
        focusOffset: selection.focusOffset
      };
    } else if (document.selection) {
      var range = document.selection.createRange();
      return {
        parentElement: range.parentElement(),
        text: range.text,
        top: range.boundingTop,
        left: range.boundingLeft
      };
    }
  }
  function constructSelectEvent(nativeEvent) {
    if (mouseDown || activeElement == null || activeElement != getActiveElement()) {
      return ;
    }
    var currentSelection = getSelection(activeElement);
    if (!lastSelection || !shallowEqual(lastSelection, currentSelection)) {
      lastSelection = currentSelection;
      var syntheticEvent = SyntheticEvent.getPooled(eventTypes.select, activeElementID, nativeEvent);
      syntheticEvent.type = 'select';
      syntheticEvent.target = activeElement;
      EventPropagators.accumulateTwoPhaseDispatches(syntheticEvent);
      return syntheticEvent;
    }
  }
  var SelectEventPlugin = {
    eventTypes: eventTypes,
    extractEvents: function(topLevelType, topLevelTarget, topLevelTargetID, nativeEvent) {
      switch (topLevelType) {
        case topLevelTypes.topFocus:
          if (isTextInputElement(topLevelTarget) || topLevelTarget.contentEditable === 'true') {
            activeElement = topLevelTarget;
            activeElementID = topLevelTargetID;
            lastSelection = null;
          }
          break;
        case topLevelTypes.topBlur:
          activeElement = null;
          activeElementID = null;
          lastSelection = null;
          break;
        case topLevelTypes.topMouseDown:
          mouseDown = true;
          break;
        case topLevelTypes.topContextMenu:
        case topLevelTypes.topMouseUp:
          mouseDown = false;
          return constructSelectEvent(nativeEvent);
        case topLevelTypes.topSelectionChange:
        case topLevelTypes.topKeyDown:
        case topLevelTypes.topKeyUp:
          return constructSelectEvent(nativeEvent);
      }
    }
  };
  module.exports = SelectEventPlugin;
  global.define = __define;
  return module.exports;
});



System.register("npm:react@0.12.2/lib/SyntheticKeyboardEvent", ["npm:react@0.12.2/lib/SyntheticUIEvent", "npm:react@0.12.2/lib/getEventCharCode", "npm:react@0.12.2/lib/getEventKey", "npm:react@0.12.2/lib/getEventModifierState"], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  "use strict";
  var SyntheticUIEvent = require("npm:react@0.12.2/lib/SyntheticUIEvent");
  var getEventCharCode = require("npm:react@0.12.2/lib/getEventCharCode");
  var getEventKey = require("npm:react@0.12.2/lib/getEventKey");
  var getEventModifierState = require("npm:react@0.12.2/lib/getEventModifierState");
  var KeyboardEventInterface = {
    key: getEventKey,
    location: null,
    ctrlKey: null,
    shiftKey: null,
    altKey: null,
    metaKey: null,
    repeat: null,
    locale: null,
    getModifierState: getEventModifierState,
    charCode: function(event) {
      if (event.type === 'keypress') {
        return getEventCharCode(event);
      }
      return 0;
    },
    keyCode: function(event) {
      if (event.type === 'keydown' || event.type === 'keyup') {
        return event.keyCode;
      }
      return 0;
    },
    which: function(event) {
      if (event.type === 'keypress') {
        return getEventCharCode(event);
      }
      if (event.type === 'keydown' || event.type === 'keyup') {
        return event.keyCode;
      }
      return 0;
    }
  };
  function SyntheticKeyboardEvent(dispatchConfig, dispatchMarker, nativeEvent) {
    SyntheticUIEvent.call(this, dispatchConfig, dispatchMarker, nativeEvent);
  }
  SyntheticUIEvent.augmentClass(SyntheticKeyboardEvent, KeyboardEventInterface);
  module.exports = SyntheticKeyboardEvent;
  global.define = __define;
  return module.exports;
});



System.register("npm:react@0.12.2/lib/performanceNow", ["npm:react@0.12.2/lib/performance"], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  var performance = require("npm:react@0.12.2/lib/performance");
  if (!performance || !performance.now) {
    performance = Date;
  }
  var performanceNow = performance.now.bind(performance);
  module.exports = performanceNow;
  global.define = __define;
  return module.exports;
});



System.register("npm:react@0.12.2/lib/ReactServerRendering", ["npm:react@0.12.2/lib/ReactElement", "npm:react@0.12.2/lib/ReactInstanceHandles", "npm:react@0.12.2/lib/ReactMarkupChecksum", "npm:react@0.12.2/lib/ReactServerRenderingTransaction", "npm:react@0.12.2/lib/instantiateReactComponent", "npm:react@0.12.2/lib/invariant", "github:jspm/nodelibs-process@0.1.1"], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  (function(process) {
    "use strict";
    var ReactElement = require("npm:react@0.12.2/lib/ReactElement");
    var ReactInstanceHandles = require("npm:react@0.12.2/lib/ReactInstanceHandles");
    var ReactMarkupChecksum = require("npm:react@0.12.2/lib/ReactMarkupChecksum");
    var ReactServerRenderingTransaction = require("npm:react@0.12.2/lib/ReactServerRenderingTransaction");
    var instantiateReactComponent = require("npm:react@0.12.2/lib/instantiateReactComponent");
    var invariant = require("npm:react@0.12.2/lib/invariant");
    function renderToString(element) {
      ("production" !== process.env.NODE_ENV ? invariant(ReactElement.isValidElement(element), 'renderToString(): You must pass a valid ReactElement.') : invariant(ReactElement.isValidElement(element)));
      var transaction;
      try {
        var id = ReactInstanceHandles.createReactRootID();
        transaction = ReactServerRenderingTransaction.getPooled(false);
        return transaction.perform(function() {
          var componentInstance = instantiateReactComponent(element, null);
          var markup = componentInstance.mountComponent(id, transaction, 0);
          return ReactMarkupChecksum.addChecksumToMarkup(markup);
        }, null);
      } finally {
        ReactServerRenderingTransaction.release(transaction);
      }
    }
    function renderToStaticMarkup(element) {
      ("production" !== process.env.NODE_ENV ? invariant(ReactElement.isValidElement(element), 'renderToStaticMarkup(): You must pass a valid ReactElement.') : invariant(ReactElement.isValidElement(element)));
      var transaction;
      try {
        var id = ReactInstanceHandles.createReactRootID();
        transaction = ReactServerRenderingTransaction.getPooled(true);
        return transaction.perform(function() {
          var componentInstance = instantiateReactComponent(element, null);
          return componentInstance.mountComponent(id, transaction, 0);
        }, null);
      } finally {
        ReactServerRenderingTransaction.release(transaction);
      }
    }
    module.exports = {
      renderToString: renderToString,
      renderToStaticMarkup: renderToStaticMarkup
    };
  })(require("github:jspm/nodelibs-process@0.1.1"));
  global.define = __define;
  return module.exports;
});



System.register("npm:es5-ext@0.10.6/object/keys/index", ["npm:es5-ext@0.10.6/object/keys/is-implemented", "npm:es5-ext@0.10.6/object/keys/shim"], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  'use strict';
  module.exports = require("npm:es5-ext@0.10.6/object/keys/is-implemented")() ? Object.keys : require("npm:es5-ext@0.10.6/object/keys/shim");
  global.define = __define;
  return module.exports;
});



System.register("npm:es5-ext@0.10.6/string/#/contains/index", ["npm:es5-ext@0.10.6/string/#/contains/is-implemented", "npm:es5-ext@0.10.6/string/#/contains/shim"], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  'use strict';
  module.exports = require("npm:es5-ext@0.10.6/string/#/contains/is-implemented")() ? String.prototype.contains : require("npm:es5-ext@0.10.6/string/#/contains/shim");
  global.define = __define;
  return module.exports;
});



System.register("app/about.jsx!github:floatdrop/plugin-jsx@0.1.1", ["npm:react@0.12.2", "app/about-text.html!github:systemjs/plugin-text@0.0.2"], function($__export) {
  "use strict";
  var __moduleName = "app/about.jsx!github:floatdrop/plugin-jsx@0.1.1";
  var React,
      aboutText;
  return {
    setters: [function($__m) {
      React = $__m.default;
    }, function($__m) {
      aboutText = $__m.default;
    }],
    execute: function() {
      $__export('default', React.createClass({render: function() {
          return (React.createElement("div", {
            className: "about",
            dangerouslySetInnerHTML: {__html: aboutText}
          }));
        }}));
    }
  };
});



System.register("npm:w3c-blob@0.0.1", ["npm:w3c-blob@0.0.1/browser"], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  module.exports = require("npm:w3c-blob@0.0.1/browser");
  global.define = __define;
  return module.exports;
});



System.register("npm:base64-js@0.0.8", ["npm:base64-js@0.0.8/lib/b64"], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  module.exports = require("npm:base64-js@0.0.8/lib/b64");
  global.define = __define;
  return module.exports;
});



System.register("npm:ieee754@1.1.4", ["npm:ieee754@1.1.4/index"], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  module.exports = require("npm:ieee754@1.1.4/index");
  global.define = __define;
  return module.exports;
});



System.register("npm:is-array@1.0.1", ["npm:is-array@1.0.1/index"], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  module.exports = require("npm:is-array@1.0.1/index");
  global.define = __define;
  return module.exports;
});



System.register("npm:esprima@2.0.0", ["npm:esprima@2.0.0/esprima"], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  module.exports = require("npm:esprima@2.0.0/esprima");
  global.define = __define;
  return module.exports;
});



System.register("npm:lodash@3.3.1", ["npm:lodash@3.3.1/index"], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  module.exports = require("npm:lodash@3.3.1/index");
  global.define = __define;
  return module.exports;
});



System.register("app/nodes/function-declaration.jsx!github:floatdrop/plugin-jsx@0.1.1", ["npm:react@0.12.2", "app/ast-node.jsx!github:floatdrop/plugin-jsx@0.1.1", "app/mixins/path", "app/mixins/render-node-property.jsx!github:floatdrop/plugin-jsx@0.1.1"], function($__export) {
  "use strict";
  var __moduleName = "app/nodes/function-declaration.jsx!github:floatdrop/plugin-jsx@0.1.1";
  var React,
      ASTNode,
      PathMixin,
      RenderNodeMixin;
  return {
    setters: [function($__m) {
      React = $__m.default;
    }, function($__m) {
      ASTNode = $__m.default;
    }, function($__m) {
      PathMixin = $__m.default;
    }, function($__m) {
      RenderNodeMixin = $__m.default;
    }],
    execute: function() {
      $__export('default', React.createClass({
        mixins: [PathMixin, RenderNodeMixin],
        render: function() {
          return (React.createElement("ul", null, this.renderProp('name'), this.renderNode('body')));
        }
      }));
    }
  };
});



System.register("github:jspm/nodelibs-process@0.1.1/index", ["npm:process@0.10.1"], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  module.exports = System._nodeRequire ? process : require("npm:process@0.10.1");
  global.define = __define;
  return module.exports;
});



System.register("npm:react@0.12.2/lib/EventPluginUtils", ["npm:react@0.12.2/lib/EventConstants", "npm:react@0.12.2/lib/invariant", "github:jspm/nodelibs-process@0.1.1"], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  (function(process) {
    "use strict";
    var EventConstants = require("npm:react@0.12.2/lib/EventConstants");
    var invariant = require("npm:react@0.12.2/lib/invariant");
    var injection = {
      Mount: null,
      injectMount: function(InjectedMount) {
        injection.Mount = InjectedMount;
        if ("production" !== process.env.NODE_ENV) {
          ("production" !== process.env.NODE_ENV ? invariant(InjectedMount && InjectedMount.getNode, 'EventPluginUtils.injection.injectMount(...): Injected Mount module ' + 'is missing getNode.') : invariant(InjectedMount && InjectedMount.getNode));
        }
      }
    };
    var topLevelTypes = EventConstants.topLevelTypes;
    function isEndish(topLevelType) {
      return topLevelType === topLevelTypes.topMouseUp || topLevelType === topLevelTypes.topTouchEnd || topLevelType === topLevelTypes.topTouchCancel;
    }
    function isMoveish(topLevelType) {
      return topLevelType === topLevelTypes.topMouseMove || topLevelType === topLevelTypes.topTouchMove;
    }
    function isStartish(topLevelType) {
      return topLevelType === topLevelTypes.topMouseDown || topLevelType === topLevelTypes.topTouchStart;
    }
    var validateEventDispatches;
    if ("production" !== process.env.NODE_ENV) {
      validateEventDispatches = function(event) {
        var dispatchListeners = event._dispatchListeners;
        var dispatchIDs = event._dispatchIDs;
        var listenersIsArr = Array.isArray(dispatchListeners);
        var idsIsArr = Array.isArray(dispatchIDs);
        var IDsLen = idsIsArr ? dispatchIDs.length : dispatchIDs ? 1 : 0;
        var listenersLen = listenersIsArr ? dispatchListeners.length : dispatchListeners ? 1 : 0;
        ("production" !== process.env.NODE_ENV ? invariant(idsIsArr === listenersIsArr && IDsLen === listenersLen, 'EventPluginUtils: Invalid `event`.') : invariant(idsIsArr === listenersIsArr && IDsLen === listenersLen));
      };
    }
    function forEachEventDispatch(event, cb) {
      var dispatchListeners = event._dispatchListeners;
      var dispatchIDs = event._dispatchIDs;
      if ("production" !== process.env.NODE_ENV) {
        validateEventDispatches(event);
      }
      if (Array.isArray(dispatchListeners)) {
        for (var i = 0; i < dispatchListeners.length; i++) {
          if (event.isPropagationStopped()) {
            break;
          }
          cb(event, dispatchListeners[i], dispatchIDs[i]);
        }
      } else if (dispatchListeners) {
        cb(event, dispatchListeners, dispatchIDs);
      }
    }
    function executeDispatch(event, listener, domID) {
      event.currentTarget = injection.Mount.getNode(domID);
      var returnValue = listener(event, domID);
      event.currentTarget = null;
      return returnValue;
    }
    function executeDispatchesInOrder(event, executeDispatch) {
      forEachEventDispatch(event, executeDispatch);
      event._dispatchListeners = null;
      event._dispatchIDs = null;
    }
    function executeDispatchesInOrderStopAtTrueImpl(event) {
      var dispatchListeners = event._dispatchListeners;
      var dispatchIDs = event._dispatchIDs;
      if ("production" !== process.env.NODE_ENV) {
        validateEventDispatches(event);
      }
      if (Array.isArray(dispatchListeners)) {
        for (var i = 0; i < dispatchListeners.length; i++) {
          if (event.isPropagationStopped()) {
            break;
          }
          if (dispatchListeners[i](event, dispatchIDs[i])) {
            return dispatchIDs[i];
          }
        }
      } else if (dispatchListeners) {
        if (dispatchListeners(event, dispatchIDs)) {
          return dispatchIDs;
        }
      }
      return null;
    }
    function executeDispatchesInOrderStopAtTrue(event) {
      var ret = executeDispatchesInOrderStopAtTrueImpl(event);
      event._dispatchIDs = null;
      event._dispatchListeners = null;
      return ret;
    }
    function executeDirectDispatch(event) {
      if ("production" !== process.env.NODE_ENV) {
        validateEventDispatches(event);
      }
      var dispatchListener = event._dispatchListeners;
      var dispatchID = event._dispatchIDs;
      ("production" !== process.env.NODE_ENV ? invariant(!Array.isArray(dispatchListener), 'executeDirectDispatch(...): Invalid `event`.') : invariant(!Array.isArray(dispatchListener)));
      var res = dispatchListener ? dispatchListener(event, dispatchID) : null;
      event._dispatchListeners = null;
      event._dispatchIDs = null;
      return res;
    }
    function hasDispatches(event) {
      return !!event._dispatchListeners;
    }
    var EventPluginUtils = {
      isEndish: isEndish,
      isMoveish: isMoveish,
      isStartish: isStartish,
      executeDirectDispatch: executeDirectDispatch,
      executeDispatch: executeDispatch,
      executeDispatchesInOrder: executeDispatchesInOrder,
      executeDispatchesInOrderStopAtTrue: executeDispatchesInOrderStopAtTrue,
      hasDispatches: hasDispatches,
      injection: injection,
      useTouchEvents: false
    };
    module.exports = EventPluginUtils;
  })(require("github:jspm/nodelibs-process@0.1.1"));
  global.define = __define;
  return module.exports;
});



System.register("npm:react@0.12.2/lib/ReactElement", ["npm:react@0.12.2/lib/ReactContext", "npm:react@0.12.2/lib/ReactCurrentOwner", "npm:react@0.12.2/lib/warning", "github:jspm/nodelibs-process@0.1.1"], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  (function(process) {
    "use strict";
    var ReactContext = require("npm:react@0.12.2/lib/ReactContext");
    var ReactCurrentOwner = require("npm:react@0.12.2/lib/ReactCurrentOwner");
    var warning = require("npm:react@0.12.2/lib/warning");
    var RESERVED_PROPS = {
      key: true,
      ref: true
    };
    function defineWarningProperty(object, key) {
      Object.defineProperty(object, key, {
        configurable: false,
        enumerable: true,
        get: function() {
          if (!this._store) {
            return null;
          }
          return this._store[key];
        },
        set: function(value) {
          ("production" !== process.env.NODE_ENV ? warning(false, 'Don\'t set the ' + key + ' property of the component. ' + 'Mutate the existing props object instead.') : null);
          this._store[key] = value;
        }
      });
    }
    var useMutationMembrane = false;
    function defineMutationMembrane(prototype) {
      try {
        var pseudoFrozenProperties = {props: true};
        for (var key in pseudoFrozenProperties) {
          defineWarningProperty(prototype, key);
        }
        useMutationMembrane = true;
      } catch (x) {}
    }
    var ReactElement = function(type, key, ref, owner, context, props) {
      this.type = type;
      this.key = key;
      this.ref = ref;
      this._owner = owner;
      this._context = context;
      if ("production" !== process.env.NODE_ENV) {
        this._store = {
          validated: false,
          props: props
        };
        if (useMutationMembrane) {
          Object.freeze(this);
          return ;
        }
      }
      this.props = props;
    };
    ReactElement.prototype = {_isReactElement: true};
    if ("production" !== process.env.NODE_ENV) {
      defineMutationMembrane(ReactElement.prototype);
    }
    ReactElement.createElement = function(type, config, children) {
      var propName;
      var props = {};
      var key = null;
      var ref = null;
      if (config != null) {
        ref = config.ref === undefined ? null : config.ref;
        if ("production" !== process.env.NODE_ENV) {
          ("production" !== process.env.NODE_ENV ? warning(config.key !== null, 'createElement(...): Encountered component with a `key` of null. In ' + 'a future version, this will be treated as equivalent to the string ' + '\'null\'; instead, provide an explicit key or use undefined.') : null);
        }
        key = config.key == null ? null : '' + config.key;
        for (propName in config) {
          if (config.hasOwnProperty(propName) && !RESERVED_PROPS.hasOwnProperty(propName)) {
            props[propName] = config[propName];
          }
        }
      }
      var childrenLength = arguments.length - 2;
      if (childrenLength === 1) {
        props.children = children;
      } else if (childrenLength > 1) {
        var childArray = Array(childrenLength);
        for (var i = 0; i < childrenLength; i++) {
          childArray[i] = arguments[i + 2];
        }
        props.children = childArray;
      }
      if (type && type.defaultProps) {
        var defaultProps = type.defaultProps;
        for (propName in defaultProps) {
          if (typeof props[propName] === 'undefined') {
            props[propName] = defaultProps[propName];
          }
        }
      }
      return new ReactElement(type, key, ref, ReactCurrentOwner.current, ReactContext.current, props);
    };
    ReactElement.createFactory = function(type) {
      var factory = ReactElement.createElement.bind(null, type);
      factory.type = type;
      return factory;
    };
    ReactElement.cloneAndReplaceProps = function(oldElement, newProps) {
      var newElement = new ReactElement(oldElement.type, oldElement.key, oldElement.ref, oldElement._owner, oldElement._context, newProps);
      if ("production" !== process.env.NODE_ENV) {
        newElement._store.validated = oldElement._store.validated;
      }
      return newElement;
    };
    ReactElement.isValidElement = function(object) {
      var isElement = !!(object && object._isReactElement);
      return isElement;
    };
    module.exports = ReactElement;
  })(require("github:jspm/nodelibs-process@0.1.1"));
  global.define = __define;
  return module.exports;
});



System.register("npm:react@0.12.2/lib/ReactComponent", ["npm:react@0.12.2/lib/ReactElement", "npm:react@0.12.2/lib/ReactOwner", "npm:react@0.12.2/lib/ReactUpdates", "npm:react@0.12.2/lib/Object.assign", "npm:react@0.12.2/lib/invariant", "npm:react@0.12.2/lib/keyMirror", "github:jspm/nodelibs-process@0.1.1"], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  (function(process) {
    "use strict";
    var ReactElement = require("npm:react@0.12.2/lib/ReactElement");
    var ReactOwner = require("npm:react@0.12.2/lib/ReactOwner");
    var ReactUpdates = require("npm:react@0.12.2/lib/ReactUpdates");
    var assign = require("npm:react@0.12.2/lib/Object.assign");
    var invariant = require("npm:react@0.12.2/lib/invariant");
    var keyMirror = require("npm:react@0.12.2/lib/keyMirror");
    var ComponentLifeCycle = keyMirror({
      MOUNTED: null,
      UNMOUNTED: null
    });
    var injected = false;
    var unmountIDFromEnvironment = null;
    var mountImageIntoNode = null;
    var ReactComponent = {
      injection: {injectEnvironment: function(ReactComponentEnvironment) {
          ("production" !== process.env.NODE_ENV ? invariant(!injected, 'ReactComponent: injectEnvironment() can only be called once.') : invariant(!injected));
          mountImageIntoNode = ReactComponentEnvironment.mountImageIntoNode;
          unmountIDFromEnvironment = ReactComponentEnvironment.unmountIDFromEnvironment;
          ReactComponent.BackendIDOperations = ReactComponentEnvironment.BackendIDOperations;
          injected = true;
        }},
      LifeCycle: ComponentLifeCycle,
      BackendIDOperations: null,
      Mixin: {
        isMounted: function() {
          return this._lifeCycleState === ComponentLifeCycle.MOUNTED;
        },
        setProps: function(partialProps, callback) {
          var element = this._pendingElement || this._currentElement;
          this.replaceProps(assign({}, element.props, partialProps), callback);
        },
        replaceProps: function(props, callback) {
          ("production" !== process.env.NODE_ENV ? invariant(this.isMounted(), 'replaceProps(...): Can only update a mounted component.') : invariant(this.isMounted()));
          ("production" !== process.env.NODE_ENV ? invariant(this._mountDepth === 0, 'replaceProps(...): You called `setProps` or `replaceProps` on a ' + 'component with a parent. This is an anti-pattern since props will ' + 'get reactively updated when rendered. Instead, change the owner\'s ' + '`render` method to pass the correct value as props to the component ' + 'where it is created.') : invariant(this._mountDepth === 0));
          this._pendingElement = ReactElement.cloneAndReplaceProps(this._pendingElement || this._currentElement, props);
          ReactUpdates.enqueueUpdate(this, callback);
        },
        _setPropsInternal: function(partialProps, callback) {
          var element = this._pendingElement || this._currentElement;
          this._pendingElement = ReactElement.cloneAndReplaceProps(element, assign({}, element.props, partialProps));
          ReactUpdates.enqueueUpdate(this, callback);
        },
        construct: function(element) {
          this.props = element.props;
          this._owner = element._owner;
          this._lifeCycleState = ComponentLifeCycle.UNMOUNTED;
          this._pendingCallbacks = null;
          this._currentElement = element;
          this._pendingElement = null;
        },
        mountComponent: function(rootID, transaction, mountDepth) {
          ("production" !== process.env.NODE_ENV ? invariant(!this.isMounted(), 'mountComponent(%s, ...): Can only mount an unmounted component. ' + 'Make sure to avoid storing components between renders or reusing a ' + 'single component instance in multiple places.', rootID) : invariant(!this.isMounted()));
          var ref = this._currentElement.ref;
          if (ref != null) {
            var owner = this._currentElement._owner;
            ReactOwner.addComponentAsRefTo(this, ref, owner);
          }
          this._rootNodeID = rootID;
          this._lifeCycleState = ComponentLifeCycle.MOUNTED;
          this._mountDepth = mountDepth;
        },
        unmountComponent: function() {
          ("production" !== process.env.NODE_ENV ? invariant(this.isMounted(), 'unmountComponent(): Can only unmount a mounted component.') : invariant(this.isMounted()));
          var ref = this._currentElement.ref;
          if (ref != null) {
            ReactOwner.removeComponentAsRefFrom(this, ref, this._owner);
          }
          unmountIDFromEnvironment(this._rootNodeID);
          this._rootNodeID = null;
          this._lifeCycleState = ComponentLifeCycle.UNMOUNTED;
        },
        receiveComponent: function(nextElement, transaction) {
          ("production" !== process.env.NODE_ENV ? invariant(this.isMounted(), 'receiveComponent(...): Can only update a mounted component.') : invariant(this.isMounted()));
          this._pendingElement = nextElement;
          this.performUpdateIfNecessary(transaction);
        },
        performUpdateIfNecessary: function(transaction) {
          if (this._pendingElement == null) {
            return ;
          }
          var prevElement = this._currentElement;
          var nextElement = this._pendingElement;
          this._currentElement = nextElement;
          this.props = nextElement.props;
          this._owner = nextElement._owner;
          this._pendingElement = null;
          this.updateComponent(transaction, prevElement);
        },
        updateComponent: function(transaction, prevElement) {
          var nextElement = this._currentElement;
          if (nextElement._owner !== prevElement._owner || nextElement.ref !== prevElement.ref) {
            if (prevElement.ref != null) {
              ReactOwner.removeComponentAsRefFrom(this, prevElement.ref, prevElement._owner);
            }
            if (nextElement.ref != null) {
              ReactOwner.addComponentAsRefTo(this, nextElement.ref, nextElement._owner);
            }
          }
        },
        mountComponentIntoNode: function(rootID, container, shouldReuseMarkup) {
          var transaction = ReactUpdates.ReactReconcileTransaction.getPooled();
          transaction.perform(this._mountComponentIntoNode, this, rootID, container, transaction, shouldReuseMarkup);
          ReactUpdates.ReactReconcileTransaction.release(transaction);
        },
        _mountComponentIntoNode: function(rootID, container, transaction, shouldReuseMarkup) {
          var markup = this.mountComponent(rootID, transaction, 0);
          mountImageIntoNode(markup, container, shouldReuseMarkup);
        },
        isOwnedBy: function(owner) {
          return this._owner === owner;
        },
        getSiblingByRef: function(ref) {
          var owner = this._owner;
          if (!owner || !owner.refs) {
            return null;
          }
          return owner.refs[ref];
        }
      }
    };
    module.exports = ReactComponent;
  })(require("github:jspm/nodelibs-process@0.1.1"));
  global.define = __define;
  return module.exports;
});



System.register("npm:react@0.12.2/lib/ReactCompositeComponent", ["npm:react@0.12.2/lib/ReactComponent", "npm:react@0.12.2/lib/ReactContext", "npm:react@0.12.2/lib/ReactCurrentOwner", "npm:react@0.12.2/lib/ReactElement", "npm:react@0.12.2/lib/ReactElementValidator", "npm:react@0.12.2/lib/ReactEmptyComponent", "npm:react@0.12.2/lib/ReactErrorUtils", "npm:react@0.12.2/lib/ReactLegacyElement", "npm:react@0.12.2/lib/ReactOwner", "npm:react@0.12.2/lib/ReactPerf", "npm:react@0.12.2/lib/ReactPropTransferer", "npm:react@0.12.2/lib/ReactPropTypeLocations", "npm:react@0.12.2/lib/ReactPropTypeLocationNames", "npm:react@0.12.2/lib/ReactUpdates", "npm:react@0.12.2/lib/Object.assign", "npm:react@0.12.2/lib/instantiateReactComponent", "npm:react@0.12.2/lib/invariant", "npm:react@0.12.2/lib/keyMirror", "npm:react@0.12.2/lib/keyOf", "npm:react@0.12.2/lib/monitorCodeUse", "npm:react@0.12.2/lib/mapObject", "npm:react@0.12.2/lib/shouldUpdateReactComponent", "npm:react@0.12.2/lib/warning", "github:jspm/nodelibs-process@0.1.1"], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  (function(process) {
    "use strict";
    var ReactComponent = require("npm:react@0.12.2/lib/ReactComponent");
    var ReactContext = require("npm:react@0.12.2/lib/ReactContext");
    var ReactCurrentOwner = require("npm:react@0.12.2/lib/ReactCurrentOwner");
    var ReactElement = require("npm:react@0.12.2/lib/ReactElement");
    var ReactElementValidator = require("npm:react@0.12.2/lib/ReactElementValidator");
    var ReactEmptyComponent = require("npm:react@0.12.2/lib/ReactEmptyComponent");
    var ReactErrorUtils = require("npm:react@0.12.2/lib/ReactErrorUtils");
    var ReactLegacyElement = require("npm:react@0.12.2/lib/ReactLegacyElement");
    var ReactOwner = require("npm:react@0.12.2/lib/ReactOwner");
    var ReactPerf = require("npm:react@0.12.2/lib/ReactPerf");
    var ReactPropTransferer = require("npm:react@0.12.2/lib/ReactPropTransferer");
    var ReactPropTypeLocations = require("npm:react@0.12.2/lib/ReactPropTypeLocations");
    var ReactPropTypeLocationNames = require("npm:react@0.12.2/lib/ReactPropTypeLocationNames");
    var ReactUpdates = require("npm:react@0.12.2/lib/ReactUpdates");
    var assign = require("npm:react@0.12.2/lib/Object.assign");
    var instantiateReactComponent = require("npm:react@0.12.2/lib/instantiateReactComponent");
    var invariant = require("npm:react@0.12.2/lib/invariant");
    var keyMirror = require("npm:react@0.12.2/lib/keyMirror");
    var keyOf = require("npm:react@0.12.2/lib/keyOf");
    var monitorCodeUse = require("npm:react@0.12.2/lib/monitorCodeUse");
    var mapObject = require("npm:react@0.12.2/lib/mapObject");
    var shouldUpdateReactComponent = require("npm:react@0.12.2/lib/shouldUpdateReactComponent");
    var warning = require("npm:react@0.12.2/lib/warning");
    var MIXINS_KEY = keyOf({mixins: null});
    var SpecPolicy = keyMirror({
      DEFINE_ONCE: null,
      DEFINE_MANY: null,
      OVERRIDE_BASE: null,
      DEFINE_MANY_MERGED: null
    });
    var injectedMixins = [];
    var ReactCompositeComponentInterface = {
      mixins: SpecPolicy.DEFINE_MANY,
      statics: SpecPolicy.DEFINE_MANY,
      propTypes: SpecPolicy.DEFINE_MANY,
      contextTypes: SpecPolicy.DEFINE_MANY,
      childContextTypes: SpecPolicy.DEFINE_MANY,
      getDefaultProps: SpecPolicy.DEFINE_MANY_MERGED,
      getInitialState: SpecPolicy.DEFINE_MANY_MERGED,
      getChildContext: SpecPolicy.DEFINE_MANY_MERGED,
      render: SpecPolicy.DEFINE_ONCE,
      componentWillMount: SpecPolicy.DEFINE_MANY,
      componentDidMount: SpecPolicy.DEFINE_MANY,
      componentWillReceiveProps: SpecPolicy.DEFINE_MANY,
      shouldComponentUpdate: SpecPolicy.DEFINE_ONCE,
      componentWillUpdate: SpecPolicy.DEFINE_MANY,
      componentDidUpdate: SpecPolicy.DEFINE_MANY,
      componentWillUnmount: SpecPolicy.DEFINE_MANY,
      updateComponent: SpecPolicy.OVERRIDE_BASE
    };
    var RESERVED_SPEC_KEYS = {
      displayName: function(Constructor, displayName) {
        Constructor.displayName = displayName;
      },
      mixins: function(Constructor, mixins) {
        if (mixins) {
          for (var i = 0; i < mixins.length; i++) {
            mixSpecIntoComponent(Constructor, mixins[i]);
          }
        }
      },
      childContextTypes: function(Constructor, childContextTypes) {
        validateTypeDef(Constructor, childContextTypes, ReactPropTypeLocations.childContext);
        Constructor.childContextTypes = assign({}, Constructor.childContextTypes, childContextTypes);
      },
      contextTypes: function(Constructor, contextTypes) {
        validateTypeDef(Constructor, contextTypes, ReactPropTypeLocations.context);
        Constructor.contextTypes = assign({}, Constructor.contextTypes, contextTypes);
      },
      getDefaultProps: function(Constructor, getDefaultProps) {
        if (Constructor.getDefaultProps) {
          Constructor.getDefaultProps = createMergedResultFunction(Constructor.getDefaultProps, getDefaultProps);
        } else {
          Constructor.getDefaultProps = getDefaultProps;
        }
      },
      propTypes: function(Constructor, propTypes) {
        validateTypeDef(Constructor, propTypes, ReactPropTypeLocations.prop);
        Constructor.propTypes = assign({}, Constructor.propTypes, propTypes);
      },
      statics: function(Constructor, statics) {
        mixStaticSpecIntoComponent(Constructor, statics);
      }
    };
    function getDeclarationErrorAddendum(component) {
      var owner = component._owner || null;
      if (owner && owner.constructor && owner.constructor.displayName) {
        return ' Check the render method of `' + owner.constructor.displayName + '`.';
      }
      return '';
    }
    function validateTypeDef(Constructor, typeDef, location) {
      for (var propName in typeDef) {
        if (typeDef.hasOwnProperty(propName)) {
          ("production" !== process.env.NODE_ENV ? invariant(typeof typeDef[propName] == 'function', '%s: %s type `%s` is invalid; it must be a function, usually from ' + 'React.PropTypes.', Constructor.displayName || 'ReactCompositeComponent', ReactPropTypeLocationNames[location], propName) : invariant(typeof typeDef[propName] == 'function'));
        }
      }
    }
    function validateMethodOverride(proto, name) {
      var specPolicy = ReactCompositeComponentInterface.hasOwnProperty(name) ? ReactCompositeComponentInterface[name] : null;
      if (ReactCompositeComponentMixin.hasOwnProperty(name)) {
        ("production" !== process.env.NODE_ENV ? invariant(specPolicy === SpecPolicy.OVERRIDE_BASE, 'ReactCompositeComponentInterface: You are attempting to override ' + '`%s` from your class specification. Ensure that your method names ' + 'do not overlap with React methods.', name) : invariant(specPolicy === SpecPolicy.OVERRIDE_BASE));
      }
      if (proto.hasOwnProperty(name)) {
        ("production" !== process.env.NODE_ENV ? invariant(specPolicy === SpecPolicy.DEFINE_MANY || specPolicy === SpecPolicy.DEFINE_MANY_MERGED, 'ReactCompositeComponentInterface: You are attempting to define ' + '`%s` on your component more than once. This conflict may be due ' + 'to a mixin.', name) : invariant(specPolicy === SpecPolicy.DEFINE_MANY || specPolicy === SpecPolicy.DEFINE_MANY_MERGED));
      }
    }
    function validateLifeCycleOnReplaceState(instance) {
      var compositeLifeCycleState = instance._compositeLifeCycleState;
      ("production" !== process.env.NODE_ENV ? invariant(instance.isMounted() || compositeLifeCycleState === CompositeLifeCycle.MOUNTING, 'replaceState(...): Can only update a mounted or mounting component.') : invariant(instance.isMounted() || compositeLifeCycleState === CompositeLifeCycle.MOUNTING));
      ("production" !== process.env.NODE_ENV ? invariant(ReactCurrentOwner.current == null, 'replaceState(...): Cannot update during an existing state transition ' + '(such as within `render`). Render methods should be a pure function ' + 'of props and state.') : invariant(ReactCurrentOwner.current == null));
      ("production" !== process.env.NODE_ENV ? invariant(compositeLifeCycleState !== CompositeLifeCycle.UNMOUNTING, 'replaceState(...): Cannot update while unmounting component. This ' + 'usually means you called setState() on an unmounted component.') : invariant(compositeLifeCycleState !== CompositeLifeCycle.UNMOUNTING));
    }
    function mixSpecIntoComponent(Constructor, spec) {
      if (!spec) {
        return ;
      }
      ("production" !== process.env.NODE_ENV ? invariant(!ReactLegacyElement.isValidFactory(spec), 'ReactCompositeComponent: You\'re attempting to ' + 'use a component class as a mixin. Instead, just use a regular object.') : invariant(!ReactLegacyElement.isValidFactory(spec)));
      ("production" !== process.env.NODE_ENV ? invariant(!ReactElement.isValidElement(spec), 'ReactCompositeComponent: You\'re attempting to ' + 'use a component as a mixin. Instead, just use a regular object.') : invariant(!ReactElement.isValidElement(spec)));
      var proto = Constructor.prototype;
      if (spec.hasOwnProperty(MIXINS_KEY)) {
        RESERVED_SPEC_KEYS.mixins(Constructor, spec.mixins);
      }
      for (var name in spec) {
        if (!spec.hasOwnProperty(name)) {
          continue;
        }
        if (name === MIXINS_KEY) {
          continue;
        }
        var property = spec[name];
        validateMethodOverride(proto, name);
        if (RESERVED_SPEC_KEYS.hasOwnProperty(name)) {
          RESERVED_SPEC_KEYS[name](Constructor, property);
        } else {
          var isCompositeComponentMethod = ReactCompositeComponentInterface.hasOwnProperty(name);
          var isAlreadyDefined = proto.hasOwnProperty(name);
          var markedDontBind = property && property.__reactDontBind;
          var isFunction = typeof property === 'function';
          var shouldAutoBind = isFunction && !isCompositeComponentMethod && !isAlreadyDefined && !markedDontBind;
          if (shouldAutoBind) {
            if (!proto.__reactAutoBindMap) {
              proto.__reactAutoBindMap = {};
            }
            proto.__reactAutoBindMap[name] = property;
            proto[name] = property;
          } else {
            if (isAlreadyDefined) {
              var specPolicy = ReactCompositeComponentInterface[name];
              ("production" !== process.env.NODE_ENV ? invariant(isCompositeComponentMethod && (specPolicy === SpecPolicy.DEFINE_MANY_MERGED || specPolicy === SpecPolicy.DEFINE_MANY), 'ReactCompositeComponent: Unexpected spec policy %s for key %s ' + 'when mixing in component specs.', specPolicy, name) : invariant(isCompositeComponentMethod && (specPolicy === SpecPolicy.DEFINE_MANY_MERGED || specPolicy === SpecPolicy.DEFINE_MANY)));
              if (specPolicy === SpecPolicy.DEFINE_MANY_MERGED) {
                proto[name] = createMergedResultFunction(proto[name], property);
              } else if (specPolicy === SpecPolicy.DEFINE_MANY) {
                proto[name] = createChainedFunction(proto[name], property);
              }
            } else {
              proto[name] = property;
              if ("production" !== process.env.NODE_ENV) {
                if (typeof property === 'function' && spec.displayName) {
                  proto[name].displayName = spec.displayName + '_' + name;
                }
              }
            }
          }
        }
      }
    }
    function mixStaticSpecIntoComponent(Constructor, statics) {
      if (!statics) {
        return ;
      }
      for (var name in statics) {
        var property = statics[name];
        if (!statics.hasOwnProperty(name)) {
          continue;
        }
        var isReserved = name in RESERVED_SPEC_KEYS;
        ("production" !== process.env.NODE_ENV ? invariant(!isReserved, 'ReactCompositeComponent: You are attempting to define a reserved ' + 'property, `%s`, that shouldn\'t be on the "statics" key. Define it ' + 'as an instance property instead; it will still be accessible on the ' + 'constructor.', name) : invariant(!isReserved));
        var isInherited = name in Constructor;
        ("production" !== process.env.NODE_ENV ? invariant(!isInherited, 'ReactCompositeComponent: You are attempting to define ' + '`%s` on your component more than once. This conflict may be ' + 'due to a mixin.', name) : invariant(!isInherited));
        Constructor[name] = property;
      }
    }
    function mergeObjectsWithNoDuplicateKeys(one, two) {
      ("production" !== process.env.NODE_ENV ? invariant(one && two && typeof one === 'object' && typeof two === 'object', 'mergeObjectsWithNoDuplicateKeys(): Cannot merge non-objects') : invariant(one && two && typeof one === 'object' && typeof two === 'object'));
      mapObject(two, function(value, key) {
        ("production" !== process.env.NODE_ENV ? invariant(one[key] === undefined, 'mergeObjectsWithNoDuplicateKeys(): ' + 'Tried to merge two objects with the same key: `%s`. This conflict ' + 'may be due to a mixin; in particular, this may be caused by two ' + 'getInitialState() or getDefaultProps() methods returning objects ' + 'with clashing keys.', key) : invariant(one[key] === undefined));
        one[key] = value;
      });
      return one;
    }
    function createMergedResultFunction(one, two) {
      return function mergedResult() {
        var a = one.apply(this, arguments);
        var b = two.apply(this, arguments);
        if (a == null) {
          return b;
        } else if (b == null) {
          return a;
        }
        return mergeObjectsWithNoDuplicateKeys(a, b);
      };
    }
    function createChainedFunction(one, two) {
      return function chainedFunction() {
        one.apply(this, arguments);
        two.apply(this, arguments);
      };
    }
    var CompositeLifeCycle = keyMirror({
      MOUNTING: null,
      UNMOUNTING: null,
      RECEIVING_PROPS: null
    });
    var ReactCompositeComponentMixin = {
      construct: function(element) {
        ReactComponent.Mixin.construct.apply(this, arguments);
        ReactOwner.Mixin.construct.apply(this, arguments);
        this.state = null;
        this._pendingState = null;
        this.context = null;
        this._compositeLifeCycleState = null;
      },
      isMounted: function() {
        return ReactComponent.Mixin.isMounted.call(this) && this._compositeLifeCycleState !== CompositeLifeCycle.MOUNTING;
      },
      mountComponent: ReactPerf.measure('ReactCompositeComponent', 'mountComponent', function(rootID, transaction, mountDepth) {
        ReactComponent.Mixin.mountComponent.call(this, rootID, transaction, mountDepth);
        this._compositeLifeCycleState = CompositeLifeCycle.MOUNTING;
        if (this.__reactAutoBindMap) {
          this._bindAutoBindMethods();
        }
        this.context = this._processContext(this._currentElement._context);
        this.props = this._processProps(this.props);
        this.state = this.getInitialState ? this.getInitialState() : null;
        ("production" !== process.env.NODE_ENV ? invariant(typeof this.state === 'object' && !Array.isArray(this.state), '%s.getInitialState(): must return an object or null', this.constructor.displayName || 'ReactCompositeComponent') : invariant(typeof this.state === 'object' && !Array.isArray(this.state)));
        this._pendingState = null;
        this._pendingForceUpdate = false;
        if (this.componentWillMount) {
          this.componentWillMount();
          if (this._pendingState) {
            this.state = this._pendingState;
            this._pendingState = null;
          }
        }
        this._renderedComponent = instantiateReactComponent(this._renderValidatedComponent(), this._currentElement.type);
        this._compositeLifeCycleState = null;
        var markup = this._renderedComponent.mountComponent(rootID, transaction, mountDepth + 1);
        if (this.componentDidMount) {
          transaction.getReactMountReady().enqueue(this.componentDidMount, this);
        }
        return markup;
      }),
      unmountComponent: function() {
        this._compositeLifeCycleState = CompositeLifeCycle.UNMOUNTING;
        if (this.componentWillUnmount) {
          this.componentWillUnmount();
        }
        this._compositeLifeCycleState = null;
        this._renderedComponent.unmountComponent();
        this._renderedComponent = null;
        ReactComponent.Mixin.unmountComponent.call(this);
      },
      setState: function(partialState, callback) {
        ("production" !== process.env.NODE_ENV ? invariant(typeof partialState === 'object' || partialState == null, 'setState(...): takes an object of state variables to update.') : invariant(typeof partialState === 'object' || partialState == null));
        if ("production" !== process.env.NODE_ENV) {
          ("production" !== process.env.NODE_ENV ? warning(partialState != null, 'setState(...): You passed an undefined or null state object; ' + 'instead, use forceUpdate().') : null);
        }
        this.replaceState(assign({}, this._pendingState || this.state, partialState), callback);
      },
      replaceState: function(completeState, callback) {
        validateLifeCycleOnReplaceState(this);
        this._pendingState = completeState;
        if (this._compositeLifeCycleState !== CompositeLifeCycle.MOUNTING) {
          ReactUpdates.enqueueUpdate(this, callback);
        }
      },
      _processContext: function(context) {
        var maskedContext = null;
        var contextTypes = this.constructor.contextTypes;
        if (contextTypes) {
          maskedContext = {};
          for (var contextName in contextTypes) {
            maskedContext[contextName] = context[contextName];
          }
          if ("production" !== process.env.NODE_ENV) {
            this._checkPropTypes(contextTypes, maskedContext, ReactPropTypeLocations.context);
          }
        }
        return maskedContext;
      },
      _processChildContext: function(currentContext) {
        var childContext = this.getChildContext && this.getChildContext();
        var displayName = this.constructor.displayName || 'ReactCompositeComponent';
        if (childContext) {
          ("production" !== process.env.NODE_ENV ? invariant(typeof this.constructor.childContextTypes === 'object', '%s.getChildContext(): childContextTypes must be defined in order to ' + 'use getChildContext().', displayName) : invariant(typeof this.constructor.childContextTypes === 'object'));
          if ("production" !== process.env.NODE_ENV) {
            this._checkPropTypes(this.constructor.childContextTypes, childContext, ReactPropTypeLocations.childContext);
          }
          for (var name in childContext) {
            ("production" !== process.env.NODE_ENV ? invariant(name in this.constructor.childContextTypes, '%s.getChildContext(): key "%s" is not defined in childContextTypes.', displayName, name) : invariant(name in this.constructor.childContextTypes));
          }
          return assign({}, currentContext, childContext);
        }
        return currentContext;
      },
      _processProps: function(newProps) {
        if ("production" !== process.env.NODE_ENV) {
          var propTypes = this.constructor.propTypes;
          if (propTypes) {
            this._checkPropTypes(propTypes, newProps, ReactPropTypeLocations.prop);
          }
        }
        return newProps;
      },
      _checkPropTypes: function(propTypes, props, location) {
        var componentName = this.constructor.displayName;
        for (var propName in propTypes) {
          if (propTypes.hasOwnProperty(propName)) {
            var error = propTypes[propName](props, propName, componentName, location);
            if (error instanceof Error) {
              var addendum = getDeclarationErrorAddendum(this);
              ("production" !== process.env.NODE_ENV ? warning(false, error.message + addendum) : null);
            }
          }
        }
      },
      performUpdateIfNecessary: function(transaction) {
        var compositeLifeCycleState = this._compositeLifeCycleState;
        if (compositeLifeCycleState === CompositeLifeCycle.MOUNTING || compositeLifeCycleState === CompositeLifeCycle.RECEIVING_PROPS) {
          return ;
        }
        if (this._pendingElement == null && this._pendingState == null && !this._pendingForceUpdate) {
          return ;
        }
        var nextContext = this.context;
        var nextProps = this.props;
        var nextElement = this._currentElement;
        if (this._pendingElement != null) {
          nextElement = this._pendingElement;
          nextContext = this._processContext(nextElement._context);
          nextProps = this._processProps(nextElement.props);
          this._pendingElement = null;
          this._compositeLifeCycleState = CompositeLifeCycle.RECEIVING_PROPS;
          if (this.componentWillReceiveProps) {
            this.componentWillReceiveProps(nextProps, nextContext);
          }
        }
        this._compositeLifeCycleState = null;
        var nextState = this._pendingState || this.state;
        this._pendingState = null;
        var shouldUpdate = this._pendingForceUpdate || !this.shouldComponentUpdate || this.shouldComponentUpdate(nextProps, nextState, nextContext);
        if ("production" !== process.env.NODE_ENV) {
          if (typeof shouldUpdate === "undefined") {
            console.warn((this.constructor.displayName || 'ReactCompositeComponent') + '.shouldComponentUpdate(): Returned undefined instead of a ' + 'boolean value. Make sure to return true or false.');
          }
        }
        if (shouldUpdate) {
          this._pendingForceUpdate = false;
          this._performComponentUpdate(nextElement, nextProps, nextState, nextContext, transaction);
        } else {
          this._currentElement = nextElement;
          this.props = nextProps;
          this.state = nextState;
          this.context = nextContext;
          this._owner = nextElement._owner;
        }
      },
      _performComponentUpdate: function(nextElement, nextProps, nextState, nextContext, transaction) {
        var prevElement = this._currentElement;
        var prevProps = this.props;
        var prevState = this.state;
        var prevContext = this.context;
        if (this.componentWillUpdate) {
          this.componentWillUpdate(nextProps, nextState, nextContext);
        }
        this._currentElement = nextElement;
        this.props = nextProps;
        this.state = nextState;
        this.context = nextContext;
        this._owner = nextElement._owner;
        this.updateComponent(transaction, prevElement);
        if (this.componentDidUpdate) {
          transaction.getReactMountReady().enqueue(this.componentDidUpdate.bind(this, prevProps, prevState, prevContext), this);
        }
      },
      receiveComponent: function(nextElement, transaction) {
        if (nextElement === this._currentElement && nextElement._owner != null) {
          return ;
        }
        ReactComponent.Mixin.receiveComponent.call(this, nextElement, transaction);
      },
      updateComponent: ReactPerf.measure('ReactCompositeComponent', 'updateComponent', function(transaction, prevParentElement) {
        ReactComponent.Mixin.updateComponent.call(this, transaction, prevParentElement);
        var prevComponentInstance = this._renderedComponent;
        var prevElement = prevComponentInstance._currentElement;
        var nextElement = this._renderValidatedComponent();
        if (shouldUpdateReactComponent(prevElement, nextElement)) {
          prevComponentInstance.receiveComponent(nextElement, transaction);
        } else {
          var thisID = this._rootNodeID;
          var prevComponentID = prevComponentInstance._rootNodeID;
          prevComponentInstance.unmountComponent();
          this._renderedComponent = instantiateReactComponent(nextElement, this._currentElement.type);
          var nextMarkup = this._renderedComponent.mountComponent(thisID, transaction, this._mountDepth + 1);
          ReactComponent.BackendIDOperations.dangerouslyReplaceNodeWithMarkupByID(prevComponentID, nextMarkup);
        }
      }),
      forceUpdate: function(callback) {
        var compositeLifeCycleState = this._compositeLifeCycleState;
        ("production" !== process.env.NODE_ENV ? invariant(this.isMounted() || compositeLifeCycleState === CompositeLifeCycle.MOUNTING, 'forceUpdate(...): Can only force an update on mounted or mounting ' + 'components.') : invariant(this.isMounted() || compositeLifeCycleState === CompositeLifeCycle.MOUNTING));
        ("production" !== process.env.NODE_ENV ? invariant(compositeLifeCycleState !== CompositeLifeCycle.UNMOUNTING && ReactCurrentOwner.current == null, 'forceUpdate(...): Cannot force an update while unmounting component ' + 'or within a `render` function.') : invariant(compositeLifeCycleState !== CompositeLifeCycle.UNMOUNTING && ReactCurrentOwner.current == null));
        this._pendingForceUpdate = true;
        ReactUpdates.enqueueUpdate(this, callback);
      },
      _renderValidatedComponent: ReactPerf.measure('ReactCompositeComponent', '_renderValidatedComponent', function() {
        var renderedComponent;
        var previousContext = ReactContext.current;
        ReactContext.current = this._processChildContext(this._currentElement._context);
        ReactCurrentOwner.current = this;
        try {
          renderedComponent = this.render();
          if (renderedComponent === null || renderedComponent === false) {
            renderedComponent = ReactEmptyComponent.getEmptyComponent();
            ReactEmptyComponent.registerNullComponentID(this._rootNodeID);
          } else {
            ReactEmptyComponent.deregisterNullComponentID(this._rootNodeID);
          }
        } finally {
          ReactContext.current = previousContext;
          ReactCurrentOwner.current = null;
        }
        ("production" !== process.env.NODE_ENV ? invariant(ReactElement.isValidElement(renderedComponent), '%s.render(): A valid ReactComponent must be returned. You may have ' + 'returned undefined, an array or some other invalid object.', this.constructor.displayName || 'ReactCompositeComponent') : invariant(ReactElement.isValidElement(renderedComponent)));
        return renderedComponent;
      }),
      _bindAutoBindMethods: function() {
        for (var autoBindKey in this.__reactAutoBindMap) {
          if (!this.__reactAutoBindMap.hasOwnProperty(autoBindKey)) {
            continue;
          }
          var method = this.__reactAutoBindMap[autoBindKey];
          this[autoBindKey] = this._bindAutoBindMethod(ReactErrorUtils.guard(method, this.constructor.displayName + '.' + autoBindKey));
        }
      },
      _bindAutoBindMethod: function(method) {
        var component = this;
        var boundMethod = method.bind(component);
        if ("production" !== process.env.NODE_ENV) {
          boundMethod.__reactBoundContext = component;
          boundMethod.__reactBoundMethod = method;
          boundMethod.__reactBoundArguments = null;
          var componentName = component.constructor.displayName;
          var _bind = boundMethod.bind;
          boundMethod.bind = function(newThis) {
            for (var args = [],
                $__0 = 1,
                $__1 = arguments.length; $__0 < $__1; $__0++)
              args.push(arguments[$__0]);
            if (newThis !== component && newThis !== null) {
              monitorCodeUse('react_bind_warning', {component: componentName});
              console.warn('bind(): React component methods may only be bound to the ' + 'component instance. See ' + componentName);
            } else if (!args.length) {
              monitorCodeUse('react_bind_warning', {component: componentName});
              console.warn('bind(): You are binding a component method to the component. ' + 'React does this for you automatically in a high-performance ' + 'way, so you can safely remove this call. See ' + componentName);
              return boundMethod;
            }
            var reboundMethod = _bind.apply(boundMethod, arguments);
            reboundMethod.__reactBoundContext = component;
            reboundMethod.__reactBoundMethod = method;
            reboundMethod.__reactBoundArguments = args;
            return reboundMethod;
          };
        }
        return boundMethod;
      }
    };
    var ReactCompositeComponentBase = function() {};
    assign(ReactCompositeComponentBase.prototype, ReactComponent.Mixin, ReactOwner.Mixin, ReactPropTransferer.Mixin, ReactCompositeComponentMixin);
    var ReactCompositeComponent = {
      LifeCycle: CompositeLifeCycle,
      Base: ReactCompositeComponentBase,
      createClass: function(spec) {
        var Constructor = function(props) {};
        Constructor.prototype = new ReactCompositeComponentBase();
        Constructor.prototype.constructor = Constructor;
        injectedMixins.forEach(mixSpecIntoComponent.bind(null, Constructor));
        mixSpecIntoComponent(Constructor, spec);
        if (Constructor.getDefaultProps) {
          Constructor.defaultProps = Constructor.getDefaultProps();
        }
        ("production" !== process.env.NODE_ENV ? invariant(Constructor.prototype.render, 'createClass(...): Class specification must implement a `render` method.') : invariant(Constructor.prototype.render));
        if ("production" !== process.env.NODE_ENV) {
          if (Constructor.prototype.componentShouldUpdate) {
            monitorCodeUse('react_component_should_update_warning', {component: spec.displayName});
            console.warn((spec.displayName || 'A component') + ' has a method called ' + 'componentShouldUpdate(). Did you mean shouldComponentUpdate()? ' + 'The name is phrased as a question because the function is ' + 'expected to return a value.');
          }
        }
        for (var methodName in ReactCompositeComponentInterface) {
          if (!Constructor.prototype[methodName]) {
            Constructor.prototype[methodName] = null;
          }
        }
        if ("production" !== process.env.NODE_ENV) {
          return ReactLegacyElement.wrapFactory(ReactElementValidator.createFactory(Constructor));
        }
        return ReactLegacyElement.wrapFactory(ReactElement.createFactory(Constructor));
      },
      injection: {injectMixin: function(mixin) {
          injectedMixins.push(mixin);
        }}
    };
    module.exports = ReactCompositeComponent;
  })(require("github:jspm/nodelibs-process@0.1.1"));
  global.define = __define;
  return module.exports;
});



System.register("npm:react@0.12.2/lib/CSSPropertyOperations", ["npm:react@0.12.2/lib/CSSProperty", "npm:react@0.12.2/lib/ExecutionEnvironment", "npm:react@0.12.2/lib/camelizeStyleName", "npm:react@0.12.2/lib/dangerousStyleValue", "npm:react@0.12.2/lib/hyphenateStyleName", "npm:react@0.12.2/lib/memoizeStringOnly", "npm:react@0.12.2/lib/warning", "github:jspm/nodelibs-process@0.1.1"], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  (function(process) {
    "use strict";
    var CSSProperty = require("npm:react@0.12.2/lib/CSSProperty");
    var ExecutionEnvironment = require("npm:react@0.12.2/lib/ExecutionEnvironment");
    var camelizeStyleName = require("npm:react@0.12.2/lib/camelizeStyleName");
    var dangerousStyleValue = require("npm:react@0.12.2/lib/dangerousStyleValue");
    var hyphenateStyleName = require("npm:react@0.12.2/lib/hyphenateStyleName");
    var memoizeStringOnly = require("npm:react@0.12.2/lib/memoizeStringOnly");
    var warning = require("npm:react@0.12.2/lib/warning");
    var processStyleName = memoizeStringOnly(function(styleName) {
      return hyphenateStyleName(styleName);
    });
    var styleFloatAccessor = 'cssFloat';
    if (ExecutionEnvironment.canUseDOM) {
      if (document.documentElement.style.cssFloat === undefined) {
        styleFloatAccessor = 'styleFloat';
      }
    }
    if ("production" !== process.env.NODE_ENV) {
      var warnedStyleNames = {};
      var warnHyphenatedStyleName = function(name) {
        if (warnedStyleNames.hasOwnProperty(name) && warnedStyleNames[name]) {
          return ;
        }
        warnedStyleNames[name] = true;
        ("production" !== process.env.NODE_ENV ? warning(false, 'Unsupported style property ' + name + '. Did you mean ' + camelizeStyleName(name) + '?') : null);
      };
    }
    var CSSPropertyOperations = {
      createMarkupForStyles: function(styles) {
        var serialized = '';
        for (var styleName in styles) {
          if (!styles.hasOwnProperty(styleName)) {
            continue;
          }
          if ("production" !== process.env.NODE_ENV) {
            if (styleName.indexOf('-') > -1) {
              warnHyphenatedStyleName(styleName);
            }
          }
          var styleValue = styles[styleName];
          if (styleValue != null) {
            serialized += processStyleName(styleName) + ':';
            serialized += dangerousStyleValue(styleName, styleValue) + ';';
          }
        }
        return serialized || null;
      },
      setValueForStyles: function(node, styles) {
        var style = node.style;
        for (var styleName in styles) {
          if (!styles.hasOwnProperty(styleName)) {
            continue;
          }
          if ("production" !== process.env.NODE_ENV) {
            if (styleName.indexOf('-') > -1) {
              warnHyphenatedStyleName(styleName);
            }
          }
          var styleValue = dangerousStyleValue(styleName, styles[styleName]);
          if (styleName === 'float') {
            styleName = styleFloatAccessor;
          }
          if (styleValue) {
            style[styleName] = styleValue;
          } else {
            var expansion = CSSProperty.shorthandPropertyExpansions[styleName];
            if (expansion) {
              for (var individualStyleName in expansion) {
                style[individualStyleName] = '';
              }
            } else {
              style[styleName] = '';
            }
          }
        }
      }
    };
    module.exports = CSSPropertyOperations;
  })(require("github:jspm/nodelibs-process@0.1.1"));
  global.define = __define;
  return module.exports;
});



System.register("npm:react@0.12.2/lib/ReactBrowserEventEmitter", ["npm:react@0.12.2/lib/EventConstants", "npm:react@0.12.2/lib/EventPluginHub", "npm:react@0.12.2/lib/EventPluginRegistry", "npm:react@0.12.2/lib/ReactEventEmitterMixin", "npm:react@0.12.2/lib/ViewportMetrics", "npm:react@0.12.2/lib/Object.assign", "npm:react@0.12.2/lib/isEventSupported", "github:jspm/nodelibs-process@0.1.1"], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  (function(process) {
    "use strict";
    var EventConstants = require("npm:react@0.12.2/lib/EventConstants");
    var EventPluginHub = require("npm:react@0.12.2/lib/EventPluginHub");
    var EventPluginRegistry = require("npm:react@0.12.2/lib/EventPluginRegistry");
    var ReactEventEmitterMixin = require("npm:react@0.12.2/lib/ReactEventEmitterMixin");
    var ViewportMetrics = require("npm:react@0.12.2/lib/ViewportMetrics");
    var assign = require("npm:react@0.12.2/lib/Object.assign");
    var isEventSupported = require("npm:react@0.12.2/lib/isEventSupported");
    var alreadyListeningTo = {};
    var isMonitoringScrollValue = false;
    var reactTopListenersCounter = 0;
    var topEventMapping = {
      topBlur: 'blur',
      topChange: 'change',
      topClick: 'click',
      topCompositionEnd: 'compositionend',
      topCompositionStart: 'compositionstart',
      topCompositionUpdate: 'compositionupdate',
      topContextMenu: 'contextmenu',
      topCopy: 'copy',
      topCut: 'cut',
      topDoubleClick: 'dblclick',
      topDrag: 'drag',
      topDragEnd: 'dragend',
      topDragEnter: 'dragenter',
      topDragExit: 'dragexit',
      topDragLeave: 'dragleave',
      topDragOver: 'dragover',
      topDragStart: 'dragstart',
      topDrop: 'drop',
      topFocus: 'focus',
      topInput: 'input',
      topKeyDown: 'keydown',
      topKeyPress: 'keypress',
      topKeyUp: 'keyup',
      topMouseDown: 'mousedown',
      topMouseMove: 'mousemove',
      topMouseOut: 'mouseout',
      topMouseOver: 'mouseover',
      topMouseUp: 'mouseup',
      topPaste: 'paste',
      topScroll: 'scroll',
      topSelectionChange: 'selectionchange',
      topTextInput: 'textInput',
      topTouchCancel: 'touchcancel',
      topTouchEnd: 'touchend',
      topTouchMove: 'touchmove',
      topTouchStart: 'touchstart',
      topWheel: 'wheel'
    };
    var topListenersIDKey = "_reactListenersID" + String(Math.random()).slice(2);
    function getListeningForDocument(mountAt) {
      if (!Object.prototype.hasOwnProperty.call(mountAt, topListenersIDKey)) {
        mountAt[topListenersIDKey] = reactTopListenersCounter++;
        alreadyListeningTo[mountAt[topListenersIDKey]] = {};
      }
      return alreadyListeningTo[mountAt[topListenersIDKey]];
    }
    var ReactBrowserEventEmitter = assign({}, ReactEventEmitterMixin, {
      ReactEventListener: null,
      injection: {injectReactEventListener: function(ReactEventListener) {
          ReactEventListener.setHandleTopLevel(ReactBrowserEventEmitter.handleTopLevel);
          ReactBrowserEventEmitter.ReactEventListener = ReactEventListener;
        }},
      setEnabled: function(enabled) {
        if (ReactBrowserEventEmitter.ReactEventListener) {
          ReactBrowserEventEmitter.ReactEventListener.setEnabled(enabled);
        }
      },
      isEnabled: function() {
        return !!(ReactBrowserEventEmitter.ReactEventListener && ReactBrowserEventEmitter.ReactEventListener.isEnabled());
      },
      listenTo: function(registrationName, contentDocumentHandle) {
        var mountAt = contentDocumentHandle;
        var isListening = getListeningForDocument(mountAt);
        var dependencies = EventPluginRegistry.registrationNameDependencies[registrationName];
        var topLevelTypes = EventConstants.topLevelTypes;
        for (var i = 0,
            l = dependencies.length; i < l; i++) {
          var dependency = dependencies[i];
          if (!(isListening.hasOwnProperty(dependency) && isListening[dependency])) {
            if (dependency === topLevelTypes.topWheel) {
              if (isEventSupported('wheel')) {
                ReactBrowserEventEmitter.ReactEventListener.trapBubbledEvent(topLevelTypes.topWheel, 'wheel', mountAt);
              } else if (isEventSupported('mousewheel')) {
                ReactBrowserEventEmitter.ReactEventListener.trapBubbledEvent(topLevelTypes.topWheel, 'mousewheel', mountAt);
              } else {
                ReactBrowserEventEmitter.ReactEventListener.trapBubbledEvent(topLevelTypes.topWheel, 'DOMMouseScroll', mountAt);
              }
            } else if (dependency === topLevelTypes.topScroll) {
              if (isEventSupported('scroll', true)) {
                ReactBrowserEventEmitter.ReactEventListener.trapCapturedEvent(topLevelTypes.topScroll, 'scroll', mountAt);
              } else {
                ReactBrowserEventEmitter.ReactEventListener.trapBubbledEvent(topLevelTypes.topScroll, 'scroll', ReactBrowserEventEmitter.ReactEventListener.WINDOW_HANDLE);
              }
            } else if (dependency === topLevelTypes.topFocus || dependency === topLevelTypes.topBlur) {
              if (isEventSupported('focus', true)) {
                ReactBrowserEventEmitter.ReactEventListener.trapCapturedEvent(topLevelTypes.topFocus, 'focus', mountAt);
                ReactBrowserEventEmitter.ReactEventListener.trapCapturedEvent(topLevelTypes.topBlur, 'blur', mountAt);
              } else if (isEventSupported('focusin')) {
                ReactBrowserEventEmitter.ReactEventListener.trapBubbledEvent(topLevelTypes.topFocus, 'focusin', mountAt);
                ReactBrowserEventEmitter.ReactEventListener.trapBubbledEvent(topLevelTypes.topBlur, 'focusout', mountAt);
              }
              isListening[topLevelTypes.topBlur] = true;
              isListening[topLevelTypes.topFocus] = true;
            } else if (topEventMapping.hasOwnProperty(dependency)) {
              ReactBrowserEventEmitter.ReactEventListener.trapBubbledEvent(dependency, topEventMapping[dependency], mountAt);
            }
            isListening[dependency] = true;
          }
        }
      },
      trapBubbledEvent: function(topLevelType, handlerBaseName, handle) {
        return ReactBrowserEventEmitter.ReactEventListener.trapBubbledEvent(topLevelType, handlerBaseName, handle);
      },
      trapCapturedEvent: function(topLevelType, handlerBaseName, handle) {
        return ReactBrowserEventEmitter.ReactEventListener.trapCapturedEvent(topLevelType, handlerBaseName, handle);
      },
      ensureScrollValueMonitoring: function() {
        if (!isMonitoringScrollValue) {
          var refresh = ViewportMetrics.refreshScrollValues;
          ReactBrowserEventEmitter.ReactEventListener.monitorScrollValue(refresh);
          isMonitoringScrollValue = true;
        }
      },
      eventNameDispatchConfigs: EventPluginHub.eventNameDispatchConfigs,
      registrationNameModules: EventPluginHub.registrationNameModules,
      putListener: EventPluginHub.putListener,
      getListener: EventPluginHub.getListener,
      deleteListener: EventPluginHub.deleteListener,
      deleteAllListeners: EventPluginHub.deleteAllListeners
    });
    module.exports = ReactBrowserEventEmitter;
  })(require("github:jspm/nodelibs-process@0.1.1"));
  global.define = __define;
  return module.exports;
});



System.register("npm:react@0.12.2/lib/containsNode", ["npm:react@0.12.2/lib/isTextNode"], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  var isTextNode = require("npm:react@0.12.2/lib/isTextNode");
  function containsNode(outerNode, innerNode) {
    if (!outerNode || !innerNode) {
      return false;
    } else if (outerNode === innerNode) {
      return true;
    } else if (isTextNode(outerNode)) {
      return false;
    } else if (isTextNode(innerNode)) {
      return containsNode(outerNode, innerNode.parentNode);
    } else if (outerNode.contains) {
      return outerNode.contains(innerNode);
    } else if (outerNode.compareDocumentPosition) {
      return !!(outerNode.compareDocumentPosition(innerNode) & 16);
    } else {
      return false;
    }
  }
  module.exports = containsNode;
  global.define = __define;
  return module.exports;
});



System.register("npm:react@0.12.2/lib/ReactMultiChild", ["npm:react@0.12.2/lib/ReactComponent", "npm:react@0.12.2/lib/ReactMultiChildUpdateTypes", "npm:react@0.12.2/lib/flattenChildren", "npm:react@0.12.2/lib/instantiateReactComponent", "npm:react@0.12.2/lib/shouldUpdateReactComponent", "github:jspm/nodelibs-process@0.1.1"], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  (function(process) {
    "use strict";
    var ReactComponent = require("npm:react@0.12.2/lib/ReactComponent");
    var ReactMultiChildUpdateTypes = require("npm:react@0.12.2/lib/ReactMultiChildUpdateTypes");
    var flattenChildren = require("npm:react@0.12.2/lib/flattenChildren");
    var instantiateReactComponent = require("npm:react@0.12.2/lib/instantiateReactComponent");
    var shouldUpdateReactComponent = require("npm:react@0.12.2/lib/shouldUpdateReactComponent");
    var updateDepth = 0;
    var updateQueue = [];
    var markupQueue = [];
    function enqueueMarkup(parentID, markup, toIndex) {
      updateQueue.push({
        parentID: parentID,
        parentNode: null,
        type: ReactMultiChildUpdateTypes.INSERT_MARKUP,
        markupIndex: markupQueue.push(markup) - 1,
        textContent: null,
        fromIndex: null,
        toIndex: toIndex
      });
    }
    function enqueueMove(parentID, fromIndex, toIndex) {
      updateQueue.push({
        parentID: parentID,
        parentNode: null,
        type: ReactMultiChildUpdateTypes.MOVE_EXISTING,
        markupIndex: null,
        textContent: null,
        fromIndex: fromIndex,
        toIndex: toIndex
      });
    }
    function enqueueRemove(parentID, fromIndex) {
      updateQueue.push({
        parentID: parentID,
        parentNode: null,
        type: ReactMultiChildUpdateTypes.REMOVE_NODE,
        markupIndex: null,
        textContent: null,
        fromIndex: fromIndex,
        toIndex: null
      });
    }
    function enqueueTextContent(parentID, textContent) {
      updateQueue.push({
        parentID: parentID,
        parentNode: null,
        type: ReactMultiChildUpdateTypes.TEXT_CONTENT,
        markupIndex: null,
        textContent: textContent,
        fromIndex: null,
        toIndex: null
      });
    }
    function processQueue() {
      if (updateQueue.length) {
        ReactComponent.BackendIDOperations.dangerouslyProcessChildrenUpdates(updateQueue, markupQueue);
        clearQueue();
      }
    }
    function clearQueue() {
      updateQueue.length = 0;
      markupQueue.length = 0;
    }
    var ReactMultiChild = {Mixin: {
        mountChildren: function(nestedChildren, transaction) {
          var children = flattenChildren(nestedChildren);
          var mountImages = [];
          var index = 0;
          this._renderedChildren = children;
          for (var name in children) {
            var child = children[name];
            if (children.hasOwnProperty(name)) {
              var childInstance = instantiateReactComponent(child, null);
              children[name] = childInstance;
              var rootID = this._rootNodeID + name;
              var mountImage = childInstance.mountComponent(rootID, transaction, this._mountDepth + 1);
              childInstance._mountIndex = index;
              mountImages.push(mountImage);
              index++;
            }
          }
          return mountImages;
        },
        updateTextContent: function(nextContent) {
          updateDepth++;
          var errorThrown = true;
          try {
            var prevChildren = this._renderedChildren;
            for (var name in prevChildren) {
              if (prevChildren.hasOwnProperty(name)) {
                this._unmountChildByName(prevChildren[name], name);
              }
            }
            this.setTextContent(nextContent);
            errorThrown = false;
          } finally {
            updateDepth--;
            if (!updateDepth) {
              errorThrown ? clearQueue() : processQueue();
            }
          }
        },
        updateChildren: function(nextNestedChildren, transaction) {
          updateDepth++;
          var errorThrown = true;
          try {
            this._updateChildren(nextNestedChildren, transaction);
            errorThrown = false;
          } finally {
            updateDepth--;
            if (!updateDepth) {
              errorThrown ? clearQueue() : processQueue();
            }
          }
        },
        _updateChildren: function(nextNestedChildren, transaction) {
          var nextChildren = flattenChildren(nextNestedChildren);
          var prevChildren = this._renderedChildren;
          if (!nextChildren && !prevChildren) {
            return ;
          }
          var name;
          var lastIndex = 0;
          var nextIndex = 0;
          for (name in nextChildren) {
            if (!nextChildren.hasOwnProperty(name)) {
              continue;
            }
            var prevChild = prevChildren && prevChildren[name];
            var prevElement = prevChild && prevChild._currentElement;
            var nextElement = nextChildren[name];
            if (shouldUpdateReactComponent(prevElement, nextElement)) {
              this.moveChild(prevChild, nextIndex, lastIndex);
              lastIndex = Math.max(prevChild._mountIndex, lastIndex);
              prevChild.receiveComponent(nextElement, transaction);
              prevChild._mountIndex = nextIndex;
            } else {
              if (prevChild) {
                lastIndex = Math.max(prevChild._mountIndex, lastIndex);
                this._unmountChildByName(prevChild, name);
              }
              var nextChildInstance = instantiateReactComponent(nextElement, null);
              this._mountChildByNameAtIndex(nextChildInstance, name, nextIndex, transaction);
            }
            nextIndex++;
          }
          for (name in prevChildren) {
            if (prevChildren.hasOwnProperty(name) && !(nextChildren && nextChildren[name])) {
              this._unmountChildByName(prevChildren[name], name);
            }
          }
        },
        unmountChildren: function() {
          var renderedChildren = this._renderedChildren;
          for (var name in renderedChildren) {
            var renderedChild = renderedChildren[name];
            if (renderedChild.unmountComponent) {
              renderedChild.unmountComponent();
            }
          }
          this._renderedChildren = null;
        },
        moveChild: function(child, toIndex, lastIndex) {
          if (child._mountIndex < lastIndex) {
            enqueueMove(this._rootNodeID, child._mountIndex, toIndex);
          }
        },
        createChild: function(child, mountImage) {
          enqueueMarkup(this._rootNodeID, mountImage, child._mountIndex);
        },
        removeChild: function(child) {
          enqueueRemove(this._rootNodeID, child._mountIndex);
        },
        setTextContent: function(textContent) {
          enqueueTextContent(this._rootNodeID, textContent);
        },
        _mountChildByNameAtIndex: function(child, name, index, transaction) {
          var rootID = this._rootNodeID + name;
          var mountImage = child.mountComponent(rootID, transaction, this._mountDepth + 1);
          child._mountIndex = index;
          this.createChild(child, mountImage);
          this._renderedChildren = this._renderedChildren || {};
          this._renderedChildren[name] = child;
        },
        _unmountChildByName: function(child, name) {
          this.removeChild(child);
          child._mountIndex = null;
          child.unmountComponent();
          delete this._renderedChildren[name];
        }
      }};
    module.exports = ReactMultiChild;
  })(require("github:jspm/nodelibs-process@0.1.1"));
  global.define = __define;
  return module.exports;
});



System.register("npm:react@0.12.2/lib/SyntheticInputEvent", ["npm:react@0.12.2/lib/SyntheticEvent"], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  "use strict";
  var SyntheticEvent = require("npm:react@0.12.2/lib/SyntheticEvent");
  var InputEventInterface = {data: null};
  function SyntheticInputEvent(dispatchConfig, dispatchMarker, nativeEvent) {
    SyntheticEvent.call(this, dispatchConfig, dispatchMarker, nativeEvent);
  }
  SyntheticEvent.augmentClass(SyntheticInputEvent, InputEventInterface);
  module.exports = SyntheticInputEvent;
  global.define = __define;
  return module.exports;
});



System.register("npm:react@0.12.2/lib/ReactInputSelection", ["npm:react@0.12.2/lib/ReactDOMSelection", "npm:react@0.12.2/lib/containsNode", "npm:react@0.12.2/lib/focusNode", "npm:react@0.12.2/lib/getActiveElement"], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  "use strict";
  var ReactDOMSelection = require("npm:react@0.12.2/lib/ReactDOMSelection");
  var containsNode = require("npm:react@0.12.2/lib/containsNode");
  var focusNode = require("npm:react@0.12.2/lib/focusNode");
  var getActiveElement = require("npm:react@0.12.2/lib/getActiveElement");
  function isInDocument(node) {
    return containsNode(document.documentElement, node);
  }
  var ReactInputSelection = {
    hasSelectionCapabilities: function(elem) {
      return elem && ((elem.nodeName === 'INPUT' && elem.type === 'text') || elem.nodeName === 'TEXTAREA' || elem.contentEditable === 'true');
    },
    getSelectionInformation: function() {
      var focusedElem = getActiveElement();
      return {
        focusedElem: focusedElem,
        selectionRange: ReactInputSelection.hasSelectionCapabilities(focusedElem) ? ReactInputSelection.getSelection(focusedElem) : null
      };
    },
    restoreSelection: function(priorSelectionInformation) {
      var curFocusedElem = getActiveElement();
      var priorFocusedElem = priorSelectionInformation.focusedElem;
      var priorSelectionRange = priorSelectionInformation.selectionRange;
      if (curFocusedElem !== priorFocusedElem && isInDocument(priorFocusedElem)) {
        if (ReactInputSelection.hasSelectionCapabilities(priorFocusedElem)) {
          ReactInputSelection.setSelection(priorFocusedElem, priorSelectionRange);
        }
        focusNode(priorFocusedElem);
      }
    },
    getSelection: function(input) {
      var selection;
      if ('selectionStart' in input) {
        selection = {
          start: input.selectionStart,
          end: input.selectionEnd
        };
      } else if (document.selection && input.nodeName === 'INPUT') {
        var range = document.selection.createRange();
        if (range.parentElement() === input) {
          selection = {
            start: -range.moveStart('character', -input.value.length),
            end: -range.moveEnd('character', -input.value.length)
          };
        }
      } else {
        selection = ReactDOMSelection.getOffsets(input);
      }
      return selection || {
        start: 0,
        end: 0
      };
    },
    setSelection: function(input, offsets) {
      var start = offsets.start;
      var end = offsets.end;
      if (typeof end === 'undefined') {
        end = start;
      }
      if ('selectionStart' in input) {
        input.selectionStart = start;
        input.selectionEnd = Math.min(end, input.value.length);
      } else if (document.selection && input.nodeName === 'INPUT') {
        var range = input.createTextRange();
        range.collapse(true);
        range.moveStart('character', start);
        range.moveEnd('character', end - start);
        range.select();
      } else {
        ReactDOMSelection.setOffsets(input, offsets);
      }
    }
  };
  module.exports = ReactInputSelection;
  global.define = __define;
  return module.exports;
});



System.register("npm:react@0.12.2/lib/EnterLeaveEventPlugin", ["npm:react@0.12.2/lib/EventConstants", "npm:react@0.12.2/lib/EventPropagators", "npm:react@0.12.2/lib/SyntheticMouseEvent", "npm:react@0.12.2/lib/ReactMount", "npm:react@0.12.2/lib/keyOf"], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  "use strict";
  var EventConstants = require("npm:react@0.12.2/lib/EventConstants");
  var EventPropagators = require("npm:react@0.12.2/lib/EventPropagators");
  var SyntheticMouseEvent = require("npm:react@0.12.2/lib/SyntheticMouseEvent");
  var ReactMount = require("npm:react@0.12.2/lib/ReactMount");
  var keyOf = require("npm:react@0.12.2/lib/keyOf");
  var topLevelTypes = EventConstants.topLevelTypes;
  var getFirstReactDOM = ReactMount.getFirstReactDOM;
  var eventTypes = {
    mouseEnter: {
      registrationName: keyOf({onMouseEnter: null}),
      dependencies: [topLevelTypes.topMouseOut, topLevelTypes.topMouseOver]
    },
    mouseLeave: {
      registrationName: keyOf({onMouseLeave: null}),
      dependencies: [topLevelTypes.topMouseOut, topLevelTypes.topMouseOver]
    }
  };
  var extractedEvents = [null, null];
  var EnterLeaveEventPlugin = {
    eventTypes: eventTypes,
    extractEvents: function(topLevelType, topLevelTarget, topLevelTargetID, nativeEvent) {
      if (topLevelType === topLevelTypes.topMouseOver && (nativeEvent.relatedTarget || nativeEvent.fromElement)) {
        return null;
      }
      if (topLevelType !== topLevelTypes.topMouseOut && topLevelType !== topLevelTypes.topMouseOver) {
        return null;
      }
      var win;
      if (topLevelTarget.window === topLevelTarget) {
        win = topLevelTarget;
      } else {
        var doc = topLevelTarget.ownerDocument;
        if (doc) {
          win = doc.defaultView || doc.parentWindow;
        } else {
          win = window;
        }
      }
      var from,
          to;
      if (topLevelType === topLevelTypes.topMouseOut) {
        from = topLevelTarget;
        to = getFirstReactDOM(nativeEvent.relatedTarget || nativeEvent.toElement) || win;
      } else {
        from = win;
        to = topLevelTarget;
      }
      if (from === to) {
        return null;
      }
      var fromID = from ? ReactMount.getID(from) : '';
      var toID = to ? ReactMount.getID(to) : '';
      var leave = SyntheticMouseEvent.getPooled(eventTypes.mouseLeave, fromID, nativeEvent);
      leave.type = 'mouseleave';
      leave.target = from;
      leave.relatedTarget = to;
      var enter = SyntheticMouseEvent.getPooled(eventTypes.mouseEnter, toID, nativeEvent);
      enter.type = 'mouseenter';
      enter.target = to;
      enter.relatedTarget = from;
      EventPropagators.accumulateEnterLeaveDispatches(leave, enter, fromID, toID);
      extractedEvents[0] = leave;
      extractedEvents[1] = enter;
      return extractedEvents;
    }
  };
  module.exports = EnterLeaveEventPlugin;
  global.define = __define;
  return module.exports;
});



System.register("npm:react@0.12.2/lib/createNodesFromMarkup", ["npm:react@0.12.2/lib/ExecutionEnvironment", "npm:react@0.12.2/lib/createArrayFrom", "npm:react@0.12.2/lib/getMarkupWrap", "npm:react@0.12.2/lib/invariant", "github:jspm/nodelibs-process@0.1.1"], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  (function(process) {
    var ExecutionEnvironment = require("npm:react@0.12.2/lib/ExecutionEnvironment");
    var createArrayFrom = require("npm:react@0.12.2/lib/createArrayFrom");
    var getMarkupWrap = require("npm:react@0.12.2/lib/getMarkupWrap");
    var invariant = require("npm:react@0.12.2/lib/invariant");
    var dummyNode = ExecutionEnvironment.canUseDOM ? document.createElement('div') : null;
    var nodeNamePattern = /^\s*<(\w+)/;
    function getNodeName(markup) {
      var nodeNameMatch = markup.match(nodeNamePattern);
      return nodeNameMatch && nodeNameMatch[1].toLowerCase();
    }
    function createNodesFromMarkup(markup, handleScript) {
      var node = dummyNode;
      ("production" !== process.env.NODE_ENV ? invariant(!!dummyNode, 'createNodesFromMarkup dummy not initialized') : invariant(!!dummyNode));
      var nodeName = getNodeName(markup);
      var wrap = nodeName && getMarkupWrap(nodeName);
      if (wrap) {
        node.innerHTML = wrap[1] + markup + wrap[2];
        var wrapDepth = wrap[0];
        while (wrapDepth--) {
          node = node.lastChild;
        }
      } else {
        node.innerHTML = markup;
      }
      var scripts = node.getElementsByTagName('script');
      if (scripts.length) {
        ("production" !== process.env.NODE_ENV ? invariant(handleScript, 'createNodesFromMarkup(...): Unexpected <script> element rendered.') : invariant(handleScript));
        createArrayFrom(scripts).forEach(handleScript);
      }
      var nodes = createArrayFrom(node.childNodes);
      while (node.lastChild) {
        node.removeChild(node.lastChild);
      }
      return nodes;
    }
    module.exports = createNodesFromMarkup;
  })(require("github:jspm/nodelibs-process@0.1.1"));
  global.define = __define;
  return module.exports;
});



System.register("npm:react@0.12.2/lib/ReactDOMInput", ["npm:react@0.12.2/lib/AutoFocusMixin", "npm:react@0.12.2/lib/DOMPropertyOperations", "npm:react@0.12.2/lib/LinkedValueUtils", "npm:react@0.12.2/lib/ReactBrowserComponentMixin", "npm:react@0.12.2/lib/ReactCompositeComponent", "npm:react@0.12.2/lib/ReactElement", "npm:react@0.12.2/lib/ReactDOM", "npm:react@0.12.2/lib/ReactMount", "npm:react@0.12.2/lib/ReactUpdates", "npm:react@0.12.2/lib/Object.assign", "npm:react@0.12.2/lib/invariant", "github:jspm/nodelibs-process@0.1.1"], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  (function(process) {
    "use strict";
    var AutoFocusMixin = require("npm:react@0.12.2/lib/AutoFocusMixin");
    var DOMPropertyOperations = require("npm:react@0.12.2/lib/DOMPropertyOperations");
    var LinkedValueUtils = require("npm:react@0.12.2/lib/LinkedValueUtils");
    var ReactBrowserComponentMixin = require("npm:react@0.12.2/lib/ReactBrowserComponentMixin");
    var ReactCompositeComponent = require("npm:react@0.12.2/lib/ReactCompositeComponent");
    var ReactElement = require("npm:react@0.12.2/lib/ReactElement");
    var ReactDOM = require("npm:react@0.12.2/lib/ReactDOM");
    var ReactMount = require("npm:react@0.12.2/lib/ReactMount");
    var ReactUpdates = require("npm:react@0.12.2/lib/ReactUpdates");
    var assign = require("npm:react@0.12.2/lib/Object.assign");
    var invariant = require("npm:react@0.12.2/lib/invariant");
    var input = ReactElement.createFactory(ReactDOM.input.type);
    var instancesByReactID = {};
    function forceUpdateIfMounted() {
      if (this.isMounted()) {
        this.forceUpdate();
      }
    }
    var ReactDOMInput = ReactCompositeComponent.createClass({
      displayName: 'ReactDOMInput',
      mixins: [AutoFocusMixin, LinkedValueUtils.Mixin, ReactBrowserComponentMixin],
      getInitialState: function() {
        var defaultValue = this.props.defaultValue;
        return {
          initialChecked: this.props.defaultChecked || false,
          initialValue: defaultValue != null ? defaultValue : null
        };
      },
      render: function() {
        var props = assign({}, this.props);
        props.defaultChecked = null;
        props.defaultValue = null;
        var value = LinkedValueUtils.getValue(this);
        props.value = value != null ? value : this.state.initialValue;
        var checked = LinkedValueUtils.getChecked(this);
        props.checked = checked != null ? checked : this.state.initialChecked;
        props.onChange = this._handleChange;
        return input(props, this.props.children);
      },
      componentDidMount: function() {
        var id = ReactMount.getID(this.getDOMNode());
        instancesByReactID[id] = this;
      },
      componentWillUnmount: function() {
        var rootNode = this.getDOMNode();
        var id = ReactMount.getID(rootNode);
        delete instancesByReactID[id];
      },
      componentDidUpdate: function(prevProps, prevState, prevContext) {
        var rootNode = this.getDOMNode();
        if (this.props.checked != null) {
          DOMPropertyOperations.setValueForProperty(rootNode, 'checked', this.props.checked || false);
        }
        var value = LinkedValueUtils.getValue(this);
        if (value != null) {
          DOMPropertyOperations.setValueForProperty(rootNode, 'value', '' + value);
        }
      },
      _handleChange: function(event) {
        var returnValue;
        var onChange = LinkedValueUtils.getOnChange(this);
        if (onChange) {
          returnValue = onChange.call(this, event);
        }
        ReactUpdates.asap(forceUpdateIfMounted, this);
        var name = this.props.name;
        if (this.props.type === 'radio' && name != null) {
          var rootNode = this.getDOMNode();
          var queryRoot = rootNode;
          while (queryRoot.parentNode) {
            queryRoot = queryRoot.parentNode;
          }
          var group = queryRoot.querySelectorAll('input[name=' + JSON.stringify('' + name) + '][type="radio"]');
          for (var i = 0,
              groupLen = group.length; i < groupLen; i++) {
            var otherNode = group[i];
            if (otherNode === rootNode || otherNode.form !== rootNode.form) {
              continue;
            }
            var otherID = ReactMount.getID(otherNode);
            ("production" !== process.env.NODE_ENV ? invariant(otherID, 'ReactDOMInput: Mixing React and non-React radio inputs with the ' + 'same `name` is not supported.') : invariant(otherID));
            var otherInstance = instancesByReactID[otherID];
            ("production" !== process.env.NODE_ENV ? invariant(otherInstance, 'ReactDOMInput: Unknown radio button ID %s.', otherID) : invariant(otherInstance));
            ReactUpdates.asap(forceUpdateIfMounted, otherInstance);
          }
        }
        return returnValue;
      }
    });
    module.exports = ReactDOMInput;
  })(require("github:jspm/nodelibs-process@0.1.1"));
  global.define = __define;
  return module.exports;
});



System.register("npm:react@0.12.2/lib/SimpleEventPlugin", ["npm:react@0.12.2/lib/EventConstants", "npm:react@0.12.2/lib/EventPluginUtils", "npm:react@0.12.2/lib/EventPropagators", "npm:react@0.12.2/lib/SyntheticClipboardEvent", "npm:react@0.12.2/lib/SyntheticEvent", "npm:react@0.12.2/lib/SyntheticFocusEvent", "npm:react@0.12.2/lib/SyntheticKeyboardEvent", "npm:react@0.12.2/lib/SyntheticMouseEvent", "npm:react@0.12.2/lib/SyntheticDragEvent", "npm:react@0.12.2/lib/SyntheticTouchEvent", "npm:react@0.12.2/lib/SyntheticUIEvent", "npm:react@0.12.2/lib/SyntheticWheelEvent", "npm:react@0.12.2/lib/getEventCharCode", "npm:react@0.12.2/lib/invariant", "npm:react@0.12.2/lib/keyOf", "npm:react@0.12.2/lib/warning", "github:jspm/nodelibs-process@0.1.1"], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  (function(process) {
    "use strict";
    var EventConstants = require("npm:react@0.12.2/lib/EventConstants");
    var EventPluginUtils = require("npm:react@0.12.2/lib/EventPluginUtils");
    var EventPropagators = require("npm:react@0.12.2/lib/EventPropagators");
    var SyntheticClipboardEvent = require("npm:react@0.12.2/lib/SyntheticClipboardEvent");
    var SyntheticEvent = require("npm:react@0.12.2/lib/SyntheticEvent");
    var SyntheticFocusEvent = require("npm:react@0.12.2/lib/SyntheticFocusEvent");
    var SyntheticKeyboardEvent = require("npm:react@0.12.2/lib/SyntheticKeyboardEvent");
    var SyntheticMouseEvent = require("npm:react@0.12.2/lib/SyntheticMouseEvent");
    var SyntheticDragEvent = require("npm:react@0.12.2/lib/SyntheticDragEvent");
    var SyntheticTouchEvent = require("npm:react@0.12.2/lib/SyntheticTouchEvent");
    var SyntheticUIEvent = require("npm:react@0.12.2/lib/SyntheticUIEvent");
    var SyntheticWheelEvent = require("npm:react@0.12.2/lib/SyntheticWheelEvent");
    var getEventCharCode = require("npm:react@0.12.2/lib/getEventCharCode");
    var invariant = require("npm:react@0.12.2/lib/invariant");
    var keyOf = require("npm:react@0.12.2/lib/keyOf");
    var warning = require("npm:react@0.12.2/lib/warning");
    var topLevelTypes = EventConstants.topLevelTypes;
    var eventTypes = {
      blur: {phasedRegistrationNames: {
          bubbled: keyOf({onBlur: true}),
          captured: keyOf({onBlurCapture: true})
        }},
      click: {phasedRegistrationNames: {
          bubbled: keyOf({onClick: true}),
          captured: keyOf({onClickCapture: true})
        }},
      contextMenu: {phasedRegistrationNames: {
          bubbled: keyOf({onContextMenu: true}),
          captured: keyOf({onContextMenuCapture: true})
        }},
      copy: {phasedRegistrationNames: {
          bubbled: keyOf({onCopy: true}),
          captured: keyOf({onCopyCapture: true})
        }},
      cut: {phasedRegistrationNames: {
          bubbled: keyOf({onCut: true}),
          captured: keyOf({onCutCapture: true})
        }},
      doubleClick: {phasedRegistrationNames: {
          bubbled: keyOf({onDoubleClick: true}),
          captured: keyOf({onDoubleClickCapture: true})
        }},
      drag: {phasedRegistrationNames: {
          bubbled: keyOf({onDrag: true}),
          captured: keyOf({onDragCapture: true})
        }},
      dragEnd: {phasedRegistrationNames: {
          bubbled: keyOf({onDragEnd: true}),
          captured: keyOf({onDragEndCapture: true})
        }},
      dragEnter: {phasedRegistrationNames: {
          bubbled: keyOf({onDragEnter: true}),
          captured: keyOf({onDragEnterCapture: true})
        }},
      dragExit: {phasedRegistrationNames: {
          bubbled: keyOf({onDragExit: true}),
          captured: keyOf({onDragExitCapture: true})
        }},
      dragLeave: {phasedRegistrationNames: {
          bubbled: keyOf({onDragLeave: true}),
          captured: keyOf({onDragLeaveCapture: true})
        }},
      dragOver: {phasedRegistrationNames: {
          bubbled: keyOf({onDragOver: true}),
          captured: keyOf({onDragOverCapture: true})
        }},
      dragStart: {phasedRegistrationNames: {
          bubbled: keyOf({onDragStart: true}),
          captured: keyOf({onDragStartCapture: true})
        }},
      drop: {phasedRegistrationNames: {
          bubbled: keyOf({onDrop: true}),
          captured: keyOf({onDropCapture: true})
        }},
      focus: {phasedRegistrationNames: {
          bubbled: keyOf({onFocus: true}),
          captured: keyOf({onFocusCapture: true})
        }},
      input: {phasedRegistrationNames: {
          bubbled: keyOf({onInput: true}),
          captured: keyOf({onInputCapture: true})
        }},
      keyDown: {phasedRegistrationNames: {
          bubbled: keyOf({onKeyDown: true}),
          captured: keyOf({onKeyDownCapture: true})
        }},
      keyPress: {phasedRegistrationNames: {
          bubbled: keyOf({onKeyPress: true}),
          captured: keyOf({onKeyPressCapture: true})
        }},
      keyUp: {phasedRegistrationNames: {
          bubbled: keyOf({onKeyUp: true}),
          captured: keyOf({onKeyUpCapture: true})
        }},
      load: {phasedRegistrationNames: {
          bubbled: keyOf({onLoad: true}),
          captured: keyOf({onLoadCapture: true})
        }},
      error: {phasedRegistrationNames: {
          bubbled: keyOf({onError: true}),
          captured: keyOf({onErrorCapture: true})
        }},
      mouseDown: {phasedRegistrationNames: {
          bubbled: keyOf({onMouseDown: true}),
          captured: keyOf({onMouseDownCapture: true})
        }},
      mouseMove: {phasedRegistrationNames: {
          bubbled: keyOf({onMouseMove: true}),
          captured: keyOf({onMouseMoveCapture: true})
        }},
      mouseOut: {phasedRegistrationNames: {
          bubbled: keyOf({onMouseOut: true}),
          captured: keyOf({onMouseOutCapture: true})
        }},
      mouseOver: {phasedRegistrationNames: {
          bubbled: keyOf({onMouseOver: true}),
          captured: keyOf({onMouseOverCapture: true})
        }},
      mouseUp: {phasedRegistrationNames: {
          bubbled: keyOf({onMouseUp: true}),
          captured: keyOf({onMouseUpCapture: true})
        }},
      paste: {phasedRegistrationNames: {
          bubbled: keyOf({onPaste: true}),
          captured: keyOf({onPasteCapture: true})
        }},
      reset: {phasedRegistrationNames: {
          bubbled: keyOf({onReset: true}),
          captured: keyOf({onResetCapture: true})
        }},
      scroll: {phasedRegistrationNames: {
          bubbled: keyOf({onScroll: true}),
          captured: keyOf({onScrollCapture: true})
        }},
      submit: {phasedRegistrationNames: {
          bubbled: keyOf({onSubmit: true}),
          captured: keyOf({onSubmitCapture: true})
        }},
      touchCancel: {phasedRegistrationNames: {
          bubbled: keyOf({onTouchCancel: true}),
          captured: keyOf({onTouchCancelCapture: true})
        }},
      touchEnd: {phasedRegistrationNames: {
          bubbled: keyOf({onTouchEnd: true}),
          captured: keyOf({onTouchEndCapture: true})
        }},
      touchMove: {phasedRegistrationNames: {
          bubbled: keyOf({onTouchMove: true}),
          captured: keyOf({onTouchMoveCapture: true})
        }},
      touchStart: {phasedRegistrationNames: {
          bubbled: keyOf({onTouchStart: true}),
          captured: keyOf({onTouchStartCapture: true})
        }},
      wheel: {phasedRegistrationNames: {
          bubbled: keyOf({onWheel: true}),
          captured: keyOf({onWheelCapture: true})
        }}
    };
    var topLevelEventsToDispatchConfig = {
      topBlur: eventTypes.blur,
      topClick: eventTypes.click,
      topContextMenu: eventTypes.contextMenu,
      topCopy: eventTypes.copy,
      topCut: eventTypes.cut,
      topDoubleClick: eventTypes.doubleClick,
      topDrag: eventTypes.drag,
      topDragEnd: eventTypes.dragEnd,
      topDragEnter: eventTypes.dragEnter,
      topDragExit: eventTypes.dragExit,
      topDragLeave: eventTypes.dragLeave,
      topDragOver: eventTypes.dragOver,
      topDragStart: eventTypes.dragStart,
      topDrop: eventTypes.drop,
      topError: eventTypes.error,
      topFocus: eventTypes.focus,
      topInput: eventTypes.input,
      topKeyDown: eventTypes.keyDown,
      topKeyPress: eventTypes.keyPress,
      topKeyUp: eventTypes.keyUp,
      topLoad: eventTypes.load,
      topMouseDown: eventTypes.mouseDown,
      topMouseMove: eventTypes.mouseMove,
      topMouseOut: eventTypes.mouseOut,
      topMouseOver: eventTypes.mouseOver,
      topMouseUp: eventTypes.mouseUp,
      topPaste: eventTypes.paste,
      topReset: eventTypes.reset,
      topScroll: eventTypes.scroll,
      topSubmit: eventTypes.submit,
      topTouchCancel: eventTypes.touchCancel,
      topTouchEnd: eventTypes.touchEnd,
      topTouchMove: eventTypes.touchMove,
      topTouchStart: eventTypes.touchStart,
      topWheel: eventTypes.wheel
    };
    for (var topLevelType in topLevelEventsToDispatchConfig) {
      topLevelEventsToDispatchConfig[topLevelType].dependencies = [topLevelType];
    }
    var SimpleEventPlugin = {
      eventTypes: eventTypes,
      executeDispatch: function(event, listener, domID) {
        var returnValue = EventPluginUtils.executeDispatch(event, listener, domID);
        ("production" !== process.env.NODE_ENV ? warning(typeof returnValue !== 'boolean', 'Returning `false` from an event handler is deprecated and will be ' + 'ignored in a future release. Instead, manually call ' + 'e.stopPropagation() or e.preventDefault(), as appropriate.') : null);
        if (returnValue === false) {
          event.stopPropagation();
          event.preventDefault();
        }
      },
      extractEvents: function(topLevelType, topLevelTarget, topLevelTargetID, nativeEvent) {
        var dispatchConfig = topLevelEventsToDispatchConfig[topLevelType];
        if (!dispatchConfig) {
          return null;
        }
        var EventConstructor;
        switch (topLevelType) {
          case topLevelTypes.topInput:
          case topLevelTypes.topLoad:
          case topLevelTypes.topError:
          case topLevelTypes.topReset:
          case topLevelTypes.topSubmit:
            EventConstructor = SyntheticEvent;
            break;
          case topLevelTypes.topKeyPress:
            if (getEventCharCode(nativeEvent) === 0) {
              return null;
            }
          case topLevelTypes.topKeyDown:
          case topLevelTypes.topKeyUp:
            EventConstructor = SyntheticKeyboardEvent;
            break;
          case topLevelTypes.topBlur:
          case topLevelTypes.topFocus:
            EventConstructor = SyntheticFocusEvent;
            break;
          case topLevelTypes.topClick:
            if (nativeEvent.button === 2) {
              return null;
            }
          case topLevelTypes.topContextMenu:
          case topLevelTypes.topDoubleClick:
          case topLevelTypes.topMouseDown:
          case topLevelTypes.topMouseMove:
          case topLevelTypes.topMouseOut:
          case topLevelTypes.topMouseOver:
          case topLevelTypes.topMouseUp:
            EventConstructor = SyntheticMouseEvent;
            break;
          case topLevelTypes.topDrag:
          case topLevelTypes.topDragEnd:
          case topLevelTypes.topDragEnter:
          case topLevelTypes.topDragExit:
          case topLevelTypes.topDragLeave:
          case topLevelTypes.topDragOver:
          case topLevelTypes.topDragStart:
          case topLevelTypes.topDrop:
            EventConstructor = SyntheticDragEvent;
            break;
          case topLevelTypes.topTouchCancel:
          case topLevelTypes.topTouchEnd:
          case topLevelTypes.topTouchMove:
          case topLevelTypes.topTouchStart:
            EventConstructor = SyntheticTouchEvent;
            break;
          case topLevelTypes.topScroll:
            EventConstructor = SyntheticUIEvent;
            break;
          case topLevelTypes.topWheel:
            EventConstructor = SyntheticWheelEvent;
            break;
          case topLevelTypes.topCopy:
          case topLevelTypes.topCut:
          case topLevelTypes.topPaste:
            EventConstructor = SyntheticClipboardEvent;
            break;
        }
        ("production" !== process.env.NODE_ENV ? invariant(EventConstructor, 'SimpleEventPlugin: Unhandled event type, `%s`.', topLevelType) : invariant(EventConstructor));
        var event = EventConstructor.getPooled(dispatchConfig, topLevelTargetID, nativeEvent);
        EventPropagators.accumulateTwoPhaseDispatches(event);
        return event;
      }
    };
    module.exports = SimpleEventPlugin;
  })(require("github:jspm/nodelibs-process@0.1.1"));
  global.define = __define;
  return module.exports;
});



System.register("npm:react@0.12.2/lib/ReactDefaultPerf", ["npm:react@0.12.2/lib/DOMProperty", "npm:react@0.12.2/lib/ReactDefaultPerfAnalysis", "npm:react@0.12.2/lib/ReactMount", "npm:react@0.12.2/lib/ReactPerf", "npm:react@0.12.2/lib/performanceNow"], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  "use strict";
  var DOMProperty = require("npm:react@0.12.2/lib/DOMProperty");
  var ReactDefaultPerfAnalysis = require("npm:react@0.12.2/lib/ReactDefaultPerfAnalysis");
  var ReactMount = require("npm:react@0.12.2/lib/ReactMount");
  var ReactPerf = require("npm:react@0.12.2/lib/ReactPerf");
  var performanceNow = require("npm:react@0.12.2/lib/performanceNow");
  function roundFloat(val) {
    return Math.floor(val * 100) / 100;
  }
  function addValue(obj, key, val) {
    obj[key] = (obj[key] || 0) + val;
  }
  var ReactDefaultPerf = {
    _allMeasurements: [],
    _mountStack: [0],
    _injected: false,
    start: function() {
      if (!ReactDefaultPerf._injected) {
        ReactPerf.injection.injectMeasure(ReactDefaultPerf.measure);
      }
      ReactDefaultPerf._allMeasurements.length = 0;
      ReactPerf.enableMeasure = true;
    },
    stop: function() {
      ReactPerf.enableMeasure = false;
    },
    getLastMeasurements: function() {
      return ReactDefaultPerf._allMeasurements;
    },
    printExclusive: function(measurements) {
      measurements = measurements || ReactDefaultPerf._allMeasurements;
      var summary = ReactDefaultPerfAnalysis.getExclusiveSummary(measurements);
      console.table(summary.map(function(item) {
        return {
          'Component class name': item.componentName,
          'Total inclusive time (ms)': roundFloat(item.inclusive),
          'Exclusive mount time (ms)': roundFloat(item.exclusive),
          'Exclusive render time (ms)': roundFloat(item.render),
          'Mount time per instance (ms)': roundFloat(item.exclusive / item.count),
          'Render time per instance (ms)': roundFloat(item.render / item.count),
          'Instances': item.count
        };
      }));
    },
    printInclusive: function(measurements) {
      measurements = measurements || ReactDefaultPerf._allMeasurements;
      var summary = ReactDefaultPerfAnalysis.getInclusiveSummary(measurements);
      console.table(summary.map(function(item) {
        return {
          'Owner > component': item.componentName,
          'Inclusive time (ms)': roundFloat(item.time),
          'Instances': item.count
        };
      }));
      console.log('Total time:', ReactDefaultPerfAnalysis.getTotalTime(measurements).toFixed(2) + ' ms');
    },
    getMeasurementsSummaryMap: function(measurements) {
      var summary = ReactDefaultPerfAnalysis.getInclusiveSummary(measurements, true);
      return summary.map(function(item) {
        return {
          'Owner > component': item.componentName,
          'Wasted time (ms)': item.time,
          'Instances': item.count
        };
      });
    },
    printWasted: function(measurements) {
      measurements = measurements || ReactDefaultPerf._allMeasurements;
      console.table(ReactDefaultPerf.getMeasurementsSummaryMap(measurements));
      console.log('Total time:', ReactDefaultPerfAnalysis.getTotalTime(measurements).toFixed(2) + ' ms');
    },
    printDOM: function(measurements) {
      measurements = measurements || ReactDefaultPerf._allMeasurements;
      var summary = ReactDefaultPerfAnalysis.getDOMSummary(measurements);
      console.table(summary.map(function(item) {
        var result = {};
        result[DOMProperty.ID_ATTRIBUTE_NAME] = item.id;
        result['type'] = item.type;
        result['args'] = JSON.stringify(item.args);
        return result;
      }));
      console.log('Total time:', ReactDefaultPerfAnalysis.getTotalTime(measurements).toFixed(2) + ' ms');
    },
    _recordWrite: function(id, fnName, totalTime, args) {
      var writes = ReactDefaultPerf._allMeasurements[ReactDefaultPerf._allMeasurements.length - 1].writes;
      writes[id] = writes[id] || [];
      writes[id].push({
        type: fnName,
        time: totalTime,
        args: args
      });
    },
    measure: function(moduleName, fnName, func) {
      return function() {
        for (var args = [],
            $__0 = 0,
            $__1 = arguments.length; $__0 < $__1; $__0++)
          args.push(arguments[$__0]);
        var totalTime;
        var rv;
        var start;
        if (fnName === '_renderNewRootComponent' || fnName === 'flushBatchedUpdates') {
          ReactDefaultPerf._allMeasurements.push({
            exclusive: {},
            inclusive: {},
            render: {},
            counts: {},
            writes: {},
            displayNames: {},
            totalTime: 0
          });
          start = performanceNow();
          rv = func.apply(this, args);
          ReactDefaultPerf._allMeasurements[ReactDefaultPerf._allMeasurements.length - 1].totalTime = performanceNow() - start;
          return rv;
        } else if (moduleName === 'ReactDOMIDOperations' || moduleName === 'ReactComponentBrowserEnvironment') {
          start = performanceNow();
          rv = func.apply(this, args);
          totalTime = performanceNow() - start;
          if (fnName === 'mountImageIntoNode') {
            var mountID = ReactMount.getID(args[1]);
            ReactDefaultPerf._recordWrite(mountID, fnName, totalTime, args[0]);
          } else if (fnName === 'dangerouslyProcessChildrenUpdates') {
            args[0].forEach(function(update) {
              var writeArgs = {};
              if (update.fromIndex !== null) {
                writeArgs.fromIndex = update.fromIndex;
              }
              if (update.toIndex !== null) {
                writeArgs.toIndex = update.toIndex;
              }
              if (update.textContent !== null) {
                writeArgs.textContent = update.textContent;
              }
              if (update.markupIndex !== null) {
                writeArgs.markup = args[1][update.markupIndex];
              }
              ReactDefaultPerf._recordWrite(update.parentID, update.type, totalTime, writeArgs);
            });
          } else {
            ReactDefaultPerf._recordWrite(args[0], fnName, totalTime, Array.prototype.slice.call(args, 1));
          }
          return rv;
        } else if (moduleName === 'ReactCompositeComponent' && (fnName === 'mountComponent' || fnName === 'updateComponent' || fnName === '_renderValidatedComponent')) {
          var rootNodeID = fnName === 'mountComponent' ? args[0] : this._rootNodeID;
          var isRender = fnName === '_renderValidatedComponent';
          var isMount = fnName === 'mountComponent';
          var mountStack = ReactDefaultPerf._mountStack;
          var entry = ReactDefaultPerf._allMeasurements[ReactDefaultPerf._allMeasurements.length - 1];
          if (isRender) {
            addValue(entry.counts, rootNodeID, 1);
          } else if (isMount) {
            mountStack.push(0);
          }
          start = performanceNow();
          rv = func.apply(this, args);
          totalTime = performanceNow() - start;
          if (isRender) {
            addValue(entry.render, rootNodeID, totalTime);
          } else if (isMount) {
            var subMountTime = mountStack.pop();
            mountStack[mountStack.length - 1] += totalTime;
            addValue(entry.exclusive, rootNodeID, totalTime - subMountTime);
            addValue(entry.inclusive, rootNodeID, totalTime);
          } else {
            addValue(entry.inclusive, rootNodeID, totalTime);
          }
          entry.displayNames[rootNodeID] = {
            current: this.constructor.displayName,
            owner: this._owner ? this._owner.constructor.displayName : '<root>'
          };
          return rv;
        } else {
          return func.apply(this, args);
        }
      };
    }
  };
  module.exports = ReactDefaultPerf;
  global.define = __define;
  return module.exports;
});



System.register("npm:es5-ext@0.10.6/object/assign/shim", ["npm:es5-ext@0.10.6/object/keys/index", "npm:es5-ext@0.10.6/object/valid-value"], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  'use strict';
  var keys = require("npm:es5-ext@0.10.6/object/keys/index"),
      value = require("npm:es5-ext@0.10.6/object/valid-value"),
      max = Math.max;
  module.exports = function(dest, src) {
    var error,
        i,
        l = max(arguments.length, 2),
        assign;
    dest = Object(value(dest));
    assign = function(key) {
      try {
        dest[key] = src[key];
      } catch (e) {
        if (!error)
          error = e;
      }
    };
    for (i = 1; i < l; ++i) {
      src = arguments[i];
      keys(src).forEach(assign);
    }
    if (error !== undefined)
      throw error;
    return dest;
  };
  global.define = __define;
  return module.exports;
});



System.register("npm:es5-ext@0.10.6/string/#/contains", ["npm:es5-ext@0.10.6/string/#/contains/index"], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  module.exports = require("npm:es5-ext@0.10.6/string/#/contains/index");
  global.define = __define;
  return module.exports;
});



System.register("npm:brace@0.5.0/index", ["npm:w3c-blob@0.0.1", "github:jspm/nodelibs-process@0.1.1"], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  (function(process) {
    (function() {
      var ACE_NAMESPACE = "ace";
      var global = (function() {
        return this;
      })();
      if (!ACE_NAMESPACE && typeof acequirejs !== "undefined")
        return ;
      var _define = function(module, deps, payload) {
        if (typeof module !== 'string') {
          if (_define.original)
            _define.original.apply(window, arguments);
          else {
            console.error('dropping module because define wasn\'t a string.');
            console.trace();
          }
          return ;
        }
        if (arguments.length == 2)
          payload = deps;
        if (!_define.modules) {
          _define.modules = {};
          _define.payloads = {};
        }
        _define.payloads[module] = payload;
        _define.modules[module] = null;
      };
      var _acequire = function(parentId, module, callback) {
        if (Object.prototype.toString.call(module) === "[object Array]") {
          var params = [];
          for (var i = 0,
              l = module.length; i < l; ++i) {
            var dep = lookup(parentId, module[i]);
            if (!dep && _acequire.original)
              return _acequire.original.apply(window, arguments);
            params.push(dep);
          }
          if (callback) {
            callback.apply(null, params);
          }
        } else if (typeof module === 'string') {
          var payload = lookup(parentId, module);
          if (!payload && _acequire.original)
            return _acequire.original.apply(window, arguments);
          if (callback) {
            callback();
          }
          return payload;
        } else {
          if (_acequire.original)
            return _acequire.original.apply(window, arguments);
        }
      };
      var normalizeModule = function(parentId, moduleName) {
        if (moduleName.indexOf("!") !== -1) {
          var chunks = moduleName.split("!");
          return normalizeModule(parentId, chunks[0]) + "!" + normalizeModule(parentId, chunks[1]);
        }
        if (moduleName.charAt(0) == ".") {
          var base = parentId.split("/").slice(0, -1).join("/");
          moduleName = base + "/" + moduleName;
          while (moduleName.indexOf(".") !== -1 && previous != moduleName) {
            var previous = moduleName;
            moduleName = moduleName.replace(/\/\.\//, "/").replace(/[^\/]+\/\.\.\//, "");
          }
        }
        return moduleName;
      };
      var lookup = function(parentId, moduleName) {
        moduleName = normalizeModule(parentId, moduleName);
        var module = _define.modules[moduleName];
        if (!module) {
          module = _define.payloads[moduleName];
          if (typeof module === 'function') {
            var exports = {};
            var mod = {
              id: moduleName,
              uri: '',
              exports: exports,
              packaged: true
            };
            var req = function(module, callback) {
              return _acequire(moduleName, module, callback);
            };
            var returnValue = module(req, exports, mod);
            exports = returnValue || mod.exports;
            _define.modules[moduleName] = exports;
            delete _define.payloads[moduleName];
          }
          module = _define.modules[moduleName] = exports || module;
        }
        return module;
      };
      function exportAce(ns) {
        var acequire = function(module, callback) {
          return _acequire("", module, callback);
        };
        var root = global;
        if (ns) {
          if (!global[ns])
            global[ns] = {};
          root = global[ns];
        }
        if (!root.define || !root.define.packaged) {
          _define.original = root.define;
          root.define = _define;
          root.define.packaged = true;
        }
        if (!root.acequire || !root.acequire.packaged) {
          _acequire.original = root.acequire;
          root.acequire = acequire;
          root.acequire.packaged = true;
        }
      }
      exportAce(ACE_NAMESPACE);
    })();
    ace.define("ace/lib/regexp", ["require", "exports", "module"], function(acequire, exports, module) {
      "use strict";
      var real = {
        exec: RegExp.prototype.exec,
        test: RegExp.prototype.test,
        match: String.prototype.match,
        replace: String.prototype.replace,
        split: String.prototype.split
      },
          compliantExecNpcg = real.exec.call(/()??/, "")[1] === undefined,
          compliantLastIndexIncrement = function() {
            var x = /^/g;
            real.test.call(x, "");
            return !x.lastIndex;
          }();
      if (compliantLastIndexIncrement && compliantExecNpcg)
        return ;
      RegExp.prototype.exec = function(str) {
        var match = real.exec.apply(this, arguments),
            name,
            r2;
        if (typeof(str) == 'string' && match) {
          if (!compliantExecNpcg && match.length > 1 && indexOf(match, "") > -1) {
            r2 = RegExp(this.source, real.replace.call(getNativeFlags(this), "g", ""));
            real.replace.call(str.slice(match.index), r2, function() {
              for (var i = 1; i < arguments.length - 2; i++) {
                if (arguments[i] === undefined)
                  match[i] = undefined;
              }
            });
          }
          if (this._xregexp && this._xregexp.captureNames) {
            for (var i = 1; i < match.length; i++) {
              name = this._xregexp.captureNames[i - 1];
              if (name)
                match[name] = match[i];
            }
          }
          if (!compliantLastIndexIncrement && this.global && !match[0].length && (this.lastIndex > match.index))
            this.lastIndex--;
        }
        return match;
      };
      if (!compliantLastIndexIncrement) {
        RegExp.prototype.test = function(str) {
          var match = real.exec.call(this, str);
          if (match && this.global && !match[0].length && (this.lastIndex > match.index))
            this.lastIndex--;
          return !!match;
        };
      }
      function getNativeFlags(regex) {
        return (regex.global ? "g" : "") + (regex.ignoreCase ? "i" : "") + (regex.multiline ? "m" : "") + (regex.extended ? "x" : "") + (regex.sticky ? "y" : "");
      }
      function indexOf(array, item, from) {
        if (Array.prototype.indexOf)
          return array.indexOf(item, from);
        for (var i = from || 0; i < array.length; i++) {
          if (array[i] === item)
            return i;
        }
        return -1;
      }
    });
    ace.define("ace/lib/es5-shim", ["require", "exports", "module"], function(acequire, exports, module) {
      function Empty() {}
      if (!Function.prototype.bind) {
        Function.prototype.bind = function bind(that) {
          var target = this;
          if (typeof target != "function") {
            throw new TypeError("Function.prototype.bind called on incompatible " + target);
          }
          var args = slice.call(arguments, 1);
          var bound = function() {
            if (this instanceof bound) {
              var result = target.apply(this, args.concat(slice.call(arguments)));
              if (Object(result) === result) {
                return result;
              }
              return this;
            } else {
              return target.apply(that, args.concat(slice.call(arguments)));
            }
          };
          if (target.prototype) {
            Empty.prototype = target.prototype;
            bound.prototype = new Empty();
            Empty.prototype = null;
          }
          return bound;
        };
      }
      var call = Function.prototype.call;
      var prototypeOfArray = Array.prototype;
      var prototypeOfObject = Object.prototype;
      var slice = prototypeOfArray.slice;
      var _toString = call.bind(prototypeOfObject.toString);
      var owns = call.bind(prototypeOfObject.hasOwnProperty);
      var defineGetter;
      var defineSetter;
      var lookupGetter;
      var lookupSetter;
      var supportsAccessors;
      if ((supportsAccessors = owns(prototypeOfObject, "__defineGetter__"))) {
        defineGetter = call.bind(prototypeOfObject.__defineGetter__);
        defineSetter = call.bind(prototypeOfObject.__defineSetter__);
        lookupGetter = call.bind(prototypeOfObject.__lookupGetter__);
        lookupSetter = call.bind(prototypeOfObject.__lookupSetter__);
      }
      if ([1, 2].splice(0).length != 2) {
        if (function() {
          function makeArray(l) {
            var a = new Array(l + 2);
            a[0] = a[1] = 0;
            return a;
          }
          var array = [],
              lengthBefore;
          array.splice.apply(array, makeArray(20));
          array.splice.apply(array, makeArray(26));
          lengthBefore = array.length;
          array.splice(5, 0, "XXX");
          lengthBefore + 1 == array.length;
          if (lengthBefore + 1 == array.length) {
            return true;
          }
        }()) {
          var array_splice = Array.prototype.splice;
          Array.prototype.splice = function(start, deleteCount) {
            if (!arguments.length) {
              return [];
            } else {
              return array_splice.apply(this, [start === void 0 ? 0 : start, deleteCount === void 0 ? (this.length - start) : deleteCount].concat(slice.call(arguments, 2)));
            }
          };
        } else {
          Array.prototype.splice = function(pos, removeCount) {
            var length = this.length;
            if (pos > 0) {
              if (pos > length)
                pos = length;
            } else if (pos == void 0) {
              pos = 0;
            } else if (pos < 0) {
              pos = Math.max(length + pos, 0);
            }
            if (!(pos + removeCount < length))
              removeCount = length - pos;
            var removed = this.slice(pos, pos + removeCount);
            var insert = slice.call(arguments, 2);
            var add = insert.length;
            if (pos === length) {
              if (add) {
                this.push.apply(this, insert);
              }
            } else {
              var remove = Math.min(removeCount, length - pos);
              var tailOldPos = pos + remove;
              var tailNewPos = tailOldPos + add - remove;
              var tailCount = length - tailOldPos;
              var lengthAfterRemove = length - remove;
              if (tailNewPos < tailOldPos) {
                for (var i = 0; i < tailCount; ++i) {
                  this[tailNewPos + i] = this[tailOldPos + i];
                }
              } else if (tailNewPos > tailOldPos) {
                for (i = tailCount; i--; ) {
                  this[tailNewPos + i] = this[tailOldPos + i];
                }
              }
              if (add && pos === lengthAfterRemove) {
                this.length = lengthAfterRemove;
                this.push.apply(this, insert);
              } else {
                this.length = lengthAfterRemove + add;
                for (i = 0; i < add; ++i) {
                  this[pos + i] = insert[i];
                }
              }
            }
            return removed;
          };
        }
      }
      if (!Array.isArray) {
        Array.isArray = function isArray(obj) {
          return _toString(obj) == "[object Array]";
        };
      }
      var boxedString = Object("a"),
          splitString = boxedString[0] != "a" || !(0 in boxedString);
      if (!Array.prototype.forEach) {
        Array.prototype.forEach = function forEach(fun) {
          var object = toObject(this),
              self = splitString && _toString(this) == "[object String]" ? this.split("") : object,
              thisp = arguments[1],
              i = -1,
              length = self.length >>> 0;
          if (_toString(fun) != "[object Function]") {
            throw new TypeError();
          }
          while (++i < length) {
            if (i in self) {
              fun.call(thisp, self[i], i, object);
            }
          }
        };
      }
      if (!Array.prototype.map) {
        Array.prototype.map = function map(fun) {
          var object = toObject(this),
              self = splitString && _toString(this) == "[object String]" ? this.split("") : object,
              length = self.length >>> 0,
              result = Array(length),
              thisp = arguments[1];
          if (_toString(fun) != "[object Function]") {
            throw new TypeError(fun + " is not a function");
          }
          for (var i = 0; i < length; i++) {
            if (i in self)
              result[i] = fun.call(thisp, self[i], i, object);
          }
          return result;
        };
      }
      if (!Array.prototype.filter) {
        Array.prototype.filter = function filter(fun) {
          var object = toObject(this),
              self = splitString && _toString(this) == "[object String]" ? this.split("") : object,
              length = self.length >>> 0,
              result = [],
              value,
              thisp = arguments[1];
          if (_toString(fun) != "[object Function]") {
            throw new TypeError(fun + " is not a function");
          }
          for (var i = 0; i < length; i++) {
            if (i in self) {
              value = self[i];
              if (fun.call(thisp, value, i, object)) {
                result.push(value);
              }
            }
          }
          return result;
        };
      }
      if (!Array.prototype.every) {
        Array.prototype.every = function every(fun) {
          var object = toObject(this),
              self = splitString && _toString(this) == "[object String]" ? this.split("") : object,
              length = self.length >>> 0,
              thisp = arguments[1];
          if (_toString(fun) != "[object Function]") {
            throw new TypeError(fun + " is not a function");
          }
          for (var i = 0; i < length; i++) {
            if (i in self && !fun.call(thisp, self[i], i, object)) {
              return false;
            }
          }
          return true;
        };
      }
      if (!Array.prototype.some) {
        Array.prototype.some = function some(fun) {
          var object = toObject(this),
              self = splitString && _toString(this) == "[object String]" ? this.split("") : object,
              length = self.length >>> 0,
              thisp = arguments[1];
          if (_toString(fun) != "[object Function]") {
            throw new TypeError(fun + " is not a function");
          }
          for (var i = 0; i < length; i++) {
            if (i in self && fun.call(thisp, self[i], i, object)) {
              return true;
            }
          }
          return false;
        };
      }
      if (!Array.prototype.reduce) {
        Array.prototype.reduce = function reduce(fun) {
          var object = toObject(this),
              self = splitString && _toString(this) == "[object String]" ? this.split("") : object,
              length = self.length >>> 0;
          if (_toString(fun) != "[object Function]") {
            throw new TypeError(fun + " is not a function");
          }
          if (!length && arguments.length == 1) {
            throw new TypeError("reduce of empty array with no initial value");
          }
          var i = 0;
          var result;
          if (arguments.length >= 2) {
            result = arguments[1];
          } else {
            do {
              if (i in self) {
                result = self[i++];
                break;
              }
              if (++i >= length) {
                throw new TypeError("reduce of empty array with no initial value");
              }
            } while (true);
          }
          for (; i < length; i++) {
            if (i in self) {
              result = fun.call(void 0, result, self[i], i, object);
            }
          }
          return result;
        };
      }
      if (!Array.prototype.reduceRight) {
        Array.prototype.reduceRight = function reduceRight(fun) {
          var object = toObject(this),
              self = splitString && _toString(this) == "[object String]" ? this.split("") : object,
              length = self.length >>> 0;
          if (_toString(fun) != "[object Function]") {
            throw new TypeError(fun + " is not a function");
          }
          if (!length && arguments.length == 1) {
            throw new TypeError("reduceRight of empty array with no initial value");
          }
          var result,
              i = length - 1;
          if (arguments.length >= 2) {
            result = arguments[1];
          } else {
            do {
              if (i in self) {
                result = self[i--];
                break;
              }
              if (--i < 0) {
                throw new TypeError("reduceRight of empty array with no initial value");
              }
            } while (true);
          }
          do {
            if (i in this) {
              result = fun.call(void 0, result, self[i], i, object);
            }
          } while (i--);
          return result;
        };
      }
      if (!Array.prototype.indexOf || ([0, 1].indexOf(1, 2) != -1)) {
        Array.prototype.indexOf = function indexOf(sought) {
          var self = splitString && _toString(this) == "[object String]" ? this.split("") : toObject(this),
              length = self.length >>> 0;
          if (!length) {
            return -1;
          }
          var i = 0;
          if (arguments.length > 1) {
            i = toInteger(arguments[1]);
          }
          i = i >= 0 ? i : Math.max(0, length + i);
          for (; i < length; i++) {
            if (i in self && self[i] === sought) {
              return i;
            }
          }
          return -1;
        };
      }
      if (!Array.prototype.lastIndexOf || ([0, 1].lastIndexOf(0, -3) != -1)) {
        Array.prototype.lastIndexOf = function lastIndexOf(sought) {
          var self = splitString && _toString(this) == "[object String]" ? this.split("") : toObject(this),
              length = self.length >>> 0;
          if (!length) {
            return -1;
          }
          var i = length - 1;
          if (arguments.length > 1) {
            i = Math.min(i, toInteger(arguments[1]));
          }
          i = i >= 0 ? i : length - Math.abs(i);
          for (; i >= 0; i--) {
            if (i in self && sought === self[i]) {
              return i;
            }
          }
          return -1;
        };
      }
      if (!Object.getPrototypeOf) {
        Object.getPrototypeOf = function getPrototypeOf(object) {
          return object.__proto__ || (object.constructor ? object.constructor.prototype : prototypeOfObject);
        };
      }
      if (!Object.getOwnPropertyDescriptor) {
        var ERR_NON_OBJECT = "Object.getOwnPropertyDescriptor called on a " + "non-object: ";
        Object.getOwnPropertyDescriptor = function getOwnPropertyDescriptor(object, property) {
          if ((typeof object != "object" && typeof object != "function") || object === null)
            throw new TypeError(ERR_NON_OBJECT + object);
          if (!owns(object, property))
            return ;
          var descriptor,
              getter,
              setter;
          descriptor = {
            enumerable: true,
            configurable: true
          };
          if (supportsAccessors) {
            var prototype = object.__proto__;
            object.__proto__ = prototypeOfObject;
            var getter = lookupGetter(object, property);
            var setter = lookupSetter(object, property);
            object.__proto__ = prototype;
            if (getter || setter) {
              if (getter)
                descriptor.get = getter;
              if (setter)
                descriptor.set = setter;
              return descriptor;
            }
          }
          descriptor.value = object[property];
          return descriptor;
        };
      }
      if (!Object.getOwnPropertyNames) {
        Object.getOwnPropertyNames = function getOwnPropertyNames(object) {
          return Object.keys(object);
        };
      }
      if (!Object.create) {
        var createEmpty;
        if (Object.prototype.__proto__ === null) {
          createEmpty = function() {
            return {"__proto__": null};
          };
        } else {
          createEmpty = function() {
            var empty = {};
            for (var i in empty)
              empty[i] = null;
            empty.constructor = empty.hasOwnProperty = empty.propertyIsEnumerable = empty.isPrototypeOf = empty.toLocaleString = empty.toString = empty.valueOf = empty.__proto__ = null;
            return empty;
          };
        }
        Object.create = function create(prototype, properties) {
          var object;
          if (prototype === null) {
            object = createEmpty();
          } else {
            if (typeof prototype != "object")
              throw new TypeError("typeof prototype[" + (typeof prototype) + "] != 'object'");
            var Type = function() {};
            Type.prototype = prototype;
            object = new Type();
            object.__proto__ = prototype;
          }
          if (properties !== void 0)
            Object.defineProperties(object, properties);
          return object;
        };
      }
      function doesDefinePropertyWork(object) {
        try {
          Object.defineProperty(object, "sentinel", {});
          return "sentinel" in object;
        } catch (exception) {}
      }
      if (Object.defineProperty) {
        var definePropertyWorksOnObject = doesDefinePropertyWork({});
        var definePropertyWorksOnDom = typeof document == "undefined" || doesDefinePropertyWork(document.createElement("div"));
        if (!definePropertyWorksOnObject || !definePropertyWorksOnDom) {
          var definePropertyFallback = Object.defineProperty;
        }
      }
      if (!Object.defineProperty || definePropertyFallback) {
        var ERR_NON_OBJECT_DESCRIPTOR = "Property description must be an object: ";
        var ERR_NON_OBJECT_TARGET = "Object.defineProperty called on non-object: ";
        var ERR_ACCESSORS_NOT_SUPPORTED = "getters & setters can not be defined " + "on this javascript engine";
        Object.defineProperty = function defineProperty(object, property, descriptor) {
          if ((typeof object != "object" && typeof object != "function") || object === null)
            throw new TypeError(ERR_NON_OBJECT_TARGET + object);
          if ((typeof descriptor != "object" && typeof descriptor != "function") || descriptor === null)
            throw new TypeError(ERR_NON_OBJECT_DESCRIPTOR + descriptor);
          if (definePropertyFallback) {
            try {
              return definePropertyFallback.call(Object, object, property, descriptor);
            } catch (exception) {}
          }
          if (owns(descriptor, "value")) {
            if (supportsAccessors && (lookupGetter(object, property) || lookupSetter(object, property))) {
              var prototype = object.__proto__;
              object.__proto__ = prototypeOfObject;
              delete object[property];
              object[property] = descriptor.value;
              object.__proto__ = prototype;
            } else {
              object[property] = descriptor.value;
            }
          } else {
            if (!supportsAccessors)
              throw new TypeError(ERR_ACCESSORS_NOT_SUPPORTED);
            if (owns(descriptor, "get"))
              defineGetter(object, property, descriptor.get);
            if (owns(descriptor, "set"))
              defineSetter(object, property, descriptor.set);
          }
          return object;
        };
      }
      if (!Object.defineProperties) {
        Object.defineProperties = function defineProperties(object, properties) {
          for (var property in properties) {
            if (owns(properties, property))
              Object.defineProperty(object, property, properties[property]);
          }
          return object;
        };
      }
      if (!Object.seal) {
        Object.seal = function seal(object) {
          return object;
        };
      }
      if (!Object.freeze) {
        Object.freeze = function freeze(object) {
          return object;
        };
      }
      try {
        Object.freeze(function() {});
      } catch (exception) {
        Object.freeze = (function freeze(freezeObject) {
          return function freeze(object) {
            if (typeof object == "function") {
              return object;
            } else {
              return freezeObject(object);
            }
          };
        })(Object.freeze);
      }
      if (!Object.preventExtensions) {
        Object.preventExtensions = function preventExtensions(object) {
          return object;
        };
      }
      if (!Object.isSealed) {
        Object.isSealed = function isSealed(object) {
          return false;
        };
      }
      if (!Object.isFrozen) {
        Object.isFrozen = function isFrozen(object) {
          return false;
        };
      }
      if (!Object.isExtensible) {
        Object.isExtensible = function isExtensible(object) {
          if (Object(object) === object) {
            throw new TypeError();
          }
          var name = '';
          while (owns(object, name)) {
            name += '?';
          }
          object[name] = true;
          var returnValue = owns(object, name);
          delete object[name];
          return returnValue;
        };
      }
      if (!Object.keys) {
        var hasDontEnumBug = true,
            dontEnums = ["toString", "toLocaleString", "valueOf", "hasOwnProperty", "isPrototypeOf", "propertyIsEnumerable", "constructor"],
            dontEnumsLength = dontEnums.length;
        for (var key in {"toString": null}) {
          hasDontEnumBug = false;
        }
        Object.keys = function keys(object) {
          if ((typeof object != "object" && typeof object != "function") || object === null) {
            throw new TypeError("Object.keys called on a non-object");
          }
          var keys = [];
          for (var name in object) {
            if (owns(object, name)) {
              keys.push(name);
            }
          }
          if (hasDontEnumBug) {
            for (var i = 0,
                ii = dontEnumsLength; i < ii; i++) {
              var dontEnum = dontEnums[i];
              if (owns(object, dontEnum)) {
                keys.push(dontEnum);
              }
            }
          }
          return keys;
        };
      }
      if (!Date.now) {
        Date.now = function now() {
          return new Date().getTime();
        };
      }
      var ws = "\x09\x0A\x0B\x0C\x0D\x20\xA0\u1680\u180E\u2000\u2001\u2002\u2003" + "\u2004\u2005\u2006\u2007\u2008\u2009\u200A\u202F\u205F\u3000\u2028" + "\u2029\uFEFF";
      if (!String.prototype.trim || ws.trim()) {
        ws = "[" + ws + "]";
        var trimBeginRegexp = new RegExp("^" + ws + ws + "*"),
            trimEndRegexp = new RegExp(ws + ws + "*$");
        String.prototype.trim = function trim() {
          return String(this).replace(trimBeginRegexp, "").replace(trimEndRegexp, "");
        };
      }
      function toInteger(n) {
        n = +n;
        if (n !== n) {
          n = 0;
        } else if (n !== 0 && n !== (1 / 0) && n !== -(1 / 0)) {
          n = (n > 0 || -1) * Math.floor(Math.abs(n));
        }
        return n;
      }
      function isPrimitive(input) {
        var type = typeof input;
        return (input === null || type === "undefined" || type === "boolean" || type === "number" || type === "string");
      }
      function toPrimitive(input) {
        var val,
            valueOf,
            toString;
        if (isPrimitive(input)) {
          return input;
        }
        valueOf = input.valueOf;
        if (typeof valueOf === "function") {
          val = valueOf.call(input);
          if (isPrimitive(val)) {
            return val;
          }
        }
        toString = input.toString;
        if (typeof toString === "function") {
          val = toString.call(input);
          if (isPrimitive(val)) {
            return val;
          }
        }
        throw new TypeError();
      }
      var toObject = function(o) {
        if (o == null) {
          throw new TypeError("can't convert " + o + " to object");
        }
        return Object(o);
      };
    });
    ace.define("ace/lib/fixoldbrowsers", ["require", "exports", "module", "ace/lib/regexp", "ace/lib/es5-shim"], function(acequire, exports, module) {
      "use strict";
      acequire("./regexp");
      acequire("./es5-shim");
    });
    ace.define("ace/lib/dom", ["require", "exports", "module"], function(acequire, exports, module) {
      "use strict";
      if (typeof document == "undefined")
        return ;
      var XHTML_NS = "http://www.w3.org/1999/xhtml";
      exports.getDocumentHead = function(doc) {
        if (!doc)
          doc = document;
        return doc.head || doc.getElementsByTagName("head")[0] || doc.documentElement;
      };
      exports.createElement = function(tag, ns) {
        return document.createElementNS ? document.createElementNS(ns || XHTML_NS, tag) : document.createElement(tag);
      };
      exports.hasCssClass = function(el, name) {
        var classes = (el.className || "").split(/\s+/g);
        return classes.indexOf(name) !== -1;
      };
      exports.addCssClass = function(el, name) {
        if (!exports.hasCssClass(el, name)) {
          el.className += " " + name;
        }
      };
      exports.removeCssClass = function(el, name) {
        var classes = el.className.split(/\s+/g);
        while (true) {
          var index = classes.indexOf(name);
          if (index == -1) {
            break;
          }
          classes.splice(index, 1);
        }
        el.className = classes.join(" ");
      };
      exports.toggleCssClass = function(el, name) {
        var classes = el.className.split(/\s+/g),
            add = true;
        while (true) {
          var index = classes.indexOf(name);
          if (index == -1) {
            break;
          }
          add = false;
          classes.splice(index, 1);
        }
        if (add)
          classes.push(name);
        el.className = classes.join(" ");
        return add;
      };
      exports.setCssClass = function(node, className, include) {
        if (include) {
          exports.addCssClass(node, className);
        } else {
          exports.removeCssClass(node, className);
        }
      };
      exports.hasCssString = function(id, doc) {
        var index = 0,
            sheets;
        doc = doc || document;
        if (doc.createStyleSheet && (sheets = doc.styleSheets)) {
          while (index < sheets.length)
            if (sheets[index++].owningElement.id === id)
              return true;
        } else if ((sheets = doc.getElementsByTagName("style"))) {
          while (index < sheets.length)
            if (sheets[index++].id === id)
              return true;
        }
        return false;
      };
      exports.importCssString = function importCssString(cssText, id, doc) {
        doc = doc || document;
        if (id && exports.hasCssString(id, doc))
          return null;
        var style;
        if (doc.createStyleSheet) {
          style = doc.createStyleSheet();
          style.cssText = cssText;
          if (id)
            style.owningElement.id = id;
        } else {
          style = doc.createElementNS ? doc.createElementNS(XHTML_NS, "style") : doc.createElement("style");
          style.appendChild(doc.createTextNode(cssText));
          if (id)
            style.id = id;
          exports.getDocumentHead(doc).appendChild(style);
        }
      };
      exports.importCssStylsheet = function(uri, doc) {
        if (doc.createStyleSheet) {
          doc.createStyleSheet(uri);
        } else {
          var link = exports.createElement('link');
          link.rel = 'stylesheet';
          link.href = uri;
          exports.getDocumentHead(doc).appendChild(link);
        }
      };
      exports.getInnerWidth = function(element) {
        return (parseInt(exports.computedStyle(element, "paddingLeft"), 10) + parseInt(exports.computedStyle(element, "paddingRight"), 10) + element.clientWidth);
      };
      exports.getInnerHeight = function(element) {
        return (parseInt(exports.computedStyle(element, "paddingTop"), 10) + parseInt(exports.computedStyle(element, "paddingBottom"), 10) + element.clientHeight);
      };
      if (window.pageYOffset !== undefined) {
        exports.getPageScrollTop = function() {
          return window.pageYOffset;
        };
        exports.getPageScrollLeft = function() {
          return window.pageXOffset;
        };
      } else {
        exports.getPageScrollTop = function() {
          return document.body.scrollTop;
        };
        exports.getPageScrollLeft = function() {
          return document.body.scrollLeft;
        };
      }
      if (window.getComputedStyle)
        exports.computedStyle = function(element, style) {
          if (style)
            return (window.getComputedStyle(element, "") || {})[style] || "";
          return window.getComputedStyle(element, "") || {};
        };
      else
        exports.computedStyle = function(element, style) {
          if (style)
            return element.currentStyle[style];
          return element.currentStyle;
        };
      exports.scrollbarWidth = function(document) {
        var inner = exports.createElement("ace_inner");
        inner.style.width = "100%";
        inner.style.minWidth = "0px";
        inner.style.height = "200px";
        inner.style.display = "block";
        var outer = exports.createElement("ace_outer");
        var style = outer.style;
        style.position = "absolute";
        style.left = "-10000px";
        style.overflow = "hidden";
        style.width = "200px";
        style.minWidth = "0px";
        style.height = "150px";
        style.display = "block";
        outer.appendChild(inner);
        var body = document.documentElement;
        body.appendChild(outer);
        var noScrollbar = inner.offsetWidth;
        style.overflow = "scroll";
        var withScrollbar = inner.offsetWidth;
        if (noScrollbar == withScrollbar) {
          withScrollbar = outer.clientWidth;
        }
        body.removeChild(outer);
        return noScrollbar - withScrollbar;
      };
      exports.setInnerHtml = function(el, innerHtml) {
        var element = el.cloneNode(false);
        element.innerHTML = innerHtml;
        el.parentNode.replaceChild(element, el);
        return element;
      };
      if ("textContent" in document.documentElement) {
        exports.setInnerText = function(el, innerText) {
          el.textContent = innerText;
        };
        exports.getInnerText = function(el) {
          return el.textContent;
        };
      } else {
        exports.setInnerText = function(el, innerText) {
          el.innerText = innerText;
        };
        exports.getInnerText = function(el) {
          return el.innerText;
        };
      }
      exports.getParentWindow = function(document) {
        return document.defaultView || document.parentWindow;
      };
    });
    ace.define("ace/lib/oop", ["require", "exports", "module"], function(acequire, exports, module) {
      "use strict";
      exports.inherits = function(ctor, superCtor) {
        ctor.super_ = superCtor;
        ctor.prototype = Object.create(superCtor.prototype, {constructor: {
            value: ctor,
            enumerable: false,
            writable: true,
            configurable: true
          }});
      };
      exports.mixin = function(obj, mixin) {
        for (var key in mixin) {
          obj[key] = mixin[key];
        }
        return obj;
      };
      exports.implement = function(proto, mixin) {
        exports.mixin(proto, mixin);
      };
    });
    ace.define("ace/lib/keys", ["require", "exports", "module", "ace/lib/fixoldbrowsers", "ace/lib/oop"], function(acequire, exports, module) {
      "use strict";
      acequire("./fixoldbrowsers");
      var oop = acequire("./oop");
      var Keys = (function() {
        var ret = {
          MODIFIER_KEYS: {
            16: 'Shift',
            17: 'Ctrl',
            18: 'Alt',
            224: 'Meta'
          },
          KEY_MODS: {
            "ctrl": 1,
            "alt": 2,
            "option": 2,
            "shift": 4,
            "super": 8,
            "meta": 8,
            "command": 8,
            "cmd": 8
          },
          FUNCTION_KEYS: {
            8: "Backspace",
            9: "Tab",
            13: "Return",
            19: "Pause",
            27: "Esc",
            32: "Space",
            33: "PageUp",
            34: "PageDown",
            35: "End",
            36: "Home",
            37: "Left",
            38: "Up",
            39: "Right",
            40: "Down",
            44: "Print",
            45: "Insert",
            46: "Delete",
            96: "Numpad0",
            97: "Numpad1",
            98: "Numpad2",
            99: "Numpad3",
            100: "Numpad4",
            101: "Numpad5",
            102: "Numpad6",
            103: "Numpad7",
            104: "Numpad8",
            105: "Numpad9",
            '-13': "NumpadEnter",
            112: "F1",
            113: "F2",
            114: "F3",
            115: "F4",
            116: "F5",
            117: "F6",
            118: "F7",
            119: "F8",
            120: "F9",
            121: "F10",
            122: "F11",
            123: "F12",
            144: "Numlock",
            145: "Scrolllock"
          },
          PRINTABLE_KEYS: {
            32: ' ',
            48: '0',
            49: '1',
            50: '2',
            51: '3',
            52: '4',
            53: '5',
            54: '6',
            55: '7',
            56: '8',
            57: '9',
            59: ';',
            61: '=',
            65: 'a',
            66: 'b',
            67: 'c',
            68: 'd',
            69: 'e',
            70: 'f',
            71: 'g',
            72: 'h',
            73: 'i',
            74: 'j',
            75: 'k',
            76: 'l',
            77: 'm',
            78: 'n',
            79: 'o',
            80: 'p',
            81: 'q',
            82: 'r',
            83: 's',
            84: 't',
            85: 'u',
            86: 'v',
            87: 'w',
            88: 'x',
            89: 'y',
            90: 'z',
            107: '+',
            109: '-',
            110: '.',
            187: '=',
            188: ',',
            189: '-',
            190: '.',
            191: '/',
            192: '`',
            219: '[',
            220: '\\',
            221: ']',
            222: '\''
          }
        };
        var name,
            i;
        for (i in ret.FUNCTION_KEYS) {
          name = ret.FUNCTION_KEYS[i].toLowerCase();
          ret[name] = parseInt(i, 10);
        }
        for (i in ret.PRINTABLE_KEYS) {
          name = ret.PRINTABLE_KEYS[i].toLowerCase();
          ret[name] = parseInt(i, 10);
        }
        oop.mixin(ret, ret.MODIFIER_KEYS);
        oop.mixin(ret, ret.PRINTABLE_KEYS);
        oop.mixin(ret, ret.FUNCTION_KEYS);
        ret.enter = ret["return"];
        ret.escape = ret.esc;
        ret.del = ret["delete"];
        ret[173] = '-';
        (function() {
          var mods = ["cmd", "ctrl", "alt", "shift"];
          for (var i = Math.pow(2, mods.length); i--; ) {
            ret.KEY_MODS[i] = mods.filter(function(x) {
              return i & ret.KEY_MODS[x];
            }).join("-") + "-";
          }
        })();
        ret.KEY_MODS[0] = "";
        ret.KEY_MODS[-1] = "input";
        return ret;
      })();
      oop.mixin(exports, Keys);
      exports.keyCodeToString = function(keyCode) {
        var keyString = Keys[keyCode];
        if (typeof keyString != "string")
          keyString = String.fromCharCode(keyCode);
        return keyString.toLowerCase();
      };
    });
    ace.define("ace/lib/useragent", ["require", "exports", "module"], function(acequire, exports, module) {
      "use strict";
      exports.OS = {
        LINUX: "LINUX",
        MAC: "MAC",
        WINDOWS: "WINDOWS"
      };
      exports.getOS = function() {
        if (exports.isMac) {
          return exports.OS.MAC;
        } else if (exports.isLinux) {
          return exports.OS.LINUX;
        } else {
          return exports.OS.WINDOWS;
        }
      };
      if (typeof navigator != "object")
        return ;
      var os = (navigator.platform.match(/mac|win|linux/i) || ["other"])[0].toLowerCase();
      var ua = navigator.userAgent;
      exports.isWin = (os == "win");
      exports.isMac = (os == "mac");
      exports.isLinux = (os == "linux");
      exports.isIE = (navigator.appName == "Microsoft Internet Explorer" || navigator.appName.indexOf("MSAppHost") >= 0) ? parseFloat((ua.match(/(?:MSIE |Trident\/[0-9]+[\.0-9]+;.*rv:)([0-9]+[\.0-9]+)/) || [])[1]) : parseFloat((ua.match(/(?:Trident\/[0-9]+[\.0-9]+;.*rv:)([0-9]+[\.0-9]+)/) || [])[1]);
      exports.isOldIE = exports.isIE && exports.isIE < 9;
      exports.isGecko = exports.isMozilla = (window.Controllers || window.controllers) && window.navigator.product === "Gecko";
      exports.isOldGecko = exports.isGecko && parseInt((ua.match(/rv\:(\d+)/) || [])[1], 10) < 4;
      exports.isOpera = window.opera && Object.prototype.toString.call(window.opera) == "[object Opera]";
      exports.isWebKit = parseFloat(ua.split("WebKit/")[1]) || undefined;
      exports.isChrome = parseFloat(ua.split(" Chrome/")[1]) || undefined;
      exports.isAIR = ua.indexOf("AdobeAIR") >= 0;
      exports.isIPad = ua.indexOf("iPad") >= 0;
      exports.isTouchPad = ua.indexOf("TouchPad") >= 0;
      exports.isChromeOS = ua.indexOf(" CrOS ") >= 0;
    });
    ace.define("ace/lib/event", ["require", "exports", "module", "ace/lib/keys", "ace/lib/useragent"], function(acequire, exports, module) {
      "use strict";
      var keys = acequire("./keys");
      var useragent = acequire("./useragent");
      exports.addListener = function(elem, type, callback) {
        if (elem.addEventListener) {
          return elem.addEventListener(type, callback, false);
        }
        if (elem.attachEvent) {
          var wrapper = function() {
            callback.call(elem, window.event);
          };
          callback._wrapper = wrapper;
          elem.attachEvent("on" + type, wrapper);
        }
      };
      exports.removeListener = function(elem, type, callback) {
        if (elem.removeEventListener) {
          return elem.removeEventListener(type, callback, false);
        }
        if (elem.detachEvent) {
          elem.detachEvent("on" + type, callback._wrapper || callback);
        }
      };
      exports.stopEvent = function(e) {
        exports.stopPropagation(e);
        exports.preventDefault(e);
        return false;
      };
      exports.stopPropagation = function(e) {
        if (e.stopPropagation)
          e.stopPropagation();
        else
          e.cancelBubble = true;
      };
      exports.preventDefault = function(e) {
        if (e.preventDefault)
          e.preventDefault();
        else
          e.returnValue = false;
      };
      exports.getButton = function(e) {
        if (e.type == "dblclick")
          return 0;
        if (e.type == "contextmenu" || (useragent.isMac && (e.ctrlKey && !e.altKey && !e.shiftKey)))
          return 2;
        if (e.preventDefault) {
          return e.button;
        } else {
          return {
            1: 0,
            2: 2,
            4: 1
          }[e.button];
        }
      };
      exports.capture = function(el, eventHandler, releaseCaptureHandler) {
        function onMouseUp(e) {
          eventHandler && eventHandler(e);
          releaseCaptureHandler && releaseCaptureHandler(e);
          exports.removeListener(document, "mousemove", eventHandler, true);
          exports.removeListener(document, "mouseup", onMouseUp, true);
          exports.removeListener(document, "dragstart", onMouseUp, true);
        }
        exports.addListener(document, "mousemove", eventHandler, true);
        exports.addListener(document, "mouseup", onMouseUp, true);
        exports.addListener(document, "dragstart", onMouseUp, true);
        return onMouseUp;
      };
      exports.addMouseWheelListener = function(el, callback) {
        if ("onmousewheel" in el) {
          exports.addListener(el, "mousewheel", function(e) {
            var factor = 8;
            if (e.wheelDeltaX !== undefined) {
              e.wheelX = -e.wheelDeltaX / factor;
              e.wheelY = -e.wheelDeltaY / factor;
            } else {
              e.wheelX = 0;
              e.wheelY = -e.wheelDelta / factor;
            }
            callback(e);
          });
        } else if ("onwheel" in el) {
          exports.addListener(el, "wheel", function(e) {
            var factor = 0.35;
            switch (e.deltaMode) {
              case e.DOM_DELTA_PIXEL:
                e.wheelX = e.deltaX * factor || 0;
                e.wheelY = e.deltaY * factor || 0;
                break;
              case e.DOM_DELTA_LINE:
              case e.DOM_DELTA_PAGE:
                e.wheelX = (e.deltaX || 0) * 5;
                e.wheelY = (e.deltaY || 0) * 5;
                break;
            }
            callback(e);
          });
        } else {
          exports.addListener(el, "DOMMouseScroll", function(e) {
            if (e.axis && e.axis == e.HORIZONTAL_AXIS) {
              e.wheelX = (e.detail || 0) * 5;
              e.wheelY = 0;
            } else {
              e.wheelX = 0;
              e.wheelY = (e.detail || 0) * 5;
            }
            callback(e);
          });
        }
      };
      exports.addMultiMouseDownListener = function(el, timeouts, eventHandler, callbackName) {
        var clicks = 0;
        var startX,
            startY,
            timer;
        var eventNames = {
          2: "dblclick",
          3: "tripleclick",
          4: "quadclick"
        };
        exports.addListener(el, "mousedown", function(e) {
          if (exports.getButton(e) !== 0) {
            clicks = 0;
          } else if (e.detail > 1) {
            clicks++;
            if (clicks > 4)
              clicks = 1;
          } else {
            clicks = 1;
          }
          if (useragent.isIE) {
            var isNewClick = Math.abs(e.clientX - startX) > 5 || Math.abs(e.clientY - startY) > 5;
            if (!timer || isNewClick)
              clicks = 1;
            if (timer)
              clearTimeout(timer);
            timer = setTimeout(function() {
              timer = null;
            }, timeouts[clicks - 1] || 600);
            if (clicks == 1) {
              startX = e.clientX;
              startY = e.clientY;
            }
          }
          e._clicks = clicks;
          eventHandler[callbackName]("mousedown", e);
          if (clicks > 4)
            clicks = 0;
          else if (clicks > 1)
            return eventHandler[callbackName](eventNames[clicks], e);
        });
        if (useragent.isOldIE) {
          exports.addListener(el, "dblclick", function(e) {
            clicks = 2;
            if (timer)
              clearTimeout(timer);
            timer = setTimeout(function() {
              timer = null;
            }, timeouts[clicks - 1] || 600);
            eventHandler[callbackName]("mousedown", e);
            eventHandler[callbackName](eventNames[clicks], e);
          });
        }
      };
      var getModifierHash = useragent.isMac && useragent.isOpera && !("KeyboardEvent" in window) ? function(e) {
        return 0 | (e.metaKey ? 1 : 0) | (e.altKey ? 2 : 0) | (e.shiftKey ? 4 : 0) | (e.ctrlKey ? 8 : 0);
      } : function(e) {
        return 0 | (e.ctrlKey ? 1 : 0) | (e.altKey ? 2 : 0) | (e.shiftKey ? 4 : 0) | (e.metaKey ? 8 : 0);
      };
      exports.getModifierString = function(e) {
        return keys.KEY_MODS[getModifierHash(e)];
      };
      function normalizeCommandKeys(callback, e, keyCode) {
        var hashId = getModifierHash(e);
        if (!useragent.isMac && pressedKeys) {
          if (pressedKeys[91] || pressedKeys[92])
            hashId |= 8;
          if (pressedKeys.altGr) {
            if ((3 & hashId) != 3)
              pressedKeys.altGr = 0;
            else
              return ;
          }
          if (keyCode === 18 || keyCode === 17) {
            var location = "location" in e ? e.location : e.keyLocation;
            if (keyCode === 17 && location === 1) {
              ts = e.timeStamp;
            } else if (keyCode === 18 && hashId === 3 && location === 2) {
              var dt = -ts;
              ts = e.timeStamp;
              dt += ts;
              if (dt < 3)
                pressedKeys.altGr = true;
            }
          }
        }
        if (keyCode in keys.MODIFIER_KEYS) {
          switch (keys.MODIFIER_KEYS[keyCode]) {
            case "Alt":
              hashId = 2;
              break;
            case "Shift":
              hashId = 4;
              break;
            case "Ctrl":
              hashId = 1;
              break;
            default:
              hashId = 8;
              break;
          }
          keyCode = -1;
        }
        if (hashId & 8 && (keyCode === 91 || keyCode === 93)) {
          keyCode = -1;
        }
        if (!hashId && keyCode === 13) {
          var location = "location" in e ? e.location : e.keyLocation;
          if (location === 3) {
            callback(e, hashId, -keyCode);
            if (e.defaultPrevented)
              return ;
          }
        }
        if (useragent.isChromeOS && hashId & 8) {
          callback(e, hashId, keyCode);
          if (e.defaultPrevented)
            return ;
          else
            hashId &= ~8;
        }
        if (!hashId && !(keyCode in keys.FUNCTION_KEYS) && !(keyCode in keys.PRINTABLE_KEYS)) {
          return false;
        }
        return callback(e, hashId, keyCode);
      }
      var pressedKeys = null;
      var ts = 0;
      exports.addCommandKeyListener = function(el, callback) {
        var addListener = exports.addListener;
        if (useragent.isOldGecko || (useragent.isOpera && !("KeyboardEvent" in window))) {
          var lastKeyDownKeyCode = null;
          addListener(el, "keydown", function(e) {
            lastKeyDownKeyCode = e.keyCode;
          });
          addListener(el, "keypress", function(e) {
            return normalizeCommandKeys(callback, e, lastKeyDownKeyCode);
          });
        } else {
          var lastDefaultPrevented = null;
          addListener(el, "keydown", function(e) {
            pressedKeys[e.keyCode] = true;
            var result = normalizeCommandKeys(callback, e, e.keyCode);
            lastDefaultPrevented = e.defaultPrevented;
            return result;
          });
          addListener(el, "keypress", function(e) {
            if (lastDefaultPrevented && (e.ctrlKey || e.altKey || e.shiftKey || e.metaKey)) {
              exports.stopEvent(e);
              lastDefaultPrevented = null;
            }
          });
          addListener(el, "keyup", function(e) {
            pressedKeys[e.keyCode] = null;
          });
          if (!pressedKeys) {
            pressedKeys = Object.create(null);
            addListener(window, "focus", function(e) {
              pressedKeys = Object.create(null);
            });
          }
        }
      };
      if (window.postMessage && !useragent.isOldIE) {
        var postMessageId = 1;
        exports.nextTick = function(callback, win) {
          win = win || window;
          var messageName = "zero-timeout-message-" + postMessageId;
          exports.addListener(win, "message", function listener(e) {
            if (e.data == messageName) {
              exports.stopPropagation(e);
              exports.removeListener(win, "message", listener);
              callback();
            }
          });
          win.postMessage(messageName, "*");
        };
      }
      exports.nextFrame = window.requestAnimationFrame || window.mozRequestAnimationFrame || window.webkitRequestAnimationFrame || window.msRequestAnimationFrame || window.oRequestAnimationFrame;
      if (exports.nextFrame)
        exports.nextFrame = exports.nextFrame.bind(window);
      else
        exports.nextFrame = function(callback) {
          setTimeout(callback, 17);
        };
    });
    ace.define("ace/lib/lang", ["require", "exports", "module"], function(acequire, exports, module) {
      "use strict";
      exports.last = function(a) {
        return a[a.length - 1];
      };
      exports.stringReverse = function(string) {
        return string.split("").reverse().join("");
      };
      exports.stringRepeat = function(string, count) {
        var result = '';
        while (count > 0) {
          if (count & 1)
            result += string;
          if (count >>= 1)
            string += string;
        }
        return result;
      };
      var trimBeginRegexp = /^\s\s*/;
      var trimEndRegexp = /\s\s*$/;
      exports.stringTrimLeft = function(string) {
        return string.replace(trimBeginRegexp, '');
      };
      exports.stringTrimRight = function(string) {
        return string.replace(trimEndRegexp, '');
      };
      exports.copyObject = function(obj) {
        var copy = {};
        for (var key in obj) {
          copy[key] = obj[key];
        }
        return copy;
      };
      exports.copyArray = function(array) {
        var copy = [];
        for (var i = 0,
            l = array.length; i < l; i++) {
          if (array[i] && typeof array[i] == "object")
            copy[i] = this.copyObject(array[i]);
          else
            copy[i] = array[i];
        }
        return copy;
      };
      exports.deepCopy = function(obj) {
        if (typeof obj !== "object" || !obj)
          return obj;
        var cons = obj.constructor;
        if (cons === RegExp)
          return obj;
        var copy = cons();
        for (var key in obj) {
          if (typeof obj[key] === "object") {
            copy[key] = exports.deepCopy(obj[key]);
          } else {
            copy[key] = obj[key];
          }
        }
        return copy;
      };
      exports.arrayToMap = function(arr) {
        var map = {};
        for (var i = 0; i < arr.length; i++) {
          map[arr[i]] = 1;
        }
        return map;
      };
      exports.createMap = function(props) {
        var map = Object.create(null);
        for (var i in props) {
          map[i] = props[i];
        }
        return map;
      };
      exports.arrayRemove = function(array, value) {
        for (var i = 0; i <= array.length; i++) {
          if (value === array[i]) {
            array.splice(i, 1);
          }
        }
      };
      exports.escapeRegExp = function(str) {
        return str.replace(/([.*+?^${}()|[\]\/\\])/g, '\\$1');
      };
      exports.escapeHTML = function(str) {
        return str.replace(/&/g, "&#38;").replace(/"/g, "&#34;").replace(/'/g, "&#39;").replace(/</g, "&#60;");
      };
      exports.getMatchOffsets = function(string, regExp) {
        var matches = [];
        string.replace(regExp, function(str) {
          matches.push({
            offset: arguments[arguments.length - 2],
            length: str.length
          });
        });
        return matches;
      };
      exports.deferredCall = function(fcn) {
        var timer = null;
        var callback = function() {
          timer = null;
          fcn();
        };
        var deferred = function(timeout) {
          deferred.cancel();
          timer = setTimeout(callback, timeout || 0);
          return deferred;
        };
        deferred.schedule = deferred;
        deferred.call = function() {
          this.cancel();
          fcn();
          return deferred;
        };
        deferred.cancel = function() {
          clearTimeout(timer);
          timer = null;
          return deferred;
        };
        deferred.isPending = function() {
          return timer;
        };
        return deferred;
      };
      exports.delayedCall = function(fcn, defaultTimeout) {
        var timer = null;
        var callback = function() {
          timer = null;
          fcn();
        };
        var _self = function(timeout) {
          if (timer == null)
            timer = setTimeout(callback, timeout || defaultTimeout);
        };
        _self.delay = function(timeout) {
          timer && clearTimeout(timer);
          timer = setTimeout(callback, timeout || defaultTimeout);
        };
        _self.schedule = _self;
        _self.call = function() {
          this.cancel();
          fcn();
        };
        _self.cancel = function() {
          timer && clearTimeout(timer);
          timer = null;
        };
        _self.isPending = function() {
          return timer;
        };
        return _self;
      };
    });
    ace.define("ace/keyboard/textinput", ["require", "exports", "module", "ace/lib/event", "ace/lib/useragent", "ace/lib/dom", "ace/lib/lang"], function(acequire, exports, module) {
      "use strict";
      var event = acequire("../lib/event");
      var useragent = acequire("../lib/useragent");
      var dom = acequire("../lib/dom");
      var lang = acequire("../lib/lang");
      var BROKEN_SETDATA = useragent.isChrome < 18;
      var USE_IE_MIME_TYPE = useragent.isIE;
      var TextInput = function(parentNode, host) {
        var text = dom.createElement("textarea");
        text.className = "ace_text-input";
        if (useragent.isTouchPad)
          text.setAttribute("x-palm-disable-auto-cap", true);
        text.wrap = "off";
        text.autocorrect = "off";
        text.autocapitalize = "off";
        text.spellcheck = false;
        text.style.opacity = "0";
        if (useragent.isOldIE)
          text.style.top = "-100px";
        parentNode.insertBefore(text, parentNode.firstChild);
        var PLACEHOLDER = "\x01\x01";
        var copied = false;
        var pasted = false;
        var inComposition = false;
        var tempStyle = '';
        var isSelectionEmpty = true;
        try {
          var isFocused = document.activeElement === text;
        } catch (e) {}
        event.addListener(text, "blur", function(e) {
          host.onBlur(e);
          isFocused = false;
        });
        event.addListener(text, "focus", function(e) {
          isFocused = true;
          host.onFocus(e);
          resetSelection();
        });
        this.focus = function() {
          text.focus();
        };
        this.blur = function() {
          text.blur();
        };
        this.isFocused = function() {
          return isFocused;
        };
        var syncSelection = lang.delayedCall(function() {
          isFocused && resetSelection(isSelectionEmpty);
        });
        var syncValue = lang.delayedCall(function() {
          if (!inComposition) {
            text.value = PLACEHOLDER;
            isFocused && resetSelection();
          }
        });
        function resetSelection(isEmpty) {
          if (inComposition)
            return ;
          if (inputHandler) {
            selectionStart = 0;
            selectionEnd = isEmpty ? 0 : text.value.length - 1;
          } else {
            var selectionStart = isEmpty ? 2 : 1;
            var selectionEnd = 2;
          }
          try {
            text.setSelectionRange(selectionStart, selectionEnd);
          } catch (e) {}
        }
        function resetValue() {
          if (inComposition)
            return ;
          text.value = PLACEHOLDER;
          if (useragent.isWebKit)
            syncValue.schedule();
        }
        useragent.isWebKit || host.addEventListener('changeSelection', function() {
          if (host.selection.isEmpty() != isSelectionEmpty) {
            isSelectionEmpty = !isSelectionEmpty;
            syncSelection.schedule();
          }
        });
        resetValue();
        if (isFocused)
          host.onFocus();
        var isAllSelected = function(text) {
          return text.selectionStart === 0 && text.selectionEnd === text.value.length;
        };
        if (!text.setSelectionRange && text.createTextRange) {
          text.setSelectionRange = function(selectionStart, selectionEnd) {
            var range = this.createTextRange();
            range.collapse(true);
            range.moveStart('character', selectionStart);
            range.moveEnd('character', selectionEnd);
            range.select();
          };
          isAllSelected = function(text) {
            try {
              var range = text.ownerDocument.selection.createRange();
            } catch (e) {}
            if (!range || range.parentElement() != text)
              return false;
            return range.text == text.value;
          };
        }
        if (useragent.isOldIE) {
          var inPropertyChange = false;
          var onPropertyChange = function(e) {
            if (inPropertyChange)
              return ;
            var data = text.value;
            if (inComposition || !data || data == PLACEHOLDER)
              return ;
            if (e && data == PLACEHOLDER[0])
              return syncProperty.schedule();
            sendText(data);
            inPropertyChange = true;
            resetValue();
            inPropertyChange = false;
          };
          var syncProperty = lang.delayedCall(onPropertyChange);
          event.addListener(text, "propertychange", onPropertyChange);
          var keytable = {
            13: 1,
            27: 1
          };
          event.addListener(text, "keyup", function(e) {
            if (inComposition && (!text.value || keytable[e.keyCode]))
              setTimeout(onCompositionEnd, 0);
            if ((text.value.charCodeAt(0) || 0) < 129) {
              return syncProperty.call();
            }
            inComposition ? onCompositionUpdate() : onCompositionStart();
          });
          event.addListener(text, "keydown", function(e) {
            syncProperty.schedule(50);
          });
        }
        var onSelect = function(e) {
          if (copied) {
            copied = false;
          } else if (isAllSelected(text)) {
            host.selectAll();
            resetSelection();
          } else if (inputHandler) {
            resetSelection(host.selection.isEmpty());
          }
        };
        var inputHandler = null;
        this.setInputHandler = function(cb) {
          inputHandler = cb;
        };
        this.getInputHandler = function() {
          return inputHandler;
        };
        var afterContextMenu = false;
        var sendText = function(data) {
          if (inputHandler) {
            data = inputHandler(data);
            inputHandler = null;
          }
          if (pasted) {
            resetSelection();
            if (data)
              host.onPaste(data);
            pasted = false;
          } else if (data == PLACEHOLDER.charAt(0)) {
            if (afterContextMenu)
              host.execCommand("del", {source: "ace"});
            else
              host.execCommand("backspace", {source: "ace"});
          } else {
            if (data.substring(0, 2) == PLACEHOLDER)
              data = data.substr(2);
            else if (data.charAt(0) == PLACEHOLDER.charAt(0))
              data = data.substr(1);
            else if (data.charAt(data.length - 1) == PLACEHOLDER.charAt(0))
              data = data.slice(0, -1);
            if (data.charAt(data.length - 1) == PLACEHOLDER.charAt(0))
              data = data.slice(0, -1);
            if (data)
              host.onTextInput(data);
          }
          if (afterContextMenu)
            afterContextMenu = false;
        };
        var onInput = function(e) {
          if (inComposition)
            return ;
          var data = text.value;
          sendText(data);
          resetValue();
        };
        var handleClipboardData = function(e, data) {
          var clipboardData = e.clipboardData || window.clipboardData;
          if (!clipboardData || BROKEN_SETDATA)
            return ;
          var mime = USE_IE_MIME_TYPE ? "Text" : "text/plain";
          if (data) {
            return clipboardData.setData(mime, data) !== false;
          } else {
            return clipboardData.getData(mime);
          }
        };
        var doCopy = function(e, isCut) {
          var data = host.getCopyText();
          if (!data)
            return event.preventDefault(e);
          if (handleClipboardData(e, data)) {
            isCut ? host.onCut() : host.onCopy();
            event.preventDefault(e);
          } else {
            copied = true;
            text.value = data;
            text.select();
            setTimeout(function() {
              copied = false;
              resetValue();
              resetSelection();
              isCut ? host.onCut() : host.onCopy();
            });
          }
        };
        var onCut = function(e) {
          doCopy(e, true);
        };
        var onCopy = function(e) {
          doCopy(e, false);
        };
        var onPaste = function(e) {
          var data = handleClipboardData(e);
          if (typeof data == "string") {
            if (data)
              host.onPaste(data);
            if (useragent.isIE)
              setTimeout(resetSelection);
            event.preventDefault(e);
          } else {
            text.value = "";
            pasted = true;
          }
        };
        event.addCommandKeyListener(text, host.onCommandKey.bind(host));
        event.addListener(text, "select", onSelect);
        event.addListener(text, "input", onInput);
        event.addListener(text, "cut", onCut);
        event.addListener(text, "copy", onCopy);
        event.addListener(text, "paste", onPaste);
        if (!('oncut' in text) || !('oncopy' in text) || !('onpaste' in text)) {
          event.addListener(parentNode, "keydown", function(e) {
            if ((useragent.isMac && !e.metaKey) || !e.ctrlKey)
              return ;
            switch (e.keyCode) {
              case 67:
                onCopy(e);
                break;
              case 86:
                onPaste(e);
                break;
              case 88:
                onCut(e);
                break;
            }
          });
        }
        var onCompositionStart = function(e) {
          if (inComposition || !host.onCompositionStart || host.$readOnly)
            return ;
          inComposition = {};
          host.onCompositionStart();
          setTimeout(onCompositionUpdate, 0);
          host.on("mousedown", onCompositionEnd);
          if (!host.selection.isEmpty()) {
            host.insert("");
            host.session.markUndoGroup();
            host.selection.clearSelection();
          }
          host.session.markUndoGroup();
        };
        var onCompositionUpdate = function() {
          if (!inComposition || !host.onCompositionUpdate || host.$readOnly)
            return ;
          var val = text.value.replace(/\x01/g, "");
          if (inComposition.lastValue === val)
            return ;
          host.onCompositionUpdate(val);
          if (inComposition.lastValue)
            host.undo();
          inComposition.lastValue = val;
          if (inComposition.lastValue) {
            var r = host.selection.getRange();
            host.insert(inComposition.lastValue);
            host.session.markUndoGroup();
            inComposition.range = host.selection.getRange();
            host.selection.setRange(r);
            host.selection.clearSelection();
          }
        };
        var onCompositionEnd = function(e) {
          if (!host.onCompositionEnd || host.$readOnly)
            return ;
          var c = inComposition;
          inComposition = false;
          var timer = setTimeout(function() {
            timer = null;
            var str = text.value.replace(/\x01/g, "");
            if (inComposition)
              return ;
            else if (str == c.lastValue)
              resetValue();
            else if (!c.lastValue && str) {
              resetValue();
              sendText(str);
            }
          });
          inputHandler = function compositionInputHandler(str) {
            if (timer)
              clearTimeout(timer);
            str = str.replace(/\x01/g, "");
            if (str == c.lastValue)
              return "";
            if (c.lastValue && timer)
              host.undo();
            return str;
          };
          host.onCompositionEnd();
          host.removeListener("mousedown", onCompositionEnd);
          if (e.type == "compositionend" && c.range) {
            host.selection.setRange(c.range);
          }
        };
        var syncComposition = lang.delayedCall(onCompositionUpdate, 50);
        event.addListener(text, "compositionstart", onCompositionStart);
        if (useragent.isGecko) {
          event.addListener(text, "text", function() {
            syncComposition.schedule();
          });
        } else {
          event.addListener(text, "keyup", function() {
            syncComposition.schedule();
          });
          event.addListener(text, "keydown", function() {
            syncComposition.schedule();
          });
        }
        event.addListener(text, "compositionend", onCompositionEnd);
        this.getElement = function() {
          return text;
        };
        this.setReadOnly = function(readOnly) {
          text.readOnly = readOnly;
        };
        this.onContextMenu = function(e) {
          afterContextMenu = true;
          resetSelection(host.selection.isEmpty());
          host._emit("nativecontextmenu", {
            target: host,
            domEvent: e
          });
          this.moveToMouse(e, true);
        };
        this.moveToMouse = function(e, bringToFront) {
          if (!bringToFront && useragent.isOldIE)
            return ;
          if (!tempStyle)
            tempStyle = text.style.cssText;
          text.style.cssText = (bringToFront ? "z-index:100000;" : "") + "height:" + text.style.height + ";" + (useragent.isIE ? "opacity:0.1;" : "");
          var rect = host.container.getBoundingClientRect();
          var style = dom.computedStyle(host.container);
          var top = rect.top + (parseInt(style.borderTopWidth) || 0);
          var left = rect.left + (parseInt(rect.borderLeftWidth) || 0);
          var maxTop = rect.bottom - top - text.clientHeight - 2;
          var move = function(e) {
            text.style.left = e.clientX - left - 2 + "px";
            text.style.top = Math.min(e.clientY - top - 2, maxTop) + "px";
          };
          move(e);
          if (e.type != "mousedown")
            return ;
          if (host.renderer.$keepTextAreaAtCursor)
            host.renderer.$keepTextAreaAtCursor = null;
          if (useragent.isWin && !useragent.isOldIE)
            event.capture(host.container, move, onContextMenuClose);
        };
        this.onContextMenuClose = onContextMenuClose;
        var closeTimeout;
        function onContextMenuClose() {
          clearTimeout(closeTimeout);
          closeTimeout = setTimeout(function() {
            if (tempStyle) {
              text.style.cssText = tempStyle;
              tempStyle = '';
            }
            if (host.renderer.$keepTextAreaAtCursor == null) {
              host.renderer.$keepTextAreaAtCursor = true;
              host.renderer.$moveTextAreaToCursor();
            }
          }, useragent.isOldIE ? 200 : 0);
        }
        var onContextMenu = function(e) {
          host.textInput.onContextMenu(e);
          onContextMenuClose();
        };
        event.addListener(host.renderer.scroller, "contextmenu", onContextMenu);
        event.addListener(text, "contextmenu", onContextMenu);
      };
      exports.TextInput = TextInput;
    });
    ace.define("ace/mouse/default_handlers", ["require", "exports", "module", "ace/lib/dom", "ace/lib/event", "ace/lib/useragent"], function(acequire, exports, module) {
      "use strict";
      var dom = acequire("../lib/dom");
      var event = acequire("../lib/event");
      var useragent = acequire("../lib/useragent");
      var DRAG_OFFSET = 0;
      function DefaultHandlers(mouseHandler) {
        mouseHandler.$clickSelection = null;
        var editor = mouseHandler.editor;
        editor.setDefaultHandler("mousedown", this.onMouseDown.bind(mouseHandler));
        editor.setDefaultHandler("dblclick", this.onDoubleClick.bind(mouseHandler));
        editor.setDefaultHandler("tripleclick", this.onTripleClick.bind(mouseHandler));
        editor.setDefaultHandler("quadclick", this.onQuadClick.bind(mouseHandler));
        editor.setDefaultHandler("mousewheel", this.onMouseWheel.bind(mouseHandler));
        var exports = ["select", "startSelect", "selectEnd", "selectAllEnd", "selectByWordsEnd", "selectByLinesEnd", "dragWait", "dragWaitEnd", "focusWait"];
        exports.forEach(function(x) {
          mouseHandler[x] = this[x];
        }, this);
        mouseHandler.selectByLines = this.extendSelectionBy.bind(mouseHandler, "getLineRange");
        mouseHandler.selectByWords = this.extendSelectionBy.bind(mouseHandler, "getWordRange");
      }
      (function() {
        this.onMouseDown = function(ev) {
          var inSelection = ev.inSelection();
          var pos = ev.getDocumentPosition();
          this.mousedownEvent = ev;
          var editor = this.editor;
          var button = ev.getButton();
          if (button !== 0) {
            var selectionRange = editor.getSelectionRange();
            var selectionEmpty = selectionRange.isEmpty();
            if (selectionEmpty)
              editor.selection.moveToPosition(pos);
            editor.textInput.onContextMenu(ev.domEvent);
            return ;
          }
          this.mousedownEvent.time = Date.now();
          if (inSelection && !editor.isFocused()) {
            editor.focus();
            if (this.$focusTimout && !this.$clickSelection && !editor.inMultiSelectMode) {
              this.setState("focusWait");
              this.captureMouse(ev);
              return ;
            }
          }
          this.captureMouse(ev);
          this.startSelect(pos, ev.domEvent._clicks > 1);
          return ev.preventDefault();
        };
        this.startSelect = function(pos, waitForClickSelection) {
          pos = pos || this.editor.renderer.screenToTextCoordinates(this.x, this.y);
          var editor = this.editor;
          if (this.mousedownEvent.getShiftKey())
            editor.selection.selectToPosition(pos);
          else if (!waitForClickSelection)
            editor.selection.moveToPosition(pos);
          if (!waitForClickSelection)
            this.select();
          if (editor.renderer.scroller.setCapture) {
            editor.renderer.scroller.setCapture();
          }
          editor.setStyle("ace_selecting");
          this.setState("select");
        };
        this.select = function() {
          var anchor,
              editor = this.editor;
          var cursor = editor.renderer.screenToTextCoordinates(this.x, this.y);
          if (this.$clickSelection) {
            var cmp = this.$clickSelection.comparePoint(cursor);
            if (cmp == -1) {
              anchor = this.$clickSelection.end;
            } else if (cmp == 1) {
              anchor = this.$clickSelection.start;
            } else {
              var orientedRange = calcRangeOrientation(this.$clickSelection, cursor);
              cursor = orientedRange.cursor;
              anchor = orientedRange.anchor;
            }
            editor.selection.setSelectionAnchor(anchor.row, anchor.column);
          }
          editor.selection.selectToPosition(cursor);
          editor.renderer.scrollCursorIntoView();
        };
        this.extendSelectionBy = function(unitName) {
          var anchor,
              editor = this.editor;
          var cursor = editor.renderer.screenToTextCoordinates(this.x, this.y);
          var range = editor.selection[unitName](cursor.row, cursor.column);
          if (this.$clickSelection) {
            var cmpStart = this.$clickSelection.comparePoint(range.start);
            var cmpEnd = this.$clickSelection.comparePoint(range.end);
            if (cmpStart == -1 && cmpEnd <= 0) {
              anchor = this.$clickSelection.end;
              if (range.end.row != cursor.row || range.end.column != cursor.column)
                cursor = range.start;
            } else if (cmpEnd == 1 && cmpStart >= 0) {
              anchor = this.$clickSelection.start;
              if (range.start.row != cursor.row || range.start.column != cursor.column)
                cursor = range.end;
            } else if (cmpStart == -1 && cmpEnd == 1) {
              cursor = range.end;
              anchor = range.start;
            } else {
              var orientedRange = calcRangeOrientation(this.$clickSelection, cursor);
              cursor = orientedRange.cursor;
              anchor = orientedRange.anchor;
            }
            editor.selection.setSelectionAnchor(anchor.row, anchor.column);
          }
          editor.selection.selectToPosition(cursor);
          editor.renderer.scrollCursorIntoView();
        };
        this.selectEnd = this.selectAllEnd = this.selectByWordsEnd = this.selectByLinesEnd = function() {
          this.$clickSelection = null;
          this.editor.unsetStyle("ace_selecting");
          if (this.editor.renderer.scroller.releaseCapture) {
            this.editor.renderer.scroller.releaseCapture();
          }
        };
        this.focusWait = function() {
          var distance = calcDistance(this.mousedownEvent.x, this.mousedownEvent.y, this.x, this.y);
          var time = Date.now();
          if (distance > DRAG_OFFSET || time - this.mousedownEvent.time > this.$focusTimout)
            this.startSelect(this.mousedownEvent.getDocumentPosition());
        };
        this.onDoubleClick = function(ev) {
          var pos = ev.getDocumentPosition();
          var editor = this.editor;
          var session = editor.session;
          var range = session.getBracketRange(pos);
          if (range) {
            if (range.isEmpty()) {
              range.start.column--;
              range.end.column++;
            }
            this.setState("select");
          } else {
            range = editor.selection.getWordRange(pos.row, pos.column);
            this.setState("selectByWords");
          }
          this.$clickSelection = range;
          this.select();
        };
        this.onTripleClick = function(ev) {
          var pos = ev.getDocumentPosition();
          var editor = this.editor;
          this.setState("selectByLines");
          var range = editor.getSelectionRange();
          if (range.isMultiLine() && range.contains(pos.row, pos.column)) {
            this.$clickSelection = editor.selection.getLineRange(range.start.row);
            this.$clickSelection.end = editor.selection.getLineRange(range.end.row).end;
          } else {
            this.$clickSelection = editor.selection.getLineRange(pos.row);
          }
          this.select();
        };
        this.onQuadClick = function(ev) {
          var editor = this.editor;
          editor.selectAll();
          this.$clickSelection = editor.getSelectionRange();
          this.setState("selectAll");
        };
        this.onMouseWheel = function(ev) {
          if (ev.getAccelKey())
            return ;
          if (ev.getShiftKey() && ev.wheelY && !ev.wheelX) {
            ev.wheelX = ev.wheelY;
            ev.wheelY = 0;
          }
          var t = ev.domEvent.timeStamp;
          var dt = t - (this.$lastScrollTime || 0);
          var editor = this.editor;
          var isScrolable = editor.renderer.isScrollableBy(ev.wheelX * ev.speed, ev.wheelY * ev.speed);
          if (isScrolable || dt < 200) {
            this.$lastScrollTime = t;
            editor.renderer.scrollBy(ev.wheelX * ev.speed, ev.wheelY * ev.speed);
            return ev.stop();
          }
        };
      }).call(DefaultHandlers.prototype);
      exports.DefaultHandlers = DefaultHandlers;
      function calcDistance(ax, ay, bx, by) {
        return Math.sqrt(Math.pow(bx - ax, 2) + Math.pow(by - ay, 2));
      }
      function calcRangeOrientation(range, cursor) {
        if (range.start.row == range.end.row)
          var cmp = 2 * cursor.column - range.start.column - range.end.column;
        else if (range.start.row == range.end.row - 1 && !range.start.column && !range.end.column)
          var cmp = cursor.column - 4;
        else
          var cmp = 2 * cursor.row - range.start.row - range.end.row;
        if (cmp < 0)
          return {
            cursor: range.start,
            anchor: range.end
          };
        else
          return {
            cursor: range.end,
            anchor: range.start
          };
      }
    });
    ace.define("ace/tooltip", ["require", "exports", "module", "ace/lib/oop", "ace/lib/dom"], function(acequire, exports, module) {
      "use strict";
      var oop = acequire("./lib/oop");
      var dom = acequire("./lib/dom");
      function Tooltip(parentNode) {
        this.isOpen = false;
        this.$element = null;
        this.$parentNode = parentNode;
      }
      (function() {
        this.$init = function() {
          this.$element = dom.createElement("div");
          this.$element.className = "ace_tooltip";
          this.$element.style.display = "none";
          this.$parentNode.appendChild(this.$element);
          return this.$element;
        };
        this.getElement = function() {
          return this.$element || this.$init();
        };
        this.setText = function(text) {
          dom.setInnerText(this.getElement(), text);
        };
        this.setHtml = function(html) {
          this.getElement().innerHTML = html;
        };
        this.setPosition = function(x, y) {
          this.getElement().style.left = x + "px";
          this.getElement().style.top = y + "px";
        };
        this.setClassName = function(className) {
          dom.addCssClass(this.getElement(), className);
        };
        this.show = function(text, x, y) {
          if (text != null)
            this.setText(text);
          if (x != null && y != null)
            this.setPosition(x, y);
          if (!this.isOpen) {
            this.getElement().style.display = "block";
            this.isOpen = true;
          }
        };
        this.hide = function() {
          if (this.isOpen) {
            this.getElement().style.display = "none";
            this.isOpen = false;
          }
        };
        this.getHeight = function() {
          return this.getElement().offsetHeight;
        };
        this.getWidth = function() {
          return this.getElement().offsetWidth;
        };
      }).call(Tooltip.prototype);
      exports.Tooltip = Tooltip;
    });
    ace.define("ace/mouse/default_gutter_handler", ["require", "exports", "module", "ace/lib/dom", "ace/lib/oop", "ace/lib/event", "ace/tooltip"], function(acequire, exports, module) {
      "use strict";
      var dom = acequire("../lib/dom");
      var oop = acequire("../lib/oop");
      var event = acequire("../lib/event");
      var Tooltip = acequire("../tooltip").Tooltip;
      function GutterHandler(mouseHandler) {
        var editor = mouseHandler.editor;
        var gutter = editor.renderer.$gutterLayer;
        var tooltip = new GutterTooltip(editor.container);
        mouseHandler.editor.setDefaultHandler("guttermousedown", function(e) {
          if (!editor.isFocused() || e.getButton() != 0)
            return ;
          var gutterRegion = gutter.getRegion(e);
          if (gutterRegion == "foldWidgets")
            return ;
          var row = e.getDocumentPosition().row;
          var selection = editor.session.selection;
          if (e.getShiftKey())
            selection.selectTo(row, 0);
          else {
            if (e.domEvent.detail == 2) {
              editor.selectAll();
              return e.preventDefault();
            }
            mouseHandler.$clickSelection = editor.selection.getLineRange(row);
          }
          mouseHandler.setState("selectByLines");
          mouseHandler.captureMouse(e);
          return e.preventDefault();
        });
        var tooltipTimeout,
            mouseEvent,
            tooltipAnnotation;
        function showTooltip() {
          var row = mouseEvent.getDocumentPosition().row;
          var annotation = gutter.$annotations[row];
          if (!annotation)
            return hideTooltip();
          var maxRow = editor.session.getLength();
          if (row == maxRow) {
            var screenRow = editor.renderer.pixelToScreenCoordinates(0, mouseEvent.y).row;
            var pos = mouseEvent.$pos;
            if (screenRow > editor.session.documentToScreenRow(pos.row, pos.column))
              return hideTooltip();
          }
          if (tooltipAnnotation == annotation)
            return ;
          tooltipAnnotation = annotation.text.join("<br/>");
          tooltip.setHtml(tooltipAnnotation);
          tooltip.show();
          editor.on("mousewheel", hideTooltip);
          if (mouseHandler.$tooltipFollowsMouse) {
            moveTooltip(mouseEvent);
          } else {
            var gutterElement = gutter.$cells[editor.session.documentToScreenRow(row, 0)].element;
            var rect = gutterElement.getBoundingClientRect();
            var style = tooltip.getElement().style;
            style.left = rect.right + "px";
            style.top = rect.bottom + "px";
          }
        }
        function hideTooltip() {
          if (tooltipTimeout)
            tooltipTimeout = clearTimeout(tooltipTimeout);
          if (tooltipAnnotation) {
            tooltip.hide();
            tooltipAnnotation = null;
            editor.removeEventListener("mousewheel", hideTooltip);
          }
        }
        function moveTooltip(e) {
          tooltip.setPosition(e.x, e.y);
        }
        mouseHandler.editor.setDefaultHandler("guttermousemove", function(e) {
          var target = e.domEvent.target || e.domEvent.srcElement;
          if (dom.hasCssClass(target, "ace_fold-widget"))
            return hideTooltip();
          if (tooltipAnnotation && mouseHandler.$tooltipFollowsMouse)
            moveTooltip(e);
          mouseEvent = e;
          if (tooltipTimeout)
            return ;
          tooltipTimeout = setTimeout(function() {
            tooltipTimeout = null;
            if (mouseEvent && !mouseHandler.isMousePressed)
              showTooltip();
            else
              hideTooltip();
          }, 50);
        });
        event.addListener(editor.renderer.$gutter, "mouseout", function(e) {
          mouseEvent = null;
          if (!tooltipAnnotation || tooltipTimeout)
            return ;
          tooltipTimeout = setTimeout(function() {
            tooltipTimeout = null;
            hideTooltip();
          }, 50);
        });
        editor.on("changeSession", hideTooltip);
      }
      function GutterTooltip(parentNode) {
        Tooltip.call(this, parentNode);
      }
      oop.inherits(GutterTooltip, Tooltip);
      (function() {
        this.setPosition = function(x, y) {
          var windowWidth = window.innerWidth || document.documentElement.clientWidth;
          var windowHeight = window.innerHeight || document.documentElement.clientHeight;
          var width = this.getWidth();
          var height = this.getHeight();
          x += 15;
          y += 15;
          if (x + width > windowWidth) {
            x -= (x + width) - windowWidth;
          }
          if (y + height > windowHeight) {
            y -= 20 + height;
          }
          Tooltip.prototype.setPosition.call(this, x, y);
        };
      }).call(GutterTooltip.prototype);
      exports.GutterHandler = GutterHandler;
    });
    ace.define("ace/mouse/mouse_event", ["require", "exports", "module", "ace/lib/event", "ace/lib/useragent"], function(acequire, exports, module) {
      "use strict";
      var event = acequire("../lib/event");
      var useragent = acequire("../lib/useragent");
      var MouseEvent = exports.MouseEvent = function(domEvent, editor) {
        this.domEvent = domEvent;
        this.editor = editor;
        this.x = this.clientX = domEvent.clientX;
        this.y = this.clientY = domEvent.clientY;
        this.$pos = null;
        this.$inSelection = null;
        this.propagationStopped = false;
        this.defaultPrevented = false;
      };
      (function() {
        this.stopPropagation = function() {
          event.stopPropagation(this.domEvent);
          this.propagationStopped = true;
        };
        this.preventDefault = function() {
          event.preventDefault(this.domEvent);
          this.defaultPrevented = true;
        };
        this.stop = function() {
          this.stopPropagation();
          this.preventDefault();
        };
        this.getDocumentPosition = function() {
          if (this.$pos)
            return this.$pos;
          this.$pos = this.editor.renderer.screenToTextCoordinates(this.clientX, this.clientY);
          return this.$pos;
        };
        this.inSelection = function() {
          if (this.$inSelection !== null)
            return this.$inSelection;
          var editor = this.editor;
          var selectionRange = editor.getSelectionRange();
          if (selectionRange.isEmpty())
            this.$inSelection = false;
          else {
            var pos = this.getDocumentPosition();
            this.$inSelection = selectionRange.contains(pos.row, pos.column);
          }
          return this.$inSelection;
        };
        this.getButton = function() {
          return event.getButton(this.domEvent);
        };
        this.getShiftKey = function() {
          return this.domEvent.shiftKey;
        };
        this.getAccelKey = useragent.isMac ? function() {
          return this.domEvent.metaKey;
        } : function() {
          return this.domEvent.ctrlKey;
        };
      }).call(MouseEvent.prototype);
    });
    ace.define("ace/mouse/dragdrop_handler", ["require", "exports", "module", "ace/lib/dom", "ace/lib/event", "ace/lib/useragent"], function(acequire, exports, module) {
      "use strict";
      var dom = acequire("../lib/dom");
      var event = acequire("../lib/event");
      var useragent = acequire("../lib/useragent");
      var AUTOSCROLL_DELAY = 200;
      var SCROLL_CURSOR_DELAY = 200;
      var SCROLL_CURSOR_HYSTERESIS = 5;
      function DragdropHandler(mouseHandler) {
        var editor = mouseHandler.editor;
        var blankImage = dom.createElement("img");
        blankImage.src = "data:image/gif;base64,R0lGODlhAQABAAAAACH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==";
        if (useragent.isOpera)
          blankImage.style.cssText = "width:1px;height:1px;position:fixed;top:0;left:0;z-index:2147483647;opacity:0;";
        var exports = ["dragWait", "dragWaitEnd", "startDrag", "dragReadyEnd", "onMouseDrag"];
        exports.forEach(function(x) {
          mouseHandler[x] = this[x];
        }, this);
        editor.addEventListener("mousedown", this.onMouseDown.bind(mouseHandler));
        var mouseTarget = editor.container;
        var dragSelectionMarker,
            x,
            y;
        var timerId,
            range;
        var dragCursor,
            counter = 0;
        var dragOperation;
        var isInternal;
        var autoScrollStartTime;
        var cursorMovedTime;
        var cursorPointOnCaretMoved;
        this.onDragStart = function(e) {
          if (this.cancelDrag || !mouseTarget.draggable) {
            var self = this;
            setTimeout(function() {
              self.startSelect();
              self.captureMouse(e);
            }, 0);
            return e.preventDefault();
          }
          range = editor.getSelectionRange();
          var dataTransfer = e.dataTransfer;
          dataTransfer.effectAllowed = editor.getReadOnly() ? "copy" : "copyMove";
          if (useragent.isOpera) {
            editor.container.appendChild(blankImage);
            blankImage.scrollTop = 0;
          }
          dataTransfer.setDragImage && dataTransfer.setDragImage(blankImage, 0, 0);
          if (useragent.isOpera) {
            editor.container.removeChild(blankImage);
          }
          dataTransfer.clearData();
          dataTransfer.setData("Text", editor.session.getTextRange());
          isInternal = true;
          this.setState("drag");
        };
        this.onDragEnd = function(e) {
          mouseTarget.draggable = false;
          isInternal = false;
          this.setState(null);
          if (!editor.getReadOnly()) {
            var dropEffect = e.dataTransfer.dropEffect;
            if (!dragOperation && dropEffect == "move")
              editor.session.remove(editor.getSelectionRange());
            editor.renderer.$cursorLayer.setBlinking(true);
          }
          this.editor.unsetStyle("ace_dragging");
          this.editor.renderer.setCursorStyle("");
        };
        this.onDragEnter = function(e) {
          if (editor.getReadOnly() || !canAccept(e.dataTransfer))
            return ;
          x = e.clientX;
          y = e.clientY;
          if (!dragSelectionMarker)
            addDragMarker();
          counter++;
          e.dataTransfer.dropEffect = dragOperation = getDropEffect(e);
          return event.preventDefault(e);
        };
        this.onDragOver = function(e) {
          if (editor.getReadOnly() || !canAccept(e.dataTransfer))
            return ;
          x = e.clientX;
          y = e.clientY;
          if (!dragSelectionMarker) {
            addDragMarker();
            counter++;
          }
          if (onMouseMoveTimer !== null)
            onMouseMoveTimer = null;
          e.dataTransfer.dropEffect = dragOperation = getDropEffect(e);
          return event.preventDefault(e);
        };
        this.onDragLeave = function(e) {
          counter--;
          if (counter <= 0 && dragSelectionMarker) {
            clearDragMarker();
            dragOperation = null;
            return event.preventDefault(e);
          }
        };
        this.onDrop = function(e) {
          if (!dragCursor)
            return ;
          var dataTransfer = e.dataTransfer;
          if (isInternal) {
            switch (dragOperation) {
              case "move":
                if (range.contains(dragCursor.row, dragCursor.column)) {
                  range = {
                    start: dragCursor,
                    end: dragCursor
                  };
                } else {
                  range = editor.moveText(range, dragCursor);
                }
                break;
              case "copy":
                range = editor.moveText(range, dragCursor, true);
                break;
            }
          } else {
            var dropData = dataTransfer.getData('Text');
            range = {
              start: dragCursor,
              end: editor.session.insert(dragCursor, dropData)
            };
            editor.focus();
            dragOperation = null;
          }
          clearDragMarker();
          return event.preventDefault(e);
        };
        event.addListener(mouseTarget, "dragstart", this.onDragStart.bind(mouseHandler));
        event.addListener(mouseTarget, "dragend", this.onDragEnd.bind(mouseHandler));
        event.addListener(mouseTarget, "dragenter", this.onDragEnter.bind(mouseHandler));
        event.addListener(mouseTarget, "dragover", this.onDragOver.bind(mouseHandler));
        event.addListener(mouseTarget, "dragleave", this.onDragLeave.bind(mouseHandler));
        event.addListener(mouseTarget, "drop", this.onDrop.bind(mouseHandler));
        function scrollCursorIntoView(cursor, prevCursor) {
          var now = Date.now();
          var vMovement = !prevCursor || cursor.row != prevCursor.row;
          var hMovement = !prevCursor || cursor.column != prevCursor.column;
          if (!cursorMovedTime || vMovement || hMovement) {
            editor.$blockScrolling += 1;
            editor.moveCursorToPosition(cursor);
            editor.$blockScrolling -= 1;
            cursorMovedTime = now;
            cursorPointOnCaretMoved = {
              x: x,
              y: y
            };
          } else {
            var distance = calcDistance(cursorPointOnCaretMoved.x, cursorPointOnCaretMoved.y, x, y);
            if (distance > SCROLL_CURSOR_HYSTERESIS) {
              cursorMovedTime = null;
            } else if (now - cursorMovedTime >= SCROLL_CURSOR_DELAY) {
              editor.renderer.scrollCursorIntoView();
              cursorMovedTime = null;
            }
          }
        }
        function autoScroll(cursor, prevCursor) {
          var now = Date.now();
          var lineHeight = editor.renderer.layerConfig.lineHeight;
          var characterWidth = editor.renderer.layerConfig.characterWidth;
          var editorRect = editor.renderer.scroller.getBoundingClientRect();
          var offsets = {
            x: {
              left: x - editorRect.left,
              right: editorRect.right - x
            },
            y: {
              top: y - editorRect.top,
              bottom: editorRect.bottom - y
            }
          };
          var nearestXOffset = Math.min(offsets.x.left, offsets.x.right);
          var nearestYOffset = Math.min(offsets.y.top, offsets.y.bottom);
          var scrollCursor = {
            row: cursor.row,
            column: cursor.column
          };
          if (nearestXOffset / characterWidth <= 2) {
            scrollCursor.column += (offsets.x.left < offsets.x.right ? -3 : +2);
          }
          if (nearestYOffset / lineHeight <= 1) {
            scrollCursor.row += (offsets.y.top < offsets.y.bottom ? -1 : +1);
          }
          var vScroll = cursor.row != scrollCursor.row;
          var hScroll = cursor.column != scrollCursor.column;
          var vMovement = !prevCursor || cursor.row != prevCursor.row;
          if (vScroll || (hScroll && !vMovement)) {
            if (!autoScrollStartTime)
              autoScrollStartTime = now;
            else if (now - autoScrollStartTime >= AUTOSCROLL_DELAY)
              editor.renderer.scrollCursorIntoView(scrollCursor);
          } else {
            autoScrollStartTime = null;
          }
        }
        function onDragInterval() {
          var prevCursor = dragCursor;
          dragCursor = editor.renderer.screenToTextCoordinates(x, y);
          scrollCursorIntoView(dragCursor, prevCursor);
          autoScroll(dragCursor, prevCursor);
        }
        function addDragMarker() {
          range = editor.selection.toOrientedRange();
          dragSelectionMarker = editor.session.addMarker(range, "ace_selection", editor.getSelectionStyle());
          editor.clearSelection();
          if (editor.isFocused())
            editor.renderer.$cursorLayer.setBlinking(false);
          clearInterval(timerId);
          onDragInterval();
          timerId = setInterval(onDragInterval, 20);
          counter = 0;
          event.addListener(document, "mousemove", onMouseMove);
        }
        function clearDragMarker() {
          clearInterval(timerId);
          editor.session.removeMarker(dragSelectionMarker);
          dragSelectionMarker = null;
          editor.$blockScrolling += 1;
          editor.selection.fromOrientedRange(range);
          editor.$blockScrolling -= 1;
          if (editor.isFocused() && !isInternal)
            editor.renderer.$cursorLayer.setBlinking(!editor.getReadOnly());
          range = null;
          dragCursor = null;
          counter = 0;
          autoScrollStartTime = null;
          cursorMovedTime = null;
          event.removeListener(document, "mousemove", onMouseMove);
        }
        var onMouseMoveTimer = null;
        function onMouseMove() {
          if (onMouseMoveTimer == null) {
            onMouseMoveTimer = setTimeout(function() {
              if (onMouseMoveTimer != null && dragSelectionMarker)
                clearDragMarker();
            }, 20);
          }
        }
        function canAccept(dataTransfer) {
          var types = dataTransfer.types;
          return !types || Array.prototype.some.call(types, function(type) {
            return type == 'text/plain' || type == 'Text';
          });
        }
        function getDropEffect(e) {
          var copyAllowed = ['copy', 'copymove', 'all', 'uninitialized'];
          var moveAllowed = ['move', 'copymove', 'linkmove', 'all', 'uninitialized'];
          var copyModifierState = useragent.isMac ? e.altKey : e.ctrlKey;
          var effectAllowed = "uninitialized";
          try {
            effectAllowed = e.dataTransfer.effectAllowed.toLowerCase();
          } catch (e) {}
          var dropEffect = "none";
          if (copyModifierState && copyAllowed.indexOf(effectAllowed) >= 0)
            dropEffect = "copy";
          else if (moveAllowed.indexOf(effectAllowed) >= 0)
            dropEffect = "move";
          else if (copyAllowed.indexOf(effectAllowed) >= 0)
            dropEffect = "copy";
          return dropEffect;
        }
      }
      (function() {
        this.dragWait = function() {
          var interval = Date.now() - this.mousedownEvent.time;
          if (interval > this.editor.getDragDelay())
            this.startDrag();
        };
        this.dragWaitEnd = function() {
          var target = this.editor.container;
          target.draggable = false;
          this.startSelect(this.mousedownEvent.getDocumentPosition());
          this.selectEnd();
        };
        this.dragReadyEnd = function(e) {
          this.editor.renderer.$cursorLayer.setBlinking(!this.editor.getReadOnly());
          this.editor.unsetStyle("ace_dragging");
          this.editor.renderer.setCursorStyle("");
          this.dragWaitEnd();
        };
        this.startDrag = function() {
          this.cancelDrag = false;
          var editor = this.editor;
          var target = editor.container;
          target.draggable = true;
          editor.renderer.$cursorLayer.setBlinking(false);
          editor.setStyle("ace_dragging");
          var cursorStyle = useragent.isWin ? "default" : "move";
          editor.renderer.setCursorStyle(cursorStyle);
          this.setState("dragReady");
        };
        this.onMouseDrag = function(e) {
          var target = this.editor.container;
          if (useragent.isIE && this.state == "dragReady") {
            var distance = calcDistance(this.mousedownEvent.x, this.mousedownEvent.y, this.x, this.y);
            if (distance > 3)
              target.dragDrop();
          }
          if (this.state === "dragWait") {
            var distance = calcDistance(this.mousedownEvent.x, this.mousedownEvent.y, this.x, this.y);
            if (distance > 0) {
              target.draggable = false;
              this.startSelect(this.mousedownEvent.getDocumentPosition());
            }
          }
        };
        this.onMouseDown = function(e) {
          if (!this.$dragEnabled)
            return ;
          this.mousedownEvent = e;
          var editor = this.editor;
          var inSelection = e.inSelection();
          var button = e.getButton();
          var clickCount = e.domEvent.detail || 1;
          if (clickCount === 1 && button === 0 && inSelection) {
            if (e.editor.inMultiSelectMode && (e.getAccelKey() || e.getShiftKey()))
              return ;
            this.mousedownEvent.time = Date.now();
            var eventTarget = e.domEvent.target || e.domEvent.srcElement;
            if ("unselectable" in eventTarget)
              eventTarget.unselectable = "on";
            if (editor.getDragDelay()) {
              if (useragent.isWebKit) {
                this.cancelDrag = true;
                var mouseTarget = editor.container;
                mouseTarget.draggable = true;
              }
              this.setState("dragWait");
            } else {
              this.startDrag();
            }
            this.captureMouse(e, this.onMouseDrag.bind(this));
            e.defaultPrevented = true;
          }
        };
      }).call(DragdropHandler.prototype);
      function calcDistance(ax, ay, bx, by) {
        return Math.sqrt(Math.pow(bx - ax, 2) + Math.pow(by - ay, 2));
      }
      exports.DragdropHandler = DragdropHandler;
    });
    ace.define("ace/lib/net", ["require", "exports", "module", "ace/lib/dom"], function(acequire, exports, module) {
      "use strict";
      var dom = acequire("./dom");
      exports.get = function(url, callback) {
        var xhr = new XMLHttpRequest();
        xhr.open('GET', url, true);
        xhr.onreadystatechange = function() {
          if (xhr.readyState === 4) {
            callback(xhr.responseText);
          }
        };
        xhr.send(null);
      };
      exports.loadScript = function(path, callback) {
        var head = dom.getDocumentHead();
        var s = document.createElement('script');
        s.src = path;
        head.appendChild(s);
        s.onload = s.onreadystatechange = function(_, isAbort) {
          if (isAbort || !s.readyState || s.readyState == "loaded" || s.readyState == "complete") {
            s = s.onload = s.onreadystatechange = null;
            if (!isAbort)
              callback();
          }
        };
      };
      exports.qualifyURL = function(url) {
        var a = document.createElement('a');
        a.href = url;
        return a.href;
      };
    });
    ace.define("ace/lib/event_emitter", ["require", "exports", "module"], function(acequire, exports, module) {
      "use strict";
      var EventEmitter = {};
      var stopPropagation = function() {
        this.propagationStopped = true;
      };
      var preventDefault = function() {
        this.defaultPrevented = true;
      };
      EventEmitter._emit = EventEmitter._dispatchEvent = function(eventName, e) {
        this._eventRegistry || (this._eventRegistry = {});
        this._defaultHandlers || (this._defaultHandlers = {});
        var listeners = this._eventRegistry[eventName] || [];
        var defaultHandler = this._defaultHandlers[eventName];
        if (!listeners.length && !defaultHandler)
          return ;
        if (typeof e != "object" || !e)
          e = {};
        if (!e.type)
          e.type = eventName;
        if (!e.stopPropagation)
          e.stopPropagation = stopPropagation;
        if (!e.preventDefault)
          e.preventDefault = preventDefault;
        listeners = listeners.slice();
        for (var i = 0; i < listeners.length; i++) {
          listeners[i](e, this);
          if (e.propagationStopped)
            break;
        }
        if (defaultHandler && !e.defaultPrevented)
          return defaultHandler(e, this);
      };
      EventEmitter._signal = function(eventName, e) {
        var listeners = (this._eventRegistry || {})[eventName];
        if (!listeners)
          return ;
        listeners = listeners.slice();
        for (var i = 0; i < listeners.length; i++)
          listeners[i](e, this);
      };
      EventEmitter.once = function(eventName, callback) {
        var _self = this;
        callback && this.addEventListener(eventName, function newCallback() {
          _self.removeEventListener(eventName, newCallback);
          callback.apply(null, arguments);
        });
      };
      EventEmitter.setDefaultHandler = function(eventName, callback) {
        var handlers = this._defaultHandlers;
        if (!handlers)
          handlers = this._defaultHandlers = {_disabled_: {}};
        if (handlers[eventName]) {
          var old = handlers[eventName];
          var disabled = handlers._disabled_[eventName];
          if (!disabled)
            handlers._disabled_[eventName] = disabled = [];
          disabled.push(old);
          var i = disabled.indexOf(callback);
          if (i != -1)
            disabled.splice(i, 1);
        }
        handlers[eventName] = callback;
      };
      EventEmitter.removeDefaultHandler = function(eventName, callback) {
        var handlers = this._defaultHandlers;
        if (!handlers)
          return ;
        var disabled = handlers._disabled_[eventName];
        if (handlers[eventName] == callback) {
          var old = handlers[eventName];
          if (disabled)
            this.setDefaultHandler(eventName, disabled.pop());
        } else if (disabled) {
          var i = disabled.indexOf(callback);
          if (i != -1)
            disabled.splice(i, 1);
        }
      };
      EventEmitter.on = EventEmitter.addEventListener = function(eventName, callback, capturing) {
        this._eventRegistry = this._eventRegistry || {};
        var listeners = this._eventRegistry[eventName];
        if (!listeners)
          listeners = this._eventRegistry[eventName] = [];
        if (listeners.indexOf(callback) == -1)
          listeners[capturing ? "unshift" : "push"](callback);
        return callback;
      };
      EventEmitter.off = EventEmitter.removeListener = EventEmitter.removeEventListener = function(eventName, callback) {
        this._eventRegistry = this._eventRegistry || {};
        var listeners = this._eventRegistry[eventName];
        if (!listeners)
          return ;
        var index = listeners.indexOf(callback);
        if (index !== -1)
          listeners.splice(index, 1);
      };
      EventEmitter.removeAllListeners = function(eventName) {
        if (this._eventRegistry)
          this._eventRegistry[eventName] = [];
      };
      exports.EventEmitter = EventEmitter;
    });
    ace.define("ace/config", ["require", "exports", "module", "ace/lib/lang", "ace/lib/oop", "ace/lib/net", "ace/lib/event_emitter"], function(acequire, exports, module) {
      "no use strict";
      var lang = acequire("./lib/lang");
      var oop = acequire("./lib/oop");
      var net = acequire("./lib/net");
      var EventEmitter = acequire("./lib/event_emitter").EventEmitter;
      var global = (function() {
        return this;
      })();
      var options = {
        packaged: false,
        workerPath: null,
        modePath: null,
        themePath: null,
        basePath: "",
        suffix: ".js",
        $moduleUrls: {}
      };
      exports.get = function(key) {
        if (!options.hasOwnProperty(key))
          throw new Error("Unknown config key: " + key);
        return options[key];
      };
      exports.set = function(key, value) {
        if (!options.hasOwnProperty(key))
          throw new Error("Unknown config key: " + key);
        options[key] = value;
      };
      exports.all = function() {
        return lang.copyObject(options);
      };
      oop.implement(exports, EventEmitter);
      exports.moduleUrl = function(name, component) {
        if (options.$moduleUrls[name])
          return options.$moduleUrls[name];
        var parts = name.split("/");
        component = component || parts[parts.length - 2] || "";
        var sep = component == "snippets" ? "/" : "-";
        var base = parts[parts.length - 1];
        if (component == "worker" && sep == "-") {
          var re = new RegExp("^" + component + "[\\-_]|[\\-_]" + component + "$", "g");
          base = base.replace(re, "");
        }
        if ((!base || base == component) && parts.length > 1)
          base = parts[parts.length - 2];
        var path = options[component + "Path"];
        if (path == null) {
          path = options.basePath;
        } else if (sep == "/") {
          component = sep = "";
        }
        if (path && path.slice(-1) != "/")
          path += "/";
        return path + component + sep + base + this.get("suffix");
      };
      exports.setModuleUrl = function(name, subst) {
        return options.$moduleUrls[name] = subst;
      };
      exports.$loading = {};
      exports.loadModule = function(moduleName, onLoad) {
        var module,
            moduleType;
        if (Array.isArray(moduleName)) {
          moduleType = moduleName[0];
          moduleName = moduleName[1];
        }
        try {
          module = acequire(moduleName);
        } catch (e) {}
        if (module && !exports.$loading[moduleName])
          return onLoad && onLoad(module);
        if (!exports.$loading[moduleName])
          exports.$loading[moduleName] = [];
        exports.$loading[moduleName].push(onLoad);
        if (exports.$loading[moduleName].length > 1)
          return ;
        var afterLoad = function() {
          acequire([moduleName], function(module) {
            exports._emit("load.module", {
              name: moduleName,
              module: module
            });
            var listeners = exports.$loading[moduleName];
            exports.$loading[moduleName] = null;
            listeners.forEach(function(onLoad) {
              onLoad && onLoad(module);
            });
          });
        };
        if (!exports.get("packaged"))
          return afterLoad();
        net.loadScript(exports.moduleUrl(moduleName, moduleType), afterLoad);
      };
      init(true);
      function init(packaged) {
        options.packaged = packaged || acequire.packaged || module.packaged || (global.define && define.packaged);
        if (!global.document)
          return "";
        var scriptOptions = {};
        var scriptUrl = "";
        var currentScript = (document.currentScript || document._currentScript);
        var currentDocument = currentScript && currentScript.ownerDocument || document;
        var scripts = currentDocument.getElementsByTagName("script");
        for (var i = 0; i < scripts.length; i++) {
          var script = scripts[i];
          var src = script.src || script.getAttribute("src");
          if (!src)
            continue;
          var attributes = script.attributes;
          for (var j = 0,
              l = attributes.length; j < l; j++) {
            var attr = attributes[j];
            if (attr.name.indexOf("data-ace-") === 0) {
              scriptOptions[deHyphenate(attr.name.replace(/^data-ace-/, ""))] = attr.value;
            }
          }
          var m = src.match(/^(.*)\/ace(\-\w+)?\.js(\?|$)/);
          if (m)
            scriptUrl = m[1];
        }
        if (scriptUrl) {
          scriptOptions.base = scriptOptions.base || scriptUrl;
          scriptOptions.packaged = true;
        }
        scriptOptions.basePath = scriptOptions.base;
        scriptOptions.workerPath = scriptOptions.workerPath || scriptOptions.base;
        scriptOptions.modePath = scriptOptions.modePath || scriptOptions.base;
        scriptOptions.themePath = scriptOptions.themePath || scriptOptions.base;
        delete scriptOptions.base;
        for (var key in scriptOptions)
          if (typeof scriptOptions[key] !== "undefined")
            exports.set(key, scriptOptions[key]);
      }
      ;
      exports.init = init;
      function deHyphenate(str) {
        return str.replace(/-(.)/g, function(m, m1) {
          return m1.toUpperCase();
        });
      }
      var optionsProvider = {
        setOptions: function(optList) {
          Object.keys(optList).forEach(function(key) {
            this.setOption(key, optList[key]);
          }, this);
        },
        getOptions: function(optionNames) {
          var result = {};
          if (!optionNames) {
            optionNames = Object.keys(this.$options);
          } else if (!Array.isArray(optionNames)) {
            result = optionNames;
            optionNames = Object.keys(result);
          }
          optionNames.forEach(function(key) {
            result[key] = this.getOption(key);
          }, this);
          return result;
        },
        setOption: function(name, value) {
          if (this["$" + name] === value)
            return ;
          var opt = this.$options[name];
          if (!opt) {
            if (typeof console != "undefined" && console.warn)
              console.warn('misspelled option "' + name + '"');
            return undefined;
          }
          if (opt.forwardTo)
            return this[opt.forwardTo] && this[opt.forwardTo].setOption(name, value);
          if (!opt.handlesSet)
            this["$" + name] = value;
          if (opt && opt.set)
            opt.set.call(this, value);
        },
        getOption: function(name) {
          var opt = this.$options[name];
          if (!opt) {
            if (typeof console != "undefined" && console.warn)
              console.warn('misspelled option "' + name + '"');
            return undefined;
          }
          if (opt.forwardTo)
            return this[opt.forwardTo] && this[opt.forwardTo].getOption(name);
          return opt && opt.get ? opt.get.call(this) : this["$" + name];
        }
      };
      var defaultOptions = {};
      exports.defineOptions = function(obj, path, options) {
        if (!obj.$options)
          defaultOptions[path] = obj.$options = {};
        Object.keys(options).forEach(function(key) {
          var opt = options[key];
          if (typeof opt == "string")
            opt = {forwardTo: opt};
          opt.name || (opt.name = key);
          obj.$options[opt.name] = opt;
          if ("initialValue" in opt)
            obj["$" + opt.name] = opt.initialValue;
        });
        oop.implement(obj, optionsProvider);
        return this;
      };
      exports.resetOptions = function(obj) {
        Object.keys(obj.$options).forEach(function(key) {
          var opt = obj.$options[key];
          if ("value" in opt)
            obj.setOption(key, opt.value);
        });
      };
      exports.setDefaultValue = function(path, name, value) {
        var opts = defaultOptions[path] || (defaultOptions[path] = {});
        if (opts[name]) {
          if (opts.forwardTo)
            exports.setDefaultValue(opts.forwardTo, name, value);
          else
            opts[name].value = value;
        }
      };
      exports.setDefaultValues = function(path, optionHash) {
        Object.keys(optionHash).forEach(function(key) {
          exports.setDefaultValue(path, key, optionHash[key]);
        });
      };
    });
    ace.define("ace/mouse/mouse_handler", ["require", "exports", "module", "ace/lib/event", "ace/lib/useragent", "ace/mouse/default_handlers", "ace/mouse/default_gutter_handler", "ace/mouse/mouse_event", "ace/mouse/dragdrop_handler", "ace/config"], function(acequire, exports, module) {
      "use strict";
      var event = acequire("../lib/event");
      var useragent = acequire("../lib/useragent");
      var DefaultHandlers = acequire("./default_handlers").DefaultHandlers;
      var DefaultGutterHandler = acequire("./default_gutter_handler").GutterHandler;
      var MouseEvent = acequire("./mouse_event").MouseEvent;
      var DragdropHandler = acequire("./dragdrop_handler").DragdropHandler;
      var config = acequire("../config");
      var MouseHandler = function(editor) {
        var _self = this;
        this.editor = editor;
        new DefaultHandlers(this);
        new DefaultGutterHandler(this);
        new DragdropHandler(this);
        var focusEditor = function(e) {
          if (!editor.isFocused() && editor.textInput)
            editor.textInput.moveToMouse(e);
          editor.focus();
        };
        var mouseTarget = editor.renderer.getMouseEventTarget();
        event.addListener(mouseTarget, "click", this.onMouseEvent.bind(this, "click"));
        event.addListener(mouseTarget, "mousemove", this.onMouseMove.bind(this, "mousemove"));
        event.addMultiMouseDownListener(mouseTarget, [400, 300, 250], this, "onMouseEvent");
        if (editor.renderer.scrollBarV) {
          event.addMultiMouseDownListener(editor.renderer.scrollBarV.inner, [400, 300, 250], this, "onMouseEvent");
          event.addMultiMouseDownListener(editor.renderer.scrollBarH.inner, [400, 300, 250], this, "onMouseEvent");
          if (useragent.isIE) {
            event.addListener(editor.renderer.scrollBarV.element, "mousedown", focusEditor);
            event.addListener(editor.renderer.scrollBarH.element, "mousemove", focusEditor);
          }
        }
        event.addMouseWheelListener(editor.container, this.onMouseWheel.bind(this, "mousewheel"));
        var gutterEl = editor.renderer.$gutter;
        event.addListener(gutterEl, "mousedown", this.onMouseEvent.bind(this, "guttermousedown"));
        event.addListener(gutterEl, "click", this.onMouseEvent.bind(this, "gutterclick"));
        event.addListener(gutterEl, "dblclick", this.onMouseEvent.bind(this, "gutterdblclick"));
        event.addListener(gutterEl, "mousemove", this.onMouseEvent.bind(this, "guttermousemove"));
        event.addListener(mouseTarget, "mousedown", focusEditor);
        event.addListener(gutterEl, "mousedown", function(e) {
          editor.focus();
          return event.preventDefault(e);
        });
        editor.on("mousemove", function(e) {
          if (_self.state || _self.$dragDelay || !_self.$dragEnabled)
            return ;
          var char = editor.renderer.screenToTextCoordinates(e.x, e.y);
          var range = editor.session.selection.getRange();
          var renderer = editor.renderer;
          if (!range.isEmpty() && range.insideStart(char.row, char.column)) {
            renderer.setCursorStyle("default");
          } else {
            renderer.setCursorStyle("");
          }
        });
      };
      (function() {
        this.onMouseEvent = function(name, e) {
          this.editor._emit(name, new MouseEvent(e, this.editor));
        };
        this.onMouseMove = function(name, e) {
          var listeners = this.editor._eventRegistry && this.editor._eventRegistry.mousemove;
          if (!listeners || !listeners.length)
            return ;
          this.editor._emit(name, new MouseEvent(e, this.editor));
        };
        this.onMouseWheel = function(name, e) {
          var mouseEvent = new MouseEvent(e, this.editor);
          mouseEvent.speed = this.$scrollSpeed * 2;
          mouseEvent.wheelX = e.wheelX;
          mouseEvent.wheelY = e.wheelY;
          this.editor._emit(name, mouseEvent);
        };
        this.setState = function(state) {
          this.state = state;
        };
        this.captureMouse = function(ev, mouseMoveHandler) {
          this.x = ev.x;
          this.y = ev.y;
          this.isMousePressed = true;
          var renderer = this.editor.renderer;
          if (renderer.$keepTextAreaAtCursor)
            renderer.$keepTextAreaAtCursor = null;
          var self = this;
          var onMouseMove = function(e) {
            if (!e)
              return ;
            if (useragent.isWebKit && !e.which && self.releaseMouse)
              return self.releaseMouse();
            self.x = e.clientX;
            self.y = e.clientY;
            mouseMoveHandler && mouseMoveHandler(e);
            self.mouseEvent = new MouseEvent(e, self.editor);
            self.$mouseMoved = true;
          };
          var onCaptureEnd = function(e) {
            clearInterval(timerId);
            onCaptureInterval();
            self[self.state + "End"] && self[self.state + "End"](e);
            self.state = "";
            if (renderer.$keepTextAreaAtCursor == null) {
              renderer.$keepTextAreaAtCursor = true;
              renderer.$moveTextAreaToCursor();
            }
            self.isMousePressed = false;
            self.$onCaptureMouseMove = self.releaseMouse = null;
            e && self.onMouseEvent("mouseup", e);
          };
          var onCaptureInterval = function() {
            self[self.state] && self[self.state]();
            self.$mouseMoved = false;
          };
          if (useragent.isOldIE && ev.domEvent.type == "dblclick") {
            return setTimeout(function() {
              onCaptureEnd(ev);
            });
          }
          self.$onCaptureMouseMove = onMouseMove;
          self.releaseMouse = event.capture(this.editor.container, onMouseMove, onCaptureEnd);
          var timerId = setInterval(onCaptureInterval, 20);
        };
        this.releaseMouse = null;
        this.cancelContextMenu = function() {
          var stop = function(e) {
            if (e && e.domEvent && e.domEvent.type != "contextmenu")
              return ;
            this.editor.off("nativecontextmenu", stop);
            if (e && e.domEvent)
              event.stopEvent(e.domEvent);
          }.bind(this);
          setTimeout(stop, 10);
          this.editor.on("nativecontextmenu", stop);
        };
      }).call(MouseHandler.prototype);
      config.defineOptions(MouseHandler.prototype, "mouseHandler", {
        scrollSpeed: {initialValue: 2},
        dragDelay: {initialValue: (useragent.isMac ? 150 : 0)},
        dragEnabled: {initialValue: true},
        focusTimout: {initialValue: 0},
        tooltipFollowsMouse: {initialValue: true}
      });
      exports.MouseHandler = MouseHandler;
    });
    ace.define("ace/mouse/fold_handler", ["require", "exports", "module"], function(acequire, exports, module) {
      "use strict";
      function FoldHandler(editor) {
        editor.on("click", function(e) {
          var position = e.getDocumentPosition();
          var session = editor.session;
          var fold = session.getFoldAt(position.row, position.column, 1);
          if (fold) {
            if (e.getAccelKey())
              session.removeFold(fold);
            else
              session.expandFold(fold);
            e.stop();
          }
        });
        editor.on("gutterclick", function(e) {
          var gutterRegion = editor.renderer.$gutterLayer.getRegion(e);
          if (gutterRegion == "foldWidgets") {
            var row = e.getDocumentPosition().row;
            var session = editor.session;
            if (session.foldWidgets && session.foldWidgets[row])
              editor.session.onFoldWidgetClick(row, e);
            if (!editor.isFocused())
              editor.focus();
            e.stop();
          }
        });
        editor.on("gutterdblclick", function(e) {
          var gutterRegion = editor.renderer.$gutterLayer.getRegion(e);
          if (gutterRegion == "foldWidgets") {
            var row = e.getDocumentPosition().row;
            var session = editor.session;
            var data = session.getParentFoldRangeData(row, true);
            var range = data.range || data.firstRange;
            if (range) {
              row = range.start.row;
              var fold = session.getFoldAt(row, session.getLine(row).length, 1);
              if (fold) {
                session.removeFold(fold);
              } else {
                session.addFold("...", range);
                editor.renderer.scrollCursorIntoView({
                  row: range.start.row,
                  column: 0
                });
              }
            }
            e.stop();
          }
        });
      }
      exports.FoldHandler = FoldHandler;
    });
    ace.define("ace/keyboard/keybinding", ["require", "exports", "module", "ace/lib/keys", "ace/lib/event"], function(acequire, exports, module) {
      "use strict";
      var keyUtil = acequire("../lib/keys");
      var event = acequire("../lib/event");
      var KeyBinding = function(editor) {
        this.$editor = editor;
        this.$data = {editor: editor};
        this.$handlers = [];
        this.setDefaultHandler(editor.commands);
      };
      (function() {
        this.setDefaultHandler = function(kb) {
          this.removeKeyboardHandler(this.$defaultHandler);
          this.$defaultHandler = kb;
          this.addKeyboardHandler(kb, 0);
        };
        this.setKeyboardHandler = function(kb) {
          var h = this.$handlers;
          if (h[h.length - 1] == kb)
            return ;
          while (h[h.length - 1] && h[h.length - 1] != this.$defaultHandler)
            this.removeKeyboardHandler(h[h.length - 1]);
          this.addKeyboardHandler(kb, 1);
        };
        this.addKeyboardHandler = function(kb, pos) {
          if (!kb)
            return ;
          if (typeof kb == "function" && !kb.handleKeyboard)
            kb.handleKeyboard = kb;
          var i = this.$handlers.indexOf(kb);
          if (i != -1)
            this.$handlers.splice(i, 1);
          if (pos == undefined)
            this.$handlers.push(kb);
          else
            this.$handlers.splice(pos, 0, kb);
          if (i == -1 && kb.attach)
            kb.attach(this.$editor);
        };
        this.removeKeyboardHandler = function(kb) {
          var i = this.$handlers.indexOf(kb);
          if (i == -1)
            return false;
          this.$handlers.splice(i, 1);
          kb.detach && kb.detach(this.$editor);
          return true;
        };
        this.getKeyboardHandler = function() {
          return this.$handlers[this.$handlers.length - 1];
        };
        this.getStatusText = function() {
          var data = this.$data;
          var editor = data.editor;
          return this.$handlers.map(function(h) {
            return h.getStatusText && h.getStatusText(editor, data) || "";
          }).filter(Boolean).join(" ");
        };
        this.$callKeyboardHandlers = function(hashId, keyString, keyCode, e) {
          var toExecute;
          var success = false;
          var commands = this.$editor.commands;
          for (var i = this.$handlers.length; i--; ) {
            toExecute = this.$handlers[i].handleKeyboard(this.$data, hashId, keyString, keyCode, e);
            if (!toExecute || !toExecute.command)
              continue;
            if (toExecute.command == "null") {
              success = true;
            } else {
              success = commands.exec(toExecute.command, this.$editor, toExecute.args, e);
            }
            if (success && e && hashId != -1 && toExecute.passEvent != true && toExecute.command.passEvent != true) {
              event.stopEvent(e);
            }
            if (success)
              break;
          }
          return success;
        };
        this.onCommandKey = function(e, hashId, keyCode) {
          var keyString = keyUtil.keyCodeToString(keyCode);
          this.$callKeyboardHandlers(hashId, keyString, keyCode, e);
        };
        this.onTextInput = function(text) {
          var success = this.$callKeyboardHandlers(-1, text);
          if (!success)
            this.$editor.commands.exec("insertstring", this.$editor, text);
        };
      }).call(KeyBinding.prototype);
      exports.KeyBinding = KeyBinding;
    });
    ace.define("ace/range", ["require", "exports", "module"], function(acequire, exports, module) {
      "use strict";
      var comparePoints = function(p1, p2) {
        return p1.row - p2.row || p1.column - p2.column;
      };
      var Range = function(startRow, startColumn, endRow, endColumn) {
        this.start = {
          row: startRow,
          column: startColumn
        };
        this.end = {
          row: endRow,
          column: endColumn
        };
      };
      (function() {
        this.isEqual = function(range) {
          return this.start.row === range.start.row && this.end.row === range.end.row && this.start.column === range.start.column && this.end.column === range.end.column;
        };
        this.toString = function() {
          return ("Range: [" + this.start.row + "/" + this.start.column + "] -> [" + this.end.row + "/" + this.end.column + "]");
        };
        this.contains = function(row, column) {
          return this.compare(row, column) == 0;
        };
        this.compareRange = function(range) {
          var cmp,
              end = range.end,
              start = range.start;
          cmp = this.compare(end.row, end.column);
          if (cmp == 1) {
            cmp = this.compare(start.row, start.column);
            if (cmp == 1) {
              return 2;
            } else if (cmp == 0) {
              return 1;
            } else {
              return 0;
            }
          } else if (cmp == -1) {
            return -2;
          } else {
            cmp = this.compare(start.row, start.column);
            if (cmp == -1) {
              return -1;
            } else if (cmp == 1) {
              return 42;
            } else {
              return 0;
            }
          }
        };
        this.comparePoint = function(p) {
          return this.compare(p.row, p.column);
        };
        this.containsRange = function(range) {
          return this.comparePoint(range.start) == 0 && this.comparePoint(range.end) == 0;
        };
        this.intersects = function(range) {
          var cmp = this.compareRange(range);
          return (cmp == -1 || cmp == 0 || cmp == 1);
        };
        this.isEnd = function(row, column) {
          return this.end.row == row && this.end.column == column;
        };
        this.isStart = function(row, column) {
          return this.start.row == row && this.start.column == column;
        };
        this.setStart = function(row, column) {
          if (typeof row == "object") {
            this.start.column = row.column;
            this.start.row = row.row;
          } else {
            this.start.row = row;
            this.start.column = column;
          }
        };
        this.setEnd = function(row, column) {
          if (typeof row == "object") {
            this.end.column = row.column;
            this.end.row = row.row;
          } else {
            this.end.row = row;
            this.end.column = column;
          }
        };
        this.inside = function(row, column) {
          if (this.compare(row, column) == 0) {
            if (this.isEnd(row, column) || this.isStart(row, column)) {
              return false;
            } else {
              return true;
            }
          }
          return false;
        };
        this.insideStart = function(row, column) {
          if (this.compare(row, column) == 0) {
            if (this.isEnd(row, column)) {
              return false;
            } else {
              return true;
            }
          }
          return false;
        };
        this.insideEnd = function(row, column) {
          if (this.compare(row, column) == 0) {
            if (this.isStart(row, column)) {
              return false;
            } else {
              return true;
            }
          }
          return false;
        };
        this.compare = function(row, column) {
          if (!this.isMultiLine()) {
            if (row === this.start.row) {
              return column < this.start.column ? -1 : (column > this.end.column ? 1 : 0);
            }
            ;
          }
          if (row < this.start.row)
            return -1;
          if (row > this.end.row)
            return 1;
          if (this.start.row === row)
            return column >= this.start.column ? 0 : -1;
          if (this.end.row === row)
            return column <= this.end.column ? 0 : 1;
          return 0;
        };
        this.compareStart = function(row, column) {
          if (this.start.row == row && this.start.column == column) {
            return -1;
          } else {
            return this.compare(row, column);
          }
        };
        this.compareEnd = function(row, column) {
          if (this.end.row == row && this.end.column == column) {
            return 1;
          } else {
            return this.compare(row, column);
          }
        };
        this.compareInside = function(row, column) {
          if (this.end.row == row && this.end.column == column) {
            return 1;
          } else if (this.start.row == row && this.start.column == column) {
            return -1;
          } else {
            return this.compare(row, column);
          }
        };
        this.clipRows = function(firstRow, lastRow) {
          if (this.end.row > lastRow)
            var end = {
              row: lastRow + 1,
              column: 0
            };
          else if (this.end.row < firstRow)
            var end = {
              row: firstRow,
              column: 0
            };
          if (this.start.row > lastRow)
            var start = {
              row: lastRow + 1,
              column: 0
            };
          else if (this.start.row < firstRow)
            var start = {
              row: firstRow,
              column: 0
            };
          return Range.fromPoints(start || this.start, end || this.end);
        };
        this.extend = function(row, column) {
          var cmp = this.compare(row, column);
          if (cmp == 0)
            return this;
          else if (cmp == -1)
            var start = {
              row: row,
              column: column
            };
          else
            var end = {
              row: row,
              column: column
            };
          return Range.fromPoints(start || this.start, end || this.end);
        };
        this.isEmpty = function() {
          return (this.start.row === this.end.row && this.start.column === this.end.column);
        };
        this.isMultiLine = function() {
          return (this.start.row !== this.end.row);
        };
        this.clone = function() {
          return Range.fromPoints(this.start, this.end);
        };
        this.collapseRows = function() {
          if (this.end.column == 0)
            return new Range(this.start.row, 0, Math.max(this.start.row, this.end.row - 1), 0);
          else
            return new Range(this.start.row, 0, this.end.row, 0);
        };
        this.toScreenRange = function(session) {
          var screenPosStart = session.documentToScreenPosition(this.start);
          var screenPosEnd = session.documentToScreenPosition(this.end);
          return new Range(screenPosStart.row, screenPosStart.column, screenPosEnd.row, screenPosEnd.column);
        };
        this.moveBy = function(row, column) {
          this.start.row += row;
          this.start.column += column;
          this.end.row += row;
          this.end.column += column;
        };
      }).call(Range.prototype);
      Range.fromPoints = function(start, end) {
        return new Range(start.row, start.column, end.row, end.column);
      };
      Range.comparePoints = comparePoints;
      Range.comparePoints = function(p1, p2) {
        return p1.row - p2.row || p1.column - p2.column;
      };
      exports.Range = Range;
    });
    ace.define("ace/selection", ["require", "exports", "module", "ace/lib/oop", "ace/lib/lang", "ace/lib/event_emitter", "ace/range"], function(acequire, exports, module) {
      "use strict";
      var oop = acequire("./lib/oop");
      var lang = acequire("./lib/lang");
      var EventEmitter = acequire("./lib/event_emitter").EventEmitter;
      var Range = acequire("./range").Range;
      var Selection = function(session) {
        this.session = session;
        this.doc = session.getDocument();
        this.clearSelection();
        this.lead = this.selectionLead = this.doc.createAnchor(0, 0);
        this.anchor = this.selectionAnchor = this.doc.createAnchor(0, 0);
        var self = this;
        this.lead.on("change", function(e) {
          self._emit("changeCursor");
          if (!self.$isEmpty)
            self._emit("changeSelection");
          if (!self.$keepDesiredColumnOnChange && e.old.column != e.value.column)
            self.$desiredColumn = null;
        });
        this.selectionAnchor.on("change", function() {
          if (!self.$isEmpty)
            self._emit("changeSelection");
        });
      };
      (function() {
        oop.implement(this, EventEmitter);
        this.isEmpty = function() {
          return (this.$isEmpty || (this.anchor.row == this.lead.row && this.anchor.column == this.lead.column));
        };
        this.isMultiLine = function() {
          if (this.isEmpty()) {
            return false;
          }
          return this.getRange().isMultiLine();
        };
        this.getCursor = function() {
          return this.lead.getPosition();
        };
        this.setSelectionAnchor = function(row, column) {
          this.anchor.setPosition(row, column);
          if (this.$isEmpty) {
            this.$isEmpty = false;
            this._emit("changeSelection");
          }
        };
        this.getSelectionAnchor = function() {
          if (this.$isEmpty)
            return this.getSelectionLead();
          else
            return this.anchor.getPosition();
        };
        this.getSelectionLead = function() {
          return this.lead.getPosition();
        };
        this.shiftSelection = function(columns) {
          if (this.$isEmpty) {
            this.moveCursorTo(this.lead.row, this.lead.column + columns);
            return ;
          }
          var anchor = this.getSelectionAnchor();
          var lead = this.getSelectionLead();
          var isBackwards = this.isBackwards();
          if (!isBackwards || anchor.column !== 0)
            this.setSelectionAnchor(anchor.row, anchor.column + columns);
          if (isBackwards || lead.column !== 0) {
            this.$moveSelection(function() {
              this.moveCursorTo(lead.row, lead.column + columns);
            });
          }
        };
        this.isBackwards = function() {
          var anchor = this.anchor;
          var lead = this.lead;
          return (anchor.row > lead.row || (anchor.row == lead.row && anchor.column > lead.column));
        };
        this.getRange = function() {
          var anchor = this.anchor;
          var lead = this.lead;
          if (this.isEmpty())
            return Range.fromPoints(lead, lead);
          if (this.isBackwards()) {
            return Range.fromPoints(lead, anchor);
          } else {
            return Range.fromPoints(anchor, lead);
          }
        };
        this.clearSelection = function() {
          if (!this.$isEmpty) {
            this.$isEmpty = true;
            this._emit("changeSelection");
          }
        };
        this.selectAll = function() {
          var lastRow = this.doc.getLength() - 1;
          this.setSelectionAnchor(0, 0);
          this.moveCursorTo(lastRow, this.doc.getLine(lastRow).length);
        };
        this.setRange = this.setSelectionRange = function(range, reverse) {
          if (reverse) {
            this.setSelectionAnchor(range.end.row, range.end.column);
            this.selectTo(range.start.row, range.start.column);
          } else {
            this.setSelectionAnchor(range.start.row, range.start.column);
            this.selectTo(range.end.row, range.end.column);
          }
          if (this.getRange().isEmpty())
            this.$isEmpty = true;
          this.$desiredColumn = null;
        };
        this.$moveSelection = function(mover) {
          var lead = this.lead;
          if (this.$isEmpty)
            this.setSelectionAnchor(lead.row, lead.column);
          mover.call(this);
        };
        this.selectTo = function(row, column) {
          this.$moveSelection(function() {
            this.moveCursorTo(row, column);
          });
        };
        this.selectToPosition = function(pos) {
          this.$moveSelection(function() {
            this.moveCursorToPosition(pos);
          });
        };
        this.moveTo = function(row, column) {
          this.clearSelection();
          this.moveCursorTo(row, column);
        };
        this.moveToPosition = function(pos) {
          this.clearSelection();
          this.moveCursorToPosition(pos);
        };
        this.selectUp = function() {
          this.$moveSelection(this.moveCursorUp);
        };
        this.selectDown = function() {
          this.$moveSelection(this.moveCursorDown);
        };
        this.selectRight = function() {
          this.$moveSelection(this.moveCursorRight);
        };
        this.selectLeft = function() {
          this.$moveSelection(this.moveCursorLeft);
        };
        this.selectLineStart = function() {
          this.$moveSelection(this.moveCursorLineStart);
        };
        this.selectLineEnd = function() {
          this.$moveSelection(this.moveCursorLineEnd);
        };
        this.selectFileEnd = function() {
          this.$moveSelection(this.moveCursorFileEnd);
        };
        this.selectFileStart = function() {
          this.$moveSelection(this.moveCursorFileStart);
        };
        this.selectWordRight = function() {
          this.$moveSelection(this.moveCursorWordRight);
        };
        this.selectWordLeft = function() {
          this.$moveSelection(this.moveCursorWordLeft);
        };
        this.getWordRange = function(row, column) {
          if (typeof column == "undefined") {
            var cursor = row || this.lead;
            row = cursor.row;
            column = cursor.column;
          }
          return this.session.getWordRange(row, column);
        };
        this.selectWord = function() {
          this.setSelectionRange(this.getWordRange());
        };
        this.selectAWord = function() {
          var cursor = this.getCursor();
          var range = this.session.getAWordRange(cursor.row, cursor.column);
          this.setSelectionRange(range);
        };
        this.getLineRange = function(row, excludeLastChar) {
          var rowStart = typeof row == "number" ? row : this.lead.row;
          var rowEnd;
          var foldLine = this.session.getFoldLine(rowStart);
          if (foldLine) {
            rowStart = foldLine.start.row;
            rowEnd = foldLine.end.row;
          } else {
            rowEnd = rowStart;
          }
          if (excludeLastChar === true)
            return new Range(rowStart, 0, rowEnd, this.session.getLine(rowEnd).length);
          else
            return new Range(rowStart, 0, rowEnd + 1, 0);
        };
        this.selectLine = function() {
          this.setSelectionRange(this.getLineRange());
        };
        this.moveCursorUp = function() {
          this.moveCursorBy(-1, 0);
        };
        this.moveCursorDown = function() {
          this.moveCursorBy(1, 0);
        };
        this.moveCursorLeft = function() {
          var cursor = this.lead.getPosition(),
              fold;
          if (fold = this.session.getFoldAt(cursor.row, cursor.column, -1)) {
            this.moveCursorTo(fold.start.row, fold.start.column);
          } else if (cursor.column === 0) {
            if (cursor.row > 0) {
              this.moveCursorTo(cursor.row - 1, this.doc.getLine(cursor.row - 1).length);
            }
          } else {
            var tabSize = this.session.getTabSize();
            if (this.session.isTabStop(cursor) && this.doc.getLine(cursor.row).slice(cursor.column - tabSize, cursor.column).split(" ").length - 1 == tabSize)
              this.moveCursorBy(0, -tabSize);
            else
              this.moveCursorBy(0, -1);
          }
        };
        this.moveCursorRight = function() {
          var cursor = this.lead.getPosition(),
              fold;
          if (fold = this.session.getFoldAt(cursor.row, cursor.column, 1)) {
            this.moveCursorTo(fold.end.row, fold.end.column);
          } else if (this.lead.column == this.doc.getLine(this.lead.row).length) {
            if (this.lead.row < this.doc.getLength() - 1) {
              this.moveCursorTo(this.lead.row + 1, 0);
            }
          } else {
            var tabSize = this.session.getTabSize();
            var cursor = this.lead;
            if (this.session.isTabStop(cursor) && this.doc.getLine(cursor.row).slice(cursor.column, cursor.column + tabSize).split(" ").length - 1 == tabSize)
              this.moveCursorBy(0, tabSize);
            else
              this.moveCursorBy(0, 1);
          }
        };
        this.moveCursorLineStart = function() {
          var row = this.lead.row;
          var column = this.lead.column;
          var screenRow = this.session.documentToScreenRow(row, column);
          var firstColumnPosition = this.session.screenToDocumentPosition(screenRow, 0);
          var beforeCursor = this.session.getDisplayLine(row, null, firstColumnPosition.row, firstColumnPosition.column);
          var leadingSpace = beforeCursor.match(/^\s*/);
          if (leadingSpace[0].length != column && !this.session.$useEmacsStyleLineStart)
            firstColumnPosition.column += leadingSpace[0].length;
          this.moveCursorToPosition(firstColumnPosition);
        };
        this.moveCursorLineEnd = function() {
          var lead = this.lead;
          var lineEnd = this.session.getDocumentLastRowColumnPosition(lead.row, lead.column);
          if (this.lead.column == lineEnd.column) {
            var line = this.session.getLine(lineEnd.row);
            if (lineEnd.column == line.length) {
              var textEnd = line.search(/\s+$/);
              if (textEnd > 0)
                lineEnd.column = textEnd;
            }
          }
          this.moveCursorTo(lineEnd.row, lineEnd.column);
        };
        this.moveCursorFileEnd = function() {
          var row = this.doc.getLength() - 1;
          var column = this.doc.getLine(row).length;
          this.moveCursorTo(row, column);
        };
        this.moveCursorFileStart = function() {
          this.moveCursorTo(0, 0);
        };
        this.moveCursorLongWordRight = function() {
          var row = this.lead.row;
          var column = this.lead.column;
          var line = this.doc.getLine(row);
          var rightOfCursor = line.substring(column);
          var match;
          this.session.nonTokenRe.lastIndex = 0;
          this.session.tokenRe.lastIndex = 0;
          var fold = this.session.getFoldAt(row, column, 1);
          if (fold) {
            this.moveCursorTo(fold.end.row, fold.end.column);
            return ;
          }
          if (match = this.session.nonTokenRe.exec(rightOfCursor)) {
            column += this.session.nonTokenRe.lastIndex;
            this.session.nonTokenRe.lastIndex = 0;
            rightOfCursor = line.substring(column);
          }
          if (column >= line.length) {
            this.moveCursorTo(row, line.length);
            this.moveCursorRight();
            if (row < this.doc.getLength() - 1)
              this.moveCursorWordRight();
            return ;
          }
          if (match = this.session.tokenRe.exec(rightOfCursor)) {
            column += this.session.tokenRe.lastIndex;
            this.session.tokenRe.lastIndex = 0;
          }
          this.moveCursorTo(row, column);
        };
        this.moveCursorLongWordLeft = function() {
          var row = this.lead.row;
          var column = this.lead.column;
          var fold;
          if (fold = this.session.getFoldAt(row, column, -1)) {
            this.moveCursorTo(fold.start.row, fold.start.column);
            return ;
          }
          var str = this.session.getFoldStringAt(row, column, -1);
          if (str == null) {
            str = this.doc.getLine(row).substring(0, column);
          }
          var leftOfCursor = lang.stringReverse(str);
          var match;
          this.session.nonTokenRe.lastIndex = 0;
          this.session.tokenRe.lastIndex = 0;
          if (match = this.session.nonTokenRe.exec(leftOfCursor)) {
            column -= this.session.nonTokenRe.lastIndex;
            leftOfCursor = leftOfCursor.slice(this.session.nonTokenRe.lastIndex);
            this.session.nonTokenRe.lastIndex = 0;
          }
          if (column <= 0) {
            this.moveCursorTo(row, 0);
            this.moveCursorLeft();
            if (row > 0)
              this.moveCursorWordLeft();
            return ;
          }
          if (match = this.session.tokenRe.exec(leftOfCursor)) {
            column -= this.session.tokenRe.lastIndex;
            this.session.tokenRe.lastIndex = 0;
          }
          this.moveCursorTo(row, column);
        };
        this.$shortWordEndIndex = function(rightOfCursor) {
          var match,
              index = 0,
              ch;
          var whitespaceRe = /\s/;
          var tokenRe = this.session.tokenRe;
          tokenRe.lastIndex = 0;
          if (match = this.session.tokenRe.exec(rightOfCursor)) {
            index = this.session.tokenRe.lastIndex;
          } else {
            while ((ch = rightOfCursor[index]) && whitespaceRe.test(ch))
              index++;
            if (index < 1) {
              tokenRe.lastIndex = 0;
              while ((ch = rightOfCursor[index]) && !tokenRe.test(ch)) {
                tokenRe.lastIndex = 0;
                index++;
                if (whitespaceRe.test(ch)) {
                  if (index > 2) {
                    index--;
                    break;
                  } else {
                    while ((ch = rightOfCursor[index]) && whitespaceRe.test(ch))
                      index++;
                    if (index > 2)
                      break;
                  }
                }
              }
            }
          }
          tokenRe.lastIndex = 0;
          return index;
        };
        this.moveCursorShortWordRight = function() {
          var row = this.lead.row;
          var column = this.lead.column;
          var line = this.doc.getLine(row);
          var rightOfCursor = line.substring(column);
          var fold = this.session.getFoldAt(row, column, 1);
          if (fold)
            return this.moveCursorTo(fold.end.row, fold.end.column);
          if (column == line.length) {
            var l = this.doc.getLength();
            do {
              row++;
              rightOfCursor = this.doc.getLine(row);
            } while (row < l && /^\s*$/.test(rightOfCursor));
            if (!/^\s+/.test(rightOfCursor))
              rightOfCursor = "";
            column = 0;
          }
          var index = this.$shortWordEndIndex(rightOfCursor);
          this.moveCursorTo(row, column + index);
        };
        this.moveCursorShortWordLeft = function() {
          var row = this.lead.row;
          var column = this.lead.column;
          var fold;
          if (fold = this.session.getFoldAt(row, column, -1))
            return this.moveCursorTo(fold.start.row, fold.start.column);
          var line = this.session.getLine(row).substring(0, column);
          if (column === 0) {
            do {
              row--;
              line = this.doc.getLine(row);
            } while (row > 0 && /^\s*$/.test(line));
            column = line.length;
            if (!/\s+$/.test(line))
              line = "";
          }
          var leftOfCursor = lang.stringReverse(line);
          var index = this.$shortWordEndIndex(leftOfCursor);
          return this.moveCursorTo(row, column - index);
        };
        this.moveCursorWordRight = function() {
          if (this.session.$selectLongWords)
            this.moveCursorLongWordRight();
          else
            this.moveCursorShortWordRight();
        };
        this.moveCursorWordLeft = function() {
          if (this.session.$selectLongWords)
            this.moveCursorLongWordLeft();
          else
            this.moveCursorShortWordLeft();
        };
        this.moveCursorBy = function(rows, chars) {
          var screenPos = this.session.documentToScreenPosition(this.lead.row, this.lead.column);
          if (chars === 0) {
            if (this.$desiredColumn)
              screenPos.column = this.$desiredColumn;
            else
              this.$desiredColumn = screenPos.column;
          }
          var docPos = this.session.screenToDocumentPosition(screenPos.row + rows, screenPos.column);
          if (rows !== 0 && chars === 0 && docPos.row === this.lead.row && docPos.column === this.lead.column) {
            if (this.session.lineWidgets && this.session.lineWidgets[docPos.row])
              docPos.row++;
          }
          this.moveCursorTo(docPos.row, docPos.column + chars, chars === 0);
        };
        this.moveCursorToPosition = function(position) {
          this.moveCursorTo(position.row, position.column);
        };
        this.moveCursorTo = function(row, column, keepDesiredColumn) {
          var fold = this.session.getFoldAt(row, column, 1);
          if (fold) {
            row = fold.start.row;
            column = fold.start.column;
          }
          this.$keepDesiredColumnOnChange = true;
          this.lead.setPosition(row, column);
          this.$keepDesiredColumnOnChange = false;
          if (!keepDesiredColumn)
            this.$desiredColumn = null;
        };
        this.moveCursorToScreen = function(row, column, keepDesiredColumn) {
          var pos = this.session.screenToDocumentPosition(row, column);
          this.moveCursorTo(pos.row, pos.column, keepDesiredColumn);
        };
        this.detach = function() {
          this.lead.detach();
          this.anchor.detach();
          this.session = this.doc = null;
        };
        this.fromOrientedRange = function(range) {
          this.setSelectionRange(range, range.cursor == range.start);
          this.$desiredColumn = range.desiredColumn || this.$desiredColumn;
        };
        this.toOrientedRange = function(range) {
          var r = this.getRange();
          if (range) {
            range.start.column = r.start.column;
            range.start.row = r.start.row;
            range.end.column = r.end.column;
            range.end.row = r.end.row;
          } else {
            range = r;
          }
          range.cursor = this.isBackwards() ? range.start : range.end;
          range.desiredColumn = this.$desiredColumn;
          return range;
        };
        this.getRangeOfMovements = function(func) {
          var start = this.getCursor();
          try {
            func.call(null, this);
            var end = this.getCursor();
            return Range.fromPoints(start, end);
          } catch (e) {
            return Range.fromPoints(start, start);
          } finally {
            this.moveCursorToPosition(start);
          }
        };
        this.toJSON = function() {
          if (this.rangeCount) {
            var data = this.ranges.map(function(r) {
              var r1 = r.clone();
              r1.isBackwards = r.cursor == r.start;
              return r1;
            });
          } else {
            var data = this.getRange();
            data.isBackwards = this.isBackwards();
          }
          return data;
        };
        this.fromJSON = function(data) {
          if (data.start == undefined) {
            if (this.rangeList) {
              this.toSingleRange(data[0]);
              for (var i = data.length; i--; ) {
                var r = Range.fromPoints(data[i].start, data[i].end);
                if (data.isBackwards)
                  r.cursor = r.start;
                this.addRange(r, true);
              }
              return ;
            } else
              data = data[0];
          }
          if (this.rangeList)
            this.toSingleRange(data);
          this.setSelectionRange(data, data.isBackwards);
        };
        this.isEqual = function(data) {
          if ((data.length || this.rangeCount) && data.length != this.rangeCount)
            return false;
          if (!data.length || !this.ranges)
            return this.getRange().isEqual(data);
          for (var i = this.ranges.length; i--; ) {
            if (!this.ranges[i].isEqual(data[i]))
              return false;
          }
          return true;
        };
      }).call(Selection.prototype);
      exports.Selection = Selection;
    });
    ace.define("ace/tokenizer", ["require", "exports", "module"], function(acequire, exports, module) {
      "use strict";
      var MAX_TOKEN_COUNT = 2000;
      var Tokenizer = function(rules) {
        this.states = rules;
        this.regExps = {};
        this.matchMappings = {};
        for (var key in this.states) {
          var state = this.states[key];
          var ruleRegExps = [];
          var matchTotal = 0;
          var mapping = this.matchMappings[key] = {defaultToken: "text"};
          var flag = "g";
          var splitterRurles = [];
          for (var i = 0; i < state.length; i++) {
            var rule = state[i];
            if (rule.defaultToken)
              mapping.defaultToken = rule.defaultToken;
            if (rule.caseInsensitive)
              flag = "gi";
            if (rule.regex == null)
              continue;
            if (rule.regex instanceof RegExp)
              rule.regex = rule.regex.toString().slice(1, -1);
            var adjustedregex = rule.regex;
            var matchcount = new RegExp("(?:(" + adjustedregex + ")|(.))").exec("a").length - 2;
            if (Array.isArray(rule.token)) {
              if (rule.token.length == 1 || matchcount == 1) {
                rule.token = rule.token[0];
              } else if (matchcount - 1 != rule.token.length) {
                this.reportError("number of classes and regexp groups doesn't match", {
                  rule: rule,
                  groupCount: matchcount - 1
                });
                rule.token = rule.token[0];
              } else {
                rule.tokenArray = rule.token;
                rule.token = null;
                rule.onMatch = this.$arrayTokens;
              }
            } else if (typeof rule.token == "function" && !rule.onMatch) {
              if (matchcount > 1)
                rule.onMatch = this.$applyToken;
              else
                rule.onMatch = rule.token;
            }
            if (matchcount > 1) {
              if (/\\\d/.test(rule.regex)) {
                adjustedregex = rule.regex.replace(/\\([0-9]+)/g, function(match, digit) {
                  return "\\" + (parseInt(digit, 10) + matchTotal + 1);
                });
              } else {
                matchcount = 1;
                adjustedregex = this.removeCapturingGroups(rule.regex);
              }
              if (!rule.splitRegex && typeof rule.token != "string")
                splitterRurles.push(rule);
            }
            mapping[matchTotal] = i;
            matchTotal += matchcount;
            ruleRegExps.push(adjustedregex);
            if (!rule.onMatch)
              rule.onMatch = null;
          }
          if (!ruleRegExps.length) {
            mapping[0] = 0;
            ruleRegExps.push("$");
          }
          splitterRurles.forEach(function(rule) {
            rule.splitRegex = this.createSplitterRegexp(rule.regex, flag);
          }, this);
          this.regExps[key] = new RegExp("(" + ruleRegExps.join(")|(") + ")|($)", flag);
        }
      };
      (function() {
        this.$setMaxTokenCount = function(m) {
          MAX_TOKEN_COUNT = m | 0;
        };
        this.$applyToken = function(str) {
          var values = this.splitRegex.exec(str).slice(1);
          var types = this.token.apply(this, values);
          if (typeof types === "string")
            return [{
              type: types,
              value: str
            }];
          var tokens = [];
          for (var i = 0,
              l = types.length; i < l; i++) {
            if (values[i])
              tokens[tokens.length] = {
                type: types[i],
                value: values[i]
              };
          }
          return tokens;
        }, this.$arrayTokens = function(str) {
          if (!str)
            return [];
          var values = this.splitRegex.exec(str);
          if (!values)
            return "text";
          var tokens = [];
          var types = this.tokenArray;
          for (var i = 0,
              l = types.length; i < l; i++) {
            if (values[i + 1])
              tokens[tokens.length] = {
                type: types[i],
                value: values[i + 1]
              };
          }
          return tokens;
        };
        this.removeCapturingGroups = function(src) {
          var r = src.replace(/\[(?:\\.|[^\]])*?\]|\\.|\(\?[:=!]|(\()/g, function(x, y) {
            return y ? "(?:" : x;
          });
          return r;
        };
        this.createSplitterRegexp = function(src, flag) {
          if (src.indexOf("(?=") != -1) {
            var stack = 0;
            var inChClass = false;
            var lastCapture = {};
            src.replace(/(\\.)|(\((?:\?[=!])?)|(\))|([\[\]])/g, function(m, esc, parenOpen, parenClose, square, index) {
              if (inChClass) {
                inChClass = square != "]";
              } else if (square) {
                inChClass = true;
              } else if (parenClose) {
                if (stack == lastCapture.stack) {
                  lastCapture.end = index + 1;
                  lastCapture.stack = -1;
                }
                stack--;
              } else if (parenOpen) {
                stack++;
                if (parenOpen.length != 1) {
                  lastCapture.stack = stack;
                  lastCapture.start = index;
                }
              }
              return m;
            });
            if (lastCapture.end != null && /^\)*$/.test(src.substr(lastCapture.end)))
              src = src.substring(0, lastCapture.start) + src.substr(lastCapture.end);
          }
          return new RegExp(src, (flag || "").replace("g", ""));
        };
        this.getLineTokens = function(line, startState) {
          if (startState && typeof startState != "string") {
            var stack = startState.slice(0);
            startState = stack[0];
            if (startState === "#tmp") {
              stack.shift();
              startState = stack.shift();
            }
          } else
            var stack = [];
          var currentState = startState || "start";
          var state = this.states[currentState];
          if (!state) {
            currentState = "start";
            state = this.states[currentState];
          }
          var mapping = this.matchMappings[currentState];
          var re = this.regExps[currentState];
          re.lastIndex = 0;
          var match,
              tokens = [];
          var lastIndex = 0;
          var matchAttempts = 0;
          var token = {
            type: null,
            value: ""
          };
          while (match = re.exec(line)) {
            var type = mapping.defaultToken;
            var rule = null;
            var value = match[0];
            var index = re.lastIndex;
            if (index - value.length > lastIndex) {
              var skipped = line.substring(lastIndex, index - value.length);
              if (token.type == type) {
                token.value += skipped;
              } else {
                if (token.type)
                  tokens.push(token);
                token = {
                  type: type,
                  value: skipped
                };
              }
            }
            for (var i = 0; i < match.length - 2; i++) {
              if (match[i + 1] === undefined)
                continue;
              rule = state[mapping[i]];
              if (rule.onMatch)
                type = rule.onMatch(value, currentState, stack);
              else
                type = rule.token;
              if (rule.next) {
                if (typeof rule.next == "string") {
                  currentState = rule.next;
                } else {
                  currentState = rule.next(currentState, stack);
                }
                state = this.states[currentState];
                if (!state) {
                  this.reportError("state doesn't exist", currentState);
                  currentState = "start";
                  state = this.states[currentState];
                }
                mapping = this.matchMappings[currentState];
                lastIndex = index;
                re = this.regExps[currentState];
                re.lastIndex = index;
              }
              break;
            }
            if (value) {
              if (typeof type === "string") {
                if ((!rule || rule.merge !== false) && token.type === type) {
                  token.value += value;
                } else {
                  if (token.type)
                    tokens.push(token);
                  token = {
                    type: type,
                    value: value
                  };
                }
              } else if (type) {
                if (token.type)
                  tokens.push(token);
                token = {
                  type: null,
                  value: ""
                };
                for (var i = 0; i < type.length; i++)
                  tokens.push(type[i]);
              }
            }
            if (lastIndex == line.length)
              break;
            lastIndex = index;
            if (matchAttempts++ > MAX_TOKEN_COUNT) {
              if (matchAttempts > 2 * line.length) {
                this.reportError("infinite loop with in ace tokenizer", {
                  startState: startState,
                  line: line
                });
              }
              while (lastIndex < line.length) {
                if (token.type)
                  tokens.push(token);
                token = {
                  value: line.substring(lastIndex, lastIndex += 2000),
                  type: "overflow"
                };
              }
              currentState = "start";
              stack = [];
              break;
            }
          }
          if (token.type)
            tokens.push(token);
          if (stack.length > 1) {
            if (stack[0] !== currentState)
              stack.unshift("#tmp", currentState);
          }
          return {
            tokens: tokens,
            state: stack.length ? stack : currentState
          };
        };
        this.reportError = function(msg, data) {
          var e = new Error(msg);
          e.data = data;
          if (typeof console == "object" && console.error)
            console.error(e);
          setTimeout(function() {
            throw e;
          });
        };
      }).call(Tokenizer.prototype);
      exports.Tokenizer = Tokenizer;
    });
    ace.define("ace/mode/text_highlight_rules", ["require", "exports", "module", "ace/lib/lang"], function(acequire, exports, module) {
      "use strict";
      var lang = acequire("../lib/lang");
      var TextHighlightRules = function() {
        this.$rules = {"start": [{
            token: "empty_line",
            regex: '^$'
          }, {defaultToken: "text"}]};
      };
      (function() {
        this.addRules = function(rules, prefix) {
          if (!prefix) {
            for (var key in rules)
              this.$rules[key] = rules[key];
            return ;
          }
          for (var key in rules) {
            var state = rules[key];
            for (var i = 0; i < state.length; i++) {
              var rule = state[i];
              if (rule.next || rule.onMatch) {
                if (typeof rule.next != "string") {
                  if (rule.nextState && rule.nextState.indexOf(prefix) !== 0)
                    rule.nextState = prefix + rule.nextState;
                } else {
                  if (rule.next.indexOf(prefix) !== 0)
                    rule.next = prefix + rule.next;
                }
              }
            }
            this.$rules[prefix + key] = state;
          }
        };
        this.getRules = function() {
          return this.$rules;
        };
        this.embedRules = function(HighlightRules, prefix, escapeRules, states, append) {
          var embedRules = typeof HighlightRules == "function" ? new HighlightRules().getRules() : HighlightRules;
          if (states) {
            for (var i = 0; i < states.length; i++)
              states[i] = prefix + states[i];
          } else {
            states = [];
            for (var key in embedRules)
              states.push(prefix + key);
          }
          this.addRules(embedRules, prefix);
          if (escapeRules) {
            var addRules = Array.prototype[append ? "push" : "unshift"];
            for (var i = 0; i < states.length; i++)
              addRules.apply(this.$rules[states[i]], lang.deepCopy(escapeRules));
          }
          if (!this.$embeds)
            this.$embeds = [];
          this.$embeds.push(prefix);
        };
        this.getEmbeds = function() {
          return this.$embeds;
        };
        var pushState = function(currentState, stack) {
          if (currentState != "start" || stack.length)
            stack.unshift(this.nextState, currentState);
          return this.nextState;
        };
        var popState = function(currentState, stack) {
          stack.shift();
          return stack.shift() || "start";
        };
        this.normalizeRules = function() {
          var id = 0;
          var rules = this.$rules;
          function processState(key) {
            var state = rules[key];
            state.processed = true;
            for (var i = 0; i < state.length; i++) {
              var rule = state[i];
              if (!rule.regex && rule.start) {
                rule.regex = rule.start;
                if (!rule.next)
                  rule.next = [];
                rule.next.push({defaultToken: rule.token}, {
                  token: rule.token + ".end",
                  regex: rule.end || rule.start,
                  next: "pop"
                });
                rule.token = rule.token + ".start";
                rule.push = true;
              }
              var next = rule.next || rule.push;
              if (next && Array.isArray(next)) {
                var stateName = rule.stateName;
                if (!stateName) {
                  stateName = rule.token;
                  if (typeof stateName != "string")
                    stateName = stateName[0] || "";
                  if (rules[stateName])
                    stateName += id++;
                }
                rules[stateName] = next;
                rule.next = stateName;
                processState(stateName);
              } else if (next == "pop") {
                rule.next = popState;
              }
              if (rule.push) {
                rule.nextState = rule.next || rule.push;
                rule.next = pushState;
                delete rule.push;
              }
              if (rule.rules) {
                for (var r in rule.rules) {
                  if (rules[r]) {
                    if (rules[r].push)
                      rules[r].push.apply(rules[r], rule.rules[r]);
                  } else {
                    rules[r] = rule.rules[r];
                  }
                }
              }
              if (rule.include || typeof rule == "string") {
                var includeName = rule.include || rule;
                var toInsert = rules[includeName];
              } else if (Array.isArray(rule))
                toInsert = rule;
              if (toInsert) {
                var args = [i, 1].concat(toInsert);
                if (rule.noEscape)
                  args = args.filter(function(x) {
                    return !x.next;
                  });
                state.splice.apply(state, args);
                i--;
                toInsert = null;
              }
              if (rule.keywordMap) {
                rule.token = this.createKeywordMapper(rule.keywordMap, rule.defaultToken || "text", rule.caseInsensitive);
                delete rule.defaultToken;
              }
            }
          }
          Object.keys(rules).forEach(processState, this);
        };
        this.createKeywordMapper = function(map, defaultToken, ignoreCase, splitChar) {
          var keywords = Object.create(null);
          Object.keys(map).forEach(function(className) {
            var a = map[className];
            if (ignoreCase)
              a = a.toLowerCase();
            var list = a.split(splitChar || "|");
            for (var i = list.length; i--; )
              keywords[list[i]] = className;
          });
          if (Object.getPrototypeOf(keywords)) {
            keywords.__proto__ = null;
          }
          this.$keywordList = Object.keys(keywords);
          map = null;
          return ignoreCase ? function(value) {
            return keywords[value.toLowerCase()] || defaultToken;
          } : function(value) {
            return keywords[value] || defaultToken;
          };
        };
        this.getKeywords = function() {
          return this.$keywords;
        };
      }).call(TextHighlightRules.prototype);
      exports.TextHighlightRules = TextHighlightRules;
    });
    ace.define("ace/mode/behaviour", ["require", "exports", "module"], function(acequire, exports, module) {
      "use strict";
      var Behaviour = function() {
        this.$behaviours = {};
      };
      (function() {
        this.add = function(name, action, callback) {
          switch (undefined) {
            case this.$behaviours:
              this.$behaviours = {};
            case this.$behaviours[name]:
              this.$behaviours[name] = {};
          }
          this.$behaviours[name][action] = callback;
        };
        this.addBehaviours = function(behaviours) {
          for (var key in behaviours) {
            for (var action in behaviours[key]) {
              this.add(key, action, behaviours[key][action]);
            }
          }
        };
        this.remove = function(name) {
          if (this.$behaviours && this.$behaviours[name]) {
            delete this.$behaviours[name];
          }
        };
        this.inherit = function(mode, filter) {
          if (typeof mode === "function") {
            var behaviours = new mode().getBehaviours(filter);
          } else {
            var behaviours = mode.getBehaviours(filter);
          }
          this.addBehaviours(behaviours);
        };
        this.getBehaviours = function(filter) {
          if (!filter) {
            return this.$behaviours;
          } else {
            var ret = {};
            for (var i = 0; i < filter.length; i++) {
              if (this.$behaviours[filter[i]]) {
                ret[filter[i]] = this.$behaviours[filter[i]];
              }
            }
            return ret;
          }
        };
      }).call(Behaviour.prototype);
      exports.Behaviour = Behaviour;
    });
    ace.define("ace/unicode", ["require", "exports", "module"], function(acequire, exports, module) {
      "use strict";
      exports.packages = {};
      addUnicodePackage({
        L: "0041-005A0061-007A00AA00B500BA00C0-00D600D8-00F600F8-02C102C6-02D102E0-02E402EC02EE0370-037403760377037A-037D03860388-038A038C038E-03A103A3-03F503F7-0481048A-05250531-055605590561-058705D0-05EA05F0-05F20621-064A066E066F0671-06D306D506E506E606EE06EF06FA-06FC06FF07100712-072F074D-07A507B107CA-07EA07F407F507FA0800-0815081A082408280904-0939093D09500958-0961097109720979-097F0985-098C098F09900993-09A809AA-09B009B209B6-09B909BD09CE09DC09DD09DF-09E109F009F10A05-0A0A0A0F0A100A13-0A280A2A-0A300A320A330A350A360A380A390A59-0A5C0A5E0A72-0A740A85-0A8D0A8F-0A910A93-0AA80AAA-0AB00AB20AB30AB5-0AB90ABD0AD00AE00AE10B05-0B0C0B0F0B100B13-0B280B2A-0B300B320B330B35-0B390B3D0B5C0B5D0B5F-0B610B710B830B85-0B8A0B8E-0B900B92-0B950B990B9A0B9C0B9E0B9F0BA30BA40BA8-0BAA0BAE-0BB90BD00C05-0C0C0C0E-0C100C12-0C280C2A-0C330C35-0C390C3D0C580C590C600C610C85-0C8C0C8E-0C900C92-0CA80CAA-0CB30CB5-0CB90CBD0CDE0CE00CE10D05-0D0C0D0E-0D100D12-0D280D2A-0D390D3D0D600D610D7A-0D7F0D85-0D960D9A-0DB10DB3-0DBB0DBD0DC0-0DC60E01-0E300E320E330E40-0E460E810E820E840E870E880E8A0E8D0E94-0E970E99-0E9F0EA1-0EA30EA50EA70EAA0EAB0EAD-0EB00EB20EB30EBD0EC0-0EC40EC60EDC0EDD0F000F40-0F470F49-0F6C0F88-0F8B1000-102A103F1050-1055105A-105D106110651066106E-10701075-1081108E10A0-10C510D0-10FA10FC1100-1248124A-124D1250-12561258125A-125D1260-1288128A-128D1290-12B012B2-12B512B8-12BE12C012C2-12C512C8-12D612D8-13101312-13151318-135A1380-138F13A0-13F41401-166C166F-167F1681-169A16A0-16EA1700-170C170E-17111720-17311740-17511760-176C176E-17701780-17B317D717DC1820-18771880-18A818AA18B0-18F51900-191C1950-196D1970-19741980-19AB19C1-19C71A00-1A161A20-1A541AA71B05-1B331B45-1B4B1B83-1BA01BAE1BAF1C00-1C231C4D-1C4F1C5A-1C7D1CE9-1CEC1CEE-1CF11D00-1DBF1E00-1F151F18-1F1D1F20-1F451F48-1F4D1F50-1F571F591F5B1F5D1F5F-1F7D1F80-1FB41FB6-1FBC1FBE1FC2-1FC41FC6-1FCC1FD0-1FD31FD6-1FDB1FE0-1FEC1FF2-1FF41FF6-1FFC2071207F2090-209421022107210A-211321152119-211D212421262128212A-212D212F-2139213C-213F2145-2149214E218321842C00-2C2E2C30-2C5E2C60-2CE42CEB-2CEE2D00-2D252D30-2D652D6F2D80-2D962DA0-2DA62DA8-2DAE2DB0-2DB62DB8-2DBE2DC0-2DC62DC8-2DCE2DD0-2DD62DD8-2DDE2E2F300530063031-3035303B303C3041-3096309D-309F30A1-30FA30FC-30FF3105-312D3131-318E31A0-31B731F0-31FF3400-4DB54E00-9FCBA000-A48CA4D0-A4FDA500-A60CA610-A61FA62AA62BA640-A65FA662-A66EA67F-A697A6A0-A6E5A717-A71FA722-A788A78BA78CA7FB-A801A803-A805A807-A80AA80C-A822A840-A873A882-A8B3A8F2-A8F7A8FBA90A-A925A930-A946A960-A97CA984-A9B2A9CFAA00-AA28AA40-AA42AA44-AA4BAA60-AA76AA7AAA80-AAAFAAB1AAB5AAB6AAB9-AABDAAC0AAC2AADB-AADDABC0-ABE2AC00-D7A3D7B0-D7C6D7CB-D7FBF900-FA2DFA30-FA6DFA70-FAD9FB00-FB06FB13-FB17FB1DFB1F-FB28FB2A-FB36FB38-FB3CFB3EFB40FB41FB43FB44FB46-FBB1FBD3-FD3DFD50-FD8FFD92-FDC7FDF0-FDFBFE70-FE74FE76-FEFCFF21-FF3AFF41-FF5AFF66-FFBEFFC2-FFC7FFCA-FFCFFFD2-FFD7FFDA-FFDC",
        Ll: "0061-007A00AA00B500BA00DF-00F600F8-00FF01010103010501070109010B010D010F01110113011501170119011B011D011F01210123012501270129012B012D012F01310133013501370138013A013C013E014001420144014601480149014B014D014F01510153015501570159015B015D015F01610163016501670169016B016D016F0171017301750177017A017C017E-0180018301850188018C018D019201950199-019B019E01A101A301A501A801AA01AB01AD01B001B401B601B901BA01BD-01BF01C601C901CC01CE01D001D201D401D601D801DA01DC01DD01DF01E101E301E501E701E901EB01ED01EF01F001F301F501F901FB01FD01FF02010203020502070209020B020D020F02110213021502170219021B021D021F02210223022502270229022B022D022F02310233-0239023C023F0240024202470249024B024D024F-02930295-02AF037103730377037B-037D039003AC-03CE03D003D103D5-03D703D903DB03DD03DF03E103E303E503E703E903EB03ED03EF-03F303F503F803FB03FC0430-045F04610463046504670469046B046D046F04710473047504770479047B047D047F0481048B048D048F04910493049504970499049B049D049F04A104A304A504A704A904AB04AD04AF04B104B304B504B704B904BB04BD04BF04C204C404C604C804CA04CC04CE04CF04D104D304D504D704D904DB04DD04DF04E104E304E504E704E904EB04ED04EF04F104F304F504F704F904FB04FD04FF05010503050505070509050B050D050F05110513051505170519051B051D051F0521052305250561-05871D00-1D2B1D62-1D771D79-1D9A1E011E031E051E071E091E0B1E0D1E0F1E111E131E151E171E191E1B1E1D1E1F1E211E231E251E271E291E2B1E2D1E2F1E311E331E351E371E391E3B1E3D1E3F1E411E431E451E471E491E4B1E4D1E4F1E511E531E551E571E591E5B1E5D1E5F1E611E631E651E671E691E6B1E6D1E6F1E711E731E751E771E791E7B1E7D1E7F1E811E831E851E871E891E8B1E8D1E8F1E911E931E95-1E9D1E9F1EA11EA31EA51EA71EA91EAB1EAD1EAF1EB11EB31EB51EB71EB91EBB1EBD1EBF1EC11EC31EC51EC71EC91ECB1ECD1ECF1ED11ED31ED51ED71ED91EDB1EDD1EDF1EE11EE31EE51EE71EE91EEB1EED1EEF1EF11EF31EF51EF71EF91EFB1EFD1EFF-1F071F10-1F151F20-1F271F30-1F371F40-1F451F50-1F571F60-1F671F70-1F7D1F80-1F871F90-1F971FA0-1FA71FB0-1FB41FB61FB71FBE1FC2-1FC41FC61FC71FD0-1FD31FD61FD71FE0-1FE71FF2-1FF41FF61FF7210A210E210F2113212F21342139213C213D2146-2149214E21842C30-2C5E2C612C652C662C682C6A2C6C2C712C732C742C76-2C7C2C812C832C852C872C892C8B2C8D2C8F2C912C932C952C972C992C9B2C9D2C9F2CA12CA32CA52CA72CA92CAB2CAD2CAF2CB12CB32CB52CB72CB92CBB2CBD2CBF2CC12CC32CC52CC72CC92CCB2CCD2CCF2CD12CD32CD52CD72CD92CDB2CDD2CDF2CE12CE32CE42CEC2CEE2D00-2D25A641A643A645A647A649A64BA64DA64FA651A653A655A657A659A65BA65DA65FA663A665A667A669A66BA66DA681A683A685A687A689A68BA68DA68FA691A693A695A697A723A725A727A729A72BA72DA72F-A731A733A735A737A739A73BA73DA73FA741A743A745A747A749A74BA74DA74FA751A753A755A757A759A75BA75DA75FA761A763A765A767A769A76BA76DA76FA771-A778A77AA77CA77FA781A783A785A787A78CFB00-FB06FB13-FB17FF41-FF5A",
        Lu: "0041-005A00C0-00D600D8-00DE01000102010401060108010A010C010E01100112011401160118011A011C011E01200122012401260128012A012C012E01300132013401360139013B013D013F0141014301450147014A014C014E01500152015401560158015A015C015E01600162016401660168016A016C016E017001720174017601780179017B017D018101820184018601870189-018B018E-0191019301940196-0198019C019D019F01A001A201A401A601A701A901AC01AE01AF01B1-01B301B501B701B801BC01C401C701CA01CD01CF01D101D301D501D701D901DB01DE01E001E201E401E601E801EA01EC01EE01F101F401F6-01F801FA01FC01FE02000202020402060208020A020C020E02100212021402160218021A021C021E02200222022402260228022A022C022E02300232023A023B023D023E02410243-02460248024A024C024E03700372037603860388-038A038C038E038F0391-03A103A3-03AB03CF03D2-03D403D803DA03DC03DE03E003E203E403E603E803EA03EC03EE03F403F703F903FA03FD-042F04600462046404660468046A046C046E04700472047404760478047A047C047E0480048A048C048E04900492049404960498049A049C049E04A004A204A404A604A804AA04AC04AE04B004B204B404B604B804BA04BC04BE04C004C104C304C504C704C904CB04CD04D004D204D404D604D804DA04DC04DE04E004E204E404E604E804EA04EC04EE04F004F204F404F604F804FA04FC04FE05000502050405060508050A050C050E05100512051405160518051A051C051E0520052205240531-055610A0-10C51E001E021E041E061E081E0A1E0C1E0E1E101E121E141E161E181E1A1E1C1E1E1E201E221E241E261E281E2A1E2C1E2E1E301E321E341E361E381E3A1E3C1E3E1E401E421E441E461E481E4A1E4C1E4E1E501E521E541E561E581E5A1E5C1E5E1E601E621E641E661E681E6A1E6C1E6E1E701E721E741E761E781E7A1E7C1E7E1E801E821E841E861E881E8A1E8C1E8E1E901E921E941E9E1EA01EA21EA41EA61EA81EAA1EAC1EAE1EB01EB21EB41EB61EB81EBA1EBC1EBE1EC01EC21EC41EC61EC81ECA1ECC1ECE1ED01ED21ED41ED61ED81EDA1EDC1EDE1EE01EE21EE41EE61EE81EEA1EEC1EEE1EF01EF21EF41EF61EF81EFA1EFC1EFE1F08-1F0F1F18-1F1D1F28-1F2F1F38-1F3F1F48-1F4D1F591F5B1F5D1F5F1F68-1F6F1FB8-1FBB1FC8-1FCB1FD8-1FDB1FE8-1FEC1FF8-1FFB21022107210B-210D2110-211221152119-211D212421262128212A-212D2130-2133213E213F214521832C00-2C2E2C602C62-2C642C672C692C6B2C6D-2C702C722C752C7E-2C802C822C842C862C882C8A2C8C2C8E2C902C922C942C962C982C9A2C9C2C9E2CA02CA22CA42CA62CA82CAA2CAC2CAE2CB02CB22CB42CB62CB82CBA2CBC2CBE2CC02CC22CC42CC62CC82CCA2CCC2CCE2CD02CD22CD42CD62CD82CDA2CDC2CDE2CE02CE22CEB2CEDA640A642A644A646A648A64AA64CA64EA650A652A654A656A658A65AA65CA65EA662A664A666A668A66AA66CA680A682A684A686A688A68AA68CA68EA690A692A694A696A722A724A726A728A72AA72CA72EA732A734A736A738A73AA73CA73EA740A742A744A746A748A74AA74CA74EA750A752A754A756A758A75AA75CA75EA760A762A764A766A768A76AA76CA76EA779A77BA77DA77EA780A782A784A786A78BFF21-FF3A",
        Lt: "01C501C801CB01F21F88-1F8F1F98-1F9F1FA8-1FAF1FBC1FCC1FFC",
        Lm: "02B0-02C102C6-02D102E0-02E402EC02EE0374037A0559064006E506E607F407F507FA081A0824082809710E460EC610FC17D718431AA71C78-1C7D1D2C-1D611D781D9B-1DBF2071207F2090-20942C7D2D6F2E2F30053031-3035303B309D309E30FC-30FEA015A4F8-A4FDA60CA67FA717-A71FA770A788A9CFAA70AADDFF70FF9EFF9F",
        Lo: "01BB01C0-01C3029405D0-05EA05F0-05F20621-063F0641-064A066E066F0671-06D306D506EE06EF06FA-06FC06FF07100712-072F074D-07A507B107CA-07EA0800-08150904-0939093D09500958-096109720979-097F0985-098C098F09900993-09A809AA-09B009B209B6-09B909BD09CE09DC09DD09DF-09E109F009F10A05-0A0A0A0F0A100A13-0A280A2A-0A300A320A330A350A360A380A390A59-0A5C0A5E0A72-0A740A85-0A8D0A8F-0A910A93-0AA80AAA-0AB00AB20AB30AB5-0AB90ABD0AD00AE00AE10B05-0B0C0B0F0B100B13-0B280B2A-0B300B320B330B35-0B390B3D0B5C0B5D0B5F-0B610B710B830B85-0B8A0B8E-0B900B92-0B950B990B9A0B9C0B9E0B9F0BA30BA40BA8-0BAA0BAE-0BB90BD00C05-0C0C0C0E-0C100C12-0C280C2A-0C330C35-0C390C3D0C580C590C600C610C85-0C8C0C8E-0C900C92-0CA80CAA-0CB30CB5-0CB90CBD0CDE0CE00CE10D05-0D0C0D0E-0D100D12-0D280D2A-0D390D3D0D600D610D7A-0D7F0D85-0D960D9A-0DB10DB3-0DBB0DBD0DC0-0DC60E01-0E300E320E330E40-0E450E810E820E840E870E880E8A0E8D0E94-0E970E99-0E9F0EA1-0EA30EA50EA70EAA0EAB0EAD-0EB00EB20EB30EBD0EC0-0EC40EDC0EDD0F000F40-0F470F49-0F6C0F88-0F8B1000-102A103F1050-1055105A-105D106110651066106E-10701075-1081108E10D0-10FA1100-1248124A-124D1250-12561258125A-125D1260-1288128A-128D1290-12B012B2-12B512B8-12BE12C012C2-12C512C8-12D612D8-13101312-13151318-135A1380-138F13A0-13F41401-166C166F-167F1681-169A16A0-16EA1700-170C170E-17111720-17311740-17511760-176C176E-17701780-17B317DC1820-18421844-18771880-18A818AA18B0-18F51900-191C1950-196D1970-19741980-19AB19C1-19C71A00-1A161A20-1A541B05-1B331B45-1B4B1B83-1BA01BAE1BAF1C00-1C231C4D-1C4F1C5A-1C771CE9-1CEC1CEE-1CF12135-21382D30-2D652D80-2D962DA0-2DA62DA8-2DAE2DB0-2DB62DB8-2DBE2DC0-2DC62DC8-2DCE2DD0-2DD62DD8-2DDE3006303C3041-3096309F30A1-30FA30FF3105-312D3131-318E31A0-31B731F0-31FF3400-4DB54E00-9FCBA000-A014A016-A48CA4D0-A4F7A500-A60BA610-A61FA62AA62BA66EA6A0-A6E5A7FB-A801A803-A805A807-A80AA80C-A822A840-A873A882-A8B3A8F2-A8F7A8FBA90A-A925A930-A946A960-A97CA984-A9B2AA00-AA28AA40-AA42AA44-AA4BAA60-AA6FAA71-AA76AA7AAA80-AAAFAAB1AAB5AAB6AAB9-AABDAAC0AAC2AADBAADCABC0-ABE2AC00-D7A3D7B0-D7C6D7CB-D7FBF900-FA2DFA30-FA6DFA70-FAD9FB1DFB1F-FB28FB2A-FB36FB38-FB3CFB3EFB40FB41FB43FB44FB46-FBB1FBD3-FD3DFD50-FD8FFD92-FDC7FDF0-FDFBFE70-FE74FE76-FEFCFF66-FF6FFF71-FF9DFFA0-FFBEFFC2-FFC7FFCA-FFCFFFD2-FFD7FFDA-FFDC",
        M: "0300-036F0483-04890591-05BD05BF05C105C205C405C505C70610-061A064B-065E067006D6-06DC06DE-06E406E706E806EA-06ED07110730-074A07A6-07B007EB-07F30816-0819081B-08230825-08270829-082D0900-0903093C093E-094E0951-0955096209630981-098309BC09BE-09C409C709C809CB-09CD09D709E209E30A01-0A030A3C0A3E-0A420A470A480A4B-0A4D0A510A700A710A750A81-0A830ABC0ABE-0AC50AC7-0AC90ACB-0ACD0AE20AE30B01-0B030B3C0B3E-0B440B470B480B4B-0B4D0B560B570B620B630B820BBE-0BC20BC6-0BC80BCA-0BCD0BD70C01-0C030C3E-0C440C46-0C480C4A-0C4D0C550C560C620C630C820C830CBC0CBE-0CC40CC6-0CC80CCA-0CCD0CD50CD60CE20CE30D020D030D3E-0D440D46-0D480D4A-0D4D0D570D620D630D820D830DCA0DCF-0DD40DD60DD8-0DDF0DF20DF30E310E34-0E3A0E47-0E4E0EB10EB4-0EB90EBB0EBC0EC8-0ECD0F180F190F350F370F390F3E0F3F0F71-0F840F860F870F90-0F970F99-0FBC0FC6102B-103E1056-1059105E-10601062-10641067-106D1071-10741082-108D108F109A-109D135F1712-17141732-1734175217531772177317B6-17D317DD180B-180D18A91920-192B1930-193B19B0-19C019C819C91A17-1A1B1A55-1A5E1A60-1A7C1A7F1B00-1B041B34-1B441B6B-1B731B80-1B821BA1-1BAA1C24-1C371CD0-1CD21CD4-1CE81CED1CF21DC0-1DE61DFD-1DFF20D0-20F02CEF-2CF12DE0-2DFF302A-302F3099309AA66F-A672A67CA67DA6F0A6F1A802A806A80BA823-A827A880A881A8B4-A8C4A8E0-A8F1A926-A92DA947-A953A980-A983A9B3-A9C0AA29-AA36AA43AA4CAA4DAA7BAAB0AAB2-AAB4AAB7AAB8AABEAABFAAC1ABE3-ABEAABECABEDFB1EFE00-FE0FFE20-FE26",
        Mn: "0300-036F0483-04870591-05BD05BF05C105C205C405C505C70610-061A064B-065E067006D6-06DC06DF-06E406E706E806EA-06ED07110730-074A07A6-07B007EB-07F30816-0819081B-08230825-08270829-082D0900-0902093C0941-0948094D0951-095509620963098109BC09C1-09C409CD09E209E30A010A020A3C0A410A420A470A480A4B-0A4D0A510A700A710A750A810A820ABC0AC1-0AC50AC70AC80ACD0AE20AE30B010B3C0B3F0B41-0B440B4D0B560B620B630B820BC00BCD0C3E-0C400C46-0C480C4A-0C4D0C550C560C620C630CBC0CBF0CC60CCC0CCD0CE20CE30D41-0D440D4D0D620D630DCA0DD2-0DD40DD60E310E34-0E3A0E47-0E4E0EB10EB4-0EB90EBB0EBC0EC8-0ECD0F180F190F350F370F390F71-0F7E0F80-0F840F860F870F90-0F970F99-0FBC0FC6102D-10301032-10371039103A103D103E10581059105E-10601071-1074108210851086108D109D135F1712-17141732-1734175217531772177317B7-17BD17C617C9-17D317DD180B-180D18A91920-19221927192819321939-193B1A171A181A561A58-1A5E1A601A621A65-1A6C1A73-1A7C1A7F1B00-1B031B341B36-1B3A1B3C1B421B6B-1B731B801B811BA2-1BA51BA81BA91C2C-1C331C361C371CD0-1CD21CD4-1CE01CE2-1CE81CED1DC0-1DE61DFD-1DFF20D0-20DC20E120E5-20F02CEF-2CF12DE0-2DFF302A-302F3099309AA66FA67CA67DA6F0A6F1A802A806A80BA825A826A8C4A8E0-A8F1A926-A92DA947-A951A980-A982A9B3A9B6-A9B9A9BCAA29-AA2EAA31AA32AA35AA36AA43AA4CAAB0AAB2-AAB4AAB7AAB8AABEAABFAAC1ABE5ABE8ABEDFB1EFE00-FE0FFE20-FE26",
        Mc: "0903093E-09400949-094C094E0982098309BE-09C009C709C809CB09CC09D70A030A3E-0A400A830ABE-0AC00AC90ACB0ACC0B020B030B3E0B400B470B480B4B0B4C0B570BBE0BBF0BC10BC20BC6-0BC80BCA-0BCC0BD70C01-0C030C41-0C440C820C830CBE0CC0-0CC40CC70CC80CCA0CCB0CD50CD60D020D030D3E-0D400D46-0D480D4A-0D4C0D570D820D830DCF-0DD10DD8-0DDF0DF20DF30F3E0F3F0F7F102B102C10311038103B103C105610571062-10641067-106D108310841087-108C108F109A-109C17B617BE-17C517C717C81923-19261929-192B193019311933-193819B0-19C019C819C91A19-1A1B1A551A571A611A631A641A6D-1A721B041B351B3B1B3D-1B411B431B441B821BA11BA61BA71BAA1C24-1C2B1C341C351CE11CF2A823A824A827A880A881A8B4-A8C3A952A953A983A9B4A9B5A9BAA9BBA9BD-A9C0AA2FAA30AA33AA34AA4DAA7BABE3ABE4ABE6ABE7ABE9ABEAABEC",
        Me: "0488048906DE20DD-20E020E2-20E4A670-A672",
        N: "0030-003900B200B300B900BC-00BE0660-066906F0-06F907C0-07C90966-096F09E6-09EF09F4-09F90A66-0A6F0AE6-0AEF0B66-0B6F0BE6-0BF20C66-0C6F0C78-0C7E0CE6-0CEF0D66-0D750E50-0E590ED0-0ED90F20-0F331040-10491090-10991369-137C16EE-16F017E0-17E917F0-17F91810-18191946-194F19D0-19DA1A80-1A891A90-1A991B50-1B591BB0-1BB91C40-1C491C50-1C5920702074-20792080-20892150-21822185-21892460-249B24EA-24FF2776-27932CFD30073021-30293038-303A3192-31953220-32293251-325F3280-328932B1-32BFA620-A629A6E6-A6EFA830-A835A8D0-A8D9A900-A909A9D0-A9D9AA50-AA59ABF0-ABF9FF10-FF19",
        Nd: "0030-00390660-066906F0-06F907C0-07C90966-096F09E6-09EF0A66-0A6F0AE6-0AEF0B66-0B6F0BE6-0BEF0C66-0C6F0CE6-0CEF0D66-0D6F0E50-0E590ED0-0ED90F20-0F291040-10491090-109917E0-17E91810-18191946-194F19D0-19DA1A80-1A891A90-1A991B50-1B591BB0-1BB91C40-1C491C50-1C59A620-A629A8D0-A8D9A900-A909A9D0-A9D9AA50-AA59ABF0-ABF9FF10-FF19",
        Nl: "16EE-16F02160-21822185-218830073021-30293038-303AA6E6-A6EF",
        No: "00B200B300B900BC-00BE09F4-09F90BF0-0BF20C78-0C7E0D70-0D750F2A-0F331369-137C17F0-17F920702074-20792080-20892150-215F21892460-249B24EA-24FF2776-27932CFD3192-31953220-32293251-325F3280-328932B1-32BFA830-A835",
        P: "0021-00230025-002A002C-002F003A003B003F0040005B-005D005F007B007D00A100AB00B700BB00BF037E0387055A-055F0589058A05BE05C005C305C605F305F40609060A060C060D061B061E061F066A-066D06D40700-070D07F7-07F90830-083E0964096509700DF40E4F0E5A0E5B0F04-0F120F3A-0F3D0F850FD0-0FD4104A-104F10FB1361-13681400166D166E169B169C16EB-16ED1735173617D4-17D617D8-17DA1800-180A1944194519DE19DF1A1E1A1F1AA0-1AA61AA8-1AAD1B5A-1B601C3B-1C3F1C7E1C7F1CD32010-20272030-20432045-20512053-205E207D207E208D208E2329232A2768-277527C527C627E6-27EF2983-299829D8-29DB29FC29FD2CF9-2CFC2CFE2CFF2E00-2E2E2E302E313001-30033008-30113014-301F3030303D30A030FBA4FEA4FFA60D-A60FA673A67EA6F2-A6F7A874-A877A8CEA8CFA8F8-A8FAA92EA92FA95FA9C1-A9CDA9DEA9DFAA5C-AA5FAADEAADFABEBFD3EFD3FFE10-FE19FE30-FE52FE54-FE61FE63FE68FE6AFE6BFF01-FF03FF05-FF0AFF0C-FF0FFF1AFF1BFF1FFF20FF3B-FF3DFF3FFF5BFF5DFF5F-FF65",
        Pd: "002D058A05BE140018062010-20152E172E1A301C303030A0FE31FE32FE58FE63FF0D",
        Ps: "0028005B007B0F3A0F3C169B201A201E2045207D208D23292768276A276C276E27702772277427C527E627E827EA27EC27EE2983298529872989298B298D298F299129932995299729D829DA29FC2E222E242E262E283008300A300C300E3010301430163018301A301DFD3EFE17FE35FE37FE39FE3BFE3DFE3FFE41FE43FE47FE59FE5BFE5DFF08FF3BFF5BFF5FFF62",
        Pe: "0029005D007D0F3B0F3D169C2046207E208E232A2769276B276D276F27712773277527C627E727E927EB27ED27EF298429862988298A298C298E2990299229942996299829D929DB29FD2E232E252E272E293009300B300D300F3011301530173019301B301E301FFD3FFE18FE36FE38FE3AFE3CFE3EFE40FE42FE44FE48FE5AFE5CFE5EFF09FF3DFF5DFF60FF63",
        Pi: "00AB2018201B201C201F20392E022E042E092E0C2E1C2E20",
        Pf: "00BB2019201D203A2E032E052E0A2E0D2E1D2E21",
        Pc: "005F203F20402054FE33FE34FE4D-FE4FFF3F",
        Po: "0021-00230025-0027002A002C002E002F003A003B003F0040005C00A100B700BF037E0387055A-055F058905C005C305C605F305F40609060A060C060D061B061E061F066A-066D06D40700-070D07F7-07F90830-083E0964096509700DF40E4F0E5A0E5B0F04-0F120F850FD0-0FD4104A-104F10FB1361-1368166D166E16EB-16ED1735173617D4-17D617D8-17DA1800-18051807-180A1944194519DE19DF1A1E1A1F1AA0-1AA61AA8-1AAD1B5A-1B601C3B-1C3F1C7E1C7F1CD3201620172020-20272030-2038203B-203E2041-20432047-205120532055-205E2CF9-2CFC2CFE2CFF2E002E012E06-2E082E0B2E0E-2E162E182E192E1B2E1E2E1F2E2A-2E2E2E302E313001-3003303D30FBA4FEA4FFA60D-A60FA673A67EA6F2-A6F7A874-A877A8CEA8CFA8F8-A8FAA92EA92FA95FA9C1-A9CDA9DEA9DFAA5C-AA5FAADEAADFABEBFE10-FE16FE19FE30FE45FE46FE49-FE4CFE50-FE52FE54-FE57FE5F-FE61FE68FE6AFE6BFF01-FF03FF05-FF07FF0AFF0CFF0EFF0FFF1AFF1BFF1FFF20FF3CFF61FF64FF65",
        S: "0024002B003C-003E005E0060007C007E00A2-00A900AC00AE-00B100B400B600B800D700F702C2-02C502D2-02DF02E5-02EB02ED02EF-02FF03750384038503F604820606-0608060B060E060F06E906FD06FE07F609F209F309FA09FB0AF10B700BF3-0BFA0C7F0CF10CF20D790E3F0F01-0F030F13-0F170F1A-0F1F0F340F360F380FBE-0FC50FC7-0FCC0FCE0FCF0FD5-0FD8109E109F13601390-139917DB194019E0-19FF1B61-1B6A1B74-1B7C1FBD1FBF-1FC11FCD-1FCF1FDD-1FDF1FED-1FEF1FFD1FFE20442052207A-207C208A-208C20A0-20B8210021012103-21062108210921142116-2118211E-2123212521272129212E213A213B2140-2144214A-214D214F2190-2328232B-23E82400-24262440-244A249C-24E92500-26CD26CF-26E126E326E8-26FF2701-27042706-2709270C-27272729-274B274D274F-27522756-275E2761-276727942798-27AF27B1-27BE27C0-27C427C7-27CA27CC27D0-27E527F0-29822999-29D729DC-29FB29FE-2B4C2B50-2B592CE5-2CEA2E80-2E992E9B-2EF32F00-2FD52FF0-2FFB300430123013302030363037303E303F309B309C319031913196-319F31C0-31E33200-321E322A-32503260-327F328A-32B032C0-32FE3300-33FF4DC0-4DFFA490-A4C6A700-A716A720A721A789A78AA828-A82BA836-A839AA77-AA79FB29FDFCFDFDFE62FE64-FE66FE69FF04FF0BFF1C-FF1EFF3EFF40FF5CFF5EFFE0-FFE6FFE8-FFEEFFFCFFFD",
        Sm: "002B003C-003E007C007E00AC00B100D700F703F60606-060820442052207A-207C208A-208C2140-2144214B2190-2194219A219B21A021A321A621AE21CE21CF21D221D421F4-22FF2308-230B23202321237C239B-23B323DC-23E125B725C125F8-25FF266F27C0-27C427C7-27CA27CC27D0-27E527F0-27FF2900-29822999-29D729DC-29FB29FE-2AFF2B30-2B442B47-2B4CFB29FE62FE64-FE66FF0BFF1C-FF1EFF5CFF5EFFE2FFE9-FFEC",
        Sc: "002400A2-00A5060B09F209F309FB0AF10BF90E3F17DB20A0-20B8A838FDFCFE69FF04FFE0FFE1FFE5FFE6",
        Sk: "005E006000A800AF00B400B802C2-02C502D2-02DF02E5-02EB02ED02EF-02FF0375038403851FBD1FBF-1FC11FCD-1FCF1FDD-1FDF1FED-1FEF1FFD1FFE309B309CA700-A716A720A721A789A78AFF3EFF40FFE3",
        So: "00A600A700A900AE00B000B60482060E060F06E906FD06FE07F609FA0B700BF3-0BF80BFA0C7F0CF10CF20D790F01-0F030F13-0F170F1A-0F1F0F340F360F380FBE-0FC50FC7-0FCC0FCE0FCF0FD5-0FD8109E109F13601390-1399194019E0-19FF1B61-1B6A1B74-1B7C210021012103-21062108210921142116-2118211E-2123212521272129212E213A213B214A214C214D214F2195-2199219C-219F21A121A221A421A521A7-21AD21AF-21CD21D021D121D321D5-21F32300-2307230C-231F2322-2328232B-237B237D-239A23B4-23DB23E2-23E82400-24262440-244A249C-24E92500-25B625B8-25C025C2-25F72600-266E2670-26CD26CF-26E126E326E8-26FF2701-27042706-2709270C-27272729-274B274D274F-27522756-275E2761-276727942798-27AF27B1-27BE2800-28FF2B00-2B2F2B452B462B50-2B592CE5-2CEA2E80-2E992E9B-2EF32F00-2FD52FF0-2FFB300430123013302030363037303E303F319031913196-319F31C0-31E33200-321E322A-32503260-327F328A-32B032C0-32FE3300-33FF4DC0-4DFFA490-A4C6A828-A82BA836A837A839AA77-AA79FDFDFFE4FFE8FFEDFFEEFFFCFFFD",
        Z: "002000A01680180E2000-200A20282029202F205F3000",
        Zs: "002000A01680180E2000-200A202F205F3000",
        Zl: "2028",
        Zp: "2029",
        C: "0000-001F007F-009F00AD03780379037F-0383038B038D03A20526-05300557055805600588058B-059005C8-05CF05EB-05EF05F5-0605061C061D0620065F06DD070E070F074B074C07B2-07BF07FB-07FF082E082F083F-08FF093A093B094F095609570973-097809800984098D098E0991099209A909B109B3-09B509BA09BB09C509C609C909CA09CF-09D609D8-09DB09DE09E409E509FC-0A000A040A0B-0A0E0A110A120A290A310A340A370A3A0A3B0A3D0A43-0A460A490A4A0A4E-0A500A52-0A580A5D0A5F-0A650A76-0A800A840A8E0A920AA90AB10AB40ABA0ABB0AC60ACA0ACE0ACF0AD1-0ADF0AE40AE50AF00AF2-0B000B040B0D0B0E0B110B120B290B310B340B3A0B3B0B450B460B490B4A0B4E-0B550B58-0B5B0B5E0B640B650B72-0B810B840B8B-0B8D0B910B96-0B980B9B0B9D0BA0-0BA20BA5-0BA70BAB-0BAD0BBA-0BBD0BC3-0BC50BC90BCE0BCF0BD1-0BD60BD8-0BE50BFB-0C000C040C0D0C110C290C340C3A-0C3C0C450C490C4E-0C540C570C5A-0C5F0C640C650C70-0C770C800C810C840C8D0C910CA90CB40CBA0CBB0CC50CC90CCE-0CD40CD7-0CDD0CDF0CE40CE50CF00CF3-0D010D040D0D0D110D290D3A-0D3C0D450D490D4E-0D560D58-0D5F0D640D650D76-0D780D800D810D840D97-0D990DB20DBC0DBE0DBF0DC7-0DC90DCB-0DCE0DD50DD70DE0-0DF10DF5-0E000E3B-0E3E0E5C-0E800E830E850E860E890E8B0E8C0E8E-0E930E980EA00EA40EA60EA80EA90EAC0EBA0EBE0EBF0EC50EC70ECE0ECF0EDA0EDB0EDE-0EFF0F480F6D-0F700F8C-0F8F0F980FBD0FCD0FD9-0FFF10C6-10CF10FD-10FF1249124E124F12571259125E125F1289128E128F12B112B612B712BF12C112C612C712D7131113161317135B-135E137D-137F139A-139F13F5-13FF169D-169F16F1-16FF170D1715-171F1737-173F1754-175F176D17711774-177F17B417B517DE17DF17EA-17EF17FA-17FF180F181A-181F1878-187F18AB-18AF18F6-18FF191D-191F192C-192F193C-193F1941-1943196E196F1975-197F19AC-19AF19CA-19CF19DB-19DD1A1C1A1D1A5F1A7D1A7E1A8A-1A8F1A9A-1A9F1AAE-1AFF1B4C-1B4F1B7D-1B7F1BAB-1BAD1BBA-1BFF1C38-1C3A1C4A-1C4C1C80-1CCF1CF3-1CFF1DE7-1DFC1F161F171F1E1F1F1F461F471F4E1F4F1F581F5A1F5C1F5E1F7E1F7F1FB51FC51FD41FD51FDC1FF01FF11FF51FFF200B-200F202A-202E2060-206F20722073208F2095-209F20B9-20CF20F1-20FF218A-218F23E9-23FF2427-243F244B-245F26CE26E226E4-26E727002705270A270B2728274C274E2753-2755275F27602795-279727B027BF27CB27CD-27CF2B4D-2B4F2B5A-2BFF2C2F2C5F2CF2-2CF82D26-2D2F2D66-2D6E2D70-2D7F2D97-2D9F2DA72DAF2DB72DBF2DC72DCF2DD72DDF2E32-2E7F2E9A2EF4-2EFF2FD6-2FEF2FFC-2FFF3040309730983100-3104312E-3130318F31B8-31BF31E4-31EF321F32FF4DB6-4DBF9FCC-9FFFA48D-A48FA4C7-A4CFA62C-A63FA660A661A674-A67BA698-A69FA6F8-A6FFA78D-A7FAA82C-A82FA83A-A83FA878-A87FA8C5-A8CDA8DA-A8DFA8FC-A8FFA954-A95EA97D-A97FA9CEA9DA-A9DDA9E0-A9FFAA37-AA3FAA4EAA4FAA5AAA5BAA7C-AA7FAAC3-AADAAAE0-ABBFABEEABEFABFA-ABFFD7A4-D7AFD7C7-D7CAD7FC-F8FFFA2EFA2FFA6EFA6FFADA-FAFFFB07-FB12FB18-FB1CFB37FB3DFB3FFB42FB45FBB2-FBD2FD40-FD4FFD90FD91FDC8-FDEFFDFEFDFFFE1A-FE1FFE27-FE2FFE53FE67FE6C-FE6FFE75FEFD-FF00FFBF-FFC1FFC8FFC9FFD0FFD1FFD8FFD9FFDD-FFDFFFE7FFEF-FFFBFFFEFFFF",
        Cc: "0000-001F007F-009F",
        Cf: "00AD0600-060306DD070F17B417B5200B-200F202A-202E2060-2064206A-206FFEFFFFF9-FFFB",
        Co: "E000-F8FF",
        Cs: "D800-DFFF",
        Cn: "03780379037F-0383038B038D03A20526-05300557055805600588058B-059005C8-05CF05EB-05EF05F5-05FF06040605061C061D0620065F070E074B074C07B2-07BF07FB-07FF082E082F083F-08FF093A093B094F095609570973-097809800984098D098E0991099209A909B109B3-09B509BA09BB09C509C609C909CA09CF-09D609D8-09DB09DE09E409E509FC-0A000A040A0B-0A0E0A110A120A290A310A340A370A3A0A3B0A3D0A43-0A460A490A4A0A4E-0A500A52-0A580A5D0A5F-0A650A76-0A800A840A8E0A920AA90AB10AB40ABA0ABB0AC60ACA0ACE0ACF0AD1-0ADF0AE40AE50AF00AF2-0B000B040B0D0B0E0B110B120B290B310B340B3A0B3B0B450B460B490B4A0B4E-0B550B58-0B5B0B5E0B640B650B72-0B810B840B8B-0B8D0B910B96-0B980B9B0B9D0BA0-0BA20BA5-0BA70BAB-0BAD0BBA-0BBD0BC3-0BC50BC90BCE0BCF0BD1-0BD60BD8-0BE50BFB-0C000C040C0D0C110C290C340C3A-0C3C0C450C490C4E-0C540C570C5A-0C5F0C640C650C70-0C770C800C810C840C8D0C910CA90CB40CBA0CBB0CC50CC90CCE-0CD40CD7-0CDD0CDF0CE40CE50CF00CF3-0D010D040D0D0D110D290D3A-0D3C0D450D490D4E-0D560D58-0D5F0D640D650D76-0D780D800D810D840D97-0D990DB20DBC0DBE0DBF0DC7-0DC90DCB-0DCE0DD50DD70DE0-0DF10DF5-0E000E3B-0E3E0E5C-0E800E830E850E860E890E8B0E8C0E8E-0E930E980EA00EA40EA60EA80EA90EAC0EBA0EBE0EBF0EC50EC70ECE0ECF0EDA0EDB0EDE-0EFF0F480F6D-0F700F8C-0F8F0F980FBD0FCD0FD9-0FFF10C6-10CF10FD-10FF1249124E124F12571259125E125F1289128E128F12B112B612B712BF12C112C612C712D7131113161317135B-135E137D-137F139A-139F13F5-13FF169D-169F16F1-16FF170D1715-171F1737-173F1754-175F176D17711774-177F17DE17DF17EA-17EF17FA-17FF180F181A-181F1878-187F18AB-18AF18F6-18FF191D-191F192C-192F193C-193F1941-1943196E196F1975-197F19AC-19AF19CA-19CF19DB-19DD1A1C1A1D1A5F1A7D1A7E1A8A-1A8F1A9A-1A9F1AAE-1AFF1B4C-1B4F1B7D-1B7F1BAB-1BAD1BBA-1BFF1C38-1C3A1C4A-1C4C1C80-1CCF1CF3-1CFF1DE7-1DFC1F161F171F1E1F1F1F461F471F4E1F4F1F581F5A1F5C1F5E1F7E1F7F1FB51FC51FD41FD51FDC1FF01FF11FF51FFF2065-206920722073208F2095-209F20B9-20CF20F1-20FF218A-218F23E9-23FF2427-243F244B-245F26CE26E226E4-26E727002705270A270B2728274C274E2753-2755275F27602795-279727B027BF27CB27CD-27CF2B4D-2B4F2B5A-2BFF2C2F2C5F2CF2-2CF82D26-2D2F2D66-2D6E2D70-2D7F2D97-2D9F2DA72DAF2DB72DBF2DC72DCF2DD72DDF2E32-2E7F2E9A2EF4-2EFF2FD6-2FEF2FFC-2FFF3040309730983100-3104312E-3130318F31B8-31BF31E4-31EF321F32FF4DB6-4DBF9FCC-9FFFA48D-A48FA4C7-A4CFA62C-A63FA660A661A674-A67BA698-A69FA6F8-A6FFA78D-A7FAA82C-A82FA83A-A83FA878-A87FA8C5-A8CDA8DA-A8DFA8FC-A8FFA954-A95EA97D-A97FA9CEA9DA-A9DDA9E0-A9FFAA37-AA3FAA4EAA4FAA5AAA5BAA7C-AA7FAAC3-AADAAAE0-ABBFABEEABEFABFA-ABFFD7A4-D7AFD7C7-D7CAD7FC-D7FFFA2EFA2FFA6EFA6FFADA-FAFFFB07-FB12FB18-FB1CFB37FB3DFB3FFB42FB45FBB2-FBD2FD40-FD4FFD90FD91FDC8-FDEFFDFEFDFFFE1A-FE1FFE27-FE2FFE53FE67FE6C-FE6FFE75FEFDFEFEFF00FFBF-FFC1FFC8FFC9FFD0FFD1FFD8FFD9FFDD-FFDFFFE7FFEF-FFF8FFFEFFFF"
      });
      function addUnicodePackage(pack) {
        var codePoint = /\w{4}/g;
        for (var name in pack)
          exports.packages[name] = pack[name].replace(codePoint, "\\u$&");
      }
      ;
    });
    ace.define("ace/token_iterator", ["require", "exports", "module"], function(acequire, exports, module) {
      "use strict";
      var TokenIterator = function(session, initialRow, initialColumn) {
        this.$session = session;
        this.$row = initialRow;
        this.$rowTokens = session.getTokens(initialRow);
        var token = session.getTokenAt(initialRow, initialColumn);
        this.$tokenIndex = token ? token.index : -1;
      };
      (function() {
        this.stepBackward = function() {
          this.$tokenIndex -= 1;
          while (this.$tokenIndex < 0) {
            this.$row -= 1;
            if (this.$row < 0) {
              this.$row = 0;
              return null;
            }
            this.$rowTokens = this.$session.getTokens(this.$row);
            this.$tokenIndex = this.$rowTokens.length - 1;
          }
          return this.$rowTokens[this.$tokenIndex];
        };
        this.stepForward = function() {
          this.$tokenIndex += 1;
          var rowCount;
          while (this.$tokenIndex >= this.$rowTokens.length) {
            this.$row += 1;
            if (!rowCount)
              rowCount = this.$session.getLength();
            if (this.$row >= rowCount) {
              this.$row = rowCount - 1;
              return null;
            }
            this.$rowTokens = this.$session.getTokens(this.$row);
            this.$tokenIndex = 0;
          }
          return this.$rowTokens[this.$tokenIndex];
        };
        this.getCurrentToken = function() {
          return this.$rowTokens[this.$tokenIndex];
        };
        this.getCurrentTokenRow = function() {
          return this.$row;
        };
        this.getCurrentTokenColumn = function() {
          var rowTokens = this.$rowTokens;
          var tokenIndex = this.$tokenIndex;
          var column = rowTokens[tokenIndex].start;
          if (column !== undefined)
            return column;
          column = 0;
          while (tokenIndex > 0) {
            tokenIndex -= 1;
            column += rowTokens[tokenIndex].value.length;
          }
          return column;
        };
      }).call(TokenIterator.prototype);
      exports.TokenIterator = TokenIterator;
    });
    ace.define("ace/mode/text", ["require", "exports", "module", "ace/tokenizer", "ace/mode/text_highlight_rules", "ace/mode/behaviour", "ace/unicode", "ace/lib/lang", "ace/token_iterator", "ace/range"], function(acequire, exports, module) {
      "use strict";
      var Tokenizer = acequire("../tokenizer").Tokenizer;
      var TextHighlightRules = acequire("./text_highlight_rules").TextHighlightRules;
      var Behaviour = acequire("./behaviour").Behaviour;
      var unicode = acequire("../unicode");
      var lang = acequire("../lib/lang");
      var TokenIterator = acequire("../token_iterator").TokenIterator;
      var Range = acequire("../range").Range;
      var Mode = function() {
        this.HighlightRules = TextHighlightRules;
        this.$behaviour = new Behaviour();
      };
      (function() {
        this.tokenRe = new RegExp("^[" + unicode.packages.L + unicode.packages.Mn + unicode.packages.Mc + unicode.packages.Nd + unicode.packages.Pc + "\\$_]+", "g");
        this.nonTokenRe = new RegExp("^(?:[^" + unicode.packages.L + unicode.packages.Mn + unicode.packages.Mc + unicode.packages.Nd + unicode.packages.Pc + "\\$_]|\\s])+", "g");
        this.getTokenizer = function() {
          if (!this.$tokenizer) {
            this.$highlightRules = this.$highlightRules || new this.HighlightRules();
            this.$tokenizer = new Tokenizer(this.$highlightRules.getRules());
          }
          return this.$tokenizer;
        };
        this.lineCommentStart = "";
        this.blockComment = "";
        this.toggleCommentLines = function(state, session, startRow, endRow) {
          var doc = session.doc;
          var ignoreBlankLines = true;
          var shouldRemove = true;
          var minIndent = Infinity;
          var tabSize = session.getTabSize();
          var insertAtTabStop = false;
          if (!this.lineCommentStart) {
            if (!this.blockComment)
              return false;
            var lineCommentStart = this.blockComment.start;
            var lineCommentEnd = this.blockComment.end;
            var regexpStart = new RegExp("^(\\s*)(?:" + lang.escapeRegExp(lineCommentStart) + ")");
            var regexpEnd = new RegExp("(?:" + lang.escapeRegExp(lineCommentEnd) + ")\\s*$");
            var comment = function(line, i) {
              if (testRemove(line, i))
                return ;
              if (!ignoreBlankLines || /\S/.test(line)) {
                doc.insertInLine({
                  row: i,
                  column: line.length
                }, lineCommentEnd);
                doc.insertInLine({
                  row: i,
                  column: minIndent
                }, lineCommentStart);
              }
            };
            var uncomment = function(line, i) {
              var m;
              if (m = line.match(regexpEnd))
                doc.removeInLine(i, line.length - m[0].length, line.length);
              if (m = line.match(regexpStart))
                doc.removeInLine(i, m[1].length, m[0].length);
            };
            var testRemove = function(line, row) {
              if (regexpStart.test(line))
                return true;
              var tokens = session.getTokens(row);
              for (var i = 0; i < tokens.length; i++) {
                if (tokens[i].type === 'comment')
                  return true;
              }
            };
          } else {
            if (Array.isArray(this.lineCommentStart)) {
              var regexpStart = this.lineCommentStart.map(lang.escapeRegExp).join("|");
              var lineCommentStart = this.lineCommentStart[0];
            } else {
              var regexpStart = lang.escapeRegExp(this.lineCommentStart);
              var lineCommentStart = this.lineCommentStart;
            }
            regexpStart = new RegExp("^(\\s*)(?:" + regexpStart + ") ?");
            insertAtTabStop = session.getUseSoftTabs();
            var uncomment = function(line, i) {
              var m = line.match(regexpStart);
              if (!m)
                return ;
              var start = m[1].length,
                  end = m[0].length;
              if (!shouldInsertSpace(line, start, end) && m[0][end - 1] == " ")
                end--;
              doc.removeInLine(i, start, end);
            };
            var commentWithSpace = lineCommentStart + " ";
            var comment = function(line, i) {
              if (!ignoreBlankLines || /\S/.test(line)) {
                if (shouldInsertSpace(line, minIndent, minIndent))
                  doc.insertInLine({
                    row: i,
                    column: minIndent
                  }, commentWithSpace);
                else
                  doc.insertInLine({
                    row: i,
                    column: minIndent
                  }, lineCommentStart);
              }
            };
            var testRemove = function(line, i) {
              return regexpStart.test(line);
            };
            var shouldInsertSpace = function(line, before, after) {
              var spaces = 0;
              while (before-- && line.charAt(before) == " ")
                spaces++;
              if (spaces % tabSize != 0)
                return false;
              var spaces = 0;
              while (line.charAt(after++) == " ")
                spaces++;
              if (tabSize > 2)
                return spaces % tabSize != tabSize - 1;
              else
                return spaces % tabSize == 0;
              return true;
            };
          }
          function iter(fun) {
            for (var i = startRow; i <= endRow; i++)
              fun(doc.getLine(i), i);
          }
          var minEmptyLength = Infinity;
          iter(function(line, i) {
            var indent = line.search(/\S/);
            if (indent !== -1) {
              if (indent < minIndent)
                minIndent = indent;
              if (shouldRemove && !testRemove(line, i))
                shouldRemove = false;
            } else if (minEmptyLength > line.length) {
              minEmptyLength = line.length;
            }
          });
          if (minIndent == Infinity) {
            minIndent = minEmptyLength;
            ignoreBlankLines = false;
            shouldRemove = false;
          }
          if (insertAtTabStop && minIndent % tabSize != 0)
            minIndent = Math.floor(minIndent / tabSize) * tabSize;
          iter(shouldRemove ? uncomment : comment);
        };
        this.toggleBlockComment = function(state, session, range, cursor) {
          var comment = this.blockComment;
          if (!comment)
            return ;
          if (!comment.start && comment[0])
            comment = comment[0];
          var iterator = new TokenIterator(session, cursor.row, cursor.column);
          var token = iterator.getCurrentToken();
          var sel = session.selection;
          var initialRange = session.selection.toOrientedRange();
          var startRow,
              colDiff;
          if (token && /comment/.test(token.type)) {
            var startRange,
                endRange;
            while (token && /comment/.test(token.type)) {
              var i = token.value.indexOf(comment.start);
              if (i != -1) {
                var row = iterator.getCurrentTokenRow();
                var column = iterator.getCurrentTokenColumn() + i;
                startRange = new Range(row, column, row, column + comment.start.length);
                break;
              }
              token = iterator.stepBackward();
            }
            var iterator = new TokenIterator(session, cursor.row, cursor.column);
            var token = iterator.getCurrentToken();
            while (token && /comment/.test(token.type)) {
              var i = token.value.indexOf(comment.end);
              if (i != -1) {
                var row = iterator.getCurrentTokenRow();
                var column = iterator.getCurrentTokenColumn() + i;
                endRange = new Range(row, column, row, column + comment.end.length);
                break;
              }
              token = iterator.stepForward();
            }
            if (endRange)
              session.remove(endRange);
            if (startRange) {
              session.remove(startRange);
              startRow = startRange.start.row;
              colDiff = -comment.start.length;
            }
          } else {
            colDiff = comment.start.length;
            startRow = range.start.row;
            session.insert(range.end, comment.end);
            session.insert(range.start, comment.start);
          }
          if (initialRange.start.row == startRow)
            initialRange.start.column += colDiff;
          if (initialRange.end.row == startRow)
            initialRange.end.column += colDiff;
          session.selection.fromOrientedRange(initialRange);
        };
        this.getNextLineIndent = function(state, line, tab) {
          return this.$getIndent(line);
        };
        this.checkOutdent = function(state, line, input) {
          return false;
        };
        this.autoOutdent = function(state, doc, row) {};
        this.$getIndent = function(line) {
          return line.match(/^\s*/)[0];
        };
        this.createWorker = function(session) {
          return null;
        };
        this.createModeDelegates = function(mapping) {
          this.$embeds = [];
          this.$modes = {};
          for (var i in mapping) {
            if (mapping[i]) {
              this.$embeds.push(i);
              this.$modes[i] = new mapping[i]();
            }
          }
          var delegations = ['toggleBlockComment', 'toggleCommentLines', 'getNextLineIndent', 'checkOutdent', 'autoOutdent', 'transformAction', 'getCompletions'];
          for (var i = 0; i < delegations.length; i++) {
            (function(scope) {
              var functionName = delegations[i];
              var defaultHandler = scope[functionName];
              scope[delegations[i]] = function() {
                return this.$delegator(functionName, arguments, defaultHandler);
              };
            }(this));
          }
        };
        this.$delegator = function(method, args, defaultHandler) {
          var state = args[0];
          if (typeof state != "string")
            state = state[0];
          for (var i = 0; i < this.$embeds.length; i++) {
            if (!this.$modes[this.$embeds[i]])
              continue;
            var split = state.split(this.$embeds[i]);
            if (!split[0] && split[1]) {
              args[0] = split[1];
              var mode = this.$modes[this.$embeds[i]];
              return mode[method].apply(mode, args);
            }
          }
          var ret = defaultHandler.apply(this, args);
          return defaultHandler ? ret : undefined;
        };
        this.transformAction = function(state, action, editor, session, param) {
          if (this.$behaviour) {
            var behaviours = this.$behaviour.getBehaviours();
            for (var key in behaviours) {
              if (behaviours[key][action]) {
                var ret = behaviours[key][action].apply(this, arguments);
                if (ret) {
                  return ret;
                }
              }
            }
          }
        };
        this.getKeywords = function(append) {
          if (!this.completionKeywords) {
            var rules = this.$tokenizer.rules;
            var completionKeywords = [];
            for (var rule in rules) {
              var ruleItr = rules[rule];
              for (var r = 0,
                  l = ruleItr.length; r < l; r++) {
                if (typeof ruleItr[r].token === "string") {
                  if (/keyword|support|storage/.test(ruleItr[r].token))
                    completionKeywords.push(ruleItr[r].regex);
                } else if (typeof ruleItr[r].token === "object") {
                  for (var a = 0,
                      aLength = ruleItr[r].token.length; a < aLength; a++) {
                    if (/keyword|support|storage/.test(ruleItr[r].token[a])) {
                      var rule = ruleItr[r].regex.match(/\(.+?\)/g)[a];
                      completionKeywords.push(rule.substr(1, rule.length - 2));
                    }
                  }
                }
              }
            }
            this.completionKeywords = completionKeywords;
          }
          if (!append)
            return this.$keywordList;
          return completionKeywords.concat(this.$keywordList || []);
        };
        this.$createKeywordList = function() {
          if (!this.$highlightRules)
            this.getTokenizer();
          return this.$keywordList = this.$highlightRules.$keywordList || [];
        };
        this.getCompletions = function(state, session, pos, prefix) {
          var keywords = this.$keywordList || this.$createKeywordList();
          return keywords.map(function(word) {
            return {
              name: word,
              value: word,
              score: 0,
              meta: "keyword"
            };
          });
        };
        this.$id = "ace/mode/text";
      }).call(Mode.prototype);
      exports.Mode = Mode;
    });
    ace.define("ace/anchor", ["require", "exports", "module", "ace/lib/oop", "ace/lib/event_emitter"], function(acequire, exports, module) {
      "use strict";
      var oop = acequire("./lib/oop");
      var EventEmitter = acequire("./lib/event_emitter").EventEmitter;
      var Anchor = exports.Anchor = function(doc, row, column) {
        this.$onChange = this.onChange.bind(this);
        this.attach(doc);
        if (typeof column == "undefined")
          this.setPosition(row.row, row.column);
        else
          this.setPosition(row, column);
      };
      (function() {
        oop.implement(this, EventEmitter);
        this.getPosition = function() {
          return this.$clipPositionToDocument(this.row, this.column);
        };
        this.getDocument = function() {
          return this.document;
        };
        this.$insertRight = false;
        this.onChange = function(e) {
          var delta = e.data;
          var range = delta.range;
          if (range.start.row == range.end.row && range.start.row != this.row)
            return ;
          if (range.start.row > this.row)
            return ;
          if (range.start.row == this.row && range.start.column > this.column)
            return ;
          var row = this.row;
          var column = this.column;
          var start = range.start;
          var end = range.end;
          if (delta.action === "insertText") {
            if (start.row === row && start.column <= column) {
              if (start.column === column && this.$insertRight) {} else if (start.row === end.row) {
                column += end.column - start.column;
              } else {
                column -= start.column;
                row += end.row - start.row;
              }
            } else if (start.row !== end.row && start.row < row) {
              row += end.row - start.row;
            }
          } else if (delta.action === "insertLines") {
            if (start.row === row && column === 0 && this.$insertRight) {} else if (start.row <= row) {
              row += end.row - start.row;
            }
          } else if (delta.action === "removeText") {
            if (start.row === row && start.column < column) {
              if (end.column >= column)
                column = start.column;
              else
                column = Math.max(0, column - (end.column - start.column));
            } else if (start.row !== end.row && start.row < row) {
              if (end.row === row)
                column = Math.max(0, column - end.column) + start.column;
              row -= (end.row - start.row);
            } else if (end.row === row) {
              row -= end.row - start.row;
              column = Math.max(0, column - end.column) + start.column;
            }
          } else if (delta.action == "removeLines") {
            if (start.row <= row) {
              if (end.row <= row)
                row -= end.row - start.row;
              else {
                row = start.row;
                column = 0;
              }
            }
          }
          this.setPosition(row, column, true);
        };
        this.setPosition = function(row, column, noClip) {
          var pos;
          if (noClip) {
            pos = {
              row: row,
              column: column
            };
          } else {
            pos = this.$clipPositionToDocument(row, column);
          }
          if (this.row == pos.row && this.column == pos.column)
            return ;
          var old = {
            row: this.row,
            column: this.column
          };
          this.row = pos.row;
          this.column = pos.column;
          this._signal("change", {
            old: old,
            value: pos
          });
        };
        this.detach = function() {
          this.document.removeEventListener("change", this.$onChange);
        };
        this.attach = function(doc) {
          this.document = doc || this.document;
          this.document.on("change", this.$onChange);
        };
        this.$clipPositionToDocument = function(row, column) {
          var pos = {};
          if (row >= this.document.getLength()) {
            pos.row = Math.max(0, this.document.getLength() - 1);
            pos.column = this.document.getLine(pos.row).length;
          } else if (row < 0) {
            pos.row = 0;
            pos.column = 0;
          } else {
            pos.row = row;
            pos.column = Math.min(this.document.getLine(pos.row).length, Math.max(0, column));
          }
          if (column < 0)
            pos.column = 0;
          return pos;
        };
      }).call(Anchor.prototype);
    });
    ace.define("ace/document", ["require", "exports", "module", "ace/lib/oop", "ace/lib/event_emitter", "ace/range", "ace/anchor"], function(acequire, exports, module) {
      "use strict";
      var oop = acequire("./lib/oop");
      var EventEmitter = acequire("./lib/event_emitter").EventEmitter;
      var Range = acequire("./range").Range;
      var Anchor = acequire("./anchor").Anchor;
      var Document = function(text) {
        this.$lines = [];
        if (text.length === 0) {
          this.$lines = [""];
        } else if (Array.isArray(text)) {
          this._insertLines(0, text);
        } else {
          this.insert({
            row: 0,
            column: 0
          }, text);
        }
      };
      (function() {
        oop.implement(this, EventEmitter);
        this.setValue = function(text) {
          var len = this.getLength();
          this.remove(new Range(0, 0, len, this.getLine(len - 1).length));
          this.insert({
            row: 0,
            column: 0
          }, text);
        };
        this.getValue = function() {
          return this.getAllLines().join(this.getNewLineCharacter());
        };
        this.createAnchor = function(row, column) {
          return new Anchor(this, row, column);
        };
        if ("aaa".split(/a/).length === 0)
          this.$split = function(text) {
            return text.replace(/\r\n|\r/g, "\n").split("\n");
          };
        else
          this.$split = function(text) {
            return text.split(/\r\n|\r|\n/);
          };
        this.$detectNewLine = function(text) {
          var match = text.match(/^.*?(\r\n|\r|\n)/m);
          this.$autoNewLine = match ? match[1] : "\n";
          this._signal("changeNewLineMode");
        };
        this.getNewLineCharacter = function() {
          switch (this.$newLineMode) {
            case "windows":
              return "\r\n";
            case "unix":
              return "\n";
            default:
              return this.$autoNewLine || "\n";
          }
        };
        this.$autoNewLine = "";
        this.$newLineMode = "auto";
        this.setNewLineMode = function(newLineMode) {
          if (this.$newLineMode === newLineMode)
            return ;
          this.$newLineMode = newLineMode;
          this._signal("changeNewLineMode");
        };
        this.getNewLineMode = function() {
          return this.$newLineMode;
        };
        this.isNewLine = function(text) {
          return (text == "\r\n" || text == "\r" || text == "\n");
        };
        this.getLine = function(row) {
          return this.$lines[row] || "";
        };
        this.getLines = function(firstRow, lastRow) {
          return this.$lines.slice(firstRow, lastRow + 1);
        };
        this.getAllLines = function() {
          return this.getLines(0, this.getLength());
        };
        this.getLength = function() {
          return this.$lines.length;
        };
        this.getTextRange = function(range) {
          if (range.start.row == range.end.row) {
            return this.getLine(range.start.row).substring(range.start.column, range.end.column);
          }
          var lines = this.getLines(range.start.row, range.end.row);
          lines[0] = (lines[0] || "").substring(range.start.column);
          var l = lines.length - 1;
          if (range.end.row - range.start.row == l)
            lines[l] = lines[l].substring(0, range.end.column);
          return lines.join(this.getNewLineCharacter());
        };
        this.$clipPosition = function(position) {
          var length = this.getLength();
          if (position.row >= length) {
            position.row = Math.max(0, length - 1);
            position.column = this.getLine(length - 1).length;
          } else if (position.row < 0)
            position.row = 0;
          return position;
        };
        this.insert = function(position, text) {
          if (!text || text.length === 0)
            return position;
          position = this.$clipPosition(position);
          if (this.getLength() <= 1)
            this.$detectNewLine(text);
          var lines = this.$split(text);
          var firstLine = lines.splice(0, 1)[0];
          var lastLine = lines.length == 0 ? null : lines.splice(lines.length - 1, 1)[0];
          position = this.insertInLine(position, firstLine);
          if (lastLine !== null) {
            position = this.insertNewLine(position);
            position = this._insertLines(position.row, lines);
            position = this.insertInLine(position, lastLine || "");
          }
          return position;
        };
        this.insertLines = function(row, lines) {
          if (row >= this.getLength())
            return this.insert({
              row: row,
              column: 0
            }, "\n" + lines.join("\n"));
          return this._insertLines(Math.max(row, 0), lines);
        };
        this._insertLines = function(row, lines) {
          if (lines.length == 0)
            return {
              row: row,
              column: 0
            };
          while (lines.length > 0xF000) {
            var end = this._insertLines(row, lines.slice(0, 0xF000));
            lines = lines.slice(0xF000);
            row = end.row;
          }
          var args = [row, 0];
          args.push.apply(args, lines);
          this.$lines.splice.apply(this.$lines, args);
          var range = new Range(row, 0, row + lines.length, 0);
          var delta = {
            action: "insertLines",
            range: range,
            lines: lines
          };
          this._signal("change", {data: delta});
          return range.end;
        };
        this.insertNewLine = function(position) {
          position = this.$clipPosition(position);
          var line = this.$lines[position.row] || "";
          this.$lines[position.row] = line.substring(0, position.column);
          this.$lines.splice(position.row + 1, 0, line.substring(position.column, line.length));
          var end = {
            row: position.row + 1,
            column: 0
          };
          var delta = {
            action: "insertText",
            range: Range.fromPoints(position, end),
            text: this.getNewLineCharacter()
          };
          this._signal("change", {data: delta});
          return end;
        };
        this.insertInLine = function(position, text) {
          if (text.length == 0)
            return position;
          var line = this.$lines[position.row] || "";
          this.$lines[position.row] = line.substring(0, position.column) + text + line.substring(position.column);
          var end = {
            row: position.row,
            column: position.column + text.length
          };
          var delta = {
            action: "insertText",
            range: Range.fromPoints(position, end),
            text: text
          };
          this._signal("change", {data: delta});
          return end;
        };
        this.remove = function(range) {
          if (!(range instanceof Range))
            range = Range.fromPoints(range.start, range.end);
          range.start = this.$clipPosition(range.start);
          range.end = this.$clipPosition(range.end);
          if (range.isEmpty())
            return range.start;
          var firstRow = range.start.row;
          var lastRow = range.end.row;
          if (range.isMultiLine()) {
            var firstFullRow = range.start.column == 0 ? firstRow : firstRow + 1;
            var lastFullRow = lastRow - 1;
            if (range.end.column > 0)
              this.removeInLine(lastRow, 0, range.end.column);
            if (lastFullRow >= firstFullRow)
              this._removeLines(firstFullRow, lastFullRow);
            if (firstFullRow != firstRow) {
              this.removeInLine(firstRow, range.start.column, this.getLine(firstRow).length);
              this.removeNewLine(range.start.row);
            }
          } else {
            this.removeInLine(firstRow, range.start.column, range.end.column);
          }
          return range.start;
        };
        this.removeInLine = function(row, startColumn, endColumn) {
          if (startColumn == endColumn)
            return ;
          var range = new Range(row, startColumn, row, endColumn);
          var line = this.getLine(row);
          var removed = line.substring(startColumn, endColumn);
          var newLine = line.substring(0, startColumn) + line.substring(endColumn, line.length);
          this.$lines.splice(row, 1, newLine);
          var delta = {
            action: "removeText",
            range: range,
            text: removed
          };
          this._signal("change", {data: delta});
          return range.start;
        };
        this.removeLines = function(firstRow, lastRow) {
          if (firstRow < 0 || lastRow >= this.getLength())
            return this.remove(new Range(firstRow, 0, lastRow + 1, 0));
          return this._removeLines(firstRow, lastRow);
        };
        this._removeLines = function(firstRow, lastRow) {
          var range = new Range(firstRow, 0, lastRow + 1, 0);
          var removed = this.$lines.splice(firstRow, lastRow - firstRow + 1);
          var delta = {
            action: "removeLines",
            range: range,
            nl: this.getNewLineCharacter(),
            lines: removed
          };
          this._signal("change", {data: delta});
          return removed;
        };
        this.removeNewLine = function(row) {
          var firstLine = this.getLine(row);
          var secondLine = this.getLine(row + 1);
          var range = new Range(row, firstLine.length, row + 1, 0);
          var line = firstLine + secondLine;
          this.$lines.splice(row, 2, line);
          var delta = {
            action: "removeText",
            range: range,
            text: this.getNewLineCharacter()
          };
          this._signal("change", {data: delta});
        };
        this.replace = function(range, text) {
          if (!(range instanceof Range))
            range = Range.fromPoints(range.start, range.end);
          if (text.length == 0 && range.isEmpty())
            return range.start;
          if (text == this.getTextRange(range))
            return range.end;
          this.remove(range);
          if (text) {
            var end = this.insert(range.start, text);
          } else {
            end = range.start;
          }
          return end;
        };
        this.applyDeltas = function(deltas) {
          for (var i = 0; i < deltas.length; i++) {
            var delta = deltas[i];
            var range = Range.fromPoints(delta.range.start, delta.range.end);
            if (delta.action == "insertLines")
              this.insertLines(range.start.row, delta.lines);
            else if (delta.action == "insertText")
              this.insert(range.start, delta.text);
            else if (delta.action == "removeLines")
              this._removeLines(range.start.row, range.end.row - 1);
            else if (delta.action == "removeText")
              this.remove(range);
          }
        };
        this.revertDeltas = function(deltas) {
          for (var i = deltas.length - 1; i >= 0; i--) {
            var delta = deltas[i];
            var range = Range.fromPoints(delta.range.start, delta.range.end);
            if (delta.action == "insertLines")
              this._removeLines(range.start.row, range.end.row - 1);
            else if (delta.action == "insertText")
              this.remove(range);
            else if (delta.action == "removeLines")
              this._insertLines(range.start.row, delta.lines);
            else if (delta.action == "removeText")
              this.insert(range.start, delta.text);
          }
        };
        this.indexToPosition = function(index, startRow) {
          var lines = this.$lines || this.getAllLines();
          var newlineLength = this.getNewLineCharacter().length;
          for (var i = startRow || 0,
              l = lines.length; i < l; i++) {
            index -= lines[i].length + newlineLength;
            if (index < 0)
              return {
                row: i,
                column: index + lines[i].length + newlineLength
              };
          }
          return {
            row: l - 1,
            column: lines[l - 1].length
          };
        };
        this.positionToIndex = function(pos, startRow) {
          var lines = this.$lines || this.getAllLines();
          var newlineLength = this.getNewLineCharacter().length;
          var index = 0;
          var row = Math.min(pos.row, lines.length);
          for (var i = startRow || 0; i < row; ++i)
            index += lines[i].length + newlineLength;
          return index + pos.column;
        };
      }).call(Document.prototype);
      exports.Document = Document;
    });
    ace.define("ace/background_tokenizer", ["require", "exports", "module", "ace/lib/oop", "ace/lib/event_emitter"], function(acequire, exports, module) {
      "use strict";
      var oop = acequire("./lib/oop");
      var EventEmitter = acequire("./lib/event_emitter").EventEmitter;
      var BackgroundTokenizer = function(tokenizer, editor) {
        this.running = false;
        this.lines = [];
        this.states = [];
        this.currentLine = 0;
        this.tokenizer = tokenizer;
        var self = this;
        this.$worker = function() {
          if (!self.running) {
            return ;
          }
          var workerStart = new Date();
          var currentLine = self.currentLine;
          var endLine = -1;
          var doc = self.doc;
          while (self.lines[currentLine])
            currentLine++;
          var startLine = currentLine;
          var len = doc.getLength();
          var processedLines = 0;
          self.running = false;
          while (currentLine < len) {
            self.$tokenizeRow(currentLine);
            endLine = currentLine;
            do {
              currentLine++;
            } while (self.lines[currentLine]);
            processedLines++;
            if ((processedLines % 5 === 0) && (new Date() - workerStart) > 20) {
              self.running = setTimeout(self.$worker, 20);
              break;
            }
          }
          self.currentLine = currentLine;
          if (startLine <= endLine)
            self.fireUpdateEvent(startLine, endLine);
        };
      };
      (function() {
        oop.implement(this, EventEmitter);
        this.setTokenizer = function(tokenizer) {
          this.tokenizer = tokenizer;
          this.lines = [];
          this.states = [];
          this.start(0);
        };
        this.setDocument = function(doc) {
          this.doc = doc;
          this.lines = [];
          this.states = [];
          this.stop();
        };
        this.fireUpdateEvent = function(firstRow, lastRow) {
          var data = {
            first: firstRow,
            last: lastRow
          };
          this._signal("update", {data: data});
        };
        this.start = function(startRow) {
          this.currentLine = Math.min(startRow || 0, this.currentLine, this.doc.getLength());
          this.lines.splice(this.currentLine, this.lines.length);
          this.states.splice(this.currentLine, this.states.length);
          this.stop();
          this.running = setTimeout(this.$worker, 700);
        };
        this.scheduleStart = function() {
          if (!this.running)
            this.running = setTimeout(this.$worker, 700);
        };
        this.$updateOnChange = function(delta) {
          var range = delta.range;
          var startRow = range.start.row;
          var len = range.end.row - startRow;
          if (len === 0) {
            this.lines[startRow] = null;
          } else if (delta.action == "removeText" || delta.action == "removeLines") {
            this.lines.splice(startRow, len + 1, null);
            this.states.splice(startRow, len + 1, null);
          } else {
            var args = Array(len + 1);
            args.unshift(startRow, 1);
            this.lines.splice.apply(this.lines, args);
            this.states.splice.apply(this.states, args);
          }
          this.currentLine = Math.min(startRow, this.currentLine, this.doc.getLength());
          this.stop();
        };
        this.stop = function() {
          if (this.running)
            clearTimeout(this.running);
          this.running = false;
        };
        this.getTokens = function(row) {
          return this.lines[row] || this.$tokenizeRow(row);
        };
        this.getState = function(row) {
          if (this.currentLine == row)
            this.$tokenizeRow(row);
          return this.states[row] || "start";
        };
        this.$tokenizeRow = function(row) {
          var line = this.doc.getLine(row);
          var state = this.states[row - 1];
          var data = this.tokenizer.getLineTokens(line, state, row);
          if (this.states[row] + "" !== data.state + "") {
            this.states[row] = data.state;
            this.lines[row + 1] = null;
            if (this.currentLine > row + 1)
              this.currentLine = row + 1;
          } else if (this.currentLine == row) {
            this.currentLine = row + 1;
          }
          return this.lines[row] = data.tokens;
        };
      }).call(BackgroundTokenizer.prototype);
      exports.BackgroundTokenizer = BackgroundTokenizer;
    });
    ace.define("ace/search_highlight", ["require", "exports", "module", "ace/lib/lang", "ace/lib/oop", "ace/range"], function(acequire, exports, module) {
      "use strict";
      var lang = acequire("./lib/lang");
      var oop = acequire("./lib/oop");
      var Range = acequire("./range").Range;
      var SearchHighlight = function(regExp, clazz, type) {
        this.setRegexp(regExp);
        this.clazz = clazz;
        this.type = type || "text";
      };
      (function() {
        this.MAX_RANGES = 500;
        this.setRegexp = function(regExp) {
          if (this.regExp + "" == regExp + "")
            return ;
          this.regExp = regExp;
          this.cache = [];
        };
        this.update = function(html, markerLayer, session, config) {
          if (!this.regExp)
            return ;
          var start = config.firstRow,
              end = config.lastRow;
          for (var i = start; i <= end; i++) {
            var ranges = this.cache[i];
            if (ranges == null) {
              ranges = lang.getMatchOffsets(session.getLine(i), this.regExp);
              if (ranges.length > this.MAX_RANGES)
                ranges = ranges.slice(0, this.MAX_RANGES);
              ranges = ranges.map(function(match) {
                return new Range(i, match.offset, i, match.offset + match.length);
              });
              this.cache[i] = ranges.length ? ranges : "";
            }
            for (var j = ranges.length; j--; ) {
              markerLayer.drawSingleLineMarker(html, ranges[j].toScreenRange(session), this.clazz, config);
            }
          }
        };
      }).call(SearchHighlight.prototype);
      exports.SearchHighlight = SearchHighlight;
    });
    ace.define("ace/edit_session/fold_line", ["require", "exports", "module", "ace/range"], function(acequire, exports, module) {
      "use strict";
      var Range = acequire("../range").Range;
      function FoldLine(foldData, folds) {
        this.foldData = foldData;
        if (Array.isArray(folds)) {
          this.folds = folds;
        } else {
          folds = this.folds = [folds];
        }
        var last = folds[folds.length - 1];
        this.range = new Range(folds[0].start.row, folds[0].start.column, last.end.row, last.end.column);
        this.start = this.range.start;
        this.end = this.range.end;
        this.folds.forEach(function(fold) {
          fold.setFoldLine(this);
        }, this);
      }
      (function() {
        this.shiftRow = function(shift) {
          this.start.row += shift;
          this.end.row += shift;
          this.folds.forEach(function(fold) {
            fold.start.row += shift;
            fold.end.row += shift;
          });
        };
        this.addFold = function(fold) {
          if (fold.sameRow) {
            if (fold.start.row < this.startRow || fold.endRow > this.endRow) {
              throw new Error("Can't add a fold to this FoldLine as it has no connection");
            }
            this.folds.push(fold);
            this.folds.sort(function(a, b) {
              return -a.range.compareEnd(b.start.row, b.start.column);
            });
            if (this.range.compareEnd(fold.start.row, fold.start.column) > 0) {
              this.end.row = fold.end.row;
              this.end.column = fold.end.column;
            } else if (this.range.compareStart(fold.end.row, fold.end.column) < 0) {
              this.start.row = fold.start.row;
              this.start.column = fold.start.column;
            }
          } else if (fold.start.row == this.end.row) {
            this.folds.push(fold);
            this.end.row = fold.end.row;
            this.end.column = fold.end.column;
          } else if (fold.end.row == this.start.row) {
            this.folds.unshift(fold);
            this.start.row = fold.start.row;
            this.start.column = fold.start.column;
          } else {
            throw new Error("Trying to add fold to FoldRow that doesn't have a matching row");
          }
          fold.foldLine = this;
        };
        this.containsRow = function(row) {
          return row >= this.start.row && row <= this.end.row;
        };
        this.walk = function(callback, endRow, endColumn) {
          var lastEnd = 0,
              folds = this.folds,
              fold,
              cmp,
              stop,
              isNewRow = true;
          if (endRow == null) {
            endRow = this.end.row;
            endColumn = this.end.column;
          }
          for (var i = 0; i < folds.length; i++) {
            fold = folds[i];
            cmp = fold.range.compareStart(endRow, endColumn);
            if (cmp == -1) {
              callback(null, endRow, endColumn, lastEnd, isNewRow);
              return ;
            }
            stop = callback(null, fold.start.row, fold.start.column, lastEnd, isNewRow);
            stop = !stop && callback(fold.placeholder, fold.start.row, fold.start.column, lastEnd);
            if (stop || cmp === 0) {
              return ;
            }
            isNewRow = !fold.sameRow;
            lastEnd = fold.end.column;
          }
          callback(null, endRow, endColumn, lastEnd, isNewRow);
        };
        this.getNextFoldTo = function(row, column) {
          var fold,
              cmp;
          for (var i = 0; i < this.folds.length; i++) {
            fold = this.folds[i];
            cmp = fold.range.compareEnd(row, column);
            if (cmp == -1) {
              return {
                fold: fold,
                kind: "after"
              };
            } else if (cmp === 0) {
              return {
                fold: fold,
                kind: "inside"
              };
            }
          }
          return null;
        };
        this.addRemoveChars = function(row, column, len) {
          var ret = this.getNextFoldTo(row, column),
              fold,
              folds;
          if (ret) {
            fold = ret.fold;
            if (ret.kind == "inside" && fold.start.column != column && fold.start.row != row) {
              window.console && window.console.log(row, column, fold);
            } else if (fold.start.row == row) {
              folds = this.folds;
              var i = folds.indexOf(fold);
              if (i === 0) {
                this.start.column += len;
              }
              for (i; i < folds.length; i++) {
                fold = folds[i];
                fold.start.column += len;
                if (!fold.sameRow) {
                  return ;
                }
                fold.end.column += len;
              }
              this.end.column += len;
            }
          }
        };
        this.split = function(row, column) {
          var pos = this.getNextFoldTo(row, column);
          if (!pos || pos.kind == "inside")
            return null;
          var fold = pos.fold;
          var folds = this.folds;
          var foldData = this.foldData;
          var i = folds.indexOf(fold);
          var foldBefore = folds[i - 1];
          this.end.row = foldBefore.end.row;
          this.end.column = foldBefore.end.column;
          folds = folds.splice(i, folds.length - i);
          var newFoldLine = new FoldLine(foldData, folds);
          foldData.splice(foldData.indexOf(this) + 1, 0, newFoldLine);
          return newFoldLine;
        };
        this.merge = function(foldLineNext) {
          var folds = foldLineNext.folds;
          for (var i = 0; i < folds.length; i++) {
            this.addFold(folds[i]);
          }
          var foldData = this.foldData;
          foldData.splice(foldData.indexOf(foldLineNext), 1);
        };
        this.toString = function() {
          var ret = [this.range.toString() + ": ["];
          this.folds.forEach(function(fold) {
            ret.push("  " + fold.toString());
          });
          ret.push("]");
          return ret.join("\n");
        };
        this.idxToPosition = function(idx) {
          var lastFoldEndColumn = 0;
          for (var i = 0; i < this.folds.length; i++) {
            var fold = this.folds[i];
            idx -= fold.start.column - lastFoldEndColumn;
            if (idx < 0) {
              return {
                row: fold.start.row,
                column: fold.start.column + idx
              };
            }
            idx -= fold.placeholder.length;
            if (idx < 0) {
              return fold.start;
            }
            lastFoldEndColumn = fold.end.column;
          }
          return {
            row: this.end.row,
            column: this.end.column + idx
          };
        };
      }).call(FoldLine.prototype);
      exports.FoldLine = FoldLine;
    });
    ace.define("ace/range_list", ["require", "exports", "module", "ace/range"], function(acequire, exports, module) {
      "use strict";
      var Range = acequire("./range").Range;
      var comparePoints = Range.comparePoints;
      var RangeList = function() {
        this.ranges = [];
      };
      (function() {
        this.comparePoints = comparePoints;
        this.pointIndex = function(pos, excludeEdges, startIndex) {
          var list = this.ranges;
          for (var i = startIndex || 0; i < list.length; i++) {
            var range = list[i];
            var cmpEnd = comparePoints(pos, range.end);
            if (cmpEnd > 0)
              continue;
            var cmpStart = comparePoints(pos, range.start);
            if (cmpEnd === 0)
              return excludeEdges && cmpStart !== 0 ? -i - 2 : i;
            if (cmpStart > 0 || (cmpStart === 0 && !excludeEdges))
              return i;
            return -i - 1;
          }
          return -i - 1;
        };
        this.add = function(range) {
          var excludeEdges = !range.isEmpty();
          var startIndex = this.pointIndex(range.start, excludeEdges);
          if (startIndex < 0)
            startIndex = -startIndex - 1;
          var endIndex = this.pointIndex(range.end, excludeEdges, startIndex);
          if (endIndex < 0)
            endIndex = -endIndex - 1;
          else
            endIndex++;
          return this.ranges.splice(startIndex, endIndex - startIndex, range);
        };
        this.addList = function(list) {
          var removed = [];
          for (var i = list.length; i--; ) {
            removed.push.call(removed, this.add(list[i]));
          }
          return removed;
        };
        this.substractPoint = function(pos) {
          var i = this.pointIndex(pos);
          if (i >= 0)
            return this.ranges.splice(i, 1);
        };
        this.merge = function() {
          var removed = [];
          var list = this.ranges;
          list = list.sort(function(a, b) {
            return comparePoints(a.start, b.start);
          });
          var next = list[0],
              range;
          for (var i = 1; i < list.length; i++) {
            range = next;
            next = list[i];
            var cmp = comparePoints(range.end, next.start);
            if (cmp < 0)
              continue;
            if (cmp == 0 && !range.isEmpty() && !next.isEmpty())
              continue;
            if (comparePoints(range.end, next.end) < 0) {
              range.end.row = next.end.row;
              range.end.column = next.end.column;
            }
            list.splice(i, 1);
            removed.push(next);
            next = range;
            i--;
          }
          this.ranges = list;
          return removed;
        };
        this.contains = function(row, column) {
          return this.pointIndex({
            row: row,
            column: column
          }) >= 0;
        };
        this.containsPoint = function(pos) {
          return this.pointIndex(pos) >= 0;
        };
        this.rangeAtPoint = function(pos) {
          var i = this.pointIndex(pos);
          if (i >= 0)
            return this.ranges[i];
        };
        this.clipRows = function(startRow, endRow) {
          var list = this.ranges;
          if (list[0].start.row > endRow || list[list.length - 1].start.row < startRow)
            return [];
          var startIndex = this.pointIndex({
            row: startRow,
            column: 0
          });
          if (startIndex < 0)
            startIndex = -startIndex - 1;
          var endIndex = this.pointIndex({
            row: endRow,
            column: 0
          }, startIndex);
          if (endIndex < 0)
            endIndex = -endIndex - 1;
          var clipped = [];
          for (var i = startIndex; i < endIndex; i++) {
            clipped.push(list[i]);
          }
          return clipped;
        };
        this.removeAll = function() {
          return this.ranges.splice(0, this.ranges.length);
        };
        this.attach = function(session) {
          if (this.session)
            this.detach();
          this.session = session;
          this.onChange = this.$onChange.bind(this);
          this.session.on('change', this.onChange);
        };
        this.detach = function() {
          if (!this.session)
            return ;
          this.session.removeListener('change', this.onChange);
          this.session = null;
        };
        this.$onChange = function(e) {
          var changeRange = e.data.range;
          if (e.data.action[0] == "i") {
            var start = changeRange.start;
            var end = changeRange.end;
          } else {
            var end = changeRange.start;
            var start = changeRange.end;
          }
          var startRow = start.row;
          var endRow = end.row;
          var lineDif = endRow - startRow;
          var colDiff = -start.column + end.column;
          var ranges = this.ranges;
          for (var i = 0,
              n = ranges.length; i < n; i++) {
            var r = ranges[i];
            if (r.end.row < startRow)
              continue;
            if (r.start.row > startRow)
              break;
            if (r.start.row == startRow && r.start.column >= start.column) {
              if (r.start.column == start.column && this.$insertRight) {} else {
                r.start.column += colDiff;
                r.start.row += lineDif;
              }
            }
            if (r.end.row == startRow && r.end.column >= start.column) {
              if (r.end.column == start.column && this.$insertRight) {
                continue;
              }
              if (r.end.column == start.column && colDiff > 0 && i < n - 1) {
                if (r.end.column > r.start.column && r.end.column == ranges[i + 1].start.column)
                  r.end.column -= colDiff;
              }
              r.end.column += colDiff;
              r.end.row += lineDif;
            }
          }
          if (lineDif != 0 && i < n) {
            for (; i < n; i++) {
              var r = ranges[i];
              r.start.row += lineDif;
              r.end.row += lineDif;
            }
          }
        };
      }).call(RangeList.prototype);
      exports.RangeList = RangeList;
    });
    ace.define("ace/edit_session/fold", ["require", "exports", "module", "ace/range", "ace/range_list", "ace/lib/oop"], function(acequire, exports, module) {
      "use strict";
      var Range = acequire("../range").Range;
      var RangeList = acequire("../range_list").RangeList;
      var oop = acequire("../lib/oop");
      var Fold = exports.Fold = function(range, placeholder) {
        this.foldLine = null;
        this.placeholder = placeholder;
        this.range = range;
        this.start = range.start;
        this.end = range.end;
        this.sameRow = range.start.row == range.end.row;
        this.subFolds = this.ranges = [];
      };
      oop.inherits(Fold, RangeList);
      (function() {
        this.toString = function() {
          return '"' + this.placeholder + '" ' + this.range.toString();
        };
        this.setFoldLine = function(foldLine) {
          this.foldLine = foldLine;
          this.subFolds.forEach(function(fold) {
            fold.setFoldLine(foldLine);
          });
        };
        this.clone = function() {
          var range = this.range.clone();
          var fold = new Fold(range, this.placeholder);
          this.subFolds.forEach(function(subFold) {
            fold.subFolds.push(subFold.clone());
          });
          fold.collapseChildren = this.collapseChildren;
          return fold;
        };
        this.addSubFold = function(fold) {
          if (this.range.isEqual(fold))
            return ;
          if (!this.range.containsRange(fold))
            throw new Error("A fold can't intersect already existing fold" + fold.range + this.range);
          consumeRange(fold, this.start);
          var row = fold.start.row,
              column = fold.start.column;
          for (var i = 0,
              cmp = -1; i < this.subFolds.length; i++) {
            cmp = this.subFolds[i].range.compare(row, column);
            if (cmp != 1)
              break;
          }
          var afterStart = this.subFolds[i];
          if (cmp == 0)
            return afterStart.addSubFold(fold);
          var row = fold.range.end.row,
              column = fold.range.end.column;
          for (var j = i,
              cmp = -1; j < this.subFolds.length; j++) {
            cmp = this.subFolds[j].range.compare(row, column);
            if (cmp != 1)
              break;
          }
          var afterEnd = this.subFolds[j];
          if (cmp == 0)
            throw new Error("A fold can't intersect already existing fold" + fold.range + this.range);
          var consumedFolds = this.subFolds.splice(i, j - i, fold);
          fold.setFoldLine(this.foldLine);
          return fold;
        };
        this.restoreRange = function(range) {
          return restoreRange(range, this.start);
        };
      }).call(Fold.prototype);
      function consumePoint(point, anchor) {
        point.row -= anchor.row;
        if (point.row == 0)
          point.column -= anchor.column;
      }
      function consumeRange(range, anchor) {
        consumePoint(range.start, anchor);
        consumePoint(range.end, anchor);
      }
      function restorePoint(point, anchor) {
        if (point.row == 0)
          point.column += anchor.column;
        point.row += anchor.row;
      }
      function restoreRange(range, anchor) {
        restorePoint(range.start, anchor);
        restorePoint(range.end, anchor);
      }
    });
    ace.define("ace/edit_session/folding", ["require", "exports", "module", "ace/range", "ace/edit_session/fold_line", "ace/edit_session/fold", "ace/token_iterator"], function(acequire, exports, module) {
      "use strict";
      var Range = acequire("../range").Range;
      var FoldLine = acequire("./fold_line").FoldLine;
      var Fold = acequire("./fold").Fold;
      var TokenIterator = acequire("../token_iterator").TokenIterator;
      function Folding() {
        this.getFoldAt = function(row, column, side) {
          var foldLine = this.getFoldLine(row);
          if (!foldLine)
            return null;
          var folds = foldLine.folds;
          for (var i = 0; i < folds.length; i++) {
            var fold = folds[i];
            if (fold.range.contains(row, column)) {
              if (side == 1 && fold.range.isEnd(row, column)) {
                continue;
              } else if (side == -1 && fold.range.isStart(row, column)) {
                continue;
              }
              return fold;
            }
          }
        };
        this.getFoldsInRange = function(range) {
          var start = range.start;
          var end = range.end;
          var foldLines = this.$foldData;
          var foundFolds = [];
          start.column += 1;
          end.column -= 1;
          for (var i = 0; i < foldLines.length; i++) {
            var cmp = foldLines[i].range.compareRange(range);
            if (cmp == 2) {
              continue;
            } else if (cmp == -2) {
              break;
            }
            var folds = foldLines[i].folds;
            for (var j = 0; j < folds.length; j++) {
              var fold = folds[j];
              cmp = fold.range.compareRange(range);
              if (cmp == -2) {
                break;
              } else if (cmp == 2) {
                continue;
              } else if (cmp == 42) {
                break;
              }
              foundFolds.push(fold);
            }
          }
          start.column -= 1;
          end.column += 1;
          return foundFolds;
        };
        this.getFoldsInRangeList = function(ranges) {
          if (Array.isArray(ranges)) {
            var folds = [];
            ranges.forEach(function(range) {
              folds = folds.concat(this.getFoldsInRange(range));
            }, this);
          } else {
            var folds = this.getFoldsInRange(ranges);
          }
          return folds;
        };
        this.getAllFolds = function() {
          var folds = [];
          var foldLines = this.$foldData;
          for (var i = 0; i < foldLines.length; i++)
            for (var j = 0; j < foldLines[i].folds.length; j++)
              folds.push(foldLines[i].folds[j]);
          return folds;
        };
        this.getFoldStringAt = function(row, column, trim, foldLine) {
          foldLine = foldLine || this.getFoldLine(row);
          if (!foldLine)
            return null;
          var lastFold = {end: {column: 0}};
          var str,
              fold;
          for (var i = 0; i < foldLine.folds.length; i++) {
            fold = foldLine.folds[i];
            var cmp = fold.range.compareEnd(row, column);
            if (cmp == -1) {
              str = this.getLine(fold.start.row).substring(lastFold.end.column, fold.start.column);
              break;
            } else if (cmp === 0) {
              return null;
            }
            lastFold = fold;
          }
          if (!str)
            str = this.getLine(fold.start.row).substring(lastFold.end.column);
          if (trim == -1)
            return str.substring(0, column - lastFold.end.column);
          else if (trim == 1)
            return str.substring(column - lastFold.end.column);
          else
            return str;
        };
        this.getFoldLine = function(docRow, startFoldLine) {
          var foldData = this.$foldData;
          var i = 0;
          if (startFoldLine)
            i = foldData.indexOf(startFoldLine);
          if (i == -1)
            i = 0;
          for (i; i < foldData.length; i++) {
            var foldLine = foldData[i];
            if (foldLine.start.row <= docRow && foldLine.end.row >= docRow) {
              return foldLine;
            } else if (foldLine.end.row > docRow) {
              return null;
            }
          }
          return null;
        };
        this.getNextFoldLine = function(docRow, startFoldLine) {
          var foldData = this.$foldData;
          var i = 0;
          if (startFoldLine)
            i = foldData.indexOf(startFoldLine);
          if (i == -1)
            i = 0;
          for (i; i < foldData.length; i++) {
            var foldLine = foldData[i];
            if (foldLine.end.row >= docRow) {
              return foldLine;
            }
          }
          return null;
        };
        this.getFoldedRowCount = function(first, last) {
          var foldData = this.$foldData,
              rowCount = last - first + 1;
          for (var i = 0; i < foldData.length; i++) {
            var foldLine = foldData[i],
                end = foldLine.end.row,
                start = foldLine.start.row;
            if (end >= last) {
              if (start < last) {
                if (start >= first)
                  rowCount -= last - start;
                else
                  rowCount = 0;
              }
              break;
            } else if (end >= first) {
              if (start >= first)
                rowCount -= end - start;
              else
                rowCount -= end - first + 1;
            }
          }
          return rowCount;
        };
        this.$addFoldLine = function(foldLine) {
          this.$foldData.push(foldLine);
          this.$foldData.sort(function(a, b) {
            return a.start.row - b.start.row;
          });
          return foldLine;
        };
        this.addFold = function(placeholder, range) {
          var foldData = this.$foldData;
          var added = false;
          var fold;
          if (placeholder instanceof Fold)
            fold = placeholder;
          else {
            fold = new Fold(range, placeholder);
            fold.collapseChildren = range.collapseChildren;
          }
          this.$clipRangeToDocument(fold.range);
          var startRow = fold.start.row;
          var startColumn = fold.start.column;
          var endRow = fold.end.row;
          var endColumn = fold.end.column;
          if (!(startRow < endRow || startRow == endRow && startColumn <= endColumn - 2))
            throw new Error("The range has to be at least 2 characters width");
          var startFold = this.getFoldAt(startRow, startColumn, 1);
          var endFold = this.getFoldAt(endRow, endColumn, -1);
          if (startFold && endFold == startFold)
            return startFold.addSubFold(fold);
          if (startFold && !startFold.range.isStart(startRow, startColumn))
            this.removeFold(startFold);
          if (endFold && !endFold.range.isEnd(endRow, endColumn))
            this.removeFold(endFold);
          var folds = this.getFoldsInRange(fold.range);
          if (folds.length > 0) {
            this.removeFolds(folds);
            folds.forEach(function(subFold) {
              fold.addSubFold(subFold);
            });
          }
          for (var i = 0; i < foldData.length; i++) {
            var foldLine = foldData[i];
            if (endRow == foldLine.start.row) {
              foldLine.addFold(fold);
              added = true;
              break;
            } else if (startRow == foldLine.end.row) {
              foldLine.addFold(fold);
              added = true;
              if (!fold.sameRow) {
                var foldLineNext = foldData[i + 1];
                if (foldLineNext && foldLineNext.start.row == endRow) {
                  foldLine.merge(foldLineNext);
                  break;
                }
              }
              break;
            } else if (endRow <= foldLine.start.row) {
              break;
            }
          }
          if (!added)
            foldLine = this.$addFoldLine(new FoldLine(this.$foldData, fold));
          if (this.$useWrapMode)
            this.$updateWrapData(foldLine.start.row, foldLine.start.row);
          else
            this.$updateRowLengthCache(foldLine.start.row, foldLine.start.row);
          this.$modified = true;
          this._emit("changeFold", {
            data: fold,
            action: "add"
          });
          return fold;
        };
        this.addFolds = function(folds) {
          folds.forEach(function(fold) {
            this.addFold(fold);
          }, this);
        };
        this.removeFold = function(fold) {
          var foldLine = fold.foldLine;
          var startRow = foldLine.start.row;
          var endRow = foldLine.end.row;
          var foldLines = this.$foldData;
          var folds = foldLine.folds;
          if (folds.length == 1) {
            foldLines.splice(foldLines.indexOf(foldLine), 1);
          } else if (foldLine.range.isEnd(fold.end.row, fold.end.column)) {
            folds.pop();
            foldLine.end.row = folds[folds.length - 1].end.row;
            foldLine.end.column = folds[folds.length - 1].end.column;
          } else if (foldLine.range.isStart(fold.start.row, fold.start.column)) {
            folds.shift();
            foldLine.start.row = folds[0].start.row;
            foldLine.start.column = folds[0].start.column;
          } else if (fold.sameRow) {
            folds.splice(folds.indexOf(fold), 1);
          } else {
            var newFoldLine = foldLine.split(fold.start.row, fold.start.column);
            folds = newFoldLine.folds;
            folds.shift();
            newFoldLine.start.row = folds[0].start.row;
            newFoldLine.start.column = folds[0].start.column;
          }
          if (!this.$updating) {
            if (this.$useWrapMode)
              this.$updateWrapData(startRow, endRow);
            else
              this.$updateRowLengthCache(startRow, endRow);
          }
          this.$modified = true;
          this._emit("changeFold", {
            data: fold,
            action: "remove"
          });
        };
        this.removeFolds = function(folds) {
          var cloneFolds = [];
          for (var i = 0; i < folds.length; i++) {
            cloneFolds.push(folds[i]);
          }
          cloneFolds.forEach(function(fold) {
            this.removeFold(fold);
          }, this);
          this.$modified = true;
        };
        this.expandFold = function(fold) {
          this.removeFold(fold);
          fold.subFolds.forEach(function(subFold) {
            fold.restoreRange(subFold);
            this.addFold(subFold);
          }, this);
          if (fold.collapseChildren > 0) {
            this.foldAll(fold.start.row + 1, fold.end.row, fold.collapseChildren - 1);
          }
          fold.subFolds = [];
        };
        this.expandFolds = function(folds) {
          folds.forEach(function(fold) {
            this.expandFold(fold);
          }, this);
        };
        this.unfold = function(location, expandInner) {
          var range,
              folds;
          if (location == null) {
            range = new Range(0, 0, this.getLength(), 0);
            expandInner = true;
          } else if (typeof location == "number")
            range = new Range(location, 0, location, this.getLine(location).length);
          else if ("row" in location)
            range = Range.fromPoints(location, location);
          else
            range = location;
          folds = this.getFoldsInRangeList(range);
          if (expandInner) {
            this.removeFolds(folds);
          } else {
            var subFolds = folds;
            while (subFolds.length) {
              this.expandFolds(subFolds);
              subFolds = this.getFoldsInRangeList(range);
            }
          }
          if (folds.length)
            return folds;
        };
        this.isRowFolded = function(docRow, startFoldRow) {
          return !!this.getFoldLine(docRow, startFoldRow);
        };
        this.getRowFoldEnd = function(docRow, startFoldRow) {
          var foldLine = this.getFoldLine(docRow, startFoldRow);
          return foldLine ? foldLine.end.row : docRow;
        };
        this.getRowFoldStart = function(docRow, startFoldRow) {
          var foldLine = this.getFoldLine(docRow, startFoldRow);
          return foldLine ? foldLine.start.row : docRow;
        };
        this.getFoldDisplayLine = function(foldLine, endRow, endColumn, startRow, startColumn) {
          if (startRow == null)
            startRow = foldLine.start.row;
          if (startColumn == null)
            startColumn = 0;
          if (endRow == null)
            endRow = foldLine.end.row;
          if (endColumn == null)
            endColumn = this.getLine(endRow).length;
          var doc = this.doc;
          var textLine = "";
          foldLine.walk(function(placeholder, row, column, lastColumn) {
            if (row < startRow)
              return ;
            if (row == startRow) {
              if (column < startColumn)
                return ;
              lastColumn = Math.max(startColumn, lastColumn);
            }
            if (placeholder != null) {
              textLine += placeholder;
            } else {
              textLine += doc.getLine(row).substring(lastColumn, column);
            }
          }, endRow, endColumn);
          return textLine;
        };
        this.getDisplayLine = function(row, endColumn, startRow, startColumn) {
          var foldLine = this.getFoldLine(row);
          if (!foldLine) {
            var line;
            line = this.doc.getLine(row);
            return line.substring(startColumn || 0, endColumn || line.length);
          } else {
            return this.getFoldDisplayLine(foldLine, row, endColumn, startRow, startColumn);
          }
        };
        this.$cloneFoldData = function() {
          var fd = [];
          fd = this.$foldData.map(function(foldLine) {
            var folds = foldLine.folds.map(function(fold) {
              return fold.clone();
            });
            return new FoldLine(fd, folds);
          });
          return fd;
        };
        this.toggleFold = function(tryToUnfold) {
          var selection = this.selection;
          var range = selection.getRange();
          var fold;
          var bracketPos;
          if (range.isEmpty()) {
            var cursor = range.start;
            fold = this.getFoldAt(cursor.row, cursor.column);
            if (fold) {
              this.expandFold(fold);
              return ;
            } else if (bracketPos = this.findMatchingBracket(cursor)) {
              if (range.comparePoint(bracketPos) == 1) {
                range.end = bracketPos;
              } else {
                range.start = bracketPos;
                range.start.column++;
                range.end.column--;
              }
            } else if (bracketPos = this.findMatchingBracket({
              row: cursor.row,
              column: cursor.column + 1
            })) {
              if (range.comparePoint(bracketPos) == 1)
                range.end = bracketPos;
              else
                range.start = bracketPos;
              range.start.column++;
            } else {
              range = this.getCommentFoldRange(cursor.row, cursor.column) || range;
            }
          } else {
            var folds = this.getFoldsInRange(range);
            if (tryToUnfold && folds.length) {
              this.expandFolds(folds);
              return ;
            } else if (folds.length == 1) {
              fold = folds[0];
            }
          }
          if (!fold)
            fold = this.getFoldAt(range.start.row, range.start.column);
          if (fold && fold.range.toString() == range.toString()) {
            this.expandFold(fold);
            return ;
          }
          var placeholder = "...";
          if (!range.isMultiLine()) {
            placeholder = this.getTextRange(range);
            if (placeholder.length < 4)
              return ;
            placeholder = placeholder.trim().substring(0, 2) + "..";
          }
          this.addFold(placeholder, range);
        };
        this.getCommentFoldRange = function(row, column, dir) {
          var iterator = new TokenIterator(this, row, column);
          var token = iterator.getCurrentToken();
          if (token && /^comment|string/.test(token.type)) {
            var range = new Range();
            var re = new RegExp(token.type.replace(/\..*/, "\\."));
            if (dir != 1) {
              do {
                token = iterator.stepBackward();
              } while (token && re.test(token.type));
              iterator.stepForward();
            }
            range.start.row = iterator.getCurrentTokenRow();
            range.start.column = iterator.getCurrentTokenColumn() + 2;
            iterator = new TokenIterator(this, row, column);
            if (dir != -1) {
              do {
                token = iterator.stepForward();
              } while (token && re.test(token.type));
              token = iterator.stepBackward();
            } else
              token = iterator.getCurrentToken();
            range.end.row = iterator.getCurrentTokenRow();
            range.end.column = iterator.getCurrentTokenColumn() + token.value.length - 2;
            return range;
          }
        };
        this.foldAll = function(startRow, endRow, depth) {
          if (depth == undefined)
            depth = 100000;
          var foldWidgets = this.foldWidgets;
          if (!foldWidgets)
            return ;
          endRow = endRow || this.getLength();
          startRow = startRow || 0;
          for (var row = startRow; row < endRow; row++) {
            if (foldWidgets[row] == null)
              foldWidgets[row] = this.getFoldWidget(row);
            if (foldWidgets[row] != "start")
              continue;
            var range = this.getFoldWidgetRange(row);
            if (range && range.isMultiLine() && range.end.row <= endRow && range.start.row >= startRow) {
              row = range.end.row;
              try {
                var fold = this.addFold("...", range);
                if (fold)
                  fold.collapseChildren = depth;
              } catch (e) {}
            }
          }
        };
        this.$foldStyles = {
          "manual": 1,
          "markbegin": 1,
          "markbeginend": 1
        };
        this.$foldStyle = "markbegin";
        this.setFoldStyle = function(style) {
          if (!this.$foldStyles[style])
            throw new Error("invalid fold style: " + style + "[" + Object.keys(this.$foldStyles).join(", ") + "]");
          if (this.$foldStyle == style)
            return ;
          this.$foldStyle = style;
          if (style == "manual")
            this.unfold();
          var mode = this.$foldMode;
          this.$setFolding(null);
          this.$setFolding(mode);
        };
        this.$setFolding = function(foldMode) {
          if (this.$foldMode == foldMode)
            return ;
          this.$foldMode = foldMode;
          this.removeListener('change', this.$updateFoldWidgets);
          this._emit("changeAnnotation");
          if (!foldMode || this.$foldStyle == "manual") {
            this.foldWidgets = null;
            return ;
          }
          this.foldWidgets = [];
          this.getFoldWidget = foldMode.getFoldWidget.bind(foldMode, this, this.$foldStyle);
          this.getFoldWidgetRange = foldMode.getFoldWidgetRange.bind(foldMode, this, this.$foldStyle);
          this.$updateFoldWidgets = this.updateFoldWidgets.bind(this);
          this.on('change', this.$updateFoldWidgets);
        };
        this.getParentFoldRangeData = function(row, ignoreCurrent) {
          var fw = this.foldWidgets;
          if (!fw || (ignoreCurrent && fw[row]))
            return {};
          var i = row - 1,
              firstRange;
          while (i >= 0) {
            var c = fw[i];
            if (c == null)
              c = fw[i] = this.getFoldWidget(i);
            if (c == "start") {
              var range = this.getFoldWidgetRange(i);
              if (!firstRange)
                firstRange = range;
              if (range && range.end.row >= row)
                break;
            }
            i--;
          }
          return {
            range: i !== -1 && range,
            firstRange: firstRange
          };
        };
        this.onFoldWidgetClick = function(row, e) {
          e = e.domEvent;
          var options = {
            children: e.shiftKey,
            all: e.ctrlKey || e.metaKey,
            siblings: e.altKey
          };
          var range = this.$toggleFoldWidget(row, options);
          if (!range) {
            var el = (e.target || e.srcElement);
            if (el && /ace_fold-widget/.test(el.className))
              el.className += " ace_invalid";
          }
        };
        this.$toggleFoldWidget = function(row, options) {
          if (!this.getFoldWidget)
            return ;
          var type = this.getFoldWidget(row);
          var line = this.getLine(row);
          var dir = type === "end" ? -1 : 1;
          var fold = this.getFoldAt(row, dir === -1 ? 0 : line.length, dir);
          if (fold) {
            if (options.children || options.all)
              this.removeFold(fold);
            else
              this.expandFold(fold);
            return ;
          }
          var range = this.getFoldWidgetRange(row, true);
          if (range && !range.isMultiLine()) {
            fold = this.getFoldAt(range.start.row, range.start.column, 1);
            if (fold && range.isEqual(fold.range)) {
              this.removeFold(fold);
              return ;
            }
          }
          if (options.siblings) {
            var data = this.getParentFoldRangeData(row);
            if (data.range) {
              var startRow = data.range.start.row + 1;
              var endRow = data.range.end.row;
            }
            this.foldAll(startRow, endRow, options.all ? 10000 : 0);
          } else if (options.children) {
            endRow = range ? range.end.row : this.getLength();
            this.foldAll(row + 1, range.end.row, options.all ? 10000 : 0);
          } else if (range) {
            if (options.all)
              range.collapseChildren = 10000;
            this.addFold("...", range);
          }
          return range;
        };
        this.toggleFoldWidget = function(toggleParent) {
          var row = this.selection.getCursor().row;
          row = this.getRowFoldStart(row);
          var range = this.$toggleFoldWidget(row, {});
          if (range)
            return ;
          var data = this.getParentFoldRangeData(row, true);
          range = data.range || data.firstRange;
          if (range) {
            row = range.start.row;
            var fold = this.getFoldAt(row, this.getLine(row).length, 1);
            if (fold) {
              this.removeFold(fold);
            } else {
              this.addFold("...", range);
            }
          }
        };
        this.updateFoldWidgets = function(e) {
          var delta = e.data;
          var range = delta.range;
          var firstRow = range.start.row;
          var len = range.end.row - firstRow;
          if (len === 0) {
            this.foldWidgets[firstRow] = null;
          } else if (delta.action == "removeText" || delta.action == "removeLines") {
            this.foldWidgets.splice(firstRow, len + 1, null);
          } else {
            var args = Array(len + 1);
            args.unshift(firstRow, 1);
            this.foldWidgets.splice.apply(this.foldWidgets, args);
          }
        };
      }
      exports.Folding = Folding;
    });
    ace.define("ace/edit_session/bracket_match", ["require", "exports", "module", "ace/token_iterator", "ace/range"], function(acequire, exports, module) {
      "use strict";
      var TokenIterator = acequire("../token_iterator").TokenIterator;
      var Range = acequire("../range").Range;
      function BracketMatch() {
        this.findMatchingBracket = function(position, chr) {
          if (position.column == 0)
            return null;
          var charBeforeCursor = chr || this.getLine(position.row).charAt(position.column - 1);
          if (charBeforeCursor == "")
            return null;
          var match = charBeforeCursor.match(/([\(\[\{])|([\)\]\}])/);
          if (!match)
            return null;
          if (match[1])
            return this.$findClosingBracket(match[1], position);
          else
            return this.$findOpeningBracket(match[2], position);
        };
        this.getBracketRange = function(pos) {
          var line = this.getLine(pos.row);
          var before = true,
              range;
          var chr = line.charAt(pos.column - 1);
          var match = chr && chr.match(/([\(\[\{])|([\)\]\}])/);
          if (!match) {
            chr = line.charAt(pos.column);
            pos = {
              row: pos.row,
              column: pos.column + 1
            };
            match = chr && chr.match(/([\(\[\{])|([\)\]\}])/);
            before = false;
          }
          if (!match)
            return null;
          if (match[1]) {
            var bracketPos = this.$findClosingBracket(match[1], pos);
            if (!bracketPos)
              return null;
            range = Range.fromPoints(pos, bracketPos);
            if (!before) {
              range.end.column++;
              range.start.column--;
            }
            range.cursor = range.end;
          } else {
            var bracketPos = this.$findOpeningBracket(match[2], pos);
            if (!bracketPos)
              return null;
            range = Range.fromPoints(bracketPos, pos);
            if (!before) {
              range.start.column++;
              range.end.column--;
            }
            range.cursor = range.start;
          }
          return range;
        };
        this.$brackets = {
          ")": "(",
          "(": ")",
          "]": "[",
          "[": "]",
          "{": "}",
          "}": "{"
        };
        this.$findOpeningBracket = function(bracket, position, typeRe) {
          var openBracket = this.$brackets[bracket];
          var depth = 1;
          var iterator = new TokenIterator(this, position.row, position.column);
          var token = iterator.getCurrentToken();
          if (!token)
            token = iterator.stepForward();
          if (!token)
            return ;
          if (!typeRe) {
            typeRe = new RegExp("(\\.?" + token.type.replace(".", "\\.").replace("rparen", ".paren").replace(/\b(?:end|start|begin)\b/, "") + ")+");
          }
          var valueIndex = position.column - iterator.getCurrentTokenColumn() - 2;
          var value = token.value;
          while (true) {
            while (valueIndex >= 0) {
              var chr = value.charAt(valueIndex);
              if (chr == openBracket) {
                depth -= 1;
                if (depth == 0) {
                  return {
                    row: iterator.getCurrentTokenRow(),
                    column: valueIndex + iterator.getCurrentTokenColumn()
                  };
                }
              } else if (chr == bracket) {
                depth += 1;
              }
              valueIndex -= 1;
            }
            do {
              token = iterator.stepBackward();
            } while (token && !typeRe.test(token.type));
            if (token == null)
              break;
            value = token.value;
            valueIndex = value.length - 1;
          }
          return null;
        };
        this.$findClosingBracket = function(bracket, position, typeRe) {
          var closingBracket = this.$brackets[bracket];
          var depth = 1;
          var iterator = new TokenIterator(this, position.row, position.column);
          var token = iterator.getCurrentToken();
          if (!token)
            token = iterator.stepForward();
          if (!token)
            return ;
          if (!typeRe) {
            typeRe = new RegExp("(\\.?" + token.type.replace(".", "\\.").replace("lparen", ".paren").replace(/\b(?:end|start|begin)\b/, "") + ")+");
          }
          var valueIndex = position.column - iterator.getCurrentTokenColumn();
          while (true) {
            var value = token.value;
            var valueLength = value.length;
            while (valueIndex < valueLength) {
              var chr = value.charAt(valueIndex);
              if (chr == closingBracket) {
                depth -= 1;
                if (depth == 0) {
                  return {
                    row: iterator.getCurrentTokenRow(),
                    column: valueIndex + iterator.getCurrentTokenColumn()
                  };
                }
              } else if (chr == bracket) {
                depth += 1;
              }
              valueIndex += 1;
            }
            do {
              token = iterator.stepForward();
            } while (token && !typeRe.test(token.type));
            if (token == null)
              break;
            valueIndex = 0;
          }
          return null;
        };
      }
      exports.BracketMatch = BracketMatch;
    });
    ace.define("ace/edit_session", ["require", "exports", "module", "ace/lib/oop", "ace/lib/lang", "ace/config", "ace/lib/event_emitter", "ace/selection", "ace/mode/text", "ace/range", "ace/document", "ace/background_tokenizer", "ace/search_highlight", "ace/edit_session/folding", "ace/edit_session/bracket_match"], function(acequire, exports, module) {
      "use strict";
      var oop = acequire("./lib/oop");
      var lang = acequire("./lib/lang");
      var config = acequire("./config");
      var EventEmitter = acequire("./lib/event_emitter").EventEmitter;
      var Selection = acequire("./selection").Selection;
      var TextMode = acequire("./mode/text").Mode;
      var Range = acequire("./range").Range;
      var Document = acequire("./document").Document;
      var BackgroundTokenizer = acequire("./background_tokenizer").BackgroundTokenizer;
      var SearchHighlight = acequire("./search_highlight").SearchHighlight;
      var EditSession = function(text, mode) {
        this.$breakpoints = [];
        this.$decorations = [];
        this.$frontMarkers = {};
        this.$backMarkers = {};
        this.$markerId = 1;
        this.$undoSelect = true;
        this.$foldData = [];
        this.$foldData.toString = function() {
          return this.join("\n");
        };
        this.on("changeFold", this.onChangeFold.bind(this));
        this.$onChange = this.onChange.bind(this);
        if (typeof text != "object" || !text.getLine)
          text = new Document(text);
        this.setDocument(text);
        this.selection = new Selection(this);
        config.resetOptions(this);
        this.setMode(mode);
        config._signal("session", this);
      };
      (function() {
        oop.implement(this, EventEmitter);
        this.setDocument = function(doc) {
          if (this.doc)
            this.doc.removeListener("change", this.$onChange);
          this.doc = doc;
          doc.on("change", this.$onChange);
          if (this.bgTokenizer)
            this.bgTokenizer.setDocument(this.getDocument());
          this.resetCaches();
        };
        this.getDocument = function() {
          return this.doc;
        };
        this.$resetRowCache = function(docRow) {
          if (!docRow) {
            this.$docRowCache = [];
            this.$screenRowCache = [];
            return ;
          }
          var l = this.$docRowCache.length;
          var i = this.$getRowCacheIndex(this.$docRowCache, docRow) + 1;
          if (l > i) {
            this.$docRowCache.splice(i, l);
            this.$screenRowCache.splice(i, l);
          }
        };
        this.$getRowCacheIndex = function(cacheArray, val) {
          var low = 0;
          var hi = cacheArray.length - 1;
          while (low <= hi) {
            var mid = (low + hi) >> 1;
            var c = cacheArray[mid];
            if (val > c)
              low = mid + 1;
            else if (val < c)
              hi = mid - 1;
            else
              return mid;
          }
          return low - 1;
        };
        this.resetCaches = function() {
          this.$modified = true;
          this.$wrapData = [];
          this.$rowLengthCache = [];
          this.$resetRowCache(0);
          if (this.bgTokenizer)
            this.bgTokenizer.start(0);
        };
        this.onChangeFold = function(e) {
          var fold = e.data;
          this.$resetRowCache(fold.start.row);
        };
        this.onChange = function(e) {
          var delta = e.data;
          this.$modified = true;
          this.$resetRowCache(delta.range.start.row);
          var removedFolds = this.$updateInternalDataOnChange(e);
          if (!this.$fromUndo && this.$undoManager && !delta.ignore) {
            this.$deltasDoc.push(delta);
            if (removedFolds && removedFolds.length != 0) {
              this.$deltasFold.push({
                action: "removeFolds",
                folds: removedFolds
              });
            }
            this.$informUndoManager.schedule();
          }
          this.bgTokenizer && this.bgTokenizer.$updateOnChange(delta);
          this._signal("change", e);
        };
        this.setValue = function(text) {
          this.doc.setValue(text);
          this.selection.moveTo(0, 0);
          this.$resetRowCache(0);
          this.$deltas = [];
          this.$deltasDoc = [];
          this.$deltasFold = [];
          this.setUndoManager(this.$undoManager);
          this.getUndoManager().reset();
        };
        this.getValue = this.toString = function() {
          return this.doc.getValue();
        };
        this.getSelection = function() {
          return this.selection;
        };
        this.getState = function(row) {
          return this.bgTokenizer.getState(row);
        };
        this.getTokens = function(row) {
          return this.bgTokenizer.getTokens(row);
        };
        this.getTokenAt = function(row, column) {
          var tokens = this.bgTokenizer.getTokens(row);
          var token,
              c = 0;
          if (column == null) {
            i = tokens.length - 1;
            c = this.getLine(row).length;
          } else {
            for (var i = 0; i < tokens.length; i++) {
              c += tokens[i].value.length;
              if (c >= column)
                break;
            }
          }
          token = tokens[i];
          if (!token)
            return null;
          token.index = i;
          token.start = c - token.value.length;
          return token;
        };
        this.setUndoManager = function(undoManager) {
          this.$undoManager = undoManager;
          this.$deltas = [];
          this.$deltasDoc = [];
          this.$deltasFold = [];
          if (this.$informUndoManager)
            this.$informUndoManager.cancel();
          if (undoManager) {
            var self = this;
            this.$syncInformUndoManager = function() {
              self.$informUndoManager.cancel();
              if (self.$deltasFold.length) {
                self.$deltas.push({
                  group: "fold",
                  deltas: self.$deltasFold
                });
                self.$deltasFold = [];
              }
              if (self.$deltasDoc.length) {
                self.$deltas.push({
                  group: "doc",
                  deltas: self.$deltasDoc
                });
                self.$deltasDoc = [];
              }
              if (self.$deltas.length > 0) {
                undoManager.execute({
                  action: "aceupdate",
                  args: [self.$deltas, self],
                  merge: self.mergeUndoDeltas
                });
              }
              self.mergeUndoDeltas = false;
              self.$deltas = [];
            };
            this.$informUndoManager = lang.delayedCall(this.$syncInformUndoManager);
          }
        };
        this.markUndoGroup = function() {
          if (this.$syncInformUndoManager)
            this.$syncInformUndoManager();
        };
        this.$defaultUndoManager = {
          undo: function() {},
          redo: function() {},
          reset: function() {}
        };
        this.getUndoManager = function() {
          return this.$undoManager || this.$defaultUndoManager;
        };
        this.getTabString = function() {
          if (this.getUseSoftTabs()) {
            return lang.stringRepeat(" ", this.getTabSize());
          } else {
            return "\t";
          }
        };
        this.setUseSoftTabs = function(val) {
          this.setOption("useSoftTabs", val);
        };
        this.getUseSoftTabs = function() {
          return this.$useSoftTabs && !this.$mode.$indentWithTabs;
        };
        this.setTabSize = function(tabSize) {
          this.setOption("tabSize", tabSize);
        };
        this.getTabSize = function() {
          return this.$tabSize;
        };
        this.isTabStop = function(position) {
          return this.$useSoftTabs && (position.column % this.$tabSize === 0);
        };
        this.$overwrite = false;
        this.setOverwrite = function(overwrite) {
          this.setOption("overwrite", overwrite);
        };
        this.getOverwrite = function() {
          return this.$overwrite;
        };
        this.toggleOverwrite = function() {
          this.setOverwrite(!this.$overwrite);
        };
        this.addGutterDecoration = function(row, className) {
          if (!this.$decorations[row])
            this.$decorations[row] = "";
          this.$decorations[row] += " " + className;
          this._signal("changeBreakpoint", {});
        };
        this.removeGutterDecoration = function(row, className) {
          this.$decorations[row] = (this.$decorations[row] || "").replace(" " + className, "");
          this._signal("changeBreakpoint", {});
        };
        this.getBreakpoints = function() {
          return this.$breakpoints;
        };
        this.setBreakpoints = function(rows) {
          this.$breakpoints = [];
          for (var i = 0; i < rows.length; i++) {
            this.$breakpoints[rows[i]] = "ace_breakpoint";
          }
          this._signal("changeBreakpoint", {});
        };
        this.clearBreakpoints = function() {
          this.$breakpoints = [];
          this._signal("changeBreakpoint", {});
        };
        this.setBreakpoint = function(row, className) {
          if (className === undefined)
            className = "ace_breakpoint";
          if (className)
            this.$breakpoints[row] = className;
          else
            delete this.$breakpoints[row];
          this._signal("changeBreakpoint", {});
        };
        this.clearBreakpoint = function(row) {
          delete this.$breakpoints[row];
          this._signal("changeBreakpoint", {});
        };
        this.addMarker = function(range, clazz, type, inFront) {
          var id = this.$markerId++;
          var marker = {
            range: range,
            type: type || "line",
            renderer: typeof type == "function" ? type : null,
            clazz: clazz,
            inFront: !!inFront,
            id: id
          };
          if (inFront) {
            this.$frontMarkers[id] = marker;
            this._signal("changeFrontMarker");
          } else {
            this.$backMarkers[id] = marker;
            this._signal("changeBackMarker");
          }
          return id;
        };
        this.addDynamicMarker = function(marker, inFront) {
          if (!marker.update)
            return ;
          var id = this.$markerId++;
          marker.id = id;
          marker.inFront = !!inFront;
          if (inFront) {
            this.$frontMarkers[id] = marker;
            this._signal("changeFrontMarker");
          } else {
            this.$backMarkers[id] = marker;
            this._signal("changeBackMarker");
          }
          return marker;
        };
        this.removeMarker = function(markerId) {
          var marker = this.$frontMarkers[markerId] || this.$backMarkers[markerId];
          if (!marker)
            return ;
          var markers = marker.inFront ? this.$frontMarkers : this.$backMarkers;
          if (marker) {
            delete(markers[markerId]);
            this._signal(marker.inFront ? "changeFrontMarker" : "changeBackMarker");
          }
        };
        this.getMarkers = function(inFront) {
          return inFront ? this.$frontMarkers : this.$backMarkers;
        };
        this.highlight = function(re) {
          if (!this.$searchHighlight) {
            var highlight = new SearchHighlight(null, "ace_selected-word", "text");
            this.$searchHighlight = this.addDynamicMarker(highlight);
          }
          this.$searchHighlight.setRegexp(re);
        };
        this.highlightLines = function(startRow, endRow, clazz, inFront) {
          if (typeof endRow != "number") {
            clazz = endRow;
            endRow = startRow;
          }
          if (!clazz)
            clazz = "ace_step";
          var range = new Range(startRow, 0, endRow, Infinity);
          range.id = this.addMarker(range, clazz, "fullLine", inFront);
          return range;
        };
        this.setAnnotations = function(annotations) {
          this.$annotations = annotations;
          this._signal("changeAnnotation", {});
        };
        this.getAnnotations = function() {
          return this.$annotations || [];
        };
        this.clearAnnotations = function() {
          this.setAnnotations([]);
        };
        this.$detectNewLine = function(text) {
          var match = text.match(/^.*?(\r?\n)/m);
          if (match) {
            this.$autoNewLine = match[1];
          } else {
            this.$autoNewLine = "\n";
          }
        };
        this.getWordRange = function(row, column) {
          var line = this.getLine(row);
          var inToken = false;
          if (column > 0)
            inToken = !!line.charAt(column - 1).match(this.tokenRe);
          if (!inToken)
            inToken = !!line.charAt(column).match(this.tokenRe);
          if (inToken)
            var re = this.tokenRe;
          else if (/^\s+$/.test(line.slice(column - 1, column + 1)))
            var re = /\s/;
          else
            var re = this.nonTokenRe;
          var start = column;
          if (start > 0) {
            do {
              start--;
            } while (start >= 0 && line.charAt(start).match(re));
            start++;
          }
          var end = column;
          while (end < line.length && line.charAt(end).match(re)) {
            end++;
          }
          return new Range(row, start, row, end);
        };
        this.getAWordRange = function(row, column) {
          var wordRange = this.getWordRange(row, column);
          var line = this.getLine(wordRange.end.row);
          while (line.charAt(wordRange.end.column).match(/[ \t]/)) {
            wordRange.end.column += 1;
          }
          return wordRange;
        };
        this.setNewLineMode = function(newLineMode) {
          this.doc.setNewLineMode(newLineMode);
        };
        this.getNewLineMode = function() {
          return this.doc.getNewLineMode();
        };
        this.setUseWorker = function(useWorker) {
          this.setOption("useWorker", useWorker);
        };
        this.getUseWorker = function() {
          return this.$useWorker;
        };
        this.onReloadTokenizer = function(e) {
          var rows = e.data;
          this.bgTokenizer.start(rows.first);
          this._signal("tokenizerUpdate", e);
        };
        this.$modes = {};
        this.$mode = null;
        this.$modeId = null;
        this.setMode = function(mode, cb) {
          if (mode && typeof mode === "object") {
            if (mode.getTokenizer)
              return this.$onChangeMode(mode);
            var options = mode;
            var path = options.path;
          } else {
            path = mode || "ace/mode/text";
          }
          if (!this.$modes["ace/mode/text"])
            this.$modes["ace/mode/text"] = new TextMode();
          if (this.$modes[path] && !options) {
            this.$onChangeMode(this.$modes[path]);
            cb && cb();
            return ;
          }
          this.$modeId = path;
          config.loadModule(["mode", path], function(m) {
            if (this.$modeId !== path)
              return cb && cb();
            if (this.$modes[path] && !options)
              return this.$onChangeMode(this.$modes[path]);
            if (m && m.Mode) {
              m = new m.Mode(options);
              if (!options) {
                this.$modes[path] = m;
                m.$id = path;
              }
              this.$onChangeMode(m);
              cb && cb();
            }
          }.bind(this));
          if (!this.$mode)
            this.$onChangeMode(this.$modes["ace/mode/text"], true);
        };
        this.$onChangeMode = function(mode, $isPlaceholder) {
          if (!$isPlaceholder)
            this.$modeId = mode.$id;
          if (this.$mode === mode)
            return ;
          this.$mode = mode;
          this.$stopWorker();
          if (this.$useWorker)
            this.$startWorker();
          var tokenizer = mode.getTokenizer();
          if (tokenizer.addEventListener !== undefined) {
            var onReloadTokenizer = this.onReloadTokenizer.bind(this);
            tokenizer.addEventListener("update", onReloadTokenizer);
          }
          if (!this.bgTokenizer) {
            this.bgTokenizer = new BackgroundTokenizer(tokenizer);
            var _self = this;
            this.bgTokenizer.addEventListener("update", function(e) {
              _self._signal("tokenizerUpdate", e);
            });
          } else {
            this.bgTokenizer.setTokenizer(tokenizer);
          }
          this.bgTokenizer.setDocument(this.getDocument());
          this.tokenRe = mode.tokenRe;
          this.nonTokenRe = mode.nonTokenRe;
          if (!$isPlaceholder) {
            if (mode.attachToSession)
              mode.attachToSession(this);
            this.$options.wrapMethod.set.call(this, this.$wrapMethod);
            this.$setFolding(mode.foldingRules);
            this.bgTokenizer.start(0);
            this._emit("changeMode");
          }
        };
        this.$stopWorker = function() {
          if (this.$worker) {
            this.$worker.terminate();
            this.$worker = null;
          }
        };
        this.$startWorker = function() {
          try {
            this.$worker = this.$mode.createWorker(this);
          } catch (e) {
            if (typeof console == "object") {
              console.log("Could not load worker");
              console.log(e);
            }
            this.$worker = null;
          }
        };
        this.getMode = function() {
          return this.$mode;
        };
        this.$scrollTop = 0;
        this.setScrollTop = function(scrollTop) {
          if (this.$scrollTop === scrollTop || isNaN(scrollTop))
            return ;
          this.$scrollTop = scrollTop;
          this._signal("changeScrollTop", scrollTop);
        };
        this.getScrollTop = function() {
          return this.$scrollTop;
        };
        this.$scrollLeft = 0;
        this.setScrollLeft = function(scrollLeft) {
          if (this.$scrollLeft === scrollLeft || isNaN(scrollLeft))
            return ;
          this.$scrollLeft = scrollLeft;
          this._signal("changeScrollLeft", scrollLeft);
        };
        this.getScrollLeft = function() {
          return this.$scrollLeft;
        };
        this.getScreenWidth = function() {
          this.$computeWidth();
          if (this.lineWidgets)
            return Math.max(this.getLineWidgetMaxWidth(), this.screenWidth);
          return this.screenWidth;
        };
        this.getLineWidgetMaxWidth = function() {
          if (this.lineWidgetsWidth != null)
            return this.lineWidgetsWidth;
          var width = 0;
          this.lineWidgets.forEach(function(w) {
            if (w && w.screenWidth > width)
              width = w.screenWidth;
          });
          return this.lineWidgetWidth = width;
        };
        this.$computeWidth = function(force) {
          if (this.$modified || force) {
            this.$modified = false;
            if (this.$useWrapMode)
              return this.screenWidth = this.$wrapLimit;
            var lines = this.doc.getAllLines();
            var cache = this.$rowLengthCache;
            var longestScreenLine = 0;
            var foldIndex = 0;
            var foldLine = this.$foldData[foldIndex];
            var foldStart = foldLine ? foldLine.start.row : Infinity;
            var len = lines.length;
            for (var i = 0; i < len; i++) {
              if (i > foldStart) {
                i = foldLine.end.row + 1;
                if (i >= len)
                  break;
                foldLine = this.$foldData[foldIndex++];
                foldStart = foldLine ? foldLine.start.row : Infinity;
              }
              if (cache[i] == null)
                cache[i] = this.$getStringScreenWidth(lines[i])[0];
              if (cache[i] > longestScreenLine)
                longestScreenLine = cache[i];
            }
            this.screenWidth = longestScreenLine;
          }
        };
        this.getLine = function(row) {
          return this.doc.getLine(row);
        };
        this.getLines = function(firstRow, lastRow) {
          return this.doc.getLines(firstRow, lastRow);
        };
        this.getLength = function() {
          return this.doc.getLength();
        };
        this.getTextRange = function(range) {
          return this.doc.getTextRange(range || this.selection.getRange());
        };
        this.insert = function(position, text) {
          return this.doc.insert(position, text);
        };
        this.remove = function(range) {
          return this.doc.remove(range);
        };
        this.undoChanges = function(deltas, dontSelect) {
          if (!deltas.length)
            return ;
          this.$fromUndo = true;
          var lastUndoRange = null;
          for (var i = deltas.length - 1; i != -1; i--) {
            var delta = deltas[i];
            if (delta.group == "doc") {
              this.doc.revertDeltas(delta.deltas);
              lastUndoRange = this.$getUndoSelection(delta.deltas, true, lastUndoRange);
            } else {
              delta.deltas.forEach(function(foldDelta) {
                this.addFolds(foldDelta.folds);
              }, this);
            }
          }
          this.$fromUndo = false;
          lastUndoRange && this.$undoSelect && !dontSelect && this.selection.setSelectionRange(lastUndoRange);
          return lastUndoRange;
        };
        this.redoChanges = function(deltas, dontSelect) {
          if (!deltas.length)
            return ;
          this.$fromUndo = true;
          var lastUndoRange = null;
          for (var i = 0; i < deltas.length; i++) {
            var delta = deltas[i];
            if (delta.group == "doc") {
              this.doc.applyDeltas(delta.deltas);
              lastUndoRange = this.$getUndoSelection(delta.deltas, false, lastUndoRange);
            }
          }
          this.$fromUndo = false;
          lastUndoRange && this.$undoSelect && !dontSelect && this.selection.setSelectionRange(lastUndoRange);
          return lastUndoRange;
        };
        this.setUndoSelect = function(enable) {
          this.$undoSelect = enable;
        };
        this.$getUndoSelection = function(deltas, isUndo, lastUndoRange) {
          function isInsert(delta) {
            var insert = delta.action === "insertText" || delta.action === "insertLines";
            return isUndo ? !insert : insert;
          }
          var delta = deltas[0];
          var range,
              point;
          var lastDeltaIsInsert = false;
          if (isInsert(delta)) {
            range = Range.fromPoints(delta.range.start, delta.range.end);
            lastDeltaIsInsert = true;
          } else {
            range = Range.fromPoints(delta.range.start, delta.range.start);
            lastDeltaIsInsert = false;
          }
          for (var i = 1; i < deltas.length; i++) {
            delta = deltas[i];
            if (isInsert(delta)) {
              point = delta.range.start;
              if (range.compare(point.row, point.column) == -1) {
                range.setStart(delta.range.start);
              }
              point = delta.range.end;
              if (range.compare(point.row, point.column) == 1) {
                range.setEnd(delta.range.end);
              }
              lastDeltaIsInsert = true;
            } else {
              point = delta.range.start;
              if (range.compare(point.row, point.column) == -1) {
                range = Range.fromPoints(delta.range.start, delta.range.start);
              }
              lastDeltaIsInsert = false;
            }
          }
          if (lastUndoRange != null) {
            if (Range.comparePoints(lastUndoRange.start, range.start) === 0) {
              lastUndoRange.start.column += range.end.column - range.start.column;
              lastUndoRange.end.column += range.end.column - range.start.column;
            }
            var cmp = lastUndoRange.compareRange(range);
            if (cmp == 1) {
              range.setStart(lastUndoRange.start);
            } else if (cmp == -1) {
              range.setEnd(lastUndoRange.end);
            }
          }
          return range;
        };
        this.replace = function(range, text) {
          return this.doc.replace(range, text);
        };
        this.moveText = function(fromRange, toPosition, copy) {
          var text = this.getTextRange(fromRange);
          var folds = this.getFoldsInRange(fromRange);
          var toRange = Range.fromPoints(toPosition, toPosition);
          if (!copy) {
            this.remove(fromRange);
            var rowDiff = fromRange.start.row - fromRange.end.row;
            var collDiff = rowDiff ? -fromRange.end.column : fromRange.start.column - fromRange.end.column;
            if (collDiff) {
              if (toRange.start.row == fromRange.end.row && toRange.start.column > fromRange.end.column)
                toRange.start.column += collDiff;
              if (toRange.end.row == fromRange.end.row && toRange.end.column > fromRange.end.column)
                toRange.end.column += collDiff;
            }
            if (rowDiff && toRange.start.row >= fromRange.end.row) {
              toRange.start.row += rowDiff;
              toRange.end.row += rowDiff;
            }
          }
          toRange.end = this.insert(toRange.start, text);
          if (folds.length) {
            var oldStart = fromRange.start;
            var newStart = toRange.start;
            var rowDiff = newStart.row - oldStart.row;
            var collDiff = newStart.column - oldStart.column;
            this.addFolds(folds.map(function(x) {
              x = x.clone();
              if (x.start.row == oldStart.row)
                x.start.column += collDiff;
              if (x.end.row == oldStart.row)
                x.end.column += collDiff;
              x.start.row += rowDiff;
              x.end.row += rowDiff;
              return x;
            }));
          }
          return toRange;
        };
        this.indentRows = function(startRow, endRow, indentString) {
          indentString = indentString.replace(/\t/g, this.getTabString());
          for (var row = startRow; row <= endRow; row++)
            this.insert({
              row: row,
              column: 0
            }, indentString);
        };
        this.outdentRows = function(range) {
          var rowRange = range.collapseRows();
          var deleteRange = new Range(0, 0, 0, 0);
          var size = this.getTabSize();
          for (var i = rowRange.start.row; i <= rowRange.end.row; ++i) {
            var line = this.getLine(i);
            deleteRange.start.row = i;
            deleteRange.end.row = i;
            for (var j = 0; j < size; ++j)
              if (line.charAt(j) != ' ')
                break;
            if (j < size && line.charAt(j) == '\t') {
              deleteRange.start.column = j;
              deleteRange.end.column = j + 1;
            } else {
              deleteRange.start.column = 0;
              deleteRange.end.column = j;
            }
            this.remove(deleteRange);
          }
        };
        this.$moveLines = function(firstRow, lastRow, dir) {
          firstRow = this.getRowFoldStart(firstRow);
          lastRow = this.getRowFoldEnd(lastRow);
          if (dir < 0) {
            var row = this.getRowFoldStart(firstRow + dir);
            if (row < 0)
              return 0;
            var diff = row - firstRow;
          } else if (dir > 0) {
            var row = this.getRowFoldEnd(lastRow + dir);
            if (row > this.doc.getLength() - 1)
              return 0;
            var diff = row - lastRow;
          } else {
            firstRow = this.$clipRowToDocument(firstRow);
            lastRow = this.$clipRowToDocument(lastRow);
            var diff = lastRow - firstRow + 1;
          }
          var range = new Range(firstRow, 0, lastRow, Number.MAX_VALUE);
          var folds = this.getFoldsInRange(range).map(function(x) {
            x = x.clone();
            x.start.row += diff;
            x.end.row += diff;
            return x;
          });
          var lines = dir == 0 ? this.doc.getLines(firstRow, lastRow) : this.doc.removeLines(firstRow, lastRow);
          this.doc.insertLines(firstRow + diff, lines);
          folds.length && this.addFolds(folds);
          return diff;
        };
        this.moveLinesUp = function(firstRow, lastRow) {
          return this.$moveLines(firstRow, lastRow, -1);
        };
        this.moveLinesDown = function(firstRow, lastRow) {
          return this.$moveLines(firstRow, lastRow, 1);
        };
        this.duplicateLines = function(firstRow, lastRow) {
          return this.$moveLines(firstRow, lastRow, 0);
        };
        this.$clipRowToDocument = function(row) {
          return Math.max(0, Math.min(row, this.doc.getLength() - 1));
        };
        this.$clipColumnToRow = function(row, column) {
          if (column < 0)
            return 0;
          return Math.min(this.doc.getLine(row).length, column);
        };
        this.$clipPositionToDocument = function(row, column) {
          column = Math.max(0, column);
          if (row < 0) {
            row = 0;
            column = 0;
          } else {
            var len = this.doc.getLength();
            if (row >= len) {
              row = len - 1;
              column = this.doc.getLine(len - 1).length;
            } else {
              column = Math.min(this.doc.getLine(row).length, column);
            }
          }
          return {
            row: row,
            column: column
          };
        };
        this.$clipRangeToDocument = function(range) {
          if (range.start.row < 0) {
            range.start.row = 0;
            range.start.column = 0;
          } else {
            range.start.column = this.$clipColumnToRow(range.start.row, range.start.column);
          }
          var len = this.doc.getLength() - 1;
          if (range.end.row > len) {
            range.end.row = len;
            range.end.column = this.doc.getLine(len).length;
          } else {
            range.end.column = this.$clipColumnToRow(range.end.row, range.end.column);
          }
          return range;
        };
        this.$wrapLimit = 80;
        this.$useWrapMode = false;
        this.$wrapLimitRange = {
          min: null,
          max: null
        };
        this.setUseWrapMode = function(useWrapMode) {
          if (useWrapMode != this.$useWrapMode) {
            this.$useWrapMode = useWrapMode;
            this.$modified = true;
            this.$resetRowCache(0);
            if (useWrapMode) {
              var len = this.getLength();
              this.$wrapData = Array(len);
              this.$updateWrapData(0, len - 1);
            }
            this._signal("changeWrapMode");
          }
        };
        this.getUseWrapMode = function() {
          return this.$useWrapMode;
        };
        this.setWrapLimitRange = function(min, max) {
          if (this.$wrapLimitRange.min !== min || this.$wrapLimitRange.max !== max) {
            this.$wrapLimitRange = {
              min: min,
              max: max
            };
            this.$modified = true;
            this._signal("changeWrapMode");
          }
        };
        this.adjustWrapLimit = function(desiredLimit, $printMargin) {
          var limits = this.$wrapLimitRange;
          if (limits.max < 0)
            limits = {
              min: $printMargin,
              max: $printMargin
            };
          var wrapLimit = this.$constrainWrapLimit(desiredLimit, limits.min, limits.max);
          if (wrapLimit != this.$wrapLimit && wrapLimit > 1) {
            this.$wrapLimit = wrapLimit;
            this.$modified = true;
            if (this.$useWrapMode) {
              this.$updateWrapData(0, this.getLength() - 1);
              this.$resetRowCache(0);
              this._signal("changeWrapLimit");
            }
            return true;
          }
          return false;
        };
        this.$constrainWrapLimit = function(wrapLimit, min, max) {
          if (min)
            wrapLimit = Math.max(min, wrapLimit);
          if (max)
            wrapLimit = Math.min(max, wrapLimit);
          return wrapLimit;
        };
        this.getWrapLimit = function() {
          return this.$wrapLimit;
        };
        this.setWrapLimit = function(limit) {
          this.setWrapLimitRange(limit, limit);
        };
        this.getWrapLimitRange = function() {
          return {
            min: this.$wrapLimitRange.min,
            max: this.$wrapLimitRange.max
          };
        };
        this.$updateInternalDataOnChange = function(e) {
          var useWrapMode = this.$useWrapMode;
          var len;
          var action = e.data.action;
          var firstRow = e.data.range.start.row;
          var lastRow = e.data.range.end.row;
          var start = e.data.range.start;
          var end = e.data.range.end;
          var removedFolds = null;
          if (action.indexOf("Lines") != -1) {
            if (action == "insertLines") {
              lastRow = firstRow + (e.data.lines.length);
            } else {
              lastRow = firstRow;
            }
            len = e.data.lines ? e.data.lines.length : lastRow - firstRow;
          } else {
            len = lastRow - firstRow;
          }
          this.$updating = true;
          if (len != 0) {
            if (action.indexOf("remove") != -1) {
              this[useWrapMode ? "$wrapData" : "$rowLengthCache"].splice(firstRow, len);
              var foldLines = this.$foldData;
              removedFolds = this.getFoldsInRange(e.data.range);
              this.removeFolds(removedFolds);
              var foldLine = this.getFoldLine(end.row);
              var idx = 0;
              if (foldLine) {
                foldLine.addRemoveChars(end.row, end.column, start.column - end.column);
                foldLine.shiftRow(-len);
                var foldLineBefore = this.getFoldLine(firstRow);
                if (foldLineBefore && foldLineBefore !== foldLine) {
                  foldLineBefore.merge(foldLine);
                  foldLine = foldLineBefore;
                }
                idx = foldLines.indexOf(foldLine) + 1;
              }
              for (idx; idx < foldLines.length; idx++) {
                var foldLine = foldLines[idx];
                if (foldLine.start.row >= end.row) {
                  foldLine.shiftRow(-len);
                }
              }
              lastRow = firstRow;
            } else {
              var args = Array(len);
              args.unshift(firstRow, 0);
              var arr = useWrapMode ? this.$wrapData : this.$rowLengthCache;
              arr.splice.apply(arr, args);
              var foldLines = this.$foldData;
              var foldLine = this.getFoldLine(firstRow);
              var idx = 0;
              if (foldLine) {
                var cmp = foldLine.range.compareInside(start.row, start.column);
                if (cmp == 0) {
                  foldLine = foldLine.split(start.row, start.column);
                  if (foldLine) {
                    foldLine.shiftRow(len);
                    foldLine.addRemoveChars(lastRow, 0, end.column - start.column);
                  }
                } else if (cmp == -1) {
                  foldLine.addRemoveChars(firstRow, 0, end.column - start.column);
                  foldLine.shiftRow(len);
                }
                idx = foldLines.indexOf(foldLine) + 1;
              }
              for (idx; idx < foldLines.length; idx++) {
                var foldLine = foldLines[idx];
                if (foldLine.start.row >= firstRow) {
                  foldLine.shiftRow(len);
                }
              }
            }
          } else {
            len = Math.abs(e.data.range.start.column - e.data.range.end.column);
            if (action.indexOf("remove") != -1) {
              removedFolds = this.getFoldsInRange(e.data.range);
              this.removeFolds(removedFolds);
              len = -len;
            }
            var foldLine = this.getFoldLine(firstRow);
            if (foldLine) {
              foldLine.addRemoveChars(firstRow, start.column, len);
            }
          }
          if (useWrapMode && this.$wrapData.length != this.doc.getLength()) {
            console.error("doc.getLength() and $wrapData.length have to be the same!");
          }
          this.$updating = false;
          if (useWrapMode)
            this.$updateWrapData(firstRow, lastRow);
          else
            this.$updateRowLengthCache(firstRow, lastRow);
          return removedFolds;
        };
        this.$updateRowLengthCache = function(firstRow, lastRow, b) {
          this.$rowLengthCache[firstRow] = null;
          this.$rowLengthCache[lastRow] = null;
        };
        this.$updateWrapData = function(firstRow, lastRow) {
          var lines = this.doc.getAllLines();
          var tabSize = this.getTabSize();
          var wrapData = this.$wrapData;
          var wrapLimit = this.$wrapLimit;
          var tokens;
          var foldLine;
          var row = firstRow;
          lastRow = Math.min(lastRow, lines.length - 1);
          while (row <= lastRow) {
            foldLine = this.getFoldLine(row, foldLine);
            if (!foldLine) {
              tokens = this.$getDisplayTokens(lines[row]);
              wrapData[row] = this.$computeWrapSplits(tokens, wrapLimit, tabSize);
              row++;
            } else {
              tokens = [];
              foldLine.walk(function(placeholder, row, column, lastColumn) {
                var walkTokens;
                if (placeholder != null) {
                  walkTokens = this.$getDisplayTokens(placeholder, tokens.length);
                  walkTokens[0] = PLACEHOLDER_START;
                  for (var i = 1; i < walkTokens.length; i++) {
                    walkTokens[i] = PLACEHOLDER_BODY;
                  }
                } else {
                  walkTokens = this.$getDisplayTokens(lines[row].substring(lastColumn, column), tokens.length);
                }
                tokens = tokens.concat(walkTokens);
              }.bind(this), foldLine.end.row, lines[foldLine.end.row].length + 1);
              wrapData[foldLine.start.row] = this.$computeWrapSplits(tokens, wrapLimit, tabSize);
              row = foldLine.end.row + 1;
            }
          }
        };
        var CHAR = 1,
            CHAR_EXT = 2,
            PLACEHOLDER_START = 3,
            PLACEHOLDER_BODY = 4,
            PUNCTUATION = 9,
            SPACE = 10,
            TAB = 11,
            TAB_SPACE = 12;
        this.$computeWrapSplits = function(tokens, wrapLimit) {
          if (tokens.length == 0) {
            return [];
          }
          var splits = [];
          var displayLength = tokens.length;
          var lastSplit = 0,
              lastDocSplit = 0;
          var isCode = this.$wrapAsCode;
          function addSplit(screenPos) {
            var displayed = tokens.slice(lastSplit, screenPos);
            var len = displayed.length;
            displayed.join("").replace(/12/g, function() {
              len -= 1;
            }).replace(/2/g, function() {
              len -= 1;
            });
            lastDocSplit += len;
            splits.push(lastDocSplit);
            lastSplit = screenPos;
          }
          while (displayLength - lastSplit > wrapLimit) {
            var split = lastSplit + wrapLimit;
            if (tokens[split - 1] >= SPACE && tokens[split] >= SPACE) {
              addSplit(split);
              continue;
            }
            if (tokens[split] == PLACEHOLDER_START || tokens[split] == PLACEHOLDER_BODY) {
              for (split; split != lastSplit - 1; split--) {
                if (tokens[split] == PLACEHOLDER_START) {
                  break;
                }
              }
              if (split > lastSplit) {
                addSplit(split);
                continue;
              }
              split = lastSplit + wrapLimit;
              for (split; split < tokens.length; split++) {
                if (tokens[split] != PLACEHOLDER_BODY) {
                  break;
                }
              }
              if (split == tokens.length) {
                break;
              }
              addSplit(split);
              continue;
            }
            var minSplit = Math.max(split - (isCode ? 10 : wrapLimit - (wrapLimit >> 2)), lastSplit - 1);
            while (split > minSplit && tokens[split] < PLACEHOLDER_START) {
              split--;
            }
            if (isCode) {
              while (split > minSplit && tokens[split] < PLACEHOLDER_START) {
                split--;
              }
              while (split > minSplit && tokens[split] == PUNCTUATION) {
                split--;
              }
            } else {
              while (split > minSplit && tokens[split] < SPACE) {
                split--;
              }
            }
            if (split > minSplit) {
              addSplit(++split);
              continue;
            }
            split = lastSplit + wrapLimit;
            if (tokens[split] == CHAR_EXT)
              split--;
            addSplit(split);
          }
          return splits;
        };
        this.$getDisplayTokens = function(str, offset) {
          var arr = [];
          var tabSize;
          offset = offset || 0;
          for (var i = 0; i < str.length; i++) {
            var c = str.charCodeAt(i);
            if (c == 9) {
              tabSize = this.getScreenTabSize(arr.length + offset);
              arr.push(TAB);
              for (var n = 1; n < tabSize; n++) {
                arr.push(TAB_SPACE);
              }
            } else if (c == 32) {
              arr.push(SPACE);
            } else if ((c > 39 && c < 48) || (c > 57 && c < 64)) {
              arr.push(PUNCTUATION);
            } else if (c >= 0x1100 && isFullWidth(c)) {
              arr.push(CHAR, CHAR_EXT);
            } else {
              arr.push(CHAR);
            }
          }
          return arr;
        };
        this.$getStringScreenWidth = function(str, maxScreenColumn, screenColumn) {
          if (maxScreenColumn == 0)
            return [0, 0];
          if (maxScreenColumn == null)
            maxScreenColumn = Infinity;
          screenColumn = screenColumn || 0;
          var c,
              column;
          for (column = 0; column < str.length; column++) {
            c = str.charCodeAt(column);
            if (c == 9) {
              screenColumn += this.getScreenTabSize(screenColumn);
            } else if (c >= 0x1100 && isFullWidth(c)) {
              screenColumn += 2;
            } else {
              screenColumn += 1;
            }
            if (screenColumn > maxScreenColumn) {
              break;
            }
          }
          return [screenColumn, column];
        };
        this.lineWidgets = null;
        this.getRowLength = function(row) {
          if (this.lineWidgets)
            var h = this.lineWidgets[row] && this.lineWidgets[row].rowCount || 0;
          else
            h = 0;
          if (!this.$useWrapMode || !this.$wrapData[row]) {
            return 1 + h;
          } else {
            return this.$wrapData[row].length + 1 + h;
          }
        };
        this.getRowLineCount = function(row) {
          if (!this.$useWrapMode || !this.$wrapData[row]) {
            return 1;
          } else {
            return this.$wrapData[row].length + 1;
          }
        };
        this.getScreenLastRowColumn = function(screenRow) {
          var pos = this.screenToDocumentPosition(screenRow, Number.MAX_VALUE);
          return this.documentToScreenColumn(pos.row, pos.column);
        };
        this.getDocumentLastRowColumn = function(docRow, docColumn) {
          var screenRow = this.documentToScreenRow(docRow, docColumn);
          return this.getScreenLastRowColumn(screenRow);
        };
        this.getDocumentLastRowColumnPosition = function(docRow, docColumn) {
          var screenRow = this.documentToScreenRow(docRow, docColumn);
          return this.screenToDocumentPosition(screenRow, Number.MAX_VALUE / 10);
        };
        this.getRowSplitData = function(row) {
          if (!this.$useWrapMode) {
            return undefined;
          } else {
            return this.$wrapData[row];
          }
        };
        this.getScreenTabSize = function(screenColumn) {
          return this.$tabSize - screenColumn % this.$tabSize;
        };
        this.screenToDocumentRow = function(screenRow, screenColumn) {
          return this.screenToDocumentPosition(screenRow, screenColumn).row;
        };
        this.screenToDocumentColumn = function(screenRow, screenColumn) {
          return this.screenToDocumentPosition(screenRow, screenColumn).column;
        };
        this.screenToDocumentPosition = function(screenRow, screenColumn) {
          if (screenRow < 0)
            return {
              row: 0,
              column: 0
            };
          var line;
          var docRow = 0;
          var docColumn = 0;
          var column;
          var row = 0;
          var rowLength = 0;
          var rowCache = this.$screenRowCache;
          var i = this.$getRowCacheIndex(rowCache, screenRow);
          var l = rowCache.length;
          if (l && i >= 0) {
            var row = rowCache[i];
            var docRow = this.$docRowCache[i];
            var doCache = screenRow > rowCache[l - 1];
          } else {
            var doCache = !l;
          }
          var maxRow = this.getLength() - 1;
          var foldLine = this.getNextFoldLine(docRow);
          var foldStart = foldLine ? foldLine.start.row : Infinity;
          while (row <= screenRow) {
            rowLength = this.getRowLength(docRow);
            if (row + rowLength > screenRow || docRow >= maxRow) {
              break;
            } else {
              row += rowLength;
              docRow++;
              if (docRow > foldStart) {
                docRow = foldLine.end.row + 1;
                foldLine = this.getNextFoldLine(docRow, foldLine);
                foldStart = foldLine ? foldLine.start.row : Infinity;
              }
            }
            if (doCache) {
              this.$docRowCache.push(docRow);
              this.$screenRowCache.push(row);
            }
          }
          if (foldLine && foldLine.start.row <= docRow) {
            line = this.getFoldDisplayLine(foldLine);
            docRow = foldLine.start.row;
          } else if (row + rowLength <= screenRow || docRow > maxRow) {
            return {
              row: maxRow,
              column: this.getLine(maxRow).length
            };
          } else {
            line = this.getLine(docRow);
            foldLine = null;
          }
          if (this.$useWrapMode) {
            var splits = this.$wrapData[docRow];
            if (splits) {
              var splitIndex = Math.floor(screenRow - row);
              column = splits[splitIndex];
              if (splitIndex > 0 && splits.length) {
                docColumn = splits[splitIndex - 1] || splits[splits.length - 1];
                line = line.substring(docColumn);
              }
            }
          }
          docColumn += this.$getStringScreenWidth(line, screenColumn)[1];
          if (this.$useWrapMode && docColumn >= column)
            docColumn = column - 1;
          if (foldLine)
            return foldLine.idxToPosition(docColumn);
          return {
            row: docRow,
            column: docColumn
          };
        };
        this.documentToScreenPosition = function(docRow, docColumn) {
          if (typeof docColumn === "undefined")
            var pos = this.$clipPositionToDocument(docRow.row, docRow.column);
          else
            pos = this.$clipPositionToDocument(docRow, docColumn);
          docRow = pos.row;
          docColumn = pos.column;
          var screenRow = 0;
          var foldStartRow = null;
          var fold = null;
          fold = this.getFoldAt(docRow, docColumn, 1);
          if (fold) {
            docRow = fold.start.row;
            docColumn = fold.start.column;
          }
          var rowEnd,
              row = 0;
          var rowCache = this.$docRowCache;
          var i = this.$getRowCacheIndex(rowCache, docRow);
          var l = rowCache.length;
          if (l && i >= 0) {
            var row = rowCache[i];
            var screenRow = this.$screenRowCache[i];
            var doCache = docRow > rowCache[l - 1];
          } else {
            var doCache = !l;
          }
          var foldLine = this.getNextFoldLine(row);
          var foldStart = foldLine ? foldLine.start.row : Infinity;
          while (row < docRow) {
            if (row >= foldStart) {
              rowEnd = foldLine.end.row + 1;
              if (rowEnd > docRow)
                break;
              foldLine = this.getNextFoldLine(rowEnd, foldLine);
              foldStart = foldLine ? foldLine.start.row : Infinity;
            } else {
              rowEnd = row + 1;
            }
            screenRow += this.getRowLength(row);
            row = rowEnd;
            if (doCache) {
              this.$docRowCache.push(row);
              this.$screenRowCache.push(screenRow);
            }
          }
          var textLine = "";
          if (foldLine && row >= foldStart) {
            textLine = this.getFoldDisplayLine(foldLine, docRow, docColumn);
            foldStartRow = foldLine.start.row;
          } else {
            textLine = this.getLine(docRow).substring(0, docColumn);
            foldStartRow = docRow;
          }
          if (this.$useWrapMode) {
            var wrapRow = this.$wrapData[foldStartRow];
            if (wrapRow) {
              var screenRowOffset = 0;
              while (textLine.length >= wrapRow[screenRowOffset]) {
                screenRow++;
                screenRowOffset++;
              }
              textLine = textLine.substring(wrapRow[screenRowOffset - 1] || 0, textLine.length);
            }
          }
          return {
            row: screenRow,
            column: this.$getStringScreenWidth(textLine)[0]
          };
        };
        this.documentToScreenColumn = function(row, docColumn) {
          return this.documentToScreenPosition(row, docColumn).column;
        };
        this.documentToScreenRow = function(docRow, docColumn) {
          return this.documentToScreenPosition(docRow, docColumn).row;
        };
        this.getScreenLength = function() {
          var screenRows = 0;
          var fold = null;
          if (!this.$useWrapMode) {
            screenRows = this.getLength();
            var foldData = this.$foldData;
            for (var i = 0; i < foldData.length; i++) {
              fold = foldData[i];
              screenRows -= fold.end.row - fold.start.row;
            }
          } else {
            var lastRow = this.$wrapData.length;
            var row = 0,
                i = 0;
            var fold = this.$foldData[i++];
            var foldStart = fold ? fold.start.row : Infinity;
            while (row < lastRow) {
              var splits = this.$wrapData[row];
              screenRows += splits ? splits.length + 1 : 1;
              row++;
              if (row > foldStart) {
                row = fold.end.row + 1;
                fold = this.$foldData[i++];
                foldStart = fold ? fold.start.row : Infinity;
              }
            }
          }
          if (this.lineWidgets)
            screenRows += this.$getWidgetScreenLength();
          return screenRows;
        };
        this.$setFontMetrics = function(fm) {};
        this.destroy = function() {
          if (this.bgTokenizer) {
            this.bgTokenizer.setDocument(null);
            this.bgTokenizer = null;
          }
          this.$stopWorker();
        };
        function isFullWidth(c) {
          if (c < 0x1100)
            return false;
          return c >= 0x1100 && c <= 0x115F || c >= 0x11A3 && c <= 0x11A7 || c >= 0x11FA && c <= 0x11FF || c >= 0x2329 && c <= 0x232A || c >= 0x2E80 && c <= 0x2E99 || c >= 0x2E9B && c <= 0x2EF3 || c >= 0x2F00 && c <= 0x2FD5 || c >= 0x2FF0 && c <= 0x2FFB || c >= 0x3000 && c <= 0x303E || c >= 0x3041 && c <= 0x3096 || c >= 0x3099 && c <= 0x30FF || c >= 0x3105 && c <= 0x312D || c >= 0x3131 && c <= 0x318E || c >= 0x3190 && c <= 0x31BA || c >= 0x31C0 && c <= 0x31E3 || c >= 0x31F0 && c <= 0x321E || c >= 0x3220 && c <= 0x3247 || c >= 0x3250 && c <= 0x32FE || c >= 0x3300 && c <= 0x4DBF || c >= 0x4E00 && c <= 0xA48C || c >= 0xA490 && c <= 0xA4C6 || c >= 0xA960 && c <= 0xA97C || c >= 0xAC00 && c <= 0xD7A3 || c >= 0xD7B0 && c <= 0xD7C6 || c >= 0xD7CB && c <= 0xD7FB || c >= 0xF900 && c <= 0xFAFF || c >= 0xFE10 && c <= 0xFE19 || c >= 0xFE30 && c <= 0xFE52 || c >= 0xFE54 && c <= 0xFE66 || c >= 0xFE68 && c <= 0xFE6B || c >= 0xFF01 && c <= 0xFF60 || c >= 0xFFE0 && c <= 0xFFE6;
        }
        ;
      }).call(EditSession.prototype);
      acequire("./edit_session/folding").Folding.call(EditSession.prototype);
      acequire("./edit_session/bracket_match").BracketMatch.call(EditSession.prototype);
      config.defineOptions(EditSession.prototype, "session", {
        wrap: {
          set: function(value) {
            if (!value || value == "off")
              value = false;
            else if (value == "free")
              value = true;
            else if (value == "printMargin")
              value = -1;
            else if (typeof value == "string")
              value = parseInt(value, 10) || false;
            if (this.$wrap == value)
              return ;
            if (!value) {
              this.setUseWrapMode(false);
            } else {
              var col = typeof value == "number" ? value : null;
              this.setWrapLimitRange(col, col);
              this.setUseWrapMode(true);
            }
            this.$wrap = value;
          },
          get: function() {
            if (this.getUseWrapMode()) {
              if (this.$wrap == -1)
                return "printMargin";
              if (!this.getWrapLimitRange().min)
                return "free";
              return this.$wrap;
            }
            return "off";
          },
          handlesSet: true
        },
        wrapMethod: {
          set: function(val) {
            val = val == "auto" ? this.$mode.type != "text" : val != "text";
            if (val != this.$wrapAsCode) {
              this.$wrapAsCode = val;
              if (this.$useWrapMode) {
                this.$modified = true;
                this.$resetRowCache(0);
                this.$updateWrapData(0, this.getLength() - 1);
              }
            }
          },
          initialValue: "auto"
        },
        firstLineNumber: {
          set: function() {
            this._signal("changeBreakpoint");
          },
          initialValue: 1
        },
        useWorker: {
          set: function(useWorker) {
            this.$useWorker = useWorker;
            this.$stopWorker();
            if (useWorker)
              this.$startWorker();
          },
          initialValue: true
        },
        useSoftTabs: {initialValue: true},
        tabSize: {
          set: function(tabSize) {
            if (isNaN(tabSize) || this.$tabSize === tabSize)
              return ;
            this.$modified = true;
            this.$rowLengthCache = [];
            this.$tabSize = tabSize;
            this._signal("changeTabSize");
          },
          initialValue: 4,
          handlesSet: true
        },
        overwrite: {
          set: function(val) {
            this._signal("changeOverwrite");
          },
          initialValue: false
        },
        newLineMode: {
          set: function(val) {
            this.doc.setNewLineMode(val);
          },
          get: function() {
            return this.doc.getNewLineMode();
          },
          handlesSet: true
        },
        mode: {
          set: function(val) {
            this.setMode(val);
          },
          get: function() {
            return this.$modeId;
          }
        }
      });
      exports.EditSession = EditSession;
    });
    ace.define("ace/search", ["require", "exports", "module", "ace/lib/lang", "ace/lib/oop", "ace/range"], function(acequire, exports, module) {
      "use strict";
      var lang = acequire("./lib/lang");
      var oop = acequire("./lib/oop");
      var Range = acequire("./range").Range;
      var Search = function() {
        this.$options = {};
      };
      (function() {
        this.set = function(options) {
          oop.mixin(this.$options, options);
          return this;
        };
        this.getOptions = function() {
          return lang.copyObject(this.$options);
        };
        this.setOptions = function(options) {
          this.$options = options;
        };
        this.find = function(session) {
          var iterator = this.$matchIterator(session, this.$options);
          if (!iterator)
            return false;
          var firstRange = null;
          iterator.forEach(function(range, row, offset) {
            if (!range.start) {
              var column = range.offset + (offset || 0);
              firstRange = new Range(row, column, row, column + range.length);
            } else
              firstRange = range;
            return true;
          });
          return firstRange;
        };
        this.findAll = function(session) {
          var options = this.$options;
          if (!options.needle)
            return [];
          this.$assembleRegExp(options);
          var range = options.range;
          var lines = range ? session.getLines(range.start.row, range.end.row) : session.doc.getAllLines();
          var ranges = [];
          var re = options.re;
          if (options.$isMultiLine) {
            var len = re.length;
            var maxRow = lines.length - len;
            var prevRange;
            outer: for (var row = re.offset || 0; row <= maxRow; row++) {
              for (var j = 0; j < len; j++)
                if (lines[row + j].search(re[j]) == -1)
                  continue outer;
              var startLine = lines[row];
              var line = lines[row + len - 1];
              var startIndex = startLine.length - startLine.match(re[0])[0].length;
              var endIndex = line.match(re[len - 1])[0].length;
              if (prevRange && prevRange.end.row === row && prevRange.end.column > startIndex) {
                continue;
              }
              ranges.push(prevRange = new Range(row, startIndex, row + len - 1, endIndex));
              if (len > 2)
                row = row + len - 2;
            }
          } else {
            for (var i = 0; i < lines.length; i++) {
              var matches = lang.getMatchOffsets(lines[i], re);
              for (var j = 0; j < matches.length; j++) {
                var match = matches[j];
                ranges.push(new Range(i, match.offset, i, match.offset + match.length));
              }
            }
          }
          if (range) {
            var startColumn = range.start.column;
            var endColumn = range.start.column;
            var i = 0,
                j = ranges.length - 1;
            while (i < j && ranges[i].start.column < startColumn && ranges[i].start.row == range.start.row)
              i++;
            while (i < j && ranges[j].end.column > endColumn && ranges[j].end.row == range.end.row)
              j--;
            ranges = ranges.slice(i, j + 1);
            for (i = 0, j = ranges.length; i < j; i++) {
              ranges[i].start.row += range.start.row;
              ranges[i].end.row += range.start.row;
            }
          }
          return ranges;
        };
        this.replace = function(input, replacement) {
          var options = this.$options;
          var re = this.$assembleRegExp(options);
          if (options.$isMultiLine)
            return replacement;
          if (!re)
            return ;
          var match = re.exec(input);
          if (!match || match[0].length != input.length)
            return null;
          replacement = input.replace(re, replacement);
          if (options.preserveCase) {
            replacement = replacement.split("");
            for (var i = Math.min(input.length, input.length); i--; ) {
              var ch = input[i];
              if (ch && ch.toLowerCase() != ch)
                replacement[i] = replacement[i].toUpperCase();
              else
                replacement[i] = replacement[i].toLowerCase();
            }
            replacement = replacement.join("");
          }
          return replacement;
        };
        this.$matchIterator = function(session, options) {
          var re = this.$assembleRegExp(options);
          if (!re)
            return false;
          var self = this,
              callback,
              backwards = options.backwards;
          if (options.$isMultiLine) {
            var len = re.length;
            var matchIterator = function(line, row, offset) {
              var startIndex = line.search(re[0]);
              if (startIndex == -1)
                return ;
              for (var i = 1; i < len; i++) {
                line = session.getLine(row + i);
                if (line.search(re[i]) == -1)
                  return ;
              }
              var endIndex = line.match(re[len - 1])[0].length;
              var range = new Range(row, startIndex, row + len - 1, endIndex);
              if (re.offset == 1) {
                range.start.row--;
                range.start.column = Number.MAX_VALUE;
              } else if (offset)
                range.start.column += offset;
              if (callback(range))
                return true;
            };
          } else if (backwards) {
            var matchIterator = function(line, row, startIndex) {
              var matches = lang.getMatchOffsets(line, re);
              for (var i = matches.length - 1; i >= 0; i--)
                if (callback(matches[i], row, startIndex))
                  return true;
            };
          } else {
            var matchIterator = function(line, row, startIndex) {
              var matches = lang.getMatchOffsets(line, re);
              for (var i = 0; i < matches.length; i++)
                if (callback(matches[i], row, startIndex))
                  return true;
            };
          }
          return {forEach: function(_callback) {
              callback = _callback;
              self.$lineIterator(session, options).forEach(matchIterator);
            }};
        };
        this.$assembleRegExp = function(options, $disableFakeMultiline) {
          if (options.needle instanceof RegExp)
            return options.re = options.needle;
          var needle = options.needle;
          if (!options.needle)
            return options.re = false;
          if (!options.regExp)
            needle = lang.escapeRegExp(needle);
          if (options.wholeWord)
            needle = "\\b" + needle + "\\b";
          var modifier = options.caseSensitive ? "gm" : "gmi";
          options.$isMultiLine = !$disableFakeMultiline && /[\n\r]/.test(needle);
          if (options.$isMultiLine)
            return options.re = this.$assembleMultilineRegExp(needle, modifier);
          try {
            var re = new RegExp(needle, modifier);
          } catch (e) {
            re = false;
          }
          return options.re = re;
        };
        this.$assembleMultilineRegExp = function(needle, modifier) {
          var parts = needle.replace(/\r\n|\r|\n/g, "$\n^").split("\n");
          var re = [];
          for (var i = 0; i < parts.length; i++)
            try {
              re.push(new RegExp(parts[i], modifier));
            } catch (e) {
              return false;
            }
          if (parts[0] == "") {
            re.shift();
            re.offset = 1;
          } else {
            re.offset = 0;
          }
          return re;
        };
        this.$lineIterator = function(session, options) {
          var backwards = options.backwards == true;
          var skipCurrent = options.skipCurrent != false;
          var range = options.range;
          var start = options.start;
          if (!start)
            start = range ? range[backwards ? "end" : "start"] : session.selection.getRange();
          if (start.start)
            start = start[skipCurrent != backwards ? "end" : "start"];
          var firstRow = range ? range.start.row : 0;
          var lastRow = range ? range.end.row : session.getLength() - 1;
          var forEach = backwards ? function(callback) {
            var row = start.row;
            var line = session.getLine(row).substring(0, start.column);
            if (callback(line, row))
              return ;
            for (row--; row >= firstRow; row--)
              if (callback(session.getLine(row), row))
                return ;
            if (options.wrap == false)
              return ;
            for (row = lastRow, firstRow = start.row; row >= firstRow; row--)
              if (callback(session.getLine(row), row))
                return ;
          } : function(callback) {
            var row = start.row;
            var line = session.getLine(row).substr(start.column);
            if (callback(line, row, start.column))
              return ;
            for (row = row + 1; row <= lastRow; row++)
              if (callback(session.getLine(row), row))
                return ;
            if (options.wrap == false)
              return ;
            for (row = firstRow, lastRow = start.row; row <= lastRow; row++)
              if (callback(session.getLine(row), row))
                return ;
          };
          return {forEach: forEach};
        };
      }).call(Search.prototype);
      exports.Search = Search;
    });
    ace.define("ace/keyboard/hash_handler", ["require", "exports", "module", "ace/lib/keys", "ace/lib/useragent"], function(acequire, exports, module) {
      "use strict";
      var keyUtil = acequire("../lib/keys");
      var useragent = acequire("../lib/useragent");
      var KEY_MODS = keyUtil.KEY_MODS;
      function HashHandler(config, platform) {
        this.platform = platform || (useragent.isMac ? "mac" : "win");
        this.commands = {};
        this.commandKeyBinding = {};
        this.addCommands(config);
        this.$singleCommand = true;
      }
      function MultiHashHandler(config, platform) {
        HashHandler.call(this, config, platform);
        this.$singleCommand = false;
      }
      MultiHashHandler.prototype = HashHandler.prototype;
      (function() {
        this.addCommand = function(command) {
          if (this.commands[command.name])
            this.removeCommand(command);
          this.commands[command.name] = command;
          if (command.bindKey)
            this._buildKeyHash(command);
        };
        this.removeCommand = function(command, keepCommand) {
          var name = command && (typeof command === 'string' ? command : command.name);
          command = this.commands[name];
          if (!keepCommand)
            delete this.commands[name];
          var ckb = this.commandKeyBinding;
          for (var keyId in ckb) {
            var cmdGroup = ckb[keyId];
            if (cmdGroup == command) {
              delete ckb[keyId];
            } else if (Array.isArray(cmdGroup)) {
              var i = cmdGroup.indexOf(command);
              if (i != -1) {
                cmdGroup.splice(i, 1);
                if (cmdGroup.length == 1)
                  ckb[keyId] = cmdGroup[0];
              }
            }
          }
        };
        this.bindKey = function(key, command, asDefault) {
          if (typeof key == "object")
            key = key[this.platform];
          if (!key)
            return ;
          if (typeof command == "function")
            return this.addCommand({
              exec: command,
              bindKey: key,
              name: command.name || key
            });
          key.split("|").forEach(function(keyPart) {
            var chain = "";
            if (keyPart.indexOf(" ") != -1) {
              var parts = keyPart.split(/\s+/);
              keyPart = parts.pop();
              parts.forEach(function(keyPart) {
                var binding = this.parseKeys(keyPart);
                var id = KEY_MODS[binding.hashId] + binding.key;
                chain += (chain ? " " : "") + id;
                this._addCommandToBinding(chain, "chainKeys");
              }, this);
              chain += " ";
            }
            var binding = this.parseKeys(keyPart);
            var id = KEY_MODS[binding.hashId] + binding.key;
            this._addCommandToBinding(chain + id, command, asDefault);
          }, this);
        };
        this._addCommandToBinding = function(keyId, command, asDefault) {
          var ckb = this.commandKeyBinding,
              i;
          if (!command) {
            delete ckb[keyId];
          } else if (!ckb[keyId] || this.$singleCommand) {
            ckb[keyId] = command;
          } else {
            if (!Array.isArray(ckb[keyId])) {
              ckb[keyId] = [ckb[keyId]];
            } else if ((i = ckb[keyId].indexOf(command)) != -1) {
              ckb[keyId].splice(i, 1);
            }
            if (asDefault || command.isDefault)
              ckb[keyId].unshift(command);
            else
              ckb[keyId].push(command);
          }
        };
        this.addCommands = function(commands) {
          commands && Object.keys(commands).forEach(function(name) {
            var command = commands[name];
            if (!command)
              return ;
            if (typeof command === "string")
              return this.bindKey(command, name);
            if (typeof command === "function")
              command = {exec: command};
            if (typeof command !== "object")
              return ;
            if (!command.name)
              command.name = name;
            this.addCommand(command);
          }, this);
        };
        this.removeCommands = function(commands) {
          Object.keys(commands).forEach(function(name) {
            this.removeCommand(commands[name]);
          }, this);
        };
        this.bindKeys = function(keyList) {
          Object.keys(keyList).forEach(function(key) {
            this.bindKey(key, keyList[key]);
          }, this);
        };
        this._buildKeyHash = function(command) {
          this.bindKey(command.bindKey, command);
        };
        this.parseKeys = function(keys) {
          var parts = keys.toLowerCase().split(/[\-\+]([\-\+])?/).filter(function(x) {
            return x;
          });
          var key = parts.pop();
          var keyCode = keyUtil[key];
          if (keyUtil.FUNCTION_KEYS[keyCode])
            key = keyUtil.FUNCTION_KEYS[keyCode].toLowerCase();
          else if (!parts.length)
            return {
              key: key,
              hashId: -1
            };
          else if (parts.length == 1 && parts[0] == "shift")
            return {
              key: key.toUpperCase(),
              hashId: -1
            };
          var hashId = 0;
          for (var i = parts.length; i--; ) {
            var modifier = keyUtil.KEY_MODS[parts[i]];
            if (modifier == null) {
              if (typeof console != "undefined")
                console.error("invalid modifier " + parts[i] + " in " + keys);
              return false;
            }
            hashId |= modifier;
          }
          return {
            key: key,
            hashId: hashId
          };
        };
        this.findKeyCommand = function findKeyCommand(hashId, keyString) {
          var key = KEY_MODS[hashId] + keyString;
          return this.commandKeyBinding[key];
        };
        this.handleKeyboard = function(data, hashId, keyString, keyCode) {
          var key = KEY_MODS[hashId] + keyString;
          var command = this.commandKeyBinding[key];
          if (data.$keyChain) {
            data.$keyChain += " " + key;
            command = this.commandKeyBinding[data.$keyChain] || command;
          }
          if (command) {
            if (command == "chainKeys" || command[command.length - 1] == "chainKeys") {
              data.$keyChain = data.$keyChain || key;
              return {command: "null"};
            }
          }
          if (data.$keyChain && keyCode > 0)
            data.$keyChain = "";
          return {command: command};
        };
      }).call(HashHandler.prototype);
      exports.HashHandler = HashHandler;
      exports.MultiHashHandler = MultiHashHandler;
    });
    ace.define("ace/commands/command_manager", ["require", "exports", "module", "ace/lib/oop", "ace/keyboard/hash_handler", "ace/lib/event_emitter"], function(acequire, exports, module) {
      "use strict";
      var oop = acequire("../lib/oop");
      var MultiHashHandler = acequire("../keyboard/hash_handler").MultiHashHandler;
      var EventEmitter = acequire("../lib/event_emitter").EventEmitter;
      var CommandManager = function(platform, commands) {
        MultiHashHandler.call(this, commands, platform);
        this.byName = this.commands;
        this.setDefaultHandler("exec", function(e) {
          return e.command.exec(e.editor, e.args || {});
        });
      };
      oop.inherits(CommandManager, MultiHashHandler);
      (function() {
        oop.implement(this, EventEmitter);
        this.exec = function(command, editor, args) {
          if (Array.isArray(command)) {
            for (var i = command.length; i--; ) {
              if (this.exec(command[i], editor, args))
                return true;
            }
            return false;
          }
          if (typeof command === "string")
            command = this.commands[command];
          if (!command)
            return false;
          if (editor && editor.$readOnly && !command.readOnly)
            return false;
          var e = {
            editor: editor,
            command: command,
            args: args
          };
          e.returnValue = this._emit("exec", e);
          this._signal("afterExec", e);
          return e.returnValue === false ? false : true;
        };
        this.toggleRecording = function(editor) {
          if (this.$inReplay)
            return ;
          editor && editor._emit("changeStatus");
          if (this.recording) {
            this.macro.pop();
            this.removeEventListener("exec", this.$addCommandToMacro);
            if (!this.macro.length)
              this.macro = this.oldMacro;
            return this.recording = false;
          }
          if (!this.$addCommandToMacro) {
            this.$addCommandToMacro = function(e) {
              this.macro.push([e.command, e.args]);
            }.bind(this);
          }
          this.oldMacro = this.macro;
          this.macro = [];
          this.on("exec", this.$addCommandToMacro);
          return this.recording = true;
        };
        this.replay = function(editor) {
          if (this.$inReplay || !this.macro)
            return ;
          if (this.recording)
            return this.toggleRecording(editor);
          try {
            this.$inReplay = true;
            this.macro.forEach(function(x) {
              if (typeof x == "string")
                this.exec(x, editor);
              else
                this.exec(x[0], editor, x[1]);
            }, this);
          } finally {
            this.$inReplay = false;
          }
        };
        this.trimMacro = function(m) {
          return m.map(function(x) {
            if (typeof x[0] != "string")
              x[0] = x[0].name;
            if (!x[1])
              x = x[0];
            return x;
          });
        };
      }).call(CommandManager.prototype);
      exports.CommandManager = CommandManager;
    });
    ace.define("ace/commands/default_commands", ["require", "exports", "module", "ace/lib/lang", "ace/config", "ace/range"], function(acequire, exports, module) {
      "use strict";
      var lang = acequire("../lib/lang");
      var config = acequire("../config");
      var Range = acequire("../range").Range;
      function bindKey(win, mac) {
        return {
          win: win,
          mac: mac
        };
      }
      exports.commands = [{
        name: "showSettingsMenu",
        bindKey: bindKey("Ctrl-,", "Command-,"),
        exec: function(editor) {
          config.loadModule("ace/ext/settings_menu", function(module) {
            module.init(editor);
            editor.showSettingsMenu();
          });
        },
        readOnly: true
      }, {
        name: "goToNextError",
        bindKey: bindKey("Alt-E", "Ctrl-E"),
        exec: function(editor) {
          config.loadModule("ace/ext/error_marker", function(module) {
            module.showErrorMarker(editor, 1);
          });
        },
        scrollIntoView: "animate",
        readOnly: true
      }, {
        name: "goToPreviousError",
        bindKey: bindKey("Alt-Shift-E", "Ctrl-Shift-E"),
        exec: function(editor) {
          config.loadModule("ace/ext/error_marker", function(module) {
            module.showErrorMarker(editor, -1);
          });
        },
        scrollIntoView: "animate",
        readOnly: true
      }, {
        name: "selectall",
        bindKey: bindKey("Ctrl-A", "Command-A"),
        exec: function(editor) {
          editor.selectAll();
        },
        readOnly: true
      }, {
        name: "centerselection",
        bindKey: bindKey(null, "Ctrl-L"),
        exec: function(editor) {
          editor.centerSelection();
        },
        readOnly: true
      }, {
        name: "gotoline",
        bindKey: bindKey("Ctrl-L", "Command-L"),
        exec: function(editor) {
          var line = parseInt(prompt("Enter line number:"), 10);
          if (!isNaN(line)) {
            editor.gotoLine(line);
          }
        },
        readOnly: true
      }, {
        name: "fold",
        bindKey: bindKey("Alt-L|Ctrl-F1", "Command-Alt-L|Command-F1"),
        exec: function(editor) {
          editor.session.toggleFold(false);
        },
        scrollIntoView: "center",
        readOnly: true
      }, {
        name: "unfold",
        bindKey: bindKey("Alt-Shift-L|Ctrl-Shift-F1", "Command-Alt-Shift-L|Command-Shift-F1"),
        exec: function(editor) {
          editor.session.toggleFold(true);
        },
        scrollIntoView: "center",
        readOnly: true
      }, {
        name: "toggleFoldWidget",
        bindKey: bindKey("F2", "F2"),
        exec: function(editor) {
          editor.session.toggleFoldWidget();
        },
        scrollIntoView: "center",
        readOnly: true
      }, {
        name: "toggleParentFoldWidget",
        bindKey: bindKey("Alt-F2", "Alt-F2"),
        exec: function(editor) {
          editor.session.toggleFoldWidget(true);
        },
        scrollIntoView: "center",
        readOnly: true
      }, {
        name: "foldall",
        bindKey: bindKey("Ctrl-Alt-0", "Ctrl-Command-Option-0"),
        exec: function(editor) {
          editor.session.foldAll();
        },
        scrollIntoView: "center",
        readOnly: true
      }, {
        name: "foldOther",
        bindKey: bindKey("Alt-0", "Command-Option-0"),
        exec: function(editor) {
          editor.session.foldAll();
          editor.session.unfold(editor.selection.getAllRanges());
        },
        scrollIntoView: "center",
        readOnly: true
      }, {
        name: "unfoldall",
        bindKey: bindKey("Alt-Shift-0", "Command-Option-Shift-0"),
        exec: function(editor) {
          editor.session.unfold();
        },
        scrollIntoView: "center",
        readOnly: true
      }, {
        name: "findnext",
        bindKey: bindKey("Ctrl-K", "Command-G"),
        exec: function(editor) {
          editor.findNext();
        },
        multiSelectAction: "forEach",
        scrollIntoView: "center",
        readOnly: true
      }, {
        name: "findprevious",
        bindKey: bindKey("Ctrl-Shift-K", "Command-Shift-G"),
        exec: function(editor) {
          editor.findPrevious();
        },
        multiSelectAction: "forEach",
        scrollIntoView: "center",
        readOnly: true
      }, {
        name: "selectOrFindNext",
        bindKey: bindKey("Alt-K", "Ctrl-G"),
        exec: function(editor) {
          if (editor.selection.isEmpty())
            editor.selection.selectWord();
          else
            editor.findNext();
        },
        readOnly: true
      }, {
        name: "selectOrFindPrevious",
        bindKey: bindKey("Alt-Shift-K", "Ctrl-Shift-G"),
        exec: function(editor) {
          if (editor.selection.isEmpty())
            editor.selection.selectWord();
          else
            editor.findPrevious();
        },
        readOnly: true
      }, {
        name: "find",
        bindKey: bindKey("Ctrl-F", "Command-F"),
        exec: function(editor) {
          config.loadModule("ace/ext/searchbox", function(e) {
            e.Search(editor);
          });
        },
        readOnly: true
      }, {
        name: "overwrite",
        bindKey: "Insert",
        exec: function(editor) {
          editor.toggleOverwrite();
        },
        readOnly: true
      }, {
        name: "selecttostart",
        bindKey: bindKey("Ctrl-Shift-Home", "Command-Shift-Up"),
        exec: function(editor) {
          editor.getSelection().selectFileStart();
        },
        multiSelectAction: "forEach",
        readOnly: true,
        scrollIntoView: "animate",
        aceCommandGroup: "fileJump"
      }, {
        name: "gotostart",
        bindKey: bindKey("Ctrl-Home", "Command-Home|Command-Up"),
        exec: function(editor) {
          editor.navigateFileStart();
        },
        multiSelectAction: "forEach",
        readOnly: true,
        scrollIntoView: "animate",
        aceCommandGroup: "fileJump"
      }, {
        name: "selectup",
        bindKey: bindKey("Shift-Up", "Shift-Up"),
        exec: function(editor) {
          editor.getSelection().selectUp();
        },
        multiSelectAction: "forEach",
        readOnly: true
      }, {
        name: "golineup",
        bindKey: bindKey("Up", "Up|Ctrl-P"),
        exec: function(editor, args) {
          editor.navigateUp(args.times);
        },
        multiSelectAction: "forEach",
        readOnly: true
      }, {
        name: "selecttoend",
        bindKey: bindKey("Ctrl-Shift-End", "Command-Shift-Down"),
        exec: function(editor) {
          editor.getSelection().selectFileEnd();
        },
        multiSelectAction: "forEach",
        readOnly: true,
        scrollIntoView: "animate",
        aceCommandGroup: "fileJump"
      }, {
        name: "gotoend",
        bindKey: bindKey("Ctrl-End", "Command-End|Command-Down"),
        exec: function(editor) {
          editor.navigateFileEnd();
        },
        multiSelectAction: "forEach",
        readOnly: true,
        scrollIntoView: "animate",
        aceCommandGroup: "fileJump"
      }, {
        name: "selectdown",
        bindKey: bindKey("Shift-Down", "Shift-Down"),
        exec: function(editor) {
          editor.getSelection().selectDown();
        },
        multiSelectAction: "forEach",
        scrollIntoView: "cursor",
        readOnly: true
      }, {
        name: "golinedown",
        bindKey: bindKey("Down", "Down|Ctrl-N"),
        exec: function(editor, args) {
          editor.navigateDown(args.times);
        },
        multiSelectAction: "forEach",
        scrollIntoView: "cursor",
        readOnly: true
      }, {
        name: "selectwordleft",
        bindKey: bindKey("Ctrl-Shift-Left", "Option-Shift-Left"),
        exec: function(editor) {
          editor.getSelection().selectWordLeft();
        },
        multiSelectAction: "forEach",
        scrollIntoView: "cursor",
        readOnly: true
      }, {
        name: "gotowordleft",
        bindKey: bindKey("Ctrl-Left", "Option-Left"),
        exec: function(editor) {
          editor.navigateWordLeft();
        },
        multiSelectAction: "forEach",
        scrollIntoView: "cursor",
        readOnly: true
      }, {
        name: "selecttolinestart",
        bindKey: bindKey("Alt-Shift-Left", "Command-Shift-Left"),
        exec: function(editor) {
          editor.getSelection().selectLineStart();
        },
        multiSelectAction: "forEach",
        scrollIntoView: "cursor",
        readOnly: true
      }, {
        name: "gotolinestart",
        bindKey: bindKey("Alt-Left|Home", "Command-Left|Home|Ctrl-A"),
        exec: function(editor) {
          editor.navigateLineStart();
        },
        multiSelectAction: "forEach",
        scrollIntoView: "cursor",
        readOnly: true
      }, {
        name: "selectleft",
        bindKey: bindKey("Shift-Left", "Shift-Left"),
        exec: function(editor) {
          editor.getSelection().selectLeft();
        },
        multiSelectAction: "forEach",
        scrollIntoView: "cursor",
        readOnly: true
      }, {
        name: "gotoleft",
        bindKey: bindKey("Left", "Left|Ctrl-B"),
        exec: function(editor, args) {
          editor.navigateLeft(args.times);
        },
        multiSelectAction: "forEach",
        scrollIntoView: "cursor",
        readOnly: true
      }, {
        name: "selectwordright",
        bindKey: bindKey("Ctrl-Shift-Right", "Option-Shift-Right"),
        exec: function(editor) {
          editor.getSelection().selectWordRight();
        },
        multiSelectAction: "forEach",
        scrollIntoView: "cursor",
        readOnly: true
      }, {
        name: "gotowordright",
        bindKey: bindKey("Ctrl-Right", "Option-Right"),
        exec: function(editor) {
          editor.navigateWordRight();
        },
        multiSelectAction: "forEach",
        scrollIntoView: "cursor",
        readOnly: true
      }, {
        name: "selecttolineend",
        bindKey: bindKey("Alt-Shift-Right", "Command-Shift-Right"),
        exec: function(editor) {
          editor.getSelection().selectLineEnd();
        },
        multiSelectAction: "forEach",
        scrollIntoView: "cursor",
        readOnly: true
      }, {
        name: "gotolineend",
        bindKey: bindKey("Alt-Right|End", "Command-Right|End|Ctrl-E"),
        exec: function(editor) {
          editor.navigateLineEnd();
        },
        multiSelectAction: "forEach",
        scrollIntoView: "cursor",
        readOnly: true
      }, {
        name: "selectright",
        bindKey: bindKey("Shift-Right", "Shift-Right"),
        exec: function(editor) {
          editor.getSelection().selectRight();
        },
        multiSelectAction: "forEach",
        scrollIntoView: "cursor",
        readOnly: true
      }, {
        name: "gotoright",
        bindKey: bindKey("Right", "Right|Ctrl-F"),
        exec: function(editor, args) {
          editor.navigateRight(args.times);
        },
        multiSelectAction: "forEach",
        scrollIntoView: "cursor",
        readOnly: true
      }, {
        name: "selectpagedown",
        bindKey: "Shift-PageDown",
        exec: function(editor) {
          editor.selectPageDown();
        },
        readOnly: true
      }, {
        name: "pagedown",
        bindKey: bindKey(null, "Option-PageDown"),
        exec: function(editor) {
          editor.scrollPageDown();
        },
        readOnly: true
      }, {
        name: "gotopagedown",
        bindKey: bindKey("PageDown", "PageDown|Ctrl-V"),
        exec: function(editor) {
          editor.gotoPageDown();
        },
        readOnly: true
      }, {
        name: "selectpageup",
        bindKey: "Shift-PageUp",
        exec: function(editor) {
          editor.selectPageUp();
        },
        readOnly: true
      }, {
        name: "pageup",
        bindKey: bindKey(null, "Option-PageUp"),
        exec: function(editor) {
          editor.scrollPageUp();
        },
        readOnly: true
      }, {
        name: "gotopageup",
        bindKey: "PageUp",
        exec: function(editor) {
          editor.gotoPageUp();
        },
        readOnly: true
      }, {
        name: "scrollup",
        bindKey: bindKey("Ctrl-Up", null),
        exec: function(e) {
          e.renderer.scrollBy(0, -2 * e.renderer.layerConfig.lineHeight);
        },
        readOnly: true
      }, {
        name: "scrolldown",
        bindKey: bindKey("Ctrl-Down", null),
        exec: function(e) {
          e.renderer.scrollBy(0, 2 * e.renderer.layerConfig.lineHeight);
        },
        readOnly: true
      }, {
        name: "selectlinestart",
        bindKey: "Shift-Home",
        exec: function(editor) {
          editor.getSelection().selectLineStart();
        },
        multiSelectAction: "forEach",
        scrollIntoView: "cursor",
        readOnly: true
      }, {
        name: "selectlineend",
        bindKey: "Shift-End",
        exec: function(editor) {
          editor.getSelection().selectLineEnd();
        },
        multiSelectAction: "forEach",
        scrollIntoView: "cursor",
        readOnly: true
      }, {
        name: "togglerecording",
        bindKey: bindKey("Ctrl-Alt-E", "Command-Option-E"),
        exec: function(editor) {
          editor.commands.toggleRecording(editor);
        },
        readOnly: true
      }, {
        name: "replaymacro",
        bindKey: bindKey("Ctrl-Shift-E", "Command-Shift-E"),
        exec: function(editor) {
          editor.commands.replay(editor);
        },
        readOnly: true
      }, {
        name: "jumptomatching",
        bindKey: bindKey("Ctrl-P", "Ctrl-P"),
        exec: function(editor) {
          editor.jumpToMatching();
        },
        multiSelectAction: "forEach",
        readOnly: true
      }, {
        name: "selecttomatching",
        bindKey: bindKey("Ctrl-Shift-P", "Ctrl-Shift-P"),
        exec: function(editor) {
          editor.jumpToMatching(true);
        },
        multiSelectAction: "forEach",
        readOnly: true
      }, {
        name: "passKeysToBrowser",
        bindKey: bindKey("null", "null"),
        exec: function() {},
        passEvent: true,
        readOnly: true
      }, {
        name: "cut",
        exec: function(editor) {
          var range = editor.getSelectionRange();
          editor._emit("cut", range);
          if (!editor.selection.isEmpty()) {
            editor.session.remove(range);
            editor.clearSelection();
          }
        },
        scrollIntoView: "cursor",
        multiSelectAction: "forEach"
      }, {
        name: "removeline",
        bindKey: bindKey("Ctrl-D", "Command-D"),
        exec: function(editor) {
          editor.removeLines();
        },
        scrollIntoView: "cursor",
        multiSelectAction: "forEachLine"
      }, {
        name: "duplicateSelection",
        bindKey: bindKey("Ctrl-Shift-D", "Command-Shift-D"),
        exec: function(editor) {
          editor.duplicateSelection();
        },
        scrollIntoView: "cursor",
        multiSelectAction: "forEach"
      }, {
        name: "sortlines",
        bindKey: bindKey("Ctrl-Alt-S", "Command-Alt-S"),
        exec: function(editor) {
          editor.sortLines();
        },
        scrollIntoView: "selection",
        multiSelectAction: "forEachLine"
      }, {
        name: "togglecomment",
        bindKey: bindKey("Ctrl-/", "Command-/"),
        exec: function(editor) {
          editor.toggleCommentLines();
        },
        multiSelectAction: "forEachLine",
        scrollIntoView: "selectionPart"
      }, {
        name: "toggleBlockComment",
        bindKey: bindKey("Ctrl-Shift-/", "Command-Shift-/"),
        exec: function(editor) {
          editor.toggleBlockComment();
        },
        multiSelectAction: "forEach",
        scrollIntoView: "selectionPart"
      }, {
        name: "modifyNumberUp",
        bindKey: bindKey("Ctrl-Shift-Up", "Alt-Shift-Up"),
        exec: function(editor) {
          editor.modifyNumber(1);
        },
        multiSelectAction: "forEach"
      }, {
        name: "modifyNumberDown",
        bindKey: bindKey("Ctrl-Shift-Down", "Alt-Shift-Down"),
        exec: function(editor) {
          editor.modifyNumber(-1);
        },
        multiSelectAction: "forEach"
      }, {
        name: "replace",
        bindKey: bindKey("Ctrl-H", "Command-Option-F"),
        exec: function(editor) {
          config.loadModule("ace/ext/searchbox", function(e) {
            e.Search(editor, true);
          });
        }
      }, {
        name: "undo",
        bindKey: bindKey("Ctrl-Z", "Command-Z"),
        exec: function(editor) {
          editor.undo();
        }
      }, {
        name: "redo",
        bindKey: bindKey("Ctrl-Shift-Z|Ctrl-Y", "Command-Shift-Z|Command-Y"),
        exec: function(editor) {
          editor.redo();
        }
      }, {
        name: "copylinesup",
        bindKey: bindKey("Alt-Shift-Up", "Command-Option-Up"),
        exec: function(editor) {
          editor.copyLinesUp();
        },
        scrollIntoView: "cursor"
      }, {
        name: "movelinesup",
        bindKey: bindKey("Alt-Up", "Option-Up"),
        exec: function(editor) {
          editor.moveLinesUp();
        },
        scrollIntoView: "cursor"
      }, {
        name: "copylinesdown",
        bindKey: bindKey("Alt-Shift-Down", "Command-Option-Down"),
        exec: function(editor) {
          editor.copyLinesDown();
        },
        scrollIntoView: "cursor"
      }, {
        name: "movelinesdown",
        bindKey: bindKey("Alt-Down", "Option-Down"),
        exec: function(editor) {
          editor.moveLinesDown();
        },
        scrollIntoView: "cursor"
      }, {
        name: "del",
        bindKey: bindKey("Delete", "Delete|Ctrl-D|Shift-Delete"),
        exec: function(editor) {
          editor.remove("right");
        },
        multiSelectAction: "forEach",
        scrollIntoView: "cursor"
      }, {
        name: "backspace",
        bindKey: bindKey("Shift-Backspace|Backspace", "Ctrl-Backspace|Shift-Backspace|Backspace|Ctrl-H"),
        exec: function(editor) {
          editor.remove("left");
        },
        multiSelectAction: "forEach",
        scrollIntoView: "cursor"
      }, {
        name: "cut_or_delete",
        bindKey: bindKey("Shift-Delete", null),
        exec: function(editor) {
          if (editor.selection.isEmpty()) {
            editor.remove("left");
          } else {
            return false;
          }
        },
        multiSelectAction: "forEach",
        scrollIntoView: "cursor"
      }, {
        name: "removetolinestart",
        bindKey: bindKey("Alt-Backspace", "Command-Backspace"),
        exec: function(editor) {
          editor.removeToLineStart();
        },
        multiSelectAction: "forEach",
        scrollIntoView: "cursor"
      }, {
        name: "removetolineend",
        bindKey: bindKey("Alt-Delete", "Ctrl-K"),
        exec: function(editor) {
          editor.removeToLineEnd();
        },
        multiSelectAction: "forEach",
        scrollIntoView: "cursor"
      }, {
        name: "removewordleft",
        bindKey: bindKey("Ctrl-Backspace", "Alt-Backspace|Ctrl-Alt-Backspace"),
        exec: function(editor) {
          editor.removeWordLeft();
        },
        multiSelectAction: "forEach",
        scrollIntoView: "cursor"
      }, {
        name: "removewordright",
        bindKey: bindKey("Ctrl-Delete", "Alt-Delete"),
        exec: function(editor) {
          editor.removeWordRight();
        },
        multiSelectAction: "forEach",
        scrollIntoView: "cursor"
      }, {
        name: "outdent",
        bindKey: bindKey("Shift-Tab", "Shift-Tab"),
        exec: function(editor) {
          editor.blockOutdent();
        },
        multiSelectAction: "forEach",
        scrollIntoView: "selectionPart"
      }, {
        name: "indent",
        bindKey: bindKey("Tab", "Tab"),
        exec: function(editor) {
          editor.indent();
        },
        multiSelectAction: "forEach",
        scrollIntoView: "selectionPart"
      }, {
        name: "blockoutdent",
        bindKey: bindKey("Ctrl-[", "Ctrl-["),
        exec: function(editor) {
          editor.blockOutdent();
        },
        multiSelectAction: "forEachLine",
        scrollIntoView: "selectionPart"
      }, {
        name: "blockindent",
        bindKey: bindKey("Ctrl-]", "Ctrl-]"),
        exec: function(editor) {
          editor.blockIndent();
        },
        multiSelectAction: "forEachLine",
        scrollIntoView: "selectionPart"
      }, {
        name: "insertstring",
        exec: function(editor, str) {
          editor.insert(str);
        },
        multiSelectAction: "forEach",
        scrollIntoView: "cursor"
      }, {
        name: "inserttext",
        exec: function(editor, args) {
          editor.insert(lang.stringRepeat(args.text || "", args.times || 1));
        },
        multiSelectAction: "forEach",
        scrollIntoView: "cursor"
      }, {
        name: "splitline",
        bindKey: bindKey(null, "Ctrl-O"),
        exec: function(editor) {
          editor.splitLine();
        },
        multiSelectAction: "forEach",
        scrollIntoView: "cursor"
      }, {
        name: "transposeletters",
        bindKey: bindKey("Ctrl-T", "Ctrl-T"),
        exec: function(editor) {
          editor.transposeLetters();
        },
        multiSelectAction: function(editor) {
          editor.transposeSelections(1);
        },
        scrollIntoView: "cursor"
      }, {
        name: "touppercase",
        bindKey: bindKey("Ctrl-U", "Ctrl-U"),
        exec: function(editor) {
          editor.toUpperCase();
        },
        multiSelectAction: "forEach",
        scrollIntoView: "cursor"
      }, {
        name: "tolowercase",
        bindKey: bindKey("Ctrl-Shift-U", "Ctrl-Shift-U"),
        exec: function(editor) {
          editor.toLowerCase();
        },
        multiSelectAction: "forEach",
        scrollIntoView: "cursor"
      }, {
        name: "expandtoline",
        bindKey: bindKey("Ctrl-Shift-L", "Command-Shift-L"),
        exec: function(editor) {
          var range = editor.selection.getRange();
          range.start.column = range.end.column = 0;
          range.end.row++;
          editor.selection.setRange(range, false);
        },
        multiSelectAction: "forEach",
        scrollIntoView: "cursor",
        readOnly: true
      }, {
        name: "joinlines",
        bindKey: bindKey(null, null),
        exec: function(editor) {
          var isBackwards = editor.selection.isBackwards();
          var selectionStart = isBackwards ? editor.selection.getSelectionLead() : editor.selection.getSelectionAnchor();
          var selectionEnd = isBackwards ? editor.selection.getSelectionAnchor() : editor.selection.getSelectionLead();
          var firstLineEndCol = editor.session.doc.getLine(selectionStart.row).length;
          var selectedText = editor.session.doc.getTextRange(editor.selection.getRange());
          var selectedCount = selectedText.replace(/\n\s*/, " ").length;
          var insertLine = editor.session.doc.getLine(selectionStart.row);
          for (var i = selectionStart.row + 1; i <= selectionEnd.row + 1; i++) {
            var curLine = lang.stringTrimLeft(lang.stringTrimRight(editor.session.doc.getLine(i)));
            if (curLine.length !== 0) {
              curLine = " " + curLine;
            }
            insertLine += curLine;
          }
          ;
          if (selectionEnd.row + 1 < (editor.session.doc.getLength() - 1)) {
            insertLine += editor.session.doc.getNewLineCharacter();
          }
          editor.clearSelection();
          editor.session.doc.replace(new Range(selectionStart.row, 0, selectionEnd.row + 2, 0), insertLine);
          if (selectedCount > 0) {
            editor.selection.moveCursorTo(selectionStart.row, selectionStart.column);
            editor.selection.selectTo(selectionStart.row, selectionStart.column + selectedCount);
          } else {
            firstLineEndCol = editor.session.doc.getLine(selectionStart.row).length > firstLineEndCol ? (firstLineEndCol + 1) : firstLineEndCol;
            editor.selection.moveCursorTo(selectionStart.row, firstLineEndCol);
          }
        },
        multiSelectAction: "forEach",
        readOnly: true
      }, {
        name: "invertSelection",
        bindKey: bindKey(null, null),
        exec: function(editor) {
          var endRow = editor.session.doc.getLength() - 1;
          var endCol = editor.session.doc.getLine(endRow).length;
          var ranges = editor.selection.rangeList.ranges;
          var newRanges = [];
          if (ranges.length < 1) {
            ranges = [editor.selection.getRange()];
          }
          for (var i = 0; i < ranges.length; i++) {
            if (i == (ranges.length - 1)) {
              if (!(ranges[i].end.row === endRow && ranges[i].end.column === endCol)) {
                newRanges.push(new Range(ranges[i].end.row, ranges[i].end.column, endRow, endCol));
              }
            }
            if (i === 0) {
              if (!(ranges[i].start.row === 0 && ranges[i].start.column === 0)) {
                newRanges.push(new Range(0, 0, ranges[i].start.row, ranges[i].start.column));
              }
            } else {
              newRanges.push(new Range(ranges[i - 1].end.row, ranges[i - 1].end.column, ranges[i].start.row, ranges[i].start.column));
            }
          }
          editor.exitMultiSelectMode();
          editor.clearSelection();
          for (var i = 0; i < newRanges.length; i++) {
            editor.selection.addRange(newRanges[i], false);
          }
        },
        readOnly: true,
        scrollIntoView: "none"
      }];
    });
    ace.define("ace/editor", ["require", "exports", "module", "ace/lib/fixoldbrowsers", "ace/lib/oop", "ace/lib/dom", "ace/lib/lang", "ace/lib/useragent", "ace/keyboard/textinput", "ace/mouse/mouse_handler", "ace/mouse/fold_handler", "ace/keyboard/keybinding", "ace/edit_session", "ace/search", "ace/range", "ace/lib/event_emitter", "ace/commands/command_manager", "ace/commands/default_commands", "ace/config", "ace/token_iterator"], function(acequire, exports, module) {
      "use strict";
      acequire("./lib/fixoldbrowsers");
      var oop = acequire("./lib/oop");
      var dom = acequire("./lib/dom");
      var lang = acequire("./lib/lang");
      var useragent = acequire("./lib/useragent");
      var TextInput = acequire("./keyboard/textinput").TextInput;
      var MouseHandler = acequire("./mouse/mouse_handler").MouseHandler;
      var FoldHandler = acequire("./mouse/fold_handler").FoldHandler;
      var KeyBinding = acequire("./keyboard/keybinding").KeyBinding;
      var EditSession = acequire("./edit_session").EditSession;
      var Search = acequire("./search").Search;
      var Range = acequire("./range").Range;
      var EventEmitter = acequire("./lib/event_emitter").EventEmitter;
      var CommandManager = acequire("./commands/command_manager").CommandManager;
      var defaultCommands = acequire("./commands/default_commands").commands;
      var config = acequire("./config");
      var TokenIterator = acequire("./token_iterator").TokenIterator;
      var Editor = function(renderer, session) {
        var container = renderer.getContainerElement();
        this.container = container;
        this.renderer = renderer;
        this.commands = new CommandManager(useragent.isMac ? "mac" : "win", defaultCommands);
        this.textInput = new TextInput(renderer.getTextAreaContainer(), this);
        this.renderer.textarea = this.textInput.getElement();
        this.keyBinding = new KeyBinding(this);
        this.$mouseHandler = new MouseHandler(this);
        new FoldHandler(this);
        this.$blockScrolling = 0;
        this.$search = new Search().set({wrap: true});
        this.$historyTracker = this.$historyTracker.bind(this);
        this.commands.on("exec", this.$historyTracker);
        this.$initOperationListeners();
        this._$emitInputEvent = lang.delayedCall(function() {
          this._signal("input", {});
          if (this.session && this.session.bgTokenizer)
            this.session.bgTokenizer.scheduleStart();
        }.bind(this));
        this.on("change", function(_, _self) {
          _self._$emitInputEvent.schedule(31);
        });
        this.setSession(session || new EditSession(""));
        config.resetOptions(this);
        config._signal("editor", this);
      };
      (function() {
        oop.implement(this, EventEmitter);
        this.$initOperationListeners = function() {
          function last(a) {
            return a[a.length - 1];
          }
          this.selections = [];
          this.commands.on("exec", this.startOperation.bind(this), true);
          this.commands.on("afterExec", this.endOperation.bind(this), true);
          this.$opResetTimer = lang.delayedCall(this.endOperation.bind(this));
          this.on("change", function() {
            this.curOp || this.startOperation();
            this.curOp.docChanged = true;
          }.bind(this), true);
          this.on("changeSelection", function() {
            this.curOp || this.startOperation();
            this.curOp.selectionChanged = true;
          }.bind(this), true);
        };
        this.curOp = null;
        this.prevOp = {};
        this.startOperation = function(commadEvent) {
          if (this.curOp) {
            if (!commadEvent || this.curOp.command)
              return ;
            this.prevOp = this.curOp;
          }
          if (!commadEvent) {
            this.previousCommand = null;
            commadEvent = {};
          }
          this.$opResetTimer.schedule();
          this.curOp = {
            command: commadEvent.command || {},
            args: commadEvent.args,
            scrollTop: this.renderer.scrollTop
          };
        };
        this.endOperation = function(e) {
          if (this.curOp) {
            if (e && e.returnValue === false)
              return this.curOp = null;
            var command = this.curOp.command;
            if (command && command.scrollIntoView) {
              switch (command.scrollIntoView) {
                case "center":
                  this.renderer.scrollCursorIntoView(null, 0.5);
                  break;
                case "animate":
                case "cursor":
                  this.renderer.scrollCursorIntoView();
                  break;
                case "selectionPart":
                  var range = this.selection.getRange();
                  var config = this.renderer.layerConfig;
                  if (range.start.row >= config.lastRow || range.end.row <= config.firstRow) {
                    this.renderer.scrollSelectionIntoView(this.selection.anchor, this.selection.lead);
                  }
                  break;
                default:
                  break;
              }
              if (command.scrollIntoView == "animate")
                this.renderer.animateScrolling(this.curOp.scrollTop);
            }
            this.prevOp = this.curOp;
            this.curOp = null;
          }
        };
        this.$mergeableCommands = ["backspace", "del", "insertstring"];
        this.$historyTracker = function(e) {
          if (!this.$mergeUndoDeltas)
            return ;
          var prev = this.prevOp;
          var mergeableCommands = this.$mergeableCommands;
          var shouldMerge = prev.command && (e.command.name == prev.command.name);
          if (e.command.name == "insertstring") {
            var text = e.args;
            if (this.mergeNextCommand === undefined)
              this.mergeNextCommand = true;
            shouldMerge = shouldMerge && this.mergeNextCommand && (!/\s/.test(text) || /\s/.test(prev.args));
            this.mergeNextCommand = true;
          } else {
            shouldMerge = shouldMerge && mergeableCommands.indexOf(e.command.name) !== -1;
          }
          if (this.$mergeUndoDeltas != "always" && Date.now() - this.sequenceStartTime > 2000) {
            shouldMerge = false;
          }
          if (shouldMerge)
            this.session.mergeUndoDeltas = true;
          else if (mergeableCommands.indexOf(e.command.name) !== -1)
            this.sequenceStartTime = Date.now();
        };
        this.setKeyboardHandler = function(keyboardHandler, cb) {
          if (keyboardHandler && typeof keyboardHandler === "string") {
            this.$keybindingId = keyboardHandler;
            var _self = this;
            config.loadModule(["keybinding", keyboardHandler], function(module) {
              if (_self.$keybindingId == keyboardHandler)
                _self.keyBinding.setKeyboardHandler(module && module.handler);
              cb && cb();
            });
          } else {
            this.$keybindingId = null;
            this.keyBinding.setKeyboardHandler(keyboardHandler);
            cb && cb();
          }
        };
        this.getKeyboardHandler = function() {
          return this.keyBinding.getKeyboardHandler();
        };
        this.setSession = function(session) {
          if (this.session == session)
            return ;
          var oldSession = this.session;
          if (oldSession) {
            this.session.removeEventListener("change", this.$onDocumentChange);
            this.session.removeEventListener("changeMode", this.$onChangeMode);
            this.session.removeEventListener("tokenizerUpdate", this.$onTokenizerUpdate);
            this.session.removeEventListener("changeTabSize", this.$onChangeTabSize);
            this.session.removeEventListener("changeWrapLimit", this.$onChangeWrapLimit);
            this.session.removeEventListener("changeWrapMode", this.$onChangeWrapMode);
            this.session.removeEventListener("onChangeFold", this.$onChangeFold);
            this.session.removeEventListener("changeFrontMarker", this.$onChangeFrontMarker);
            this.session.removeEventListener("changeBackMarker", this.$onChangeBackMarker);
            this.session.removeEventListener("changeBreakpoint", this.$onChangeBreakpoint);
            this.session.removeEventListener("changeAnnotation", this.$onChangeAnnotation);
            this.session.removeEventListener("changeOverwrite", this.$onCursorChange);
            this.session.removeEventListener("changeScrollTop", this.$onScrollTopChange);
            this.session.removeEventListener("changeScrollLeft", this.$onScrollLeftChange);
            var selection = this.session.getSelection();
            selection.removeEventListener("changeCursor", this.$onCursorChange);
            selection.removeEventListener("changeSelection", this.$onSelectionChange);
          }
          this.session = session;
          if (session) {
            this.$onDocumentChange = this.onDocumentChange.bind(this);
            session.addEventListener("change", this.$onDocumentChange);
            this.renderer.setSession(session);
            this.$onChangeMode = this.onChangeMode.bind(this);
            session.addEventListener("changeMode", this.$onChangeMode);
            this.$onTokenizerUpdate = this.onTokenizerUpdate.bind(this);
            session.addEventListener("tokenizerUpdate", this.$onTokenizerUpdate);
            this.$onChangeTabSize = this.renderer.onChangeTabSize.bind(this.renderer);
            session.addEventListener("changeTabSize", this.$onChangeTabSize);
            this.$onChangeWrapLimit = this.onChangeWrapLimit.bind(this);
            session.addEventListener("changeWrapLimit", this.$onChangeWrapLimit);
            this.$onChangeWrapMode = this.onChangeWrapMode.bind(this);
            session.addEventListener("changeWrapMode", this.$onChangeWrapMode);
            this.$onChangeFold = this.onChangeFold.bind(this);
            session.addEventListener("changeFold", this.$onChangeFold);
            this.$onChangeFrontMarker = this.onChangeFrontMarker.bind(this);
            this.session.addEventListener("changeFrontMarker", this.$onChangeFrontMarker);
            this.$onChangeBackMarker = this.onChangeBackMarker.bind(this);
            this.session.addEventListener("changeBackMarker", this.$onChangeBackMarker);
            this.$onChangeBreakpoint = this.onChangeBreakpoint.bind(this);
            this.session.addEventListener("changeBreakpoint", this.$onChangeBreakpoint);
            this.$onChangeAnnotation = this.onChangeAnnotation.bind(this);
            this.session.addEventListener("changeAnnotation", this.$onChangeAnnotation);
            this.$onCursorChange = this.onCursorChange.bind(this);
            this.session.addEventListener("changeOverwrite", this.$onCursorChange);
            this.$onScrollTopChange = this.onScrollTopChange.bind(this);
            this.session.addEventListener("changeScrollTop", this.$onScrollTopChange);
            this.$onScrollLeftChange = this.onScrollLeftChange.bind(this);
            this.session.addEventListener("changeScrollLeft", this.$onScrollLeftChange);
            this.selection = session.getSelection();
            this.selection.addEventListener("changeCursor", this.$onCursorChange);
            this.$onSelectionChange = this.onSelectionChange.bind(this);
            this.selection.addEventListener("changeSelection", this.$onSelectionChange);
            this.onChangeMode();
            this.$blockScrolling += 1;
            this.onCursorChange();
            this.$blockScrolling -= 1;
            this.onScrollTopChange();
            this.onScrollLeftChange();
            this.onSelectionChange();
            this.onChangeFrontMarker();
            this.onChangeBackMarker();
            this.onChangeBreakpoint();
            this.onChangeAnnotation();
            this.session.getUseWrapMode() && this.renderer.adjustWrapLimit();
            this.renderer.updateFull();
          } else {
            this.selection = null;
            this.renderer.setSession(session);
          }
          this._signal("changeSession", {
            session: session,
            oldSession: oldSession
          });
          oldSession && oldSession._signal("changeEditor", {oldEditor: this});
          session && session._signal("changeEditor", {editor: this});
        };
        this.getSession = function() {
          return this.session;
        };
        this.setValue = function(val, cursorPos) {
          this.session.doc.setValue(val);
          if (!cursorPos)
            this.selectAll();
          else if (cursorPos == 1)
            this.navigateFileEnd();
          else if (cursorPos == -1)
            this.navigateFileStart();
          return val;
        };
        this.getValue = function() {
          return this.session.getValue();
        };
        this.getSelection = function() {
          return this.selection;
        };
        this.resize = function(force) {
          this.renderer.onResize(force);
        };
        this.setTheme = function(theme, cb) {
          this.renderer.setTheme(theme, cb);
        };
        this.getTheme = function() {
          return this.renderer.getTheme();
        };
        this.setStyle = function(style) {
          this.renderer.setStyle(style);
        };
        this.unsetStyle = function(style) {
          this.renderer.unsetStyle(style);
        };
        this.getFontSize = function() {
          return this.getOption("fontSize") || dom.computedStyle(this.container, "fontSize");
        };
        this.setFontSize = function(size) {
          this.setOption("fontSize", size);
        };
        this.$highlightBrackets = function() {
          if (this.session.$bracketHighlight) {
            this.session.removeMarker(this.session.$bracketHighlight);
            this.session.$bracketHighlight = null;
          }
          if (this.$highlightPending) {
            return ;
          }
          var self = this;
          this.$highlightPending = true;
          setTimeout(function() {
            self.$highlightPending = false;
            var session = self.session;
            if (!session || !session.bgTokenizer)
              return ;
            var pos = session.findMatchingBracket(self.getCursorPosition());
            if (pos) {
              var range = new Range(pos.row, pos.column, pos.row, pos.column + 1);
            } else if (session.$mode.getMatching) {
              var range = session.$mode.getMatching(self.session);
            }
            if (range)
              session.$bracketHighlight = session.addMarker(range, "ace_bracket", "text");
          }, 50);
        };
        this.$highlightTags = function() {
          if (this.$highlightTagPending)
            return ;
          var self = this;
          this.$highlightTagPending = true;
          setTimeout(function() {
            self.$highlightTagPending = false;
            var session = self.session;
            if (!session || !session.bgTokenizer)
              return ;
            var pos = self.getCursorPosition();
            var iterator = new TokenIterator(self.session, pos.row, pos.column);
            var token = iterator.getCurrentToken();
            if (!token || token.type.indexOf('tag-name') === -1) {
              session.removeMarker(session.$tagHighlight);
              session.$tagHighlight = null;
              return ;
            }
            var tag = token.value;
            var depth = 0;
            var prevToken = iterator.stepBackward();
            if (prevToken.value == '<') {
              do {
                prevToken = token;
                token = iterator.stepForward();
                if (token && token.value === tag && token.type.indexOf('tag-name') !== -1) {
                  if (prevToken.value === '<') {
                    depth++;
                  } else if (prevToken.value === '</') {
                    depth--;
                  }
                }
              } while (token && depth >= 0);
            } else {
              do {
                token = prevToken;
                prevToken = iterator.stepBackward();
                if (token && token.value === tag && token.type.indexOf('tag-name') !== -1) {
                  if (prevToken.value === '<') {
                    depth++;
                  } else if (prevToken.value === '</') {
                    depth--;
                  }
                }
              } while (prevToken && depth <= 0);
              iterator.stepForward();
            }
            if (!token) {
              session.removeMarker(session.$tagHighlight);
              session.$tagHighlight = null;
              return ;
            }
            var row = iterator.getCurrentTokenRow();
            var column = iterator.getCurrentTokenColumn();
            var range = new Range(row, column, row, column + token.value.length);
            if (session.$tagHighlight && range.compareRange(session.$backMarkers[session.$tagHighlight].range) !== 0) {
              session.removeMarker(session.$tagHighlight);
              session.$tagHighlight = null;
            }
            if (range && !session.$tagHighlight)
              session.$tagHighlight = session.addMarker(range, "ace_bracket", "text");
          }, 50);
        };
        this.focus = function() {
          var _self = this;
          setTimeout(function() {
            _self.textInput.focus();
          });
          this.textInput.focus();
        };
        this.isFocused = function() {
          return this.textInput.isFocused();
        };
        this.blur = function() {
          this.textInput.blur();
        };
        this.onFocus = function(e) {
          if (this.$isFocused)
            return ;
          this.$isFocused = true;
          this.renderer.showCursor();
          this.renderer.visualizeFocus();
          this._emit("focus", e);
        };
        this.onBlur = function(e) {
          if (!this.$isFocused)
            return ;
          this.$isFocused = false;
          this.renderer.hideCursor();
          this.renderer.visualizeBlur();
          this._emit("blur", e);
        };
        this.$cursorChange = function() {
          this.renderer.updateCursor();
        };
        this.onDocumentChange = function(e) {
          var delta = e.data;
          var range = delta.range;
          var lastRow;
          if (range.start.row == range.end.row && delta.action != "insertLines" && delta.action != "removeLines")
            lastRow = range.end.row;
          else
            lastRow = Infinity;
          this.renderer.updateLines(range.start.row, lastRow, this.session.$useWrapMode);
          this._signal("change", e);
          this.$cursorChange();
          this.$updateHighlightActiveLine();
        };
        this.onTokenizerUpdate = function(e) {
          var rows = e.data;
          this.renderer.updateLines(rows.first, rows.last);
        };
        this.onScrollTopChange = function() {
          this.renderer.scrollToY(this.session.getScrollTop());
        };
        this.onScrollLeftChange = function() {
          this.renderer.scrollToX(this.session.getScrollLeft());
        };
        this.onCursorChange = function() {
          this.$cursorChange();
          if (!this.$blockScrolling) {
            this.renderer.scrollCursorIntoView();
          }
          this.$highlightBrackets();
          this.$highlightTags();
          this.$updateHighlightActiveLine();
          this._signal("changeSelection");
        };
        this.$updateHighlightActiveLine = function() {
          var session = this.getSession();
          var highlight;
          if (this.$highlightActiveLine) {
            if ((this.$selectionStyle != "line" || !this.selection.isMultiLine()))
              highlight = this.getCursorPosition();
            if (this.renderer.$maxLines && this.session.getLength() === 1 && !(this.renderer.$minLines > 1))
              highlight = false;
          }
          if (session.$highlightLineMarker && !highlight) {
            session.removeMarker(session.$highlightLineMarker.id);
            session.$highlightLineMarker = null;
          } else if (!session.$highlightLineMarker && highlight) {
            var range = new Range(highlight.row, highlight.column, highlight.row, Infinity);
            range.id = session.addMarker(range, "ace_active-line", "screenLine");
            session.$highlightLineMarker = range;
          } else if (highlight) {
            session.$highlightLineMarker.start.row = highlight.row;
            session.$highlightLineMarker.end.row = highlight.row;
            session.$highlightLineMarker.start.column = highlight.column;
            session._signal("changeBackMarker");
          }
        };
        this.onSelectionChange = function(e) {
          var session = this.session;
          if (session.$selectionMarker) {
            session.removeMarker(session.$selectionMarker);
          }
          session.$selectionMarker = null;
          if (!this.selection.isEmpty()) {
            var range = this.selection.getRange();
            var style = this.getSelectionStyle();
            session.$selectionMarker = session.addMarker(range, "ace_selection", style);
          } else {
            this.$updateHighlightActiveLine();
          }
          var re = this.$highlightSelectedWord && this.$getSelectionHighLightRegexp();
          this.session.highlight(re);
          this._signal("changeSelection");
        };
        this.$getSelectionHighLightRegexp = function() {
          var session = this.session;
          var selection = this.getSelectionRange();
          if (selection.isEmpty() || selection.isMultiLine())
            return ;
          var startOuter = selection.start.column - 1;
          var endOuter = selection.end.column + 1;
          var line = session.getLine(selection.start.row);
          var lineCols = line.length;
          var needle = line.substring(Math.max(startOuter, 0), Math.min(endOuter, lineCols));
          if ((startOuter >= 0 && /^[\w\d]/.test(needle)) || (endOuter <= lineCols && /[\w\d]$/.test(needle)))
            return ;
          needle = line.substring(selection.start.column, selection.end.column);
          if (!/^[\w\d]+$/.test(needle))
            return ;
          var re = this.$search.$assembleRegExp({
            wholeWord: true,
            caseSensitive: true,
            needle: needle
          });
          return re;
        };
        this.onChangeFrontMarker = function() {
          this.renderer.updateFrontMarkers();
        };
        this.onChangeBackMarker = function() {
          this.renderer.updateBackMarkers();
        };
        this.onChangeBreakpoint = function() {
          this.renderer.updateBreakpoints();
        };
        this.onChangeAnnotation = function() {
          this.renderer.setAnnotations(this.session.getAnnotations());
        };
        this.onChangeMode = function(e) {
          this.renderer.updateText();
          this._emit("changeMode", e);
        };
        this.onChangeWrapLimit = function() {
          this.renderer.updateFull();
        };
        this.onChangeWrapMode = function() {
          this.renderer.onResize(true);
        };
        this.onChangeFold = function() {
          this.$updateHighlightActiveLine();
          this.renderer.updateFull();
        };
        this.getSelectedText = function() {
          return this.session.getTextRange(this.getSelectionRange());
        };
        this.getCopyText = function() {
          var text = this.getSelectedText();
          this._signal("copy", text);
          return text;
        };
        this.onCopy = function() {
          this.commands.exec("copy", this);
        };
        this.onCut = function() {
          this.commands.exec("cut", this);
        };
        this.onPaste = function(text) {
          if (this.$readOnly)
            return ;
          var e = {text: text};
          this._signal("paste", e);
          this.insert(e.text, true);
        };
        this.execCommand = function(command, args) {
          return this.commands.exec(command, this, args);
        };
        this.insert = function(text, pasted) {
          var session = this.session;
          var mode = session.getMode();
          var cursor = this.getCursorPosition();
          if (this.getBehavioursEnabled() && !pasted) {
            var transform = mode.transformAction(session.getState(cursor.row), 'insertion', this, session, text);
            if (transform) {
              if (text !== transform.text) {
                this.session.mergeUndoDeltas = false;
                this.$mergeNextCommand = false;
              }
              text = transform.text;
            }
          }
          if (text == "\t")
            text = this.session.getTabString();
          if (!this.selection.isEmpty()) {
            var range = this.getSelectionRange();
            cursor = this.session.remove(range);
            this.clearSelection();
          } else if (this.session.getOverwrite()) {
            var range = new Range.fromPoints(cursor, cursor);
            range.end.column += text.length;
            this.session.remove(range);
          }
          if (text == "\n" || text == "\r\n") {
            var line = session.getLine(cursor.row);
            if (cursor.column > line.search(/\S|$/)) {
              var d = line.substr(cursor.column).search(/\S|$/);
              session.doc.removeInLine(cursor.row, cursor.column, cursor.column + d);
            }
          }
          this.clearSelection();
          var start = cursor.column;
          var lineState = session.getState(cursor.row);
          var line = session.getLine(cursor.row);
          var shouldOutdent = mode.checkOutdent(lineState, line, text);
          var end = session.insert(cursor, text);
          if (transform && transform.selection) {
            if (transform.selection.length == 2) {
              this.selection.setSelectionRange(new Range(cursor.row, start + transform.selection[0], cursor.row, start + transform.selection[1]));
            } else {
              this.selection.setSelectionRange(new Range(cursor.row + transform.selection[0], transform.selection[1], cursor.row + transform.selection[2], transform.selection[3]));
            }
          }
          if (session.getDocument().isNewLine(text)) {
            var lineIndent = mode.getNextLineIndent(lineState, line.slice(0, cursor.column), session.getTabString());
            session.insert({
              row: cursor.row + 1,
              column: 0
            }, lineIndent);
          }
          if (shouldOutdent)
            mode.autoOutdent(lineState, session, cursor.row);
        };
        this.onTextInput = function(text) {
          this.keyBinding.onTextInput(text);
        };
        this.onCommandKey = function(e, hashId, keyCode) {
          this.keyBinding.onCommandKey(e, hashId, keyCode);
        };
        this.setOverwrite = function(overwrite) {
          this.session.setOverwrite(overwrite);
        };
        this.getOverwrite = function() {
          return this.session.getOverwrite();
        };
        this.toggleOverwrite = function() {
          this.session.toggleOverwrite();
        };
        this.setScrollSpeed = function(speed) {
          this.setOption("scrollSpeed", speed);
        };
        this.getScrollSpeed = function() {
          return this.getOption("scrollSpeed");
        };
        this.setDragDelay = function(dragDelay) {
          this.setOption("dragDelay", dragDelay);
        };
        this.getDragDelay = function() {
          return this.getOption("dragDelay");
        };
        this.setSelectionStyle = function(val) {
          this.setOption("selectionStyle", val);
        };
        this.getSelectionStyle = function() {
          return this.getOption("selectionStyle");
        };
        this.setHighlightActiveLine = function(shouldHighlight) {
          this.setOption("highlightActiveLine", shouldHighlight);
        };
        this.getHighlightActiveLine = function() {
          return this.getOption("highlightActiveLine");
        };
        this.setHighlightGutterLine = function(shouldHighlight) {
          this.setOption("highlightGutterLine", shouldHighlight);
        };
        this.getHighlightGutterLine = function() {
          return this.getOption("highlightGutterLine");
        };
        this.setHighlightSelectedWord = function(shouldHighlight) {
          this.setOption("highlightSelectedWord", shouldHighlight);
        };
        this.getHighlightSelectedWord = function() {
          return this.$highlightSelectedWord;
        };
        this.setAnimatedScroll = function(shouldAnimate) {
          this.renderer.setAnimatedScroll(shouldAnimate);
        };
        this.getAnimatedScroll = function() {
          return this.renderer.getAnimatedScroll();
        };
        this.setShowInvisibles = function(showInvisibles) {
          this.renderer.setShowInvisibles(showInvisibles);
        };
        this.getShowInvisibles = function() {
          return this.renderer.getShowInvisibles();
        };
        this.setDisplayIndentGuides = function(display) {
          this.renderer.setDisplayIndentGuides(display);
        };
        this.getDisplayIndentGuides = function() {
          return this.renderer.getDisplayIndentGuides();
        };
        this.setShowPrintMargin = function(showPrintMargin) {
          this.renderer.setShowPrintMargin(showPrintMargin);
        };
        this.getShowPrintMargin = function() {
          return this.renderer.getShowPrintMargin();
        };
        this.setPrintMarginColumn = function(showPrintMargin) {
          this.renderer.setPrintMarginColumn(showPrintMargin);
        };
        this.getPrintMarginColumn = function() {
          return this.renderer.getPrintMarginColumn();
        };
        this.setReadOnly = function(readOnly) {
          this.setOption("readOnly", readOnly);
        };
        this.getReadOnly = function() {
          return this.getOption("readOnly");
        };
        this.setBehavioursEnabled = function(enabled) {
          this.setOption("behavioursEnabled", enabled);
        };
        this.getBehavioursEnabled = function() {
          return this.getOption("behavioursEnabled");
        };
        this.setWrapBehavioursEnabled = function(enabled) {
          this.setOption("wrapBehavioursEnabled", enabled);
        };
        this.getWrapBehavioursEnabled = function() {
          return this.getOption("wrapBehavioursEnabled");
        };
        this.setShowFoldWidgets = function(show) {
          this.setOption("showFoldWidgets", show);
        };
        this.getShowFoldWidgets = function() {
          return this.getOption("showFoldWidgets");
        };
        this.setFadeFoldWidgets = function(fade) {
          this.setOption("fadeFoldWidgets", fade);
        };
        this.getFadeFoldWidgets = function() {
          return this.getOption("fadeFoldWidgets");
        };
        this.remove = function(dir) {
          if (this.selection.isEmpty()) {
            if (dir == "left")
              this.selection.selectLeft();
            else
              this.selection.selectRight();
          }
          var range = this.getSelectionRange();
          if (this.getBehavioursEnabled()) {
            var session = this.session;
            var state = session.getState(range.start.row);
            var new_range = session.getMode().transformAction(state, 'deletion', this, session, range);
            if (range.end.column === 0) {
              var text = session.getTextRange(range);
              if (text[text.length - 1] == "\n") {
                var line = session.getLine(range.end.row);
                if (/^\s+$/.test(line)) {
                  range.end.column = line.length;
                }
              }
            }
            if (new_range)
              range = new_range;
          }
          this.session.remove(range);
          this.clearSelection();
        };
        this.removeWordRight = function() {
          if (this.selection.isEmpty())
            this.selection.selectWordRight();
          this.session.remove(this.getSelectionRange());
          this.clearSelection();
        };
        this.removeWordLeft = function() {
          if (this.selection.isEmpty())
            this.selection.selectWordLeft();
          this.session.remove(this.getSelectionRange());
          this.clearSelection();
        };
        this.removeToLineStart = function() {
          if (this.selection.isEmpty())
            this.selection.selectLineStart();
          this.session.remove(this.getSelectionRange());
          this.clearSelection();
        };
        this.removeToLineEnd = function() {
          if (this.selection.isEmpty())
            this.selection.selectLineEnd();
          var range = this.getSelectionRange();
          if (range.start.column == range.end.column && range.start.row == range.end.row) {
            range.end.column = 0;
            range.end.row++;
          }
          this.session.remove(range);
          this.clearSelection();
        };
        this.splitLine = function() {
          if (!this.selection.isEmpty()) {
            this.session.remove(this.getSelectionRange());
            this.clearSelection();
          }
          var cursor = this.getCursorPosition();
          this.insert("\n");
          this.moveCursorToPosition(cursor);
        };
        this.transposeLetters = function() {
          if (!this.selection.isEmpty()) {
            return ;
          }
          var cursor = this.getCursorPosition();
          var column = cursor.column;
          if (column === 0)
            return ;
          var line = this.session.getLine(cursor.row);
          var swap,
              range;
          if (column < line.length) {
            swap = line.charAt(column) + line.charAt(column - 1);
            range = new Range(cursor.row, column - 1, cursor.row, column + 1);
          } else {
            swap = line.charAt(column - 1) + line.charAt(column - 2);
            range = new Range(cursor.row, column - 2, cursor.row, column);
          }
          this.session.replace(range, swap);
        };
        this.toLowerCase = function() {
          var originalRange = this.getSelectionRange();
          if (this.selection.isEmpty()) {
            this.selection.selectWord();
          }
          var range = this.getSelectionRange();
          var text = this.session.getTextRange(range);
          this.session.replace(range, text.toLowerCase());
          this.selection.setSelectionRange(originalRange);
        };
        this.toUpperCase = function() {
          var originalRange = this.getSelectionRange();
          if (this.selection.isEmpty()) {
            this.selection.selectWord();
          }
          var range = this.getSelectionRange();
          var text = this.session.getTextRange(range);
          this.session.replace(range, text.toUpperCase());
          this.selection.setSelectionRange(originalRange);
        };
        this.indent = function() {
          var session = this.session;
          var range = this.getSelectionRange();
          if (range.start.row < range.end.row) {
            var rows = this.$getSelectedRows();
            session.indentRows(rows.first, rows.last, "\t");
            return ;
          } else if (range.start.column < range.end.column) {
            var text = session.getTextRange(range);
            if (!/^\s+$/.test(text)) {
              var rows = this.$getSelectedRows();
              session.indentRows(rows.first, rows.last, "\t");
              return ;
            }
          }
          var line = session.getLine(range.start.row);
          var position = range.start;
          var size = session.getTabSize();
          var column = session.documentToScreenColumn(position.row, position.column);
          if (this.session.getUseSoftTabs()) {
            var count = (size - column % size);
            var indentString = lang.stringRepeat(" ", count);
          } else {
            var count = column % size;
            while (line[range.start.column] == " " && count) {
              range.start.column--;
              count--;
            }
            this.selection.setSelectionRange(range);
            indentString = "\t";
          }
          return this.insert(indentString);
        };
        this.blockIndent = function() {
          var rows = this.$getSelectedRows();
          this.session.indentRows(rows.first, rows.last, "\t");
        };
        this.blockOutdent = function() {
          var selection = this.session.getSelection();
          this.session.outdentRows(selection.getRange());
        };
        this.sortLines = function() {
          var rows = this.$getSelectedRows();
          var session = this.session;
          var lines = [];
          for (i = rows.first; i <= rows.last; i++)
            lines.push(session.getLine(i));
          lines.sort(function(a, b) {
            if (a.toLowerCase() < b.toLowerCase())
              return -1;
            if (a.toLowerCase() > b.toLowerCase())
              return 1;
            return 0;
          });
          var deleteRange = new Range(0, 0, 0, 0);
          for (var i = rows.first; i <= rows.last; i++) {
            var line = session.getLine(i);
            deleteRange.start.row = i;
            deleteRange.end.row = i;
            deleteRange.end.column = line.length;
            session.replace(deleteRange, lines[i - rows.first]);
          }
        };
        this.toggleCommentLines = function() {
          var state = this.session.getState(this.getCursorPosition().row);
          var rows = this.$getSelectedRows();
          this.session.getMode().toggleCommentLines(state, this.session, rows.first, rows.last);
        };
        this.toggleBlockComment = function() {
          var cursor = this.getCursorPosition();
          var state = this.session.getState(cursor.row);
          var range = this.getSelectionRange();
          this.session.getMode().toggleBlockComment(state, this.session, range, cursor);
        };
        this.getNumberAt = function(row, column) {
          var _numberRx = /[\-]?[0-9]+(?:\.[0-9]+)?/g;
          _numberRx.lastIndex = 0;
          var s = this.session.getLine(row);
          while (_numberRx.lastIndex < column) {
            var m = _numberRx.exec(s);
            if (m.index <= column && m.index + m[0].length >= column) {
              var number = {
                value: m[0],
                start: m.index,
                end: m.index + m[0].length
              };
              return number;
            }
          }
          return null;
        };
        this.modifyNumber = function(amount) {
          var row = this.selection.getCursor().row;
          var column = this.selection.getCursor().column;
          var charRange = new Range(row, column - 1, row, column);
          var c = this.session.getTextRange(charRange);
          if (!isNaN(parseFloat(c)) && isFinite(c)) {
            var nr = this.getNumberAt(row, column);
            if (nr) {
              var fp = nr.value.indexOf(".") >= 0 ? nr.start + nr.value.indexOf(".") + 1 : nr.end;
              var decimals = nr.start + nr.value.length - fp;
              var t = parseFloat(nr.value);
              t *= Math.pow(10, decimals);
              if (fp !== nr.end && column < fp) {
                amount *= Math.pow(10, nr.end - column - 1);
              } else {
                amount *= Math.pow(10, nr.end - column);
              }
              t += amount;
              t /= Math.pow(10, decimals);
              var nnr = t.toFixed(decimals);
              var replaceRange = new Range(row, nr.start, row, nr.end);
              this.session.replace(replaceRange, nnr);
              this.moveCursorTo(row, Math.max(nr.start + 1, column + nnr.length - nr.value.length));
            }
          }
        };
        this.removeLines = function() {
          var rows = this.$getSelectedRows();
          var range;
          if (rows.first === 0 || rows.last + 1 < this.session.getLength())
            range = new Range(rows.first, 0, rows.last + 1, 0);
          else
            range = new Range(rows.first - 1, this.session.getLine(rows.first - 1).length, rows.last, this.session.getLine(rows.last).length);
          this.session.remove(range);
          this.clearSelection();
        };
        this.duplicateSelection = function() {
          var sel = this.selection;
          var doc = this.session;
          var range = sel.getRange();
          var reverse = sel.isBackwards();
          if (range.isEmpty()) {
            var row = range.start.row;
            doc.duplicateLines(row, row);
          } else {
            var point = reverse ? range.start : range.end;
            var endPoint = doc.insert(point, doc.getTextRange(range), false);
            range.start = point;
            range.end = endPoint;
            sel.setSelectionRange(range, reverse);
          }
        };
        this.moveLinesDown = function() {
          this.$moveLines(function(firstRow, lastRow) {
            return this.session.moveLinesDown(firstRow, lastRow);
          });
        };
        this.moveLinesUp = function() {
          this.$moveLines(function(firstRow, lastRow) {
            return this.session.moveLinesUp(firstRow, lastRow);
          });
        };
        this.moveText = function(range, toPosition, copy) {
          return this.session.moveText(range, toPosition, copy);
        };
        this.copyLinesUp = function() {
          this.$moveLines(function(firstRow, lastRow) {
            this.session.duplicateLines(firstRow, lastRow);
            return 0;
          });
        };
        this.copyLinesDown = function() {
          this.$moveLines(function(firstRow, lastRow) {
            return this.session.duplicateLines(firstRow, lastRow);
          });
        };
        this.$moveLines = function(mover) {
          var selection = this.selection;
          if (!selection.inMultiSelectMode || this.inVirtualSelectionMode) {
            var range = selection.toOrientedRange();
            var rows = this.$getSelectedRows(range);
            var linesMoved = mover.call(this, rows.first, rows.last);
            range.moveBy(linesMoved, 0);
            selection.fromOrientedRange(range);
          } else {
            var ranges = selection.rangeList.ranges;
            selection.rangeList.detach(this.session);
            for (var i = ranges.length; i--; ) {
              var rangeIndex = i;
              var rows = ranges[i].collapseRows();
              var last = rows.end.row;
              var first = rows.start.row;
              while (i--) {
                rows = ranges[i].collapseRows();
                if (first - rows.end.row <= 1)
                  first = rows.end.row;
                else
                  break;
              }
              i++;
              var linesMoved = mover.call(this, first, last);
              while (rangeIndex >= i) {
                ranges[rangeIndex].moveBy(linesMoved, 0);
                rangeIndex--;
              }
            }
            selection.fromOrientedRange(selection.ranges[0]);
            selection.rangeList.attach(this.session);
          }
        };
        this.$getSelectedRows = function() {
          var range = this.getSelectionRange().collapseRows();
          return {
            first: this.session.getRowFoldStart(range.start.row),
            last: this.session.getRowFoldEnd(range.end.row)
          };
        };
        this.onCompositionStart = function(text) {
          this.renderer.showComposition(this.getCursorPosition());
        };
        this.onCompositionUpdate = function(text) {
          this.renderer.setCompositionText(text);
        };
        this.onCompositionEnd = function() {
          this.renderer.hideComposition();
        };
        this.getFirstVisibleRow = function() {
          return this.renderer.getFirstVisibleRow();
        };
        this.getLastVisibleRow = function() {
          return this.renderer.getLastVisibleRow();
        };
        this.isRowVisible = function(row) {
          return (row >= this.getFirstVisibleRow() && row <= this.getLastVisibleRow());
        };
        this.isRowFullyVisible = function(row) {
          return (row >= this.renderer.getFirstFullyVisibleRow() && row <= this.renderer.getLastFullyVisibleRow());
        };
        this.$getVisibleRowCount = function() {
          return this.renderer.getScrollBottomRow() - this.renderer.getScrollTopRow() + 1;
        };
        this.$moveByPage = function(dir, select) {
          var renderer = this.renderer;
          var config = this.renderer.layerConfig;
          var rows = dir * Math.floor(config.height / config.lineHeight);
          this.$blockScrolling++;
          if (select === true) {
            this.selection.$moveSelection(function() {
              this.moveCursorBy(rows, 0);
            });
          } else if (select === false) {
            this.selection.moveCursorBy(rows, 0);
            this.selection.clearSelection();
          }
          this.$blockScrolling--;
          var scrollTop = renderer.scrollTop;
          renderer.scrollBy(0, rows * config.lineHeight);
          if (select != null)
            renderer.scrollCursorIntoView(null, 0.5);
          renderer.animateScrolling(scrollTop);
        };
        this.selectPageDown = function() {
          this.$moveByPage(1, true);
        };
        this.selectPageUp = function() {
          this.$moveByPage(-1, true);
        };
        this.gotoPageDown = function() {
          this.$moveByPage(1, false);
        };
        this.gotoPageUp = function() {
          this.$moveByPage(-1, false);
        };
        this.scrollPageDown = function() {
          this.$moveByPage(1);
        };
        this.scrollPageUp = function() {
          this.$moveByPage(-1);
        };
        this.scrollToRow = function(row) {
          this.renderer.scrollToRow(row);
        };
        this.scrollToLine = function(line, center, animate, callback) {
          this.renderer.scrollToLine(line, center, animate, callback);
        };
        this.centerSelection = function() {
          var range = this.getSelectionRange();
          var pos = {
            row: Math.floor(range.start.row + (range.end.row - range.start.row) / 2),
            column: Math.floor(range.start.column + (range.end.column - range.start.column) / 2)
          };
          this.renderer.alignCursor(pos, 0.5);
        };
        this.getCursorPosition = function() {
          return this.selection.getCursor();
        };
        this.getCursorPositionScreen = function() {
          return this.session.documentToScreenPosition(this.getCursorPosition());
        };
        this.getSelectionRange = function() {
          return this.selection.getRange();
        };
        this.selectAll = function() {
          this.$blockScrolling += 1;
          this.selection.selectAll();
          this.$blockScrolling -= 1;
        };
        this.clearSelection = function() {
          this.selection.clearSelection();
        };
        this.moveCursorTo = function(row, column) {
          this.selection.moveCursorTo(row, column);
        };
        this.moveCursorToPosition = function(pos) {
          this.selection.moveCursorToPosition(pos);
        };
        this.jumpToMatching = function(select, expand) {
          var cursor = this.getCursorPosition();
          var iterator = new TokenIterator(this.session, cursor.row, cursor.column);
          var prevToken = iterator.getCurrentToken();
          var token = prevToken || iterator.stepForward();
          if (!token)
            return ;
          var matchType;
          var found = false;
          var depth = {};
          var i = cursor.column - token.start;
          var bracketType;
          var brackets = {
            ")": "(",
            "(": "(",
            "]": "[",
            "[": "[",
            "{": "{",
            "}": "{"
          };
          do {
            if (token.value.match(/[{}()\[\]]/g)) {
              for (; i < token.value.length && !found; i++) {
                if (!brackets[token.value[i]]) {
                  continue;
                }
                bracketType = brackets[token.value[i]] + '.' + token.type.replace("rparen", "lparen");
                if (isNaN(depth[bracketType])) {
                  depth[bracketType] = 0;
                }
                switch (token.value[i]) {
                  case '(':
                  case '[':
                  case '{':
                    depth[bracketType]++;
                    break;
                  case ')':
                  case ']':
                  case '}':
                    depth[bracketType]--;
                    if (depth[bracketType] === -1) {
                      matchType = 'bracket';
                      found = true;
                    }
                    break;
                }
              }
            } else if (token && token.type.indexOf('tag-name') !== -1) {
              if (isNaN(depth[token.value])) {
                depth[token.value] = 0;
              }
              if (prevToken.value === '<') {
                depth[token.value]++;
              } else if (prevToken.value === '</') {
                depth[token.value]--;
              }
              if (depth[token.value] === -1) {
                matchType = 'tag';
                found = true;
              }
            }
            if (!found) {
              prevToken = token;
              token = iterator.stepForward();
              i = 0;
            }
          } while (token && !found);
          if (!matchType)
            return ;
          var range,
              pos;
          if (matchType === 'bracket') {
            range = this.session.getBracketRange(cursor);
            if (!range) {
              range = new Range(iterator.getCurrentTokenRow(), iterator.getCurrentTokenColumn() + i - 1, iterator.getCurrentTokenRow(), iterator.getCurrentTokenColumn() + i - 1);
              pos = range.start;
              if (expand || pos.row === cursor.row && Math.abs(pos.column - cursor.column) < 2)
                range = this.session.getBracketRange(pos);
            }
          } else if (matchType === 'tag') {
            if (token && token.type.indexOf('tag-name') !== -1)
              var tag = token.value;
            else
              return ;
            range = new Range(iterator.getCurrentTokenRow(), iterator.getCurrentTokenColumn() - 2, iterator.getCurrentTokenRow(), iterator.getCurrentTokenColumn() - 2);
            if (range.compare(cursor.row, cursor.column) === 0) {
              found = false;
              do {
                token = prevToken;
                prevToken = iterator.stepBackward();
                if (prevToken) {
                  if (prevToken.type.indexOf('tag-close') !== -1) {
                    range.setEnd(iterator.getCurrentTokenRow(), iterator.getCurrentTokenColumn() + 1);
                  }
                  if (token.value === tag && token.type.indexOf('tag-name') !== -1) {
                    if (prevToken.value === '<') {
                      depth[tag]++;
                    } else if (prevToken.value === '</') {
                      depth[tag]--;
                    }
                    if (depth[tag] === 0)
                      found = true;
                  }
                }
              } while (prevToken && !found);
            }
            if (token && token.type.indexOf('tag-name')) {
              pos = range.start;
              if (pos.row == cursor.row && Math.abs(pos.column - cursor.column) < 2)
                pos = range.end;
            }
          }
          pos = range && range.cursor || pos;
          if (pos) {
            if (select) {
              if (range && expand) {
                this.selection.setRange(range);
              } else if (range && range.isEqual(this.getSelectionRange())) {
                this.clearSelection();
              } else {
                this.selection.selectTo(pos.row, pos.column);
              }
            } else {
              this.selection.moveTo(pos.row, pos.column);
            }
          }
        };
        this.gotoLine = function(lineNumber, column, animate) {
          this.selection.clearSelection();
          this.session.unfold({
            row: lineNumber - 1,
            column: column || 0
          });
          this.$blockScrolling += 1;
          this.exitMultiSelectMode && this.exitMultiSelectMode();
          this.moveCursorTo(lineNumber - 1, column || 0);
          this.$blockScrolling -= 1;
          if (!this.isRowFullyVisible(lineNumber - 1))
            this.scrollToLine(lineNumber - 1, true, animate);
        };
        this.navigateTo = function(row, column) {
          this.selection.moveTo(row, column);
        };
        this.navigateUp = function(times) {
          if (this.selection.isMultiLine() && !this.selection.isBackwards()) {
            var selectionStart = this.selection.anchor.getPosition();
            return this.moveCursorToPosition(selectionStart);
          }
          this.selection.clearSelection();
          this.selection.moveCursorBy(-times || -1, 0);
        };
        this.navigateDown = function(times) {
          if (this.selection.isMultiLine() && this.selection.isBackwards()) {
            var selectionEnd = this.selection.anchor.getPosition();
            return this.moveCursorToPosition(selectionEnd);
          }
          this.selection.clearSelection();
          this.selection.moveCursorBy(times || 1, 0);
        };
        this.navigateLeft = function(times) {
          if (!this.selection.isEmpty()) {
            var selectionStart = this.getSelectionRange().start;
            this.moveCursorToPosition(selectionStart);
          } else {
            times = times || 1;
            while (times--) {
              this.selection.moveCursorLeft();
            }
          }
          this.clearSelection();
        };
        this.navigateRight = function(times) {
          if (!this.selection.isEmpty()) {
            var selectionEnd = this.getSelectionRange().end;
            this.moveCursorToPosition(selectionEnd);
          } else {
            times = times || 1;
            while (times--) {
              this.selection.moveCursorRight();
            }
          }
          this.clearSelection();
        };
        this.navigateLineStart = function() {
          this.selection.moveCursorLineStart();
          this.clearSelection();
        };
        this.navigateLineEnd = function() {
          this.selection.moveCursorLineEnd();
          this.clearSelection();
        };
        this.navigateFileEnd = function() {
          this.selection.moveCursorFileEnd();
          this.clearSelection();
        };
        this.navigateFileStart = function() {
          this.selection.moveCursorFileStart();
          this.clearSelection();
        };
        this.navigateWordRight = function() {
          this.selection.moveCursorWordRight();
          this.clearSelection();
        };
        this.navigateWordLeft = function() {
          this.selection.moveCursorWordLeft();
          this.clearSelection();
        };
        this.replace = function(replacement, options) {
          if (options)
            this.$search.set(options);
          var range = this.$search.find(this.session);
          var replaced = 0;
          if (!range)
            return replaced;
          if (this.$tryReplace(range, replacement)) {
            replaced = 1;
          }
          if (range !== null) {
            this.selection.setSelectionRange(range);
            this.renderer.scrollSelectionIntoView(range.start, range.end);
          }
          return replaced;
        };
        this.replaceAll = function(replacement, options) {
          if (options) {
            this.$search.set(options);
          }
          var ranges = this.$search.findAll(this.session);
          var replaced = 0;
          if (!ranges.length)
            return replaced;
          this.$blockScrolling += 1;
          var selection = this.getSelectionRange();
          this.selection.moveTo(0, 0);
          for (var i = ranges.length - 1; i >= 0; --i) {
            if (this.$tryReplace(ranges[i], replacement)) {
              replaced++;
            }
          }
          this.selection.setSelectionRange(selection);
          this.$blockScrolling -= 1;
          return replaced;
        };
        this.$tryReplace = function(range, replacement) {
          var input = this.session.getTextRange(range);
          replacement = this.$search.replace(input, replacement);
          if (replacement !== null) {
            range.end = this.session.replace(range, replacement);
            return range;
          } else {
            return null;
          }
        };
        this.getLastSearchOptions = function() {
          return this.$search.getOptions();
        };
        this.find = function(needle, options, animate) {
          if (!options)
            options = {};
          if (typeof needle == "string" || needle instanceof RegExp)
            options.needle = needle;
          else if (typeof needle == "object")
            oop.mixin(options, needle);
          var range = this.selection.getRange();
          if (options.needle == null) {
            needle = this.session.getTextRange(range) || this.$search.$options.needle;
            if (!needle) {
              range = this.session.getWordRange(range.start.row, range.start.column);
              needle = this.session.getTextRange(range);
            }
            this.$search.set({needle: needle});
          }
          this.$search.set(options);
          if (!options.start)
            this.$search.set({start: range});
          var newRange = this.$search.find(this.session);
          if (options.preventScroll)
            return newRange;
          if (newRange) {
            this.revealRange(newRange, animate);
            return newRange;
          }
          if (options.backwards)
            range.start = range.end;
          else
            range.end = range.start;
          this.selection.setRange(range);
        };
        this.findNext = function(options, animate) {
          this.find({
            skipCurrent: true,
            backwards: false
          }, options, animate);
        };
        this.findPrevious = function(options, animate) {
          this.find(options, {
            skipCurrent: true,
            backwards: true
          }, animate);
        };
        this.revealRange = function(range, animate) {
          this.$blockScrolling += 1;
          this.session.unfold(range);
          this.selection.setSelectionRange(range);
          this.$blockScrolling -= 1;
          var scrollTop = this.renderer.scrollTop;
          this.renderer.scrollSelectionIntoView(range.start, range.end, 0.5);
          if (animate !== false)
            this.renderer.animateScrolling(scrollTop);
        };
        this.undo = function() {
          this.$blockScrolling++;
          this.session.getUndoManager().undo();
          this.$blockScrolling--;
          this.renderer.scrollCursorIntoView(null, 0.5);
        };
        this.redo = function() {
          this.$blockScrolling++;
          this.session.getUndoManager().redo();
          this.$blockScrolling--;
          this.renderer.scrollCursorIntoView(null, 0.5);
        };
        this.destroy = function() {
          this.renderer.destroy();
          this._signal("destroy", this);
          if (this.session) {
            this.session.destroy();
          }
        };
        this.setAutoScrollEditorIntoView = function(enable) {
          if (!enable)
            return ;
          var rect;
          var self = this;
          var shouldScroll = false;
          if (!this.$scrollAnchor)
            this.$scrollAnchor = document.createElement("div");
          var scrollAnchor = this.$scrollAnchor;
          scrollAnchor.style.cssText = "position:absolute";
          this.container.insertBefore(scrollAnchor, this.container.firstChild);
          var onChangeSelection = this.on("changeSelection", function() {
            shouldScroll = true;
          });
          var onBeforeRender = this.renderer.on("beforeRender", function() {
            if (shouldScroll)
              rect = self.renderer.container.getBoundingClientRect();
          });
          var onAfterRender = this.renderer.on("afterRender", function() {
            if (shouldScroll && rect && (self.isFocused() || self.searchBox && self.searchBox.isFocused())) {
              var renderer = self.renderer;
              var pos = renderer.$cursorLayer.$pixelPos;
              var config = renderer.layerConfig;
              var top = pos.top - config.offset;
              if (pos.top >= 0 && top + rect.top < 0) {
                shouldScroll = true;
              } else if (pos.top < config.height && pos.top + rect.top + config.lineHeight > window.innerHeight) {
                shouldScroll = false;
              } else {
                shouldScroll = null;
              }
              if (shouldScroll != null) {
                scrollAnchor.style.top = top + "px";
                scrollAnchor.style.left = pos.left + "px";
                scrollAnchor.style.height = config.lineHeight + "px";
                scrollAnchor.scrollIntoView(shouldScroll);
              }
              shouldScroll = rect = null;
            }
          });
          this.setAutoScrollEditorIntoView = function(enable) {
            if (enable)
              return ;
            delete this.setAutoScrollEditorIntoView;
            this.removeEventListener("changeSelection", onChangeSelection);
            this.renderer.removeEventListener("afterRender", onAfterRender);
            this.renderer.removeEventListener("beforeRender", onBeforeRender);
          };
        };
        this.$resetCursorStyle = function() {
          var style = this.$cursorStyle || "ace";
          var cursorLayer = this.renderer.$cursorLayer;
          if (!cursorLayer)
            return ;
          cursorLayer.setSmoothBlinking(/smooth/.test(style));
          cursorLayer.isBlinking = !this.$readOnly && style != "wide";
          dom.setCssClass(cursorLayer.element, "ace_slim-cursors", /slim/.test(style));
        };
      }).call(Editor.prototype);
      config.defineOptions(Editor.prototype, "editor", {
        selectionStyle: {
          set: function(style) {
            this.onSelectionChange();
            this._signal("changeSelectionStyle", {data: style});
          },
          initialValue: "line"
        },
        highlightActiveLine: {
          set: function() {
            this.$updateHighlightActiveLine();
          },
          initialValue: true
        },
        highlightSelectedWord: {
          set: function(shouldHighlight) {
            this.$onSelectionChange();
          },
          initialValue: true
        },
        readOnly: {
          set: function(readOnly) {
            this.$resetCursorStyle();
          },
          initialValue: false
        },
        cursorStyle: {
          set: function(val) {
            this.$resetCursorStyle();
          },
          values: ["ace", "slim", "smooth", "wide"],
          initialValue: "ace"
        },
        mergeUndoDeltas: {
          values: [false, true, "always"],
          initialValue: true
        },
        behavioursEnabled: {initialValue: true},
        wrapBehavioursEnabled: {initialValue: true},
        autoScrollEditorIntoView: {set: function(val) {
            this.setAutoScrollEditorIntoView(val);
          }},
        hScrollBarAlwaysVisible: "renderer",
        vScrollBarAlwaysVisible: "renderer",
        highlightGutterLine: "renderer",
        animatedScroll: "renderer",
        showInvisibles: "renderer",
        showPrintMargin: "renderer",
        printMarginColumn: "renderer",
        printMargin: "renderer",
        fadeFoldWidgets: "renderer",
        showFoldWidgets: "renderer",
        showLineNumbers: "renderer",
        showGutter: "renderer",
        displayIndentGuides: "renderer",
        fontSize: "renderer",
        fontFamily: "renderer",
        maxLines: "renderer",
        minLines: "renderer",
        scrollPastEnd: "renderer",
        fixedWidthGutter: "renderer",
        theme: "renderer",
        scrollSpeed: "$mouseHandler",
        dragDelay: "$mouseHandler",
        dragEnabled: "$mouseHandler",
        focusTimout: "$mouseHandler",
        tooltipFollowsMouse: "$mouseHandler",
        firstLineNumber: "session",
        overwrite: "session",
        newLineMode: "session",
        useWorker: "session",
        useSoftTabs: "session",
        tabSize: "session",
        wrap: "session",
        foldStyle: "session",
        mode: "session"
      });
      exports.Editor = Editor;
    });
    ace.define("ace/undomanager", ["require", "exports", "module"], function(acequire, exports, module) {
      "use strict";
      var UndoManager = function() {
        this.reset();
      };
      (function() {
        this.execute = function(options) {
          var deltas = options.args[0];
          this.$doc = options.args[1];
          if (options.merge && this.hasUndo()) {
            this.dirtyCounter--;
            deltas = this.$undoStack.pop().concat(deltas);
          }
          this.$undoStack.push(deltas);
          this.$redoStack = [];
          if (this.dirtyCounter < 0) {
            this.dirtyCounter = NaN;
          }
          this.dirtyCounter++;
        };
        this.undo = function(dontSelect) {
          var deltas = this.$undoStack.pop();
          var undoSelectionRange = null;
          if (deltas) {
            undoSelectionRange = this.$doc.undoChanges(deltas, dontSelect);
            this.$redoStack.push(deltas);
            this.dirtyCounter--;
          }
          return undoSelectionRange;
        };
        this.redo = function(dontSelect) {
          var deltas = this.$redoStack.pop();
          var redoSelectionRange = null;
          if (deltas) {
            redoSelectionRange = this.$doc.redoChanges(deltas, dontSelect);
            this.$undoStack.push(deltas);
            this.dirtyCounter++;
          }
          return redoSelectionRange;
        };
        this.reset = function() {
          this.$undoStack = [];
          this.$redoStack = [];
          this.dirtyCounter = 0;
        };
        this.hasUndo = function() {
          return this.$undoStack.length > 0;
        };
        this.hasRedo = function() {
          return this.$redoStack.length > 0;
        };
        this.markClean = function() {
          this.dirtyCounter = 0;
        };
        this.isClean = function() {
          return this.dirtyCounter === 0;
        };
      }).call(UndoManager.prototype);
      exports.UndoManager = UndoManager;
    });
    ace.define("ace/layer/gutter", ["require", "exports", "module", "ace/lib/dom", "ace/lib/oop", "ace/lib/lang", "ace/lib/event_emitter"], function(acequire, exports, module) {
      "use strict";
      var dom = acequire("../lib/dom");
      var oop = acequire("../lib/oop");
      var lang = acequire("../lib/lang");
      var EventEmitter = acequire("../lib/event_emitter").EventEmitter;
      var Gutter = function(parentEl) {
        this.element = dom.createElement("div");
        this.element.className = "ace_layer ace_gutter-layer";
        parentEl.appendChild(this.element);
        this.setShowFoldWidgets(this.$showFoldWidgets);
        this.gutterWidth = 0;
        this.$annotations = [];
        this.$updateAnnotations = this.$updateAnnotations.bind(this);
        this.$cells = [];
      };
      (function() {
        oop.implement(this, EventEmitter);
        this.setSession = function(session) {
          if (this.session)
            this.session.removeEventListener("change", this.$updateAnnotations);
          this.session = session;
          if (session)
            session.on("change", this.$updateAnnotations);
        };
        this.addGutterDecoration = function(row, className) {
          if (window.console)
            console.warn && console.warn("deprecated use session.addGutterDecoration");
          this.session.addGutterDecoration(row, className);
        };
        this.removeGutterDecoration = function(row, className) {
          if (window.console)
            console.warn && console.warn("deprecated use session.removeGutterDecoration");
          this.session.removeGutterDecoration(row, className);
        };
        this.setAnnotations = function(annotations) {
          this.$annotations = [];
          for (var i = 0; i < annotations.length; i++) {
            var annotation = annotations[i];
            var row = annotation.row;
            var rowInfo = this.$annotations[row];
            if (!rowInfo)
              rowInfo = this.$annotations[row] = {text: []};
            var annoText = annotation.text;
            annoText = annoText ? lang.escapeHTML(annoText) : annotation.html || "";
            if (rowInfo.text.indexOf(annoText) === -1)
              rowInfo.text.push(annoText);
            var type = annotation.type;
            if (type == "error")
              rowInfo.className = " ace_error";
            else if (type == "warning" && rowInfo.className != " ace_error")
              rowInfo.className = " ace_warning";
            else if (type == "info" && (!rowInfo.className))
              rowInfo.className = " ace_info";
          }
        };
        this.$updateAnnotations = function(e) {
          if (!this.$annotations.length)
            return ;
          var delta = e.data;
          var range = delta.range;
          var firstRow = range.start.row;
          var len = range.end.row - firstRow;
          if (len === 0) {} else if (delta.action == "removeText" || delta.action == "removeLines") {
            this.$annotations.splice(firstRow, len + 1, null);
          } else {
            var args = new Array(len + 1);
            args.unshift(firstRow, 1);
            this.$annotations.splice.apply(this.$annotations, args);
          }
        };
        this.update = function(config) {
          var session = this.session;
          var firstRow = config.firstRow;
          var lastRow = Math.min(config.lastRow + config.gutterOffset, session.getLength() - 1);
          var fold = session.getNextFoldLine(firstRow);
          var foldStart = fold ? fold.start.row : Infinity;
          var foldWidgets = this.$showFoldWidgets && session.foldWidgets;
          var breakpoints = session.$breakpoints;
          var decorations = session.$decorations;
          var firstLineNumber = session.$firstLineNumber;
          var lastLineNumber = 0;
          var gutterRenderer = session.gutterRenderer || this.$renderer;
          var cell = null;
          var index = -1;
          var row = firstRow;
          while (true) {
            if (row > foldStart) {
              row = fold.end.row + 1;
              fold = session.getNextFoldLine(row, fold);
              foldStart = fold ? fold.start.row : Infinity;
            }
            if (row > lastRow) {
              while (this.$cells.length > index + 1) {
                cell = this.$cells.pop();
                this.element.removeChild(cell.element);
              }
              break;
            }
            cell = this.$cells[++index];
            if (!cell) {
              cell = {
                element: null,
                textNode: null,
                foldWidget: null
              };
              cell.element = dom.createElement("div");
              cell.textNode = document.createTextNode('');
              cell.element.appendChild(cell.textNode);
              this.element.appendChild(cell.element);
              this.$cells[index] = cell;
            }
            var className = "ace_gutter-cell ";
            if (breakpoints[row])
              className += breakpoints[row];
            if (decorations[row])
              className += decorations[row];
            if (this.$annotations[row])
              className += this.$annotations[row].className;
            if (cell.element.className != className)
              cell.element.className = className;
            var height = session.getRowLength(row) * config.lineHeight + "px";
            if (height != cell.element.style.height)
              cell.element.style.height = height;
            if (foldWidgets) {
              var c = foldWidgets[row];
              if (c == null)
                c = foldWidgets[row] = session.getFoldWidget(row);
            }
            if (c) {
              if (!cell.foldWidget) {
                cell.foldWidget = dom.createElement("span");
                cell.element.appendChild(cell.foldWidget);
              }
              var className = "ace_fold-widget ace_" + c;
              if (c == "start" && row == foldStart && row < fold.end.row)
                className += " ace_closed";
              else
                className += " ace_open";
              if (cell.foldWidget.className != className)
                cell.foldWidget.className = className;
              var height = config.lineHeight + "px";
              if (cell.foldWidget.style.height != height)
                cell.foldWidget.style.height = height;
            } else {
              if (cell.foldWidget) {
                cell.element.removeChild(cell.foldWidget);
                cell.foldWidget = null;
              }
            }
            var text = lastLineNumber = gutterRenderer ? gutterRenderer.getText(session, row) : row + firstLineNumber;
            if (text != cell.textNode.data)
              cell.textNode.data = text;
            row++;
          }
          this.element.style.height = config.minHeight + "px";
          if (this.$fixedWidth || session.$useWrapMode)
            lastLineNumber = session.getLength() + firstLineNumber;
          var gutterWidth = gutterRenderer ? gutterRenderer.getWidth(session, lastLineNumber, config) : lastLineNumber.toString().length * config.characterWidth;
          var padding = this.$padding || this.$computePadding();
          gutterWidth += padding.left + padding.right;
          if (gutterWidth !== this.gutterWidth && !isNaN(gutterWidth)) {
            this.gutterWidth = gutterWidth;
            this.element.style.width = Math.ceil(this.gutterWidth) + "px";
            this._emit("changeGutterWidth", gutterWidth);
          }
        };
        this.$fixedWidth = false;
        this.$showLineNumbers = true;
        this.$renderer = "";
        this.setShowLineNumbers = function(show) {
          this.$renderer = !show && {
            getWidth: function() {
              return "";
            },
            getText: function() {
              return "";
            }
          };
        };
        this.getShowLineNumbers = function() {
          return this.$showLineNumbers;
        };
        this.$showFoldWidgets = true;
        this.setShowFoldWidgets = function(show) {
          if (show)
            dom.addCssClass(this.element, "ace_folding-enabled");
          else
            dom.removeCssClass(this.element, "ace_folding-enabled");
          this.$showFoldWidgets = show;
          this.$padding = null;
        };
        this.getShowFoldWidgets = function() {
          return this.$showFoldWidgets;
        };
        this.$computePadding = function() {
          if (!this.element.firstChild)
            return {
              left: 0,
              right: 0
            };
          var style = dom.computedStyle(this.element.firstChild);
          this.$padding = {};
          this.$padding.left = parseInt(style.paddingLeft) + 1 || 0;
          this.$padding.right = parseInt(style.paddingRight) || 0;
          return this.$padding;
        };
        this.getRegion = function(point) {
          var padding = this.$padding || this.$computePadding();
          var rect = this.element.getBoundingClientRect();
          if (point.x < padding.left + rect.left)
            return "markers";
          if (this.$showFoldWidgets && point.x > rect.right - padding.right)
            return "foldWidgets";
        };
      }).call(Gutter.prototype);
      exports.Gutter = Gutter;
    });
    ace.define("ace/layer/marker", ["require", "exports", "module", "ace/range", "ace/lib/dom"], function(acequire, exports, module) {
      "use strict";
      var Range = acequire("../range").Range;
      var dom = acequire("../lib/dom");
      var Marker = function(parentEl) {
        this.element = dom.createElement("div");
        this.element.className = "ace_layer ace_marker-layer";
        parentEl.appendChild(this.element);
      };
      (function() {
        this.$padding = 0;
        this.setPadding = function(padding) {
          this.$padding = padding;
        };
        this.setSession = function(session) {
          this.session = session;
        };
        this.setMarkers = function(markers) {
          this.markers = markers;
        };
        this.update = function(config) {
          var config = config || this.config;
          if (!config)
            return ;
          this.config = config;
          var html = [];
          for (var key in this.markers) {
            var marker = this.markers[key];
            if (!marker.range) {
              marker.update(html, this, this.session, config);
              continue;
            }
            var range = marker.range.clipRows(config.firstRow, config.lastRow);
            if (range.isEmpty())
              continue;
            range = range.toScreenRange(this.session);
            if (marker.renderer) {
              var top = this.$getTop(range.start.row, config);
              var left = this.$padding + range.start.column * config.characterWidth;
              marker.renderer(html, range, left, top, config);
            } else if (marker.type == "fullLine") {
              this.drawFullLineMarker(html, range, marker.clazz, config);
            } else if (marker.type == "screenLine") {
              this.drawScreenLineMarker(html, range, marker.clazz, config);
            } else if (range.isMultiLine()) {
              if (marker.type == "text")
                this.drawTextMarker(html, range, marker.clazz, config);
              else
                this.drawMultiLineMarker(html, range, marker.clazz, config);
            } else {
              this.drawSingleLineMarker(html, range, marker.clazz + " ace_start", config);
            }
          }
          this.element.innerHTML = html.join("");
        };
        this.$getTop = function(row, layerConfig) {
          return (row - layerConfig.firstRowScreen) * layerConfig.lineHeight;
        };
        this.drawTextMarker = function(stringBuilder, range, clazz, layerConfig, extraStyle) {
          var row = range.start.row;
          var lineRange = new Range(row, range.start.column, row, this.session.getScreenLastRowColumn(row));
          this.drawSingleLineMarker(stringBuilder, lineRange, clazz + " ace_start", layerConfig, 1, extraStyle);
          row = range.end.row;
          lineRange = new Range(row, 0, row, range.end.column);
          this.drawSingleLineMarker(stringBuilder, lineRange, clazz, layerConfig, 0, extraStyle);
          for (row = range.start.row + 1; row < range.end.row; row++) {
            lineRange.start.row = row;
            lineRange.end.row = row;
            lineRange.end.column = this.session.getScreenLastRowColumn(row);
            this.drawSingleLineMarker(stringBuilder, lineRange, clazz, layerConfig, 1, extraStyle);
          }
        };
        this.drawMultiLineMarker = function(stringBuilder, range, clazz, config, extraStyle) {
          var padding = this.$padding;
          var height = config.lineHeight;
          var top = this.$getTop(range.start.row, config);
          var left = padding + range.start.column * config.characterWidth;
          extraStyle = extraStyle || "";
          stringBuilder.push("<div class='", clazz, " ace_start' style='", "height:", height, "px;", "right:0;", "top:", top, "px;", "left:", left, "px;", extraStyle, "'></div>");
          top = this.$getTop(range.end.row, config);
          var width = range.end.column * config.characterWidth;
          stringBuilder.push("<div class='", clazz, "' style='", "height:", height, "px;", "width:", width, "px;", "top:", top, "px;", "left:", padding, "px;", extraStyle, "'></div>");
          height = (range.end.row - range.start.row - 1) * config.lineHeight;
          if (height < 0)
            return ;
          top = this.$getTop(range.start.row + 1, config);
          stringBuilder.push("<div class='", clazz, "' style='", "height:", height, "px;", "right:0;", "top:", top, "px;", "left:", padding, "px;", extraStyle, "'></div>");
        };
        this.drawSingleLineMarker = function(stringBuilder, range, clazz, config, extraLength, extraStyle) {
          var height = config.lineHeight;
          var width = (range.end.column + (extraLength || 0) - range.start.column) * config.characterWidth;
          var top = this.$getTop(range.start.row, config);
          var left = this.$padding + range.start.column * config.characterWidth;
          stringBuilder.push("<div class='", clazz, "' style='", "height:", height, "px;", "width:", width, "px;", "top:", top, "px;", "left:", left, "px;", extraStyle || "", "'></div>");
        };
        this.drawFullLineMarker = function(stringBuilder, range, clazz, config, extraStyle) {
          var top = this.$getTop(range.start.row, config);
          var height = config.lineHeight;
          if (range.start.row != range.end.row)
            height += this.$getTop(range.end.row, config) - top;
          stringBuilder.push("<div class='", clazz, "' style='", "height:", height, "px;", "top:", top, "px;", "left:0;right:0;", extraStyle || "", "'></div>");
        };
        this.drawScreenLineMarker = function(stringBuilder, range, clazz, config, extraStyle) {
          var top = this.$getTop(range.start.row, config);
          var height = config.lineHeight;
          stringBuilder.push("<div class='", clazz, "' style='", "height:", height, "px;", "top:", top, "px;", "left:0;right:0;", extraStyle || "", "'></div>");
        };
      }).call(Marker.prototype);
      exports.Marker = Marker;
    });
    ace.define("ace/layer/text", ["require", "exports", "module", "ace/lib/oop", "ace/lib/dom", "ace/lib/lang", "ace/lib/useragent", "ace/lib/event_emitter"], function(acequire, exports, module) {
      "use strict";
      var oop = acequire("../lib/oop");
      var dom = acequire("../lib/dom");
      var lang = acequire("../lib/lang");
      var useragent = acequire("../lib/useragent");
      var EventEmitter = acequire("../lib/event_emitter").EventEmitter;
      var Text = function(parentEl) {
        this.element = dom.createElement("div");
        this.element.className = "ace_layer ace_text-layer";
        parentEl.appendChild(this.element);
        this.$updateEolChar = this.$updateEolChar.bind(this);
      };
      (function() {
        oop.implement(this, EventEmitter);
        this.EOF_CHAR = "\xB6";
        this.EOL_CHAR_LF = "\xAC";
        this.EOL_CHAR_CRLF = "\xa4";
        this.EOL_CHAR = this.EOL_CHAR_LF;
        this.TAB_CHAR = "\u2192";
        this.SPACE_CHAR = "\xB7";
        this.$padding = 0;
        this.$updateEolChar = function() {
          var EOL_CHAR = this.session.doc.getNewLineCharacter() == "\n" ? this.EOL_CHAR_LF : this.EOL_CHAR_CRLF;
          if (this.EOL_CHAR != EOL_CHAR) {
            this.EOL_CHAR = EOL_CHAR;
            return true;
          }
        };
        this.setPadding = function(padding) {
          this.$padding = padding;
          this.element.style.padding = "0 " + padding + "px";
        };
        this.getLineHeight = function() {
          return this.$fontMetrics.$characterSize.height || 0;
        };
        this.getCharacterWidth = function() {
          return this.$fontMetrics.$characterSize.width || 0;
        };
        this.$setFontMetrics = function(measure) {
          this.$fontMetrics = measure;
          this.$fontMetrics.on("changeCharacterSize", function(e) {
            this._signal("changeCharacterSize", e);
          }.bind(this));
          this.$pollSizeChanges();
        };
        this.checkForSizeChanges = function() {
          this.$fontMetrics.checkForSizeChanges();
        };
        this.$pollSizeChanges = function() {
          return this.$pollSizeChangesTimer = this.$fontMetrics.$pollSizeChanges();
        };
        this.setSession = function(session) {
          this.session = session;
          if (session)
            this.$computeTabString();
        };
        this.showInvisibles = false;
        this.setShowInvisibles = function(showInvisibles) {
          if (this.showInvisibles == showInvisibles)
            return false;
          this.showInvisibles = showInvisibles;
          this.$computeTabString();
          return true;
        };
        this.displayIndentGuides = true;
        this.setDisplayIndentGuides = function(display) {
          if (this.displayIndentGuides == display)
            return false;
          this.displayIndentGuides = display;
          this.$computeTabString();
          return true;
        };
        this.$tabStrings = [];
        this.onChangeTabSize = this.$computeTabString = function() {
          var tabSize = this.session.getTabSize();
          this.tabSize = tabSize;
          var tabStr = this.$tabStrings = [0];
          for (var i = 1; i < tabSize + 1; i++) {
            if (this.showInvisibles) {
              tabStr.push("<span class='ace_invisible ace_invisible_tab'>" + this.TAB_CHAR + lang.stringRepeat("\xa0", i - 1) + "</span>");
            } else {
              tabStr.push(lang.stringRepeat("\xa0", i));
            }
          }
          if (this.displayIndentGuides) {
            this.$indentGuideRe = /\s\S| \t|\t |\s$/;
            var className = "ace_indent-guide";
            var spaceClass = "";
            var tabClass = "";
            if (this.showInvisibles) {
              className += " ace_invisible";
              spaceClass = " ace_invisible_space";
              tabClass = " ace_invisible_tab";
              var spaceContent = lang.stringRepeat(this.SPACE_CHAR, this.tabSize);
              var tabContent = this.TAB_CHAR + lang.stringRepeat("\xa0", this.tabSize - 1);
            } else {
              var spaceContent = lang.stringRepeat("\xa0", this.tabSize);
              var tabContent = spaceContent;
            }
            this.$tabStrings[" "] = "<span class='" + className + spaceClass + "'>" + spaceContent + "</span>";
            this.$tabStrings["\t"] = "<span class='" + className + tabClass + "'>" + tabContent + "</span>";
          }
        };
        this.updateLines = function(config, firstRow, lastRow) {
          if (this.config.lastRow != config.lastRow || this.config.firstRow != config.firstRow) {
            this.scrollLines(config);
          }
          this.config = config;
          var first = Math.max(firstRow, config.firstRow);
          var last = Math.min(lastRow, config.lastRow);
          var lineElements = this.element.childNodes;
          var lineElementsIdx = 0;
          for (var row = config.firstRow; row < first; row++) {
            var foldLine = this.session.getFoldLine(row);
            if (foldLine) {
              if (foldLine.containsRow(first)) {
                first = foldLine.start.row;
                break;
              } else {
                row = foldLine.end.row;
              }
            }
            lineElementsIdx++;
          }
          var row = first;
          var foldLine = this.session.getNextFoldLine(row);
          var foldStart = foldLine ? foldLine.start.row : Infinity;
          while (true) {
            if (row > foldStart) {
              row = foldLine.end.row + 1;
              foldLine = this.session.getNextFoldLine(row, foldLine);
              foldStart = foldLine ? foldLine.start.row : Infinity;
            }
            if (row > last)
              break;
            var lineElement = lineElements[lineElementsIdx++];
            if (lineElement) {
              var html = [];
              this.$renderLine(html, row, !this.$useLineGroups(), row == foldStart ? foldLine : false);
              lineElement.style.height = config.lineHeight * this.session.getRowLength(row) + "px";
              lineElement.innerHTML = html.join("");
            }
            row++;
          }
        };
        this.scrollLines = function(config) {
          var oldConfig = this.config;
          this.config = config;
          if (!oldConfig || oldConfig.lastRow < config.firstRow)
            return this.update(config);
          if (config.lastRow < oldConfig.firstRow)
            return this.update(config);
          var el = this.element;
          if (oldConfig.firstRow < config.firstRow)
            for (var row = this.session.getFoldedRowCount(oldConfig.firstRow, config.firstRow - 1); row > 0; row--)
              el.removeChild(el.firstChild);
          if (oldConfig.lastRow > config.lastRow)
            for (var row = this.session.getFoldedRowCount(config.lastRow + 1, oldConfig.lastRow); row > 0; row--)
              el.removeChild(el.lastChild);
          if (config.firstRow < oldConfig.firstRow) {
            var fragment = this.$renderLinesFragment(config, config.firstRow, oldConfig.firstRow - 1);
            if (el.firstChild)
              el.insertBefore(fragment, el.firstChild);
            else
              el.appendChild(fragment);
          }
          if (config.lastRow > oldConfig.lastRow) {
            var fragment = this.$renderLinesFragment(config, oldConfig.lastRow + 1, config.lastRow);
            el.appendChild(fragment);
          }
        };
        this.$renderLinesFragment = function(config, firstRow, lastRow) {
          var fragment = this.element.ownerDocument.createDocumentFragment();
          var row = firstRow;
          var foldLine = this.session.getNextFoldLine(row);
          var foldStart = foldLine ? foldLine.start.row : Infinity;
          while (true) {
            if (row > foldStart) {
              row = foldLine.end.row + 1;
              foldLine = this.session.getNextFoldLine(row, foldLine);
              foldStart = foldLine ? foldLine.start.row : Infinity;
            }
            if (row > lastRow)
              break;
            var container = dom.createElement("div");
            var html = [];
            this.$renderLine(html, row, false, row == foldStart ? foldLine : false);
            container.innerHTML = html.join("");
            if (this.$useLineGroups()) {
              container.className = 'ace_line_group';
              fragment.appendChild(container);
              container.style.height = config.lineHeight * this.session.getRowLength(row) + "px";
            } else {
              while (container.firstChild)
                fragment.appendChild(container.firstChild);
            }
            row++;
          }
          return fragment;
        };
        this.update = function(config) {
          this.config = config;
          var html = [];
          var firstRow = config.firstRow,
              lastRow = config.lastRow;
          var row = firstRow;
          var foldLine = this.session.getNextFoldLine(row);
          var foldStart = foldLine ? foldLine.start.row : Infinity;
          while (true) {
            if (row > foldStart) {
              row = foldLine.end.row + 1;
              foldLine = this.session.getNextFoldLine(row, foldLine);
              foldStart = foldLine ? foldLine.start.row : Infinity;
            }
            if (row > lastRow)
              break;
            if (this.$useLineGroups())
              html.push("<div class='ace_line_group' style='height:", config.lineHeight * this.session.getRowLength(row), "px'>");
            this.$renderLine(html, row, false, row == foldStart ? foldLine : false);
            if (this.$useLineGroups())
              html.push("</div>");
            row++;
          }
          this.element.innerHTML = html.join("");
        };
        this.$textToken = {
          "text": true,
          "rparen": true,
          "lparen": true
        };
        this.$renderToken = function(stringBuilder, screenColumn, token, value) {
          var self = this;
          var replaceReg = /\t|&|<|( +)|([\x00-\x1f\x80-\xa0\xad\u1680\u180E\u2000-\u200f\u2028\u2029\u202F\u205F\u3000\uFEFF])|[\u1100-\u115F\u11A3-\u11A7\u11FA-\u11FF\u2329-\u232A\u2E80-\u2E99\u2E9B-\u2EF3\u2F00-\u2FD5\u2FF0-\u2FFB\u3000-\u303E\u3041-\u3096\u3099-\u30FF\u3105-\u312D\u3131-\u318E\u3190-\u31BA\u31C0-\u31E3\u31F0-\u321E\u3220-\u3247\u3250-\u32FE\u3300-\u4DBF\u4E00-\uA48C\uA490-\uA4C6\uA960-\uA97C\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFAFF\uFE10-\uFE19\uFE30-\uFE52\uFE54-\uFE66\uFE68-\uFE6B\uFF01-\uFF60\uFFE0-\uFFE6]/g;
          var replaceFunc = function(c, a, b, tabIdx, idx4) {
            if (a) {
              return self.showInvisibles ? "<span class='ace_invisible ace_invisible_space'>" + lang.stringRepeat(self.SPACE_CHAR, c.length) + "</span>" : lang.stringRepeat("\xa0", c.length);
            } else if (c == "&") {
              return "&#38;";
            } else if (c == "<") {
              return "&#60;";
            } else if (c == "\t") {
              var tabSize = self.session.getScreenTabSize(screenColumn + tabIdx);
              screenColumn += tabSize - 1;
              return self.$tabStrings[tabSize];
            } else if (c == "\u3000") {
              var classToUse = self.showInvisibles ? "ace_cjk ace_invisible ace_invisible_space" : "ace_cjk";
              var space = self.showInvisibles ? self.SPACE_CHAR : "";
              screenColumn += 1;
              return "<span class='" + classToUse + "' style='width:" + (self.config.characterWidth * 2) + "px'>" + space + "</span>";
            } else if (b) {
              return "<span class='ace_invisible ace_invisible_space ace_invalid'>" + self.SPACE_CHAR + "</span>";
            } else {
              screenColumn += 1;
              return "<span class='ace_cjk' style='width:" + (self.config.characterWidth * 2) + "px'>" + c + "</span>";
            }
          };
          var output = value.replace(replaceReg, replaceFunc);
          if (!this.$textToken[token.type]) {
            var classes = "ace_" + token.type.replace(/\./g, " ace_");
            var style = "";
            if (token.type == "fold")
              style = " style='width:" + (token.value.length * this.config.characterWidth) + "px;' ";
            stringBuilder.push("<span class='", classes, "'", style, ">", output, "</span>");
          } else {
            stringBuilder.push(output);
          }
          return screenColumn + value.length;
        };
        this.renderIndentGuide = function(stringBuilder, value, max) {
          var cols = value.search(this.$indentGuideRe);
          if (cols <= 0 || cols >= max)
            return value;
          if (value[0] == " ") {
            cols -= cols % this.tabSize;
            stringBuilder.push(lang.stringRepeat(this.$tabStrings[" "], cols / this.tabSize));
            return value.substr(cols);
          } else if (value[0] == "\t") {
            stringBuilder.push(lang.stringRepeat(this.$tabStrings["\t"], cols));
            return value.substr(cols);
          }
          return value;
        };
        this.$renderWrappedLine = function(stringBuilder, tokens, splits, onlyContents) {
          var chars = 0;
          var split = 0;
          var splitChars = splits[0];
          var screenColumn = 0;
          for (var i = 0; i < tokens.length; i++) {
            var token = tokens[i];
            var value = token.value;
            if (i == 0 && this.displayIndentGuides) {
              chars = value.length;
              value = this.renderIndentGuide(stringBuilder, value, splitChars);
              if (!value)
                continue;
              chars -= value.length;
            }
            if (chars + value.length < splitChars) {
              screenColumn = this.$renderToken(stringBuilder, screenColumn, token, value);
              chars += value.length;
            } else {
              while (chars + value.length >= splitChars) {
                screenColumn = this.$renderToken(stringBuilder, screenColumn, token, value.substring(0, splitChars - chars));
                value = value.substring(splitChars - chars);
                chars = splitChars;
                if (!onlyContents) {
                  stringBuilder.push("</div>", "<div class='ace_line' style='height:", this.config.lineHeight, "px'>");
                }
                split++;
                screenColumn = 0;
                splitChars = splits[split] || Number.MAX_VALUE;
              }
              if (value.length != 0) {
                chars += value.length;
                screenColumn = this.$renderToken(stringBuilder, screenColumn, token, value);
              }
            }
          }
        };
        this.$renderSimpleLine = function(stringBuilder, tokens) {
          var screenColumn = 0;
          var token = tokens[0];
          var value = token.value;
          if (this.displayIndentGuides)
            value = this.renderIndentGuide(stringBuilder, value);
          if (value)
            screenColumn = this.$renderToken(stringBuilder, screenColumn, token, value);
          for (var i = 1; i < tokens.length; i++) {
            token = tokens[i];
            value = token.value;
            screenColumn = this.$renderToken(stringBuilder, screenColumn, token, value);
          }
        };
        this.$renderLine = function(stringBuilder, row, onlyContents, foldLine) {
          if (!foldLine && foldLine != false)
            foldLine = this.session.getFoldLine(row);
          if (foldLine)
            var tokens = this.$getFoldLineTokens(row, foldLine);
          else
            var tokens = this.session.getTokens(row);
          if (!onlyContents) {
            stringBuilder.push("<div class='ace_line' style='height:", this.config.lineHeight * (this.$useLineGroups() ? 1 : this.session.getRowLength(row)), "px'>");
          }
          if (tokens.length) {
            var splits = this.session.getRowSplitData(row);
            if (splits && splits.length)
              this.$renderWrappedLine(stringBuilder, tokens, splits, onlyContents);
            else
              this.$renderSimpleLine(stringBuilder, tokens);
          }
          if (this.showInvisibles) {
            if (foldLine)
              row = foldLine.end.row;
            stringBuilder.push("<span class='ace_invisible ace_invisible_eol'>", row == this.session.getLength() - 1 ? this.EOF_CHAR : this.EOL_CHAR, "</span>");
          }
          if (!onlyContents)
            stringBuilder.push("</div>");
        };
        this.$getFoldLineTokens = function(row, foldLine) {
          var session = this.session;
          var renderTokens = [];
          function addTokens(tokens, from, to) {
            var idx = 0,
                col = 0;
            while ((col + tokens[idx].value.length) < from) {
              col += tokens[idx].value.length;
              idx++;
              if (idx == tokens.length)
                return ;
            }
            if (col != from) {
              var value = tokens[idx].value.substring(from - col);
              if (value.length > (to - from))
                value = value.substring(0, to - from);
              renderTokens.push({
                type: tokens[idx].type,
                value: value
              });
              col = from + value.length;
              idx += 1;
            }
            while (col < to && idx < tokens.length) {
              var value = tokens[idx].value;
              if (value.length + col > to) {
                renderTokens.push({
                  type: tokens[idx].type,
                  value: value.substring(0, to - col)
                });
              } else
                renderTokens.push(tokens[idx]);
              col += value.length;
              idx += 1;
            }
          }
          var tokens = session.getTokens(row);
          foldLine.walk(function(placeholder, row, column, lastColumn, isNewRow) {
            if (placeholder != null) {
              renderTokens.push({
                type: "fold",
                value: placeholder
              });
            } else {
              if (isNewRow)
                tokens = session.getTokens(row);
              if (tokens.length)
                addTokens(tokens, lastColumn, column);
            }
          }, foldLine.end.row, this.session.getLine(foldLine.end.row).length);
          return renderTokens;
        };
        this.$useLineGroups = function() {
          return this.session.getUseWrapMode();
        };
        this.destroy = function() {
          clearInterval(this.$pollSizeChangesTimer);
          if (this.$measureNode)
            this.$measureNode.parentNode.removeChild(this.$measureNode);
          delete this.$measureNode;
        };
      }).call(Text.prototype);
      exports.Text = Text;
    });
    ace.define("ace/layer/cursor", ["require", "exports", "module", "ace/lib/dom"], function(acequire, exports, module) {
      "use strict";
      var dom = acequire("../lib/dom");
      var IE8;
      var Cursor = function(parentEl) {
        this.element = dom.createElement("div");
        this.element.className = "ace_layer ace_cursor-layer";
        parentEl.appendChild(this.element);
        if (IE8 === undefined)
          IE8 = "opacity" in this.element;
        this.isVisible = false;
        this.isBlinking = true;
        this.blinkInterval = 1000;
        this.smoothBlinking = false;
        this.cursors = [];
        this.cursor = this.addCursor();
        dom.addCssClass(this.element, "ace_hidden-cursors");
        this.$updateCursors = this.$updateVisibility.bind(this);
      };
      (function() {
        this.$updateVisibility = function(val) {
          var cursors = this.cursors;
          for (var i = cursors.length; i--; )
            cursors[i].style.visibility = val ? "" : "hidden";
        };
        this.$updateOpacity = function(val) {
          var cursors = this.cursors;
          for (var i = cursors.length; i--; )
            cursors[i].style.opacity = val ? "" : "0";
        };
        this.$padding = 0;
        this.setPadding = function(padding) {
          this.$padding = padding;
        };
        this.setSession = function(session) {
          this.session = session;
        };
        this.setBlinking = function(blinking) {
          if (blinking != this.isBlinking) {
            this.isBlinking = blinking;
            this.restartTimer();
          }
        };
        this.setBlinkInterval = function(blinkInterval) {
          if (blinkInterval != this.blinkInterval) {
            this.blinkInterval = blinkInterval;
            this.restartTimer();
          }
        };
        this.setSmoothBlinking = function(smoothBlinking) {
          if (smoothBlinking != this.smoothBlinking && !IE8) {
            this.smoothBlinking = smoothBlinking;
            dom.setCssClass(this.element, "ace_smooth-blinking", smoothBlinking);
            this.$updateCursors(true);
            this.$updateCursors = (smoothBlinking ? this.$updateOpacity : this.$updateVisibility).bind(this);
            this.restartTimer();
          }
        };
        this.addCursor = function() {
          var el = dom.createElement("div");
          el.className = "ace_cursor";
          this.element.appendChild(el);
          this.cursors.push(el);
          return el;
        };
        this.removeCursor = function() {
          if (this.cursors.length > 1) {
            var el = this.cursors.pop();
            el.parentNode.removeChild(el);
            return el;
          }
        };
        this.hideCursor = function() {
          this.isVisible = false;
          dom.addCssClass(this.element, "ace_hidden-cursors");
          this.restartTimer();
        };
        this.showCursor = function() {
          this.isVisible = true;
          dom.removeCssClass(this.element, "ace_hidden-cursors");
          this.restartTimer();
        };
        this.restartTimer = function() {
          var update = this.$updateCursors;
          clearInterval(this.intervalId);
          clearTimeout(this.timeoutId);
          if (this.smoothBlinking) {
            dom.removeCssClass(this.element, "ace_smooth-blinking");
          }
          update(true);
          if (!this.isBlinking || !this.blinkInterval || !this.isVisible)
            return ;
          if (this.smoothBlinking) {
            setTimeout(function() {
              dom.addCssClass(this.element, "ace_smooth-blinking");
            }.bind(this));
          }
          var blink = function() {
            this.timeoutId = setTimeout(function() {
              update(false);
            }, 0.6 * this.blinkInterval);
          }.bind(this);
          this.intervalId = setInterval(function() {
            update(true);
            blink();
          }, this.blinkInterval);
          blink();
        };
        this.getPixelPosition = function(position, onScreen) {
          if (!this.config || !this.session)
            return {
              left: 0,
              top: 0
            };
          if (!position)
            position = this.session.selection.getCursor();
          var pos = this.session.documentToScreenPosition(position);
          var cursorLeft = this.$padding + pos.column * this.config.characterWidth;
          var cursorTop = (pos.row - (onScreen ? this.config.firstRowScreen : 0)) * this.config.lineHeight;
          return {
            left: cursorLeft,
            top: cursorTop
          };
        };
        this.update = function(config) {
          this.config = config;
          var selections = this.session.$selectionMarkers;
          var i = 0,
              cursorIndex = 0;
          if (selections === undefined || selections.length === 0) {
            selections = [{cursor: null}];
          }
          for (var i = 0,
              n = selections.length; i < n; i++) {
            var pixelPos = this.getPixelPosition(selections[i].cursor, true);
            if ((pixelPos.top > config.height + config.offset || pixelPos.top < 0) && i > 1) {
              continue;
            }
            var style = (this.cursors[cursorIndex++] || this.addCursor()).style;
            style.left = pixelPos.left + "px";
            style.top = pixelPos.top + "px";
            style.width = config.characterWidth + "px";
            style.height = config.lineHeight + "px";
          }
          while (this.cursors.length > cursorIndex)
            this.removeCursor();
          var overwrite = this.session.getOverwrite();
          this.$setOverwrite(overwrite);
          this.$pixelPos = pixelPos;
          this.restartTimer();
        };
        this.$setOverwrite = function(overwrite) {
          if (overwrite != this.overwrite) {
            this.overwrite = overwrite;
            if (overwrite)
              dom.addCssClass(this.element, "ace_overwrite-cursors");
            else
              dom.removeCssClass(this.element, "ace_overwrite-cursors");
          }
        };
        this.destroy = function() {
          clearInterval(this.intervalId);
          clearTimeout(this.timeoutId);
        };
      }).call(Cursor.prototype);
      exports.Cursor = Cursor;
    });
    ace.define("ace/scrollbar", ["require", "exports", "module", "ace/lib/oop", "ace/lib/dom", "ace/lib/event", "ace/lib/event_emitter"], function(acequire, exports, module) {
      "use strict";
      var oop = acequire("./lib/oop");
      var dom = acequire("./lib/dom");
      var event = acequire("./lib/event");
      var EventEmitter = acequire("./lib/event_emitter").EventEmitter;
      var ScrollBar = function(parent) {
        this.element = dom.createElement("div");
        this.element.className = "ace_scrollbar ace_scrollbar" + this.classSuffix;
        this.inner = dom.createElement("div");
        this.inner.className = "ace_scrollbar-inner";
        this.element.appendChild(this.inner);
        parent.appendChild(this.element);
        this.setVisible(false);
        this.skipEvent = false;
        event.addListener(this.element, "scroll", this.onScroll.bind(this));
        event.addListener(this.element, "mousedown", event.preventDefault);
      };
      (function() {
        oop.implement(this, EventEmitter);
        this.setVisible = function(isVisible) {
          this.element.style.display = isVisible ? "" : "none";
          this.isVisible = isVisible;
        };
      }).call(ScrollBar.prototype);
      var VScrollBar = function(parent, renderer) {
        ScrollBar.call(this, parent);
        this.scrollTop = 0;
        renderer.$scrollbarWidth = this.width = dom.scrollbarWidth(parent.ownerDocument);
        this.inner.style.width = this.element.style.width = (this.width || 15) + 5 + "px";
      };
      oop.inherits(VScrollBar, ScrollBar);
      (function() {
        this.classSuffix = '-v';
        this.onScroll = function() {
          if (!this.skipEvent) {
            this.scrollTop = this.element.scrollTop;
            this._emit("scroll", {data: this.scrollTop});
          }
          this.skipEvent = false;
        };
        this.getWidth = function() {
          return this.isVisible ? this.width : 0;
        };
        this.setHeight = function(height) {
          this.element.style.height = height + "px";
        };
        this.setInnerHeight = function(height) {
          this.inner.style.height = height + "px";
        };
        this.setScrollHeight = function(height) {
          this.inner.style.height = height + "px";
        };
        this.setScrollTop = function(scrollTop) {
          if (this.scrollTop != scrollTop) {
            this.skipEvent = true;
            this.scrollTop = this.element.scrollTop = scrollTop;
          }
        };
      }).call(VScrollBar.prototype);
      var HScrollBar = function(parent, renderer) {
        ScrollBar.call(this, parent);
        this.scrollLeft = 0;
        this.height = renderer.$scrollbarWidth;
        this.inner.style.height = this.element.style.height = (this.height || 15) + 5 + "px";
      };
      oop.inherits(HScrollBar, ScrollBar);
      (function() {
        this.classSuffix = '-h';
        this.onScroll = function() {
          if (!this.skipEvent) {
            this.scrollLeft = this.element.scrollLeft;
            this._emit("scroll", {data: this.scrollLeft});
          }
          this.skipEvent = false;
        };
        this.getHeight = function() {
          return this.isVisible ? this.height : 0;
        };
        this.setWidth = function(width) {
          this.element.style.width = width + "px";
        };
        this.setInnerWidth = function(width) {
          this.inner.style.width = width + "px";
        };
        this.setScrollWidth = function(width) {
          this.inner.style.width = width + "px";
        };
        this.setScrollLeft = function(scrollLeft) {
          if (this.scrollLeft != scrollLeft) {
            this.skipEvent = true;
            this.scrollLeft = this.element.scrollLeft = scrollLeft;
          }
        };
      }).call(HScrollBar.prototype);
      exports.ScrollBar = VScrollBar;
      exports.ScrollBarV = VScrollBar;
      exports.ScrollBarH = HScrollBar;
      exports.VScrollBar = VScrollBar;
      exports.HScrollBar = HScrollBar;
    });
    ace.define("ace/renderloop", ["require", "exports", "module", "ace/lib/event"], function(acequire, exports, module) {
      "use strict";
      var event = acequire("./lib/event");
      var RenderLoop = function(onRender, win) {
        this.onRender = onRender;
        this.pending = false;
        this.changes = 0;
        this.window = win || window;
      };
      (function() {
        this.schedule = function(change) {
          this.changes = this.changes | change;
          if (!this.pending && this.changes) {
            this.pending = true;
            var _self = this;
            event.nextFrame(function() {
              _self.pending = false;
              var changes;
              while (changes = _self.changes) {
                _self.changes = 0;
                _self.onRender(changes);
              }
            }, this.window);
          }
        };
      }).call(RenderLoop.prototype);
      exports.RenderLoop = RenderLoop;
    });
    ace.define("ace/layer/font_metrics", ["require", "exports", "module", "ace/lib/oop", "ace/lib/dom", "ace/lib/lang", "ace/lib/useragent", "ace/lib/event_emitter"], function(acequire, exports, module) {
      var oop = acequire("../lib/oop");
      var dom = acequire("../lib/dom");
      var lang = acequire("../lib/lang");
      var useragent = acequire("../lib/useragent");
      var EventEmitter = acequire("../lib/event_emitter").EventEmitter;
      var CHAR_COUNT = 0;
      var FontMetrics = exports.FontMetrics = function(parentEl, interval) {
        this.el = dom.createElement("div");
        this.$setMeasureNodeStyles(this.el.style, true);
        this.$main = dom.createElement("div");
        this.$setMeasureNodeStyles(this.$main.style);
        this.$measureNode = dom.createElement("div");
        this.$setMeasureNodeStyles(this.$measureNode.style);
        this.el.appendChild(this.$main);
        this.el.appendChild(this.$measureNode);
        parentEl.appendChild(this.el);
        if (!CHAR_COUNT)
          this.$testFractionalRect();
        this.$measureNode.innerHTML = lang.stringRepeat("X", CHAR_COUNT);
        this.$characterSize = {
          width: 0,
          height: 0
        };
        this.checkForSizeChanges();
      };
      (function() {
        oop.implement(this, EventEmitter);
        this.$characterSize = {
          width: 0,
          height: 0
        };
        this.$testFractionalRect = function() {
          var el = dom.createElement("div");
          this.$setMeasureNodeStyles(el.style);
          el.style.width = "0.2px";
          document.documentElement.appendChild(el);
          var w = el.getBoundingClientRect().width;
          if (w > 0 && w < 1)
            CHAR_COUNT = 50;
          else
            CHAR_COUNT = 100;
          el.parentNode.removeChild(el);
        };
        this.$setMeasureNodeStyles = function(style, isRoot) {
          style.width = style.height = "auto";
          style.left = style.top = "-100px";
          style.visibility = "hidden";
          style.position = "fixed";
          style.whiteSpace = "pre";
          if (useragent.isIE < 8) {
            style["font-family"] = "inherit";
          } else {
            style.font = "inherit";
          }
          style.overflow = isRoot ? "hidden" : "visible";
        };
        this.checkForSizeChanges = function() {
          var size = this.$measureSizes();
          if (size && (this.$characterSize.width !== size.width || this.$characterSize.height !== size.height)) {
            this.$measureNode.style.fontWeight = "bold";
            var boldSize = this.$measureSizes();
            this.$measureNode.style.fontWeight = "";
            this.$characterSize = size;
            this.charSizes = Object.create(null);
            this.allowBoldFonts = boldSize && boldSize.width === size.width && boldSize.height === size.height;
            this._emit("changeCharacterSize", {data: size});
          }
        };
        this.$pollSizeChanges = function() {
          if (this.$pollSizeChangesTimer)
            return this.$pollSizeChangesTimer;
          var self = this;
          return this.$pollSizeChangesTimer = setInterval(function() {
            self.checkForSizeChanges();
          }, 500);
        };
        this.setPolling = function(val) {
          if (val) {
            this.$pollSizeChanges();
          } else {
            if (this.$pollSizeChangesTimer)
              this.$pollSizeChangesTimer;
          }
        };
        this.$measureSizes = function() {
          if (CHAR_COUNT === 50) {
            var rect = null;
            try {
              rect = this.$measureNode.getBoundingClientRect();
            } catch (e) {
              rect = {
                width: 0,
                height: 0
              };
            }
            ;
            var size = {
              height: rect.height,
              width: rect.width / CHAR_COUNT
            };
          } else {
            var size = {
              height: this.$measureNode.clientHeight,
              width: this.$measureNode.clientWidth / CHAR_COUNT
            };
          }
          if (size.width === 0 || size.height === 0)
            return null;
          return size;
        };
        this.$measureCharWidth = function(ch) {
          this.$main.innerHTML = lang.stringRepeat(ch, CHAR_COUNT);
          var rect = this.$main.getBoundingClientRect();
          return rect.width / CHAR_COUNT;
        };
        this.getCharacterWidth = function(ch) {
          var w = this.charSizes[ch];
          if (w === undefined) {
            this.charSizes[ch] = this.$measureCharWidth(ch) / this.$characterSize.width;
          }
          return w;
        };
        this.destroy = function() {
          clearInterval(this.$pollSizeChangesTimer);
          if (this.el && this.el.parentNode)
            this.el.parentNode.removeChild(this.el);
        };
      }).call(FontMetrics.prototype);
    });
    ace.define("ace/virtual_renderer", ["require", "exports", "module", "ace/lib/oop", "ace/lib/dom", "ace/config", "ace/lib/useragent", "ace/layer/gutter", "ace/layer/marker", "ace/layer/text", "ace/layer/cursor", "ace/scrollbar", "ace/scrollbar", "ace/renderloop", "ace/layer/font_metrics", "ace/lib/event_emitter"], function(acequire, exports, module) {
      "use strict";
      var oop = acequire("./lib/oop");
      var dom = acequire("./lib/dom");
      var config = acequire("./config");
      var useragent = acequire("./lib/useragent");
      var GutterLayer = acequire("./layer/gutter").Gutter;
      var MarkerLayer = acequire("./layer/marker").Marker;
      var TextLayer = acequire("./layer/text").Text;
      var CursorLayer = acequire("./layer/cursor").Cursor;
      var HScrollBar = acequire("./scrollbar").HScrollBar;
      var VScrollBar = acequire("./scrollbar").VScrollBar;
      var RenderLoop = acequire("./renderloop").RenderLoop;
      var FontMetrics = acequire("./layer/font_metrics").FontMetrics;
      var EventEmitter = acequire("./lib/event_emitter").EventEmitter;
      var editorCss = ".ace_editor {\
position: relative;\
overflow: hidden;\
font: 12px/normal 'Monaco', 'Menlo', 'Ubuntu Mono', 'Consolas', 'source-code-pro', monospace;\
direction: ltr;\
}\
.ace_scroller {\
position: absolute;\
overflow: hidden;\
top: 0;\
bottom: 0;\
background-color: inherit;\
-ms-user-select: none;\
-moz-user-select: none;\
-webkit-user-select: none;\
user-select: none;\
cursor: text;\
}\
.ace_content {\
position: absolute;\
-moz-box-sizing: border-box;\
-webkit-box-sizing: border-box;\
box-sizing: border-box;\
min-width: 100%;\
}\
.ace_dragging .ace_scroller:before{\
position: absolute;\
top: 0;\
left: 0;\
right: 0;\
bottom: 0;\
content: '';\
background: rgba(250, 250, 250, 0.01);\
z-index: 1000;\
}\
.ace_dragging.ace_dark .ace_scroller:before{\
background: rgba(0, 0, 0, 0.01);\
}\
.ace_selecting, .ace_selecting * {\
cursor: text !important;\
}\
.ace_gutter {\
position: absolute;\
overflow : hidden;\
width: auto;\
top: 0;\
bottom: 0;\
left: 0;\
cursor: default;\
z-index: 4;\
-ms-user-select: none;\
-moz-user-select: none;\
-webkit-user-select: none;\
user-select: none;\
}\
.ace_gutter-active-line {\
position: absolute;\
left: 0;\
right: 0;\
}\
.ace_scroller.ace_scroll-left {\
box-shadow: 17px 0 16px -16px rgba(0, 0, 0, 0.4) inset;\
}\
.ace_gutter-cell {\
padding-left: 19px;\
padding-right: 6px;\
background-repeat: no-repeat;\
}\
.ace_gutter-cell.ace_error {\
background-image: url(\"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAMAAAAoLQ9TAAABOFBMVEX/////////QRswFAb/Ui4wFAYwFAYwFAaWGAfDRymzOSH/PxswFAb/SiUwFAYwFAbUPRvjQiDllog5HhHdRybsTi3/Tyv9Tir+Syj/UC3////XurebMBIwFAb/RSHbPx/gUzfdwL3kzMivKBAwFAbbvbnhPx66NhowFAYwFAaZJg8wFAaxKBDZurf/RB6mMxb/SCMwFAYwFAbxQB3+RB4wFAb/Qhy4Oh+4QifbNRcwFAYwFAYwFAb/QRzdNhgwFAYwFAbav7v/Uy7oaE68MBK5LxLewr/r2NXewLswFAaxJw4wFAbkPRy2PyYwFAaxKhLm1tMwFAazPiQwFAaUGAb/QBrfOx3bvrv/VC/maE4wFAbRPBq6MRO8Qynew8Dp2tjfwb0wFAbx6eju5+by6uns4uH9/f36+vr/GkHjAAAAYnRSTlMAGt+64rnWu/bo8eAA4InH3+DwoN7j4eLi4xP99Nfg4+b+/u9B/eDs1MD1mO7+4PHg2MXa347g7vDizMLN4eG+Pv7i5evs/v79yu7S3/DV7/498Yv24eH+4ufQ3Ozu/v7+y13sRqwAAADLSURBVHjaZc/XDsFgGIBhtDrshlitmk2IrbHFqL2pvXf/+78DPokj7+Fz9qpU/9UXJIlhmPaTaQ6QPaz0mm+5gwkgovcV6GZzd5JtCQwgsxoHOvJO15kleRLAnMgHFIESUEPmawB9ngmelTtipwwfASilxOLyiV5UVUyVAfbG0cCPHig+GBkzAENHS0AstVF6bacZIOzgLmxsHbt2OecNgJC83JERmePUYq8ARGkJx6XtFsdddBQgZE2nPR6CICZhawjA4Fb/chv+399kfR+MMMDGOQAAAABJRU5ErkJggg==\");\
background-repeat: no-repeat;\
background-position: 2px center;\
}\
.ace_gutter-cell.ace_warning {\
background-image: url(\"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAMAAAAoLQ9TAAAAmVBMVEX///8AAAD///8AAAAAAABPSzb/5sAAAAB/blH/73z/ulkAAAAAAAD85pkAAAAAAAACAgP/vGz/rkDerGbGrV7/pkQICAf////e0IsAAAD/oED/qTvhrnUAAAD/yHD/njcAAADuv2r/nz//oTj/p064oGf/zHAAAAA9Nir/tFIAAAD/tlTiuWf/tkIAAACynXEAAAAAAAAtIRW7zBpBAAAAM3RSTlMAABR1m7RXO8Ln31Z36zT+neXe5OzooRDfn+TZ4p3h2hTf4t3k3ucyrN1K5+Xaks52Sfs9CXgrAAAAjklEQVR42o3PbQ+CIBQFYEwboPhSYgoYunIqqLn6/z8uYdH8Vmdnu9vz4WwXgN/xTPRD2+sgOcZjsge/whXZgUaYYvT8QnuJaUrjrHUQreGczuEafQCO/SJTufTbroWsPgsllVhq3wJEk2jUSzX3CUEDJC84707djRc5MTAQxoLgupWRwW6UB5fS++NV8AbOZgnsC7BpEAAAAABJRU5ErkJggg==\");\
background-position: 2px center;\
}\
.ace_gutter-cell.ace_info {\
background-image: url(\"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAAAAAA6mKC9AAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAAJ0Uk5TAAB2k804AAAAPklEQVQY02NgIB68QuO3tiLznjAwpKTgNyDbMegwisCHZUETUZV0ZqOquBpXj2rtnpSJT1AEnnRmL2OgGgAAIKkRQap2htgAAAAASUVORK5CYII=\");\
background-position: 2px center;\
}\
.ace_dark .ace_gutter-cell.ace_info {\
background-image: url(\"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQBAMAAADt3eJSAAAAJFBMVEUAAAChoaGAgIAqKiq+vr6tra1ZWVmUlJSbm5s8PDxubm56enrdgzg3AAAAAXRSTlMAQObYZgAAAClJREFUeNpjYMAPdsMYHegyJZFQBlsUlMFVCWUYKkAZMxZAGdxlDMQBAG+TBP4B6RyJAAAAAElFTkSuQmCC\");\
}\
.ace_scrollbar {\
position: absolute;\
right: 0;\
bottom: 0;\
z-index: 6;\
}\
.ace_scrollbar-inner {\
position: absolute;\
cursor: text;\
left: 0;\
top: 0;\
}\
.ace_scrollbar-v{\
overflow-x: hidden;\
overflow-y: scroll;\
top: 0;\
}\
.ace_scrollbar-h {\
overflow-x: scroll;\
overflow-y: hidden;\
left: 0;\
}\
.ace_print-margin {\
position: absolute;\
height: 100%;\
}\
.ace_text-input {\
position: absolute;\
z-index: 0;\
width: 0.5em;\
height: 1em;\
opacity: 0;\
background: transparent;\
-moz-appearance: none;\
appearance: none;\
border: none;\
resize: none;\
outline: none;\
overflow: hidden;\
font: inherit;\
padding: 0 1px;\
margin: 0 -1px;\
text-indent: -1em;\
-ms-user-select: text;\
-moz-user-select: text;\
-webkit-user-select: text;\
user-select: text;\
}\
.ace_text-input.ace_composition {\
background: inherit;\
color: inherit;\
z-index: 1000;\
opacity: 1;\
text-indent: 0;\
}\
.ace_layer {\
z-index: 1;\
position: absolute;\
overflow: hidden;\
white-space: pre;\
height: 100%;\
width: 100%;\
-moz-box-sizing: border-box;\
-webkit-box-sizing: border-box;\
box-sizing: border-box;\
pointer-events: none;\
}\
.ace_gutter-layer {\
position: relative;\
width: auto;\
text-align: right;\
pointer-events: auto;\
}\
.ace_text-layer {\
font: inherit !important;\
}\
.ace_cjk {\
display: inline-block;\
text-align: center;\
}\
.ace_cursor-layer {\
z-index: 4;\
}\
.ace_cursor {\
z-index: 4;\
position: absolute;\
-moz-box-sizing: border-box;\
-webkit-box-sizing: border-box;\
box-sizing: border-box;\
border-left: 2px solid\
}\
.ace_slim-cursors .ace_cursor {\
border-left-width: 1px;\
}\
.ace_overwrite-cursors .ace_cursor {\
border-left-width: 0;\
border-bottom: 1px solid;\
}\
.ace_hidden-cursors .ace_cursor {\
opacity: 0.2;\
}\
.ace_smooth-blinking .ace_cursor {\
-webkit-transition: opacity 0.18s;\
transition: opacity 0.18s;\
}\
.ace_editor.ace_multiselect .ace_cursor {\
border-left-width: 1px;\
}\
.ace_marker-layer .ace_step, .ace_marker-layer .ace_stack {\
position: absolute;\
z-index: 3;\
}\
.ace_marker-layer .ace_selection {\
position: absolute;\
z-index: 5;\
}\
.ace_marker-layer .ace_bracket {\
position: absolute;\
z-index: 6;\
}\
.ace_marker-layer .ace_active-line {\
position: absolute;\
z-index: 2;\
}\
.ace_marker-layer .ace_selected-word {\
position: absolute;\
z-index: 4;\
-moz-box-sizing: border-box;\
-webkit-box-sizing: border-box;\
box-sizing: border-box;\
}\
.ace_line .ace_fold {\
-moz-box-sizing: border-box;\
-webkit-box-sizing: border-box;\
box-sizing: border-box;\
display: inline-block;\
height: 11px;\
margin-top: -2px;\
vertical-align: middle;\
background-image:\
url(\"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABEAAAAJCAYAAADU6McMAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAJpJREFUeNpi/P//PwOlgAXGYGRklAVSokD8GmjwY1wasKljQpYACtpCFeADcHVQfQyMQAwzwAZI3wJKvCLkfKBaMSClBlR7BOQikCFGQEErIH0VqkabiGCAqwUadAzZJRxQr/0gwiXIal8zQQPnNVTgJ1TdawL0T5gBIP1MUJNhBv2HKoQHHjqNrA4WO4zY0glyNKLT2KIfIMAAQsdgGiXvgnYAAAAASUVORK5CYII=\"),\
url(\"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAA3CAYAAADNNiA5AAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAACJJREFUeNpi+P//fxgTAwPDBxDxD078RSX+YeEyDFMCIMAAI3INmXiwf2YAAAAASUVORK5CYII=\");\
background-repeat: no-repeat, repeat-x;\
background-position: center center, top left;\
color: transparent;\
border: 1px solid black;\
border-radius: 2px;\
cursor: pointer;\
pointer-events: auto;\
}\
.ace_dark .ace_fold {\
}\
.ace_fold:hover{\
background-image:\
url(\"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABEAAAAJCAYAAADU6McMAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAJpJREFUeNpi/P//PwOlgAXGYGRklAVSokD8GmjwY1wasKljQpYACtpCFeADcHVQfQyMQAwzwAZI3wJKvCLkfKBaMSClBlR7BOQikCFGQEErIH0VqkabiGCAqwUadAzZJRxQr/0gwiXIal8zQQPnNVTgJ1TdawL0T5gBIP1MUJNhBv2HKoQHHjqNrA4WO4zY0glyNKLT2KIfIMAAQsdgGiXvgnYAAAAASUVORK5CYII=\"),\
url(\"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAA3CAYAAADNNiA5AAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAACBJREFUeNpi+P//fz4TAwPDZxDxD5X4i5fLMEwJgAADAEPVDbjNw87ZAAAAAElFTkSuQmCC\");\
}\
.ace_tooltip {\
background-color: #FFF;\
background-image: -webkit-linear-gradient(top, transparent, rgba(0, 0, 0, 0.1));\
background-image: linear-gradient(to bottom, transparent, rgba(0, 0, 0, 0.1));\
border: 1px solid gray;\
border-radius: 1px;\
box-shadow: 0 1px 2px rgba(0, 0, 0, 0.3);\
color: black;\
max-width: 100%;\
padding: 3px 4px;\
position: fixed;\
z-index: 999999;\
-moz-box-sizing: border-box;\
-webkit-box-sizing: border-box;\
box-sizing: border-box;\
cursor: default;\
white-space: pre;\
word-wrap: break-word;\
line-height: normal;\
font-style: normal;\
font-weight: normal;\
letter-spacing: normal;\
pointer-events: none;\
}\
.ace_folding-enabled > .ace_gutter-cell {\
padding-right: 13px;\
}\
.ace_fold-widget {\
-moz-box-sizing: border-box;\
-webkit-box-sizing: border-box;\
box-sizing: border-box;\
margin: 0 -12px 0 1px;\
display: none;\
width: 11px;\
vertical-align: top;\
background-image: url(\"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAUAAAAFCAYAAACNbyblAAAANElEQVR42mWKsQ0AMAzC8ixLlrzQjzmBiEjp0A6WwBCSPgKAXoLkqSot7nN3yMwR7pZ32NzpKkVoDBUxKAAAAABJRU5ErkJggg==\");\
background-repeat: no-repeat;\
background-position: center;\
border-radius: 3px;\
border: 1px solid transparent;\
cursor: pointer;\
}\
.ace_folding-enabled .ace_fold-widget {\
display: inline-block;   \
}\
.ace_fold-widget.ace_end {\
background-image: url(\"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAUAAAAFCAYAAACNbyblAAAANElEQVR42m3HwQkAMAhD0YzsRchFKI7sAikeWkrxwScEB0nh5e7KTPWimZki4tYfVbX+MNl4pyZXejUO1QAAAABJRU5ErkJggg==\");\
}\
.ace_fold-widget.ace_closed {\
background-image: url(\"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAMAAAAGCAYAAAAG5SQMAAAAOUlEQVR42jXKwQkAMAgDwKwqKD4EwQ26sSOkVWjgIIHAzPiCgaqiqnJHZnKICBERHN194O5b9vbLuAVRL+l0YWnZAAAAAElFTkSuQmCCXA==\");\
}\
.ace_fold-widget:hover {\
border: 1px solid rgba(0, 0, 0, 0.3);\
background-color: rgba(255, 255, 255, 0.2);\
box-shadow: 0 1px 1px rgba(255, 255, 255, 0.7);\
}\
.ace_fold-widget:active {\
border: 1px solid rgba(0, 0, 0, 0.4);\
background-color: rgba(0, 0, 0, 0.05);\
box-shadow: 0 1px 1px rgba(255, 255, 255, 0.8);\
}\
.ace_dark .ace_fold-widget {\
background-image: url(\"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAUAAAAFCAYAAACNbyblAAAAHklEQVQIW2P4//8/AzoGEQ7oGCaLLAhWiSwB146BAQCSTPYocqT0AAAAAElFTkSuQmCC\");\
}\
.ace_dark .ace_fold-widget.ace_end {\
background-image: url(\"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAUAAAAFCAYAAACNbyblAAAAH0lEQVQIW2P4//8/AxQ7wNjIAjDMgC4AxjCVKBirIAAF0kz2rlhxpAAAAABJRU5ErkJggg==\");\
}\
.ace_dark .ace_fold-widget.ace_closed {\
background-image: url(\"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAMAAAAFCAYAAACAcVaiAAAAHElEQVQIW2P4//+/AxAzgDADlOOAznHAKgPWAwARji8UIDTfQQAAAABJRU5ErkJggg==\");\
}\
.ace_dark .ace_fold-widget:hover {\
box-shadow: 0 1px 1px rgba(255, 255, 255, 0.2);\
background-color: rgba(255, 255, 255, 0.1);\
}\
.ace_dark .ace_fold-widget:active {\
box-shadow: 0 1px 1px rgba(255, 255, 255, 0.2);\
}\
.ace_fold-widget.ace_invalid {\
background-color: #FFB4B4;\
border-color: #DE5555;\
}\
.ace_fade-fold-widgets .ace_fold-widget {\
-webkit-transition: opacity 0.4s ease 0.05s;\
transition: opacity 0.4s ease 0.05s;\
opacity: 0;\
}\
.ace_fade-fold-widgets:hover .ace_fold-widget {\
-webkit-transition: opacity 0.05s ease 0.05s;\
transition: opacity 0.05s ease 0.05s;\
opacity:1;\
}\
.ace_underline {\
text-decoration: underline;\
}\
.ace_bold {\
font-weight: bold;\
}\
.ace_nobold .ace_bold {\
font-weight: normal;\
}\
.ace_italic {\
font-style: italic;\
}\
.ace_error-marker {\
background-color: rgba(255, 0, 0,0.2);\
position: absolute;\
z-index: 9;\
}\
.ace_highlight-marker {\
background-color: rgba(255, 255, 0,0.2);\
position: absolute;\
z-index: 8;\
}\
";
      dom.importCssString(editorCss, "ace_editor");
      var VirtualRenderer = function(container, theme) {
        var _self = this;
        this.container = container || dom.createElement("div");
        this.$keepTextAreaAtCursor = !useragent.isOldIE;
        dom.addCssClass(this.container, "ace_editor");
        this.setTheme(theme);
        this.$gutter = dom.createElement("div");
        this.$gutter.className = "ace_gutter";
        this.container.appendChild(this.$gutter);
        this.scroller = dom.createElement("div");
        this.scroller.className = "ace_scroller";
        this.container.appendChild(this.scroller);
        this.content = dom.createElement("div");
        this.content.className = "ace_content";
        this.scroller.appendChild(this.content);
        this.$gutterLayer = new GutterLayer(this.$gutter);
        this.$gutterLayer.on("changeGutterWidth", this.onGutterResize.bind(this));
        this.$markerBack = new MarkerLayer(this.content);
        var textLayer = this.$textLayer = new TextLayer(this.content);
        this.canvas = textLayer.element;
        this.$markerFront = new MarkerLayer(this.content);
        this.$cursorLayer = new CursorLayer(this.content);
        this.$horizScroll = false;
        this.$vScroll = false;
        this.scrollBar = this.scrollBarV = new VScrollBar(this.container, this);
        this.scrollBarH = new HScrollBar(this.container, this);
        this.scrollBarV.addEventListener("scroll", function(e) {
          if (!_self.$scrollAnimation)
            _self.session.setScrollTop(e.data - _self.scrollMargin.top);
        });
        this.scrollBarH.addEventListener("scroll", function(e) {
          if (!_self.$scrollAnimation)
            _self.session.setScrollLeft(e.data - _self.scrollMargin.left);
        });
        this.scrollTop = 0;
        this.scrollLeft = 0;
        this.cursorPos = {
          row: 0,
          column: 0
        };
        this.$fontMetrics = new FontMetrics(this.container, 500);
        this.$textLayer.$setFontMetrics(this.$fontMetrics);
        this.$textLayer.addEventListener("changeCharacterSize", function(e) {
          _self.updateCharacterSize();
          _self.onResize(true, _self.gutterWidth, _self.$size.width, _self.$size.height);
          _self._signal("changeCharacterSize", e);
        });
        this.$size = {
          width: 0,
          height: 0,
          scrollerHeight: 0,
          scrollerWidth: 0,
          $dirty: true
        };
        this.layerConfig = {
          width: 1,
          padding: 0,
          firstRow: 0,
          firstRowScreen: 0,
          lastRow: 0,
          lineHeight: 0,
          characterWidth: 0,
          minHeight: 1,
          maxHeight: 1,
          offset: 0,
          height: 1,
          gutterOffset: 1
        };
        this.scrollMargin = {
          left: 0,
          right: 0,
          top: 0,
          bottom: 0,
          v: 0,
          h: 0
        };
        this.$loop = new RenderLoop(this.$renderChanges.bind(this), this.container.ownerDocument.defaultView);
        this.$loop.schedule(this.CHANGE_FULL);
        this.updateCharacterSize();
        this.setPadding(4);
        config.resetOptions(this);
        config._emit("renderer", this);
      };
      (function() {
        this.CHANGE_CURSOR = 1;
        this.CHANGE_MARKER = 2;
        this.CHANGE_GUTTER = 4;
        this.CHANGE_SCROLL = 8;
        this.CHANGE_LINES = 16;
        this.CHANGE_TEXT = 32;
        this.CHANGE_SIZE = 64;
        this.CHANGE_MARKER_BACK = 128;
        this.CHANGE_MARKER_FRONT = 256;
        this.CHANGE_FULL = 512;
        this.CHANGE_H_SCROLL = 1024;
        oop.implement(this, EventEmitter);
        this.updateCharacterSize = function() {
          if (this.$textLayer.allowBoldFonts != this.$allowBoldFonts) {
            this.$allowBoldFonts = this.$textLayer.allowBoldFonts;
            this.setStyle("ace_nobold", !this.$allowBoldFonts);
          }
          this.layerConfig.characterWidth = this.characterWidth = this.$textLayer.getCharacterWidth();
          this.layerConfig.lineHeight = this.lineHeight = this.$textLayer.getLineHeight();
          this.$updatePrintMargin();
        };
        this.setSession = function(session) {
          if (this.session)
            this.session.doc.off("changeNewLineMode", this.onChangeNewLineMode);
          this.session = session;
          if (session && this.scrollMargin.top && session.getScrollTop() <= 0)
            session.setScrollTop(-this.scrollMargin.top);
          this.$cursorLayer.setSession(session);
          this.$markerBack.setSession(session);
          this.$markerFront.setSession(session);
          this.$gutterLayer.setSession(session);
          this.$textLayer.setSession(session);
          if (!session)
            return ;
          this.$loop.schedule(this.CHANGE_FULL);
          this.session.$setFontMetrics(this.$fontMetrics);
          this.onChangeNewLineMode = this.onChangeNewLineMode.bind(this);
          this.onChangeNewLineMode();
          this.session.doc.on("changeNewLineMode", this.onChangeNewLineMode);
        };
        this.updateLines = function(firstRow, lastRow, force) {
          if (lastRow === undefined)
            lastRow = Infinity;
          if (!this.$changedLines) {
            this.$changedLines = {
              firstRow: firstRow,
              lastRow: lastRow
            };
          } else {
            if (this.$changedLines.firstRow > firstRow)
              this.$changedLines.firstRow = firstRow;
            if (this.$changedLines.lastRow < lastRow)
              this.$changedLines.lastRow = lastRow;
          }
          if (this.$changedLines.lastRow < this.layerConfig.firstRow) {
            if (force)
              this.$changedLines.lastRow = this.layerConfig.lastRow;
            else
              return ;
          }
          if (this.$changedLines.firstRow > this.layerConfig.lastRow)
            return ;
          this.$loop.schedule(this.CHANGE_LINES);
        };
        this.onChangeNewLineMode = function() {
          this.$loop.schedule(this.CHANGE_TEXT);
          this.$textLayer.$updateEolChar();
        };
        this.onChangeTabSize = function() {
          this.$loop.schedule(this.CHANGE_TEXT | this.CHANGE_MARKER);
          this.$textLayer.onChangeTabSize();
        };
        this.updateText = function() {
          this.$loop.schedule(this.CHANGE_TEXT);
        };
        this.updateFull = function(force) {
          if (force)
            this.$renderChanges(this.CHANGE_FULL, true);
          else
            this.$loop.schedule(this.CHANGE_FULL);
        };
        this.updateFontSize = function() {
          this.$textLayer.checkForSizeChanges();
        };
        this.$changes = 0;
        this.$updateSizeAsync = function() {
          if (this.$loop.pending)
            this.$size.$dirty = true;
          else
            this.onResize();
        };
        this.onResize = function(force, gutterWidth, width, height) {
          if (this.resizing > 2)
            return ;
          else if (this.resizing > 0)
            this.resizing++;
          else
            this.resizing = force ? 1 : 0;
          var el = this.container;
          if (!height)
            height = el.clientHeight || el.scrollHeight;
          if (!width)
            width = el.clientWidth || el.scrollWidth;
          var changes = this.$updateCachedSize(force, gutterWidth, width, height);
          if (!this.$size.scrollerHeight || (!width && !height))
            return this.resizing = 0;
          if (force)
            this.$gutterLayer.$padding = null;
          if (force)
            this.$renderChanges(changes | this.$changes, true);
          else
            this.$loop.schedule(changes | this.$changes);
          if (this.resizing)
            this.resizing = 0;
        };
        this.$updateCachedSize = function(force, gutterWidth, width, height) {
          height -= (this.$extraHeight || 0);
          var changes = 0;
          var size = this.$size;
          var oldSize = {
            width: size.width,
            height: size.height,
            scrollerHeight: size.scrollerHeight,
            scrollerWidth: size.scrollerWidth
          };
          if (height && (force || size.height != height)) {
            size.height = height;
            changes |= this.CHANGE_SIZE;
            size.scrollerHeight = size.height;
            if (this.$horizScroll)
              size.scrollerHeight -= this.scrollBarH.getHeight();
            this.scrollBarV.element.style.bottom = this.scrollBarH.getHeight() + "px";
            changes = changes | this.CHANGE_SCROLL;
          }
          if (width && (force || size.width != width)) {
            changes |= this.CHANGE_SIZE;
            size.width = width;
            if (gutterWidth == null)
              gutterWidth = this.$showGutter ? this.$gutter.offsetWidth : 0;
            this.gutterWidth = gutterWidth;
            this.scrollBarH.element.style.left = this.scroller.style.left = gutterWidth + "px";
            size.scrollerWidth = Math.max(0, width - gutterWidth - this.scrollBarV.getWidth());
            this.scrollBarH.element.style.right = this.scroller.style.right = this.scrollBarV.getWidth() + "px";
            this.scroller.style.bottom = this.scrollBarH.getHeight() + "px";
            if (this.session && this.session.getUseWrapMode() && this.adjustWrapLimit() || force)
              changes |= this.CHANGE_FULL;
          }
          size.$dirty = !width || !height;
          if (changes)
            this._signal("resize", oldSize);
          return changes;
        };
        this.onGutterResize = function() {
          var gutterWidth = this.$showGutter ? this.$gutter.offsetWidth : 0;
          if (gutterWidth != this.gutterWidth)
            this.$changes |= this.$updateCachedSize(true, gutterWidth, this.$size.width, this.$size.height);
          if (this.session.getUseWrapMode() && this.adjustWrapLimit()) {
            this.$loop.schedule(this.CHANGE_FULL);
          } else if (this.$size.$dirty) {
            this.$loop.schedule(this.CHANGE_FULL);
          } else {
            this.$computeLayerConfig();
            this.$loop.schedule(this.CHANGE_MARKER);
          }
        };
        this.adjustWrapLimit = function() {
          var availableWidth = this.$size.scrollerWidth - this.$padding * 2;
          var limit = Math.floor(availableWidth / this.characterWidth);
          return this.session.adjustWrapLimit(limit, this.$showPrintMargin && this.$printMarginColumn);
        };
        this.setAnimatedScroll = function(shouldAnimate) {
          this.setOption("animatedScroll", shouldAnimate);
        };
        this.getAnimatedScroll = function() {
          return this.$animatedScroll;
        };
        this.setShowInvisibles = function(showInvisibles) {
          this.setOption("showInvisibles", showInvisibles);
        };
        this.getShowInvisibles = function() {
          return this.getOption("showInvisibles");
        };
        this.getDisplayIndentGuides = function() {
          return this.getOption("displayIndentGuides");
        };
        this.setDisplayIndentGuides = function(display) {
          this.setOption("displayIndentGuides", display);
        };
        this.setShowPrintMargin = function(showPrintMargin) {
          this.setOption("showPrintMargin", showPrintMargin);
        };
        this.getShowPrintMargin = function() {
          return this.getOption("showPrintMargin");
        };
        this.setPrintMarginColumn = function(showPrintMargin) {
          this.setOption("printMarginColumn", showPrintMargin);
        };
        this.getPrintMarginColumn = function() {
          return this.getOption("printMarginColumn");
        };
        this.getShowGutter = function() {
          return this.getOption("showGutter");
        };
        this.setShowGutter = function(show) {
          return this.setOption("showGutter", show);
        };
        this.getFadeFoldWidgets = function() {
          return this.getOption("fadeFoldWidgets");
        };
        this.setFadeFoldWidgets = function(show) {
          this.setOption("fadeFoldWidgets", show);
        };
        this.setHighlightGutterLine = function(shouldHighlight) {
          this.setOption("highlightGutterLine", shouldHighlight);
        };
        this.getHighlightGutterLine = function() {
          return this.getOption("highlightGutterLine");
        };
        this.$updateGutterLineHighlight = function() {
          var pos = this.$cursorLayer.$pixelPos;
          var height = this.layerConfig.lineHeight;
          if (this.session.getUseWrapMode()) {
            var cursor = this.session.selection.getCursor();
            cursor.column = 0;
            pos = this.$cursorLayer.getPixelPosition(cursor, true);
            height *= this.session.getRowLength(cursor.row);
          }
          this.$gutterLineHighlight.style.top = pos.top - this.layerConfig.offset + "px";
          this.$gutterLineHighlight.style.height = height + "px";
        };
        this.$updatePrintMargin = function() {
          if (!this.$showPrintMargin && !this.$printMarginEl)
            return ;
          if (!this.$printMarginEl) {
            var containerEl = dom.createElement("div");
            containerEl.className = "ace_layer ace_print-margin-layer";
            this.$printMarginEl = dom.createElement("div");
            this.$printMarginEl.className = "ace_print-margin";
            containerEl.appendChild(this.$printMarginEl);
            this.content.insertBefore(containerEl, this.content.firstChild);
          }
          var style = this.$printMarginEl.style;
          style.left = ((this.characterWidth * this.$printMarginColumn) + this.$padding) + "px";
          style.visibility = this.$showPrintMargin ? "visible" : "hidden";
          if (this.session && this.session.$wrap == -1)
            this.adjustWrapLimit();
        };
        this.getContainerElement = function() {
          return this.container;
        };
        this.getMouseEventTarget = function() {
          return this.content;
        };
        this.getTextAreaContainer = function() {
          return this.container;
        };
        this.$moveTextAreaToCursor = function() {
          if (!this.$keepTextAreaAtCursor)
            return ;
          var config = this.layerConfig;
          var posTop = this.$cursorLayer.$pixelPos.top;
          var posLeft = this.$cursorLayer.$pixelPos.left;
          posTop -= config.offset;
          var h = this.lineHeight;
          if (posTop < 0 || posTop > config.height - h)
            return ;
          var w = this.characterWidth;
          if (this.$composition) {
            var val = this.textarea.value.replace(/^\x01+/, "");
            w *= (this.session.$getStringScreenWidth(val)[0] + 2);
            h += 2;
          }
          posLeft -= this.scrollLeft;
          if (posLeft > this.$size.scrollerWidth - w)
            posLeft = this.$size.scrollerWidth - w;
          posLeft += this.gutterWidth;
          this.textarea.style.height = h + "px";
          this.textarea.style.width = w + "px";
          this.textarea.style.left = Math.min(posLeft, this.$size.scrollerWidth - w) + "px";
          this.textarea.style.top = Math.min(posTop, this.$size.height - h) + "px";
        };
        this.getFirstVisibleRow = function() {
          return this.layerConfig.firstRow;
        };
        this.getFirstFullyVisibleRow = function() {
          return this.layerConfig.firstRow + (this.layerConfig.offset === 0 ? 0 : 1);
        };
        this.getLastFullyVisibleRow = function() {
          var flint = Math.floor((this.layerConfig.height + this.layerConfig.offset) / this.layerConfig.lineHeight);
          return this.layerConfig.firstRow - 1 + flint;
        };
        this.getLastVisibleRow = function() {
          return this.layerConfig.lastRow;
        };
        this.$padding = null;
        this.setPadding = function(padding) {
          this.$padding = padding;
          this.$textLayer.setPadding(padding);
          this.$cursorLayer.setPadding(padding);
          this.$markerFront.setPadding(padding);
          this.$markerBack.setPadding(padding);
          this.$loop.schedule(this.CHANGE_FULL);
          this.$updatePrintMargin();
        };
        this.setScrollMargin = function(top, bottom, left, right) {
          var sm = this.scrollMargin;
          sm.top = top | 0;
          sm.bottom = bottom | 0;
          sm.right = right | 0;
          sm.left = left | 0;
          sm.v = sm.top + sm.bottom;
          sm.h = sm.left + sm.right;
          if (sm.top && this.scrollTop <= 0 && this.session)
            this.session.setScrollTop(-sm.top);
          this.updateFull();
        };
        this.getHScrollBarAlwaysVisible = function() {
          return this.$hScrollBarAlwaysVisible;
        };
        this.setHScrollBarAlwaysVisible = function(alwaysVisible) {
          this.setOption("hScrollBarAlwaysVisible", alwaysVisible);
        };
        this.getVScrollBarAlwaysVisible = function() {
          return this.$hScrollBarAlwaysVisible;
        };
        this.setVScrollBarAlwaysVisible = function(alwaysVisible) {
          this.setOption("vScrollBarAlwaysVisible", alwaysVisible);
        };
        this.$updateScrollBarV = function() {
          var scrollHeight = this.layerConfig.maxHeight;
          var scrollerHeight = this.$size.scrollerHeight;
          if (!this.$maxLines && this.$scrollPastEnd) {
            scrollHeight -= (scrollerHeight - this.lineHeight) * this.$scrollPastEnd;
            if (this.scrollTop > scrollHeight - scrollerHeight) {
              scrollHeight = this.scrollTop + scrollerHeight;
              this.scrollBarV.scrollTop = null;
            }
          }
          this.scrollBarV.setScrollHeight(scrollHeight + this.scrollMargin.v);
          this.scrollBarV.setScrollTop(this.scrollTop + this.scrollMargin.top);
        };
        this.$updateScrollBarH = function() {
          this.scrollBarH.setScrollWidth(this.layerConfig.width + 2 * this.$padding + this.scrollMargin.h);
          this.scrollBarH.setScrollLeft(this.scrollLeft + this.scrollMargin.left);
        };
        this.$frozen = false;
        this.freeze = function() {
          this.$frozen = true;
        };
        this.unfreeze = function() {
          this.$frozen = false;
        };
        this.$renderChanges = function(changes, force) {
          if (this.$changes) {
            changes |= this.$changes;
            this.$changes = 0;
          }
          if ((!this.session || !this.container.offsetWidth || this.$frozen) || (!changes && !force)) {
            this.$changes |= changes;
            return ;
          }
          if (this.$size.$dirty) {
            this.$changes |= changes;
            return this.onResize(true);
          }
          if (!this.lineHeight) {
            this.$textLayer.checkForSizeChanges();
          }
          this._signal("beforeRender");
          var config = this.layerConfig;
          if (changes & this.CHANGE_FULL || changes & this.CHANGE_SIZE || changes & this.CHANGE_TEXT || changes & this.CHANGE_LINES || changes & this.CHANGE_SCROLL || changes & this.CHANGE_H_SCROLL) {
            changes |= this.$computeLayerConfig();
            if (config.firstRow != this.layerConfig.firstRow && config.firstRowScreen == this.layerConfig.firstRowScreen) {
              var st = this.scrollTop + (config.firstRow - this.layerConfig.firstRow) * this.lineHeight;
              if (st > 0) {
                this.scrollTop = st;
                changes = changes | this.CHANGE_SCROLL;
                changes |= this.$computeLayerConfig();
              }
            }
            config = this.layerConfig;
            this.$updateScrollBarV();
            if (changes & this.CHANGE_H_SCROLL)
              this.$updateScrollBarH();
            this.$gutterLayer.element.style.marginTop = (-config.offset) + "px";
            this.content.style.marginTop = (-config.offset) + "px";
            this.content.style.width = config.width + 2 * this.$padding + "px";
            this.content.style.height = config.minHeight + "px";
          }
          if (changes & this.CHANGE_H_SCROLL) {
            this.content.style.marginLeft = -this.scrollLeft + "px";
            this.scroller.className = this.scrollLeft <= 0 ? "ace_scroller" : "ace_scroller ace_scroll-left";
          }
          if (changes & this.CHANGE_FULL) {
            this.$textLayer.update(config);
            if (this.$showGutter)
              this.$gutterLayer.update(config);
            this.$markerBack.update(config);
            this.$markerFront.update(config);
            this.$cursorLayer.update(config);
            this.$moveTextAreaToCursor();
            this.$highlightGutterLine && this.$updateGutterLineHighlight();
            this._signal("afterRender");
            return ;
          }
          if (changes & this.CHANGE_SCROLL) {
            if (changes & this.CHANGE_TEXT || changes & this.CHANGE_LINES)
              this.$textLayer.update(config);
            else
              this.$textLayer.scrollLines(config);
            if (this.$showGutter)
              this.$gutterLayer.update(config);
            this.$markerBack.update(config);
            this.$markerFront.update(config);
            this.$cursorLayer.update(config);
            this.$highlightGutterLine && this.$updateGutterLineHighlight();
            this.$moveTextAreaToCursor();
            this._signal("afterRender");
            return ;
          }
          if (changes & this.CHANGE_TEXT) {
            this.$textLayer.update(config);
            if (this.$showGutter)
              this.$gutterLayer.update(config);
          } else if (changes & this.CHANGE_LINES) {
            if (this.$updateLines() || (changes & this.CHANGE_GUTTER) && this.$showGutter)
              this.$gutterLayer.update(config);
          } else if (changes & this.CHANGE_TEXT || changes & this.CHANGE_GUTTER) {
            if (this.$showGutter)
              this.$gutterLayer.update(config);
          }
          if (changes & this.CHANGE_CURSOR) {
            this.$cursorLayer.update(config);
            this.$moveTextAreaToCursor();
            this.$highlightGutterLine && this.$updateGutterLineHighlight();
          }
          if (changes & (this.CHANGE_MARKER | this.CHANGE_MARKER_FRONT)) {
            this.$markerFront.update(config);
          }
          if (changes & (this.CHANGE_MARKER | this.CHANGE_MARKER_BACK)) {
            this.$markerBack.update(config);
          }
          this._signal("afterRender");
        };
        this.$autosize = function() {
          var height = this.session.getScreenLength() * this.lineHeight;
          var maxHeight = this.$maxLines * this.lineHeight;
          var desiredHeight = Math.max((this.$minLines || 1) * this.lineHeight, Math.min(maxHeight, height)) + this.scrollMargin.v + (this.$extraHeight || 0);
          var vScroll = height > maxHeight;
          if (desiredHeight != this.desiredHeight || this.$size.height != this.desiredHeight || vScroll != this.$vScroll) {
            if (vScroll != this.$vScroll) {
              this.$vScroll = vScroll;
              this.scrollBarV.setVisible(vScroll);
            }
            var w = this.container.clientWidth;
            this.container.style.height = desiredHeight + "px";
            this.$updateCachedSize(true, this.$gutterWidth, w, desiredHeight);
            this.desiredHeight = desiredHeight;
            this._signal("autosize");
          }
        };
        this.$computeLayerConfig = function() {
          if (this.$maxLines && this.lineHeight > 1)
            this.$autosize();
          var session = this.session;
          var size = this.$size;
          var hideScrollbars = size.height <= 2 * this.lineHeight;
          var screenLines = this.session.getScreenLength();
          var maxHeight = screenLines * this.lineHeight;
          var offset = this.scrollTop % this.lineHeight;
          var minHeight = size.scrollerHeight + this.lineHeight;
          var longestLine = this.$getLongestLine();
          var horizScroll = !hideScrollbars && (this.$hScrollBarAlwaysVisible || size.scrollerWidth - longestLine - 2 * this.$padding < 0);
          var hScrollChanged = this.$horizScroll !== horizScroll;
          if (hScrollChanged) {
            this.$horizScroll = horizScroll;
            this.scrollBarH.setVisible(horizScroll);
          }
          var scrollPastEnd = !this.$maxLines && this.$scrollPastEnd ? (size.scrollerHeight - this.lineHeight) * this.$scrollPastEnd : 0;
          maxHeight += scrollPastEnd;
          this.session.setScrollTop(Math.max(-this.scrollMargin.top, Math.min(this.scrollTop, maxHeight - size.scrollerHeight + this.scrollMargin.bottom)));
          this.session.setScrollLeft(Math.max(-this.scrollMargin.left, Math.min(this.scrollLeft, longestLine + 2 * this.$padding - size.scrollerWidth + this.scrollMargin.right)));
          var vScroll = !hideScrollbars && (this.$vScrollBarAlwaysVisible || size.scrollerHeight - maxHeight + scrollPastEnd < 0 || this.scrollTop);
          var vScrollChanged = this.$vScroll !== vScroll;
          if (vScrollChanged) {
            this.$vScroll = vScroll;
            this.scrollBarV.setVisible(vScroll);
          }
          var lineCount = Math.ceil(minHeight / this.lineHeight) - 1;
          var firstRow = Math.max(0, Math.round((this.scrollTop - offset) / this.lineHeight));
          var lastRow = firstRow + lineCount;
          var firstRowScreen,
              firstRowHeight;
          var lineHeight = this.lineHeight;
          firstRow = session.screenToDocumentRow(firstRow, 0);
          var foldLine = session.getFoldLine(firstRow);
          if (foldLine) {
            firstRow = foldLine.start.row;
          }
          firstRowScreen = session.documentToScreenRow(firstRow, 0);
          firstRowHeight = session.getRowLength(firstRow) * lineHeight;
          lastRow = Math.min(session.screenToDocumentRow(lastRow, 0), session.getLength() - 1);
          minHeight = size.scrollerHeight + session.getRowLength(lastRow) * lineHeight + firstRowHeight;
          offset = this.scrollTop - firstRowScreen * lineHeight;
          var changes = 0;
          if (this.layerConfig.width != longestLine)
            changes = this.CHANGE_H_SCROLL;
          if (hScrollChanged || vScrollChanged) {
            changes = this.$updateCachedSize(true, this.gutterWidth, size.width, size.height);
            this._signal("scrollbarVisibilityChanged");
            if (vScrollChanged)
              longestLine = this.$getLongestLine();
          }
          this.layerConfig = {
            width: longestLine,
            padding: this.$padding,
            firstRow: firstRow,
            firstRowScreen: firstRowScreen,
            lastRow: lastRow,
            lineHeight: lineHeight,
            characterWidth: this.characterWidth,
            minHeight: minHeight,
            maxHeight: maxHeight,
            offset: offset,
            gutterOffset: Math.max(0, Math.ceil((offset + size.height - size.scrollerHeight) / lineHeight)),
            height: this.$size.scrollerHeight
          };
          return changes;
        };
        this.$updateLines = function() {
          var firstRow = this.$changedLines.firstRow;
          var lastRow = this.$changedLines.lastRow;
          this.$changedLines = null;
          var layerConfig = this.layerConfig;
          if (firstRow > layerConfig.lastRow + 1) {
            return ;
          }
          if (lastRow < layerConfig.firstRow) {
            return ;
          }
          if (lastRow === Infinity) {
            if (this.$showGutter)
              this.$gutterLayer.update(layerConfig);
            this.$textLayer.update(layerConfig);
            return ;
          }
          this.$textLayer.updateLines(layerConfig, firstRow, lastRow);
          return true;
        };
        this.$getLongestLine = function() {
          var charCount = this.session.getScreenWidth();
          if (this.showInvisibles && !this.session.$useWrapMode)
            charCount += 1;
          return Math.max(this.$size.scrollerWidth - 2 * this.$padding, Math.round(charCount * this.characterWidth));
        };
        this.updateFrontMarkers = function() {
          this.$markerFront.setMarkers(this.session.getMarkers(true));
          this.$loop.schedule(this.CHANGE_MARKER_FRONT);
        };
        this.updateBackMarkers = function() {
          this.$markerBack.setMarkers(this.session.getMarkers());
          this.$loop.schedule(this.CHANGE_MARKER_BACK);
        };
        this.addGutterDecoration = function(row, className) {
          this.$gutterLayer.addGutterDecoration(row, className);
        };
        this.removeGutterDecoration = function(row, className) {
          this.$gutterLayer.removeGutterDecoration(row, className);
        };
        this.updateBreakpoints = function(rows) {
          this.$loop.schedule(this.CHANGE_GUTTER);
        };
        this.setAnnotations = function(annotations) {
          this.$gutterLayer.setAnnotations(annotations);
          this.$loop.schedule(this.CHANGE_GUTTER);
        };
        this.updateCursor = function() {
          this.$loop.schedule(this.CHANGE_CURSOR);
        };
        this.hideCursor = function() {
          this.$cursorLayer.hideCursor();
        };
        this.showCursor = function() {
          this.$cursorLayer.showCursor();
        };
        this.scrollSelectionIntoView = function(anchor, lead, offset) {
          this.scrollCursorIntoView(anchor, offset);
          this.scrollCursorIntoView(lead, offset);
        };
        this.scrollCursorIntoView = function(cursor, offset, $viewMargin) {
          if (this.$size.scrollerHeight === 0)
            return ;
          var pos = this.$cursorLayer.getPixelPosition(cursor);
          var left = pos.left;
          var top = pos.top;
          var topMargin = $viewMargin && $viewMargin.top || 0;
          var bottomMargin = $viewMargin && $viewMargin.bottom || 0;
          var scrollTop = this.$scrollAnimation ? this.session.getScrollTop() : this.scrollTop;
          if (scrollTop + topMargin > top) {
            if (offset)
              top -= offset * this.$size.scrollerHeight;
            if (top === 0)
              top = -this.scrollMargin.top;
            this.session.setScrollTop(top);
          } else if (scrollTop + this.$size.scrollerHeight - bottomMargin < top + this.lineHeight) {
            if (offset)
              top += offset * this.$size.scrollerHeight;
            this.session.setScrollTop(top + this.lineHeight - this.$size.scrollerHeight);
          }
          var scrollLeft = this.scrollLeft;
          if (scrollLeft > left) {
            if (left < this.$padding + 2 * this.layerConfig.characterWidth)
              left = -this.scrollMargin.left;
            this.session.setScrollLeft(left);
          } else if (scrollLeft + this.$size.scrollerWidth < left + this.characterWidth) {
            this.session.setScrollLeft(Math.round(left + this.characterWidth - this.$size.scrollerWidth));
          } else if (scrollLeft <= this.$padding && left - scrollLeft < this.characterWidth) {
            this.session.setScrollLeft(0);
          }
        };
        this.getScrollTop = function() {
          return this.session.getScrollTop();
        };
        this.getScrollLeft = function() {
          return this.session.getScrollLeft();
        };
        this.getScrollTopRow = function() {
          return this.scrollTop / this.lineHeight;
        };
        this.getScrollBottomRow = function() {
          return Math.max(0, Math.floor((this.scrollTop + this.$size.scrollerHeight) / this.lineHeight) - 1);
        };
        this.scrollToRow = function(row) {
          this.session.setScrollTop(row * this.lineHeight);
        };
        this.alignCursor = function(cursor, alignment) {
          if (typeof cursor == "number")
            cursor = {
              row: cursor,
              column: 0
            };
          var pos = this.$cursorLayer.getPixelPosition(cursor);
          var h = this.$size.scrollerHeight - this.lineHeight;
          var offset = pos.top - h * (alignment || 0);
          this.session.setScrollTop(offset);
          return offset;
        };
        this.STEPS = 8;
        this.$calcSteps = function(fromValue, toValue) {
          var i = 0;
          var l = this.STEPS;
          var steps = [];
          var func = function(t, x_min, dx) {
            return dx * (Math.pow(t - 1, 3) + 1) + x_min;
          };
          for (i = 0; i < l; ++i)
            steps.push(func(i / this.STEPS, fromValue, toValue - fromValue));
          return steps;
        };
        this.scrollToLine = function(line, center, animate, callback) {
          var pos = this.$cursorLayer.getPixelPosition({
            row: line,
            column: 0
          });
          var offset = pos.top;
          if (center)
            offset -= this.$size.scrollerHeight / 2;
          var initialScroll = this.scrollTop;
          this.session.setScrollTop(offset);
          if (animate !== false)
            this.animateScrolling(initialScroll, callback);
        };
        this.animateScrolling = function(fromValue, callback) {
          var toValue = this.scrollTop;
          if (!this.$animatedScroll)
            return ;
          var _self = this;
          if (fromValue == toValue)
            return ;
          if (this.$scrollAnimation) {
            var oldSteps = this.$scrollAnimation.steps;
            if (oldSteps.length) {
              fromValue = oldSteps[0];
              if (fromValue == toValue)
                return ;
            }
          }
          var steps = _self.$calcSteps(fromValue, toValue);
          this.$scrollAnimation = {
            from: fromValue,
            to: toValue,
            steps: steps
          };
          clearInterval(this.$timer);
          _self.session.setScrollTop(steps.shift());
          _self.session.$scrollTop = toValue;
          this.$timer = setInterval(function() {
            if (steps.length) {
              _self.session.setScrollTop(steps.shift());
              _self.session.$scrollTop = toValue;
            } else if (toValue != null) {
              _self.session.$scrollTop = -1;
              _self.session.setScrollTop(toValue);
              toValue = null;
            } else {
              _self.$timer = clearInterval(_self.$timer);
              _self.$scrollAnimation = null;
              callback && callback();
            }
          }, 10);
        };
        this.scrollToY = function(scrollTop) {
          if (this.scrollTop !== scrollTop) {
            this.$loop.schedule(this.CHANGE_SCROLL);
            this.scrollTop = scrollTop;
          }
        };
        this.scrollToX = function(scrollLeft) {
          if (this.scrollLeft !== scrollLeft)
            this.scrollLeft = scrollLeft;
          this.$loop.schedule(this.CHANGE_H_SCROLL);
        };
        this.scrollTo = function(x, y) {
          this.session.setScrollTop(y);
          this.session.setScrollLeft(y);
        };
        this.scrollBy = function(deltaX, deltaY) {
          deltaY && this.session.setScrollTop(this.session.getScrollTop() + deltaY);
          deltaX && this.session.setScrollLeft(this.session.getScrollLeft() + deltaX);
        };
        this.isScrollableBy = function(deltaX, deltaY) {
          if (deltaY < 0 && this.session.getScrollTop() >= 1 - this.scrollMargin.top)
            return true;
          if (deltaY > 0 && this.session.getScrollTop() + this.$size.scrollerHeight - this.layerConfig.maxHeight < -1 + this.scrollMargin.bottom)
            return true;
          if (deltaX < 0 && this.session.getScrollLeft() >= 1 - this.scrollMargin.left)
            return true;
          if (deltaX > 0 && this.session.getScrollLeft() + this.$size.scrollerWidth - this.layerConfig.width < -1 + this.scrollMargin.right)
            return true;
        };
        this.pixelToScreenCoordinates = function(x, y) {
          var canvasPos = this.scroller.getBoundingClientRect();
          var offset = (x + this.scrollLeft - canvasPos.left - this.$padding) / this.characterWidth;
          var row = Math.floor((y + this.scrollTop - canvasPos.top) / this.lineHeight);
          var col = Math.round(offset);
          return {
            row: row,
            column: col,
            side: offset - col > 0 ? 1 : -1
          };
        };
        this.screenToTextCoordinates = function(x, y) {
          var canvasPos = this.scroller.getBoundingClientRect();
          var col = Math.round((x + this.scrollLeft - canvasPos.left - this.$padding) / this.characterWidth);
          var row = (y + this.scrollTop - canvasPos.top) / this.lineHeight;
          return this.session.screenToDocumentPosition(row, Math.max(col, 0));
        };
        this.textToScreenCoordinates = function(row, column) {
          var canvasPos = this.scroller.getBoundingClientRect();
          var pos = this.session.documentToScreenPosition(row, column);
          var x = this.$padding + Math.round(pos.column * this.characterWidth);
          var y = pos.row * this.lineHeight;
          return {
            pageX: canvasPos.left + x - this.scrollLeft,
            pageY: canvasPos.top + y - this.scrollTop
          };
        };
        this.visualizeFocus = function() {
          dom.addCssClass(this.container, "ace_focus");
        };
        this.visualizeBlur = function() {
          dom.removeCssClass(this.container, "ace_focus");
        };
        this.showComposition = function(position) {
          if (!this.$composition)
            this.$composition = {
              keepTextAreaAtCursor: this.$keepTextAreaAtCursor,
              cssText: this.textarea.style.cssText
            };
          this.$keepTextAreaAtCursor = true;
          dom.addCssClass(this.textarea, "ace_composition");
          this.textarea.style.cssText = "";
          this.$moveTextAreaToCursor();
        };
        this.setCompositionText = function(text) {
          this.$moveTextAreaToCursor();
        };
        this.hideComposition = function() {
          if (!this.$composition)
            return ;
          dom.removeCssClass(this.textarea, "ace_composition");
          this.$keepTextAreaAtCursor = this.$composition.keepTextAreaAtCursor;
          this.textarea.style.cssText = this.$composition.cssText;
          this.$composition = null;
        };
        this.setTheme = function(theme, cb) {
          var _self = this;
          this.$themeId = theme;
          _self._dispatchEvent('themeChange', {theme: theme});
          if (!theme || typeof theme == "string") {
            var moduleName = theme || this.$options.theme.initialValue;
            config.loadModule(["theme", moduleName], afterLoad);
          } else {
            afterLoad(theme);
          }
          function afterLoad(module) {
            if (_self.$themeId != theme)
              return cb && cb();
            if (!module.cssClass)
              return ;
            dom.importCssString(module.cssText, module.cssClass, _self.container.ownerDocument);
            if (_self.theme)
              dom.removeCssClass(_self.container, _self.theme.cssClass);
            var padding = "padding" in module ? module.padding : "padding" in (_self.theme || {}) ? 4 : _self.$padding;
            if (_self.$padding && padding != _self.$padding)
              _self.setPadding(padding);
            _self.$theme = module.cssClass;
            _self.theme = module;
            dom.addCssClass(_self.container, module.cssClass);
            dom.setCssClass(_self.container, "ace_dark", module.isDark);
            if (_self.$size) {
              _self.$size.width = 0;
              _self.$updateSizeAsync();
            }
            _self._dispatchEvent('themeLoaded', {theme: module});
            cb && cb();
          }
        };
        this.getTheme = function() {
          return this.$themeId;
        };
        this.setStyle = function(style, include) {
          dom.setCssClass(this.container, style, include !== false);
        };
        this.unsetStyle = function(style) {
          dom.removeCssClass(this.container, style);
        };
        this.setCursorStyle = function(style) {
          if (this.scroller.style.cursor != style)
            this.scroller.style.cursor = style;
        };
        this.setMouseCursor = function(cursorStyle) {
          this.scroller.style.cursor = cursorStyle;
        };
        this.destroy = function() {
          this.$textLayer.destroy();
          this.$cursorLayer.destroy();
        };
      }).call(VirtualRenderer.prototype);
      config.defineOptions(VirtualRenderer.prototype, "renderer", {
        animatedScroll: {initialValue: false},
        showInvisibles: {
          set: function(value) {
            if (this.$textLayer.setShowInvisibles(value))
              this.$loop.schedule(this.CHANGE_TEXT);
          },
          initialValue: false
        },
        showPrintMargin: {
          set: function() {
            this.$updatePrintMargin();
          },
          initialValue: true
        },
        printMarginColumn: {
          set: function() {
            this.$updatePrintMargin();
          },
          initialValue: 80
        },
        printMargin: {
          set: function(val) {
            if (typeof val == "number")
              this.$printMarginColumn = val;
            this.$showPrintMargin = !!val;
            this.$updatePrintMargin();
          },
          get: function() {
            return this.$showPrintMargin && this.$printMarginColumn;
          }
        },
        showGutter: {
          set: function(show) {
            this.$gutter.style.display = show ? "block" : "none";
            this.$loop.schedule(this.CHANGE_FULL);
            this.onGutterResize();
          },
          initialValue: true
        },
        fadeFoldWidgets: {
          set: function(show) {
            dom.setCssClass(this.$gutter, "ace_fade-fold-widgets", show);
          },
          initialValue: false
        },
        showFoldWidgets: {
          set: function(show) {
            this.$gutterLayer.setShowFoldWidgets(show);
          },
          initialValue: true
        },
        showLineNumbers: {
          set: function(show) {
            this.$gutterLayer.setShowLineNumbers(show);
            this.$loop.schedule(this.CHANGE_GUTTER);
          },
          initialValue: true
        },
        displayIndentGuides: {
          set: function(show) {
            if (this.$textLayer.setDisplayIndentGuides(show))
              this.$loop.schedule(this.CHANGE_TEXT);
          },
          initialValue: true
        },
        highlightGutterLine: {
          set: function(shouldHighlight) {
            if (!this.$gutterLineHighlight) {
              this.$gutterLineHighlight = dom.createElement("div");
              this.$gutterLineHighlight.className = "ace_gutter-active-line";
              this.$gutter.appendChild(this.$gutterLineHighlight);
              return ;
            }
            this.$gutterLineHighlight.style.display = shouldHighlight ? "" : "none";
            if (this.$cursorLayer.$pixelPos)
              this.$updateGutterLineHighlight();
          },
          initialValue: false,
          value: true
        },
        hScrollBarAlwaysVisible: {
          set: function(val) {
            if (!this.$hScrollBarAlwaysVisible || !this.$horizScroll)
              this.$loop.schedule(this.CHANGE_SCROLL);
          },
          initialValue: false
        },
        vScrollBarAlwaysVisible: {
          set: function(val) {
            if (!this.$vScrollBarAlwaysVisible || !this.$vScroll)
              this.$loop.schedule(this.CHANGE_SCROLL);
          },
          initialValue: false
        },
        fontSize: {
          set: function(size) {
            if (typeof size == "number")
              size = size + "px";
            this.container.style.fontSize = size;
            this.updateFontSize();
          },
          initialValue: 12
        },
        fontFamily: {set: function(name) {
            this.container.style.fontFamily = name;
            this.updateFontSize();
          }},
        maxLines: {set: function(val) {
            this.updateFull();
          }},
        minLines: {set: function(val) {
            this.updateFull();
          }},
        scrollPastEnd: {
          set: function(val) {
            val = +val || 0;
            if (this.$scrollPastEnd == val)
              return ;
            this.$scrollPastEnd = val;
            this.$loop.schedule(this.CHANGE_SCROLL);
          },
          initialValue: 0,
          handlesSet: true
        },
        fixedWidthGutter: {set: function(val) {
            this.$gutterLayer.$fixedWidth = !!val;
            this.$loop.schedule(this.CHANGE_GUTTER);
          }},
        theme: {
          set: function(val) {
            this.setTheme(val);
          },
          get: function() {
            return this.$themeId || this.theme;
          },
          initialValue: "./theme/textmate",
          handlesSet: true
        }
      });
      exports.VirtualRenderer = VirtualRenderer;
    });
    ace.define("ace/worker/worker_client", ["require", "exports", "module", "ace/lib/oop", "ace/lib/net", "ace/lib/event_emitter", "ace/config"], function(acequire, exports, module) {
      "use strict";
      var oop = acequire("../lib/oop");
      var net = acequire("../lib/net");
      var EventEmitter = acequire("../lib/event_emitter").EventEmitter;
      var config = acequire("../config");
      var WorkerClient = function(topLevelNamespaces, mod, classname, workerUrl) {
        this.$sendDeltaQueue = this.$sendDeltaQueue.bind(this);
        this.changeListener = this.changeListener.bind(this);
        this.onMessage = this.onMessage.bind(this);
        if (acequire.nameToUrl && !acequire.toUrl)
          acequire.toUrl = acequire.nameToUrl;
        if (config.get("packaged") || !acequire.toUrl) {
          workerUrl = workerUrl || config.moduleUrl(mod.id, "worker");
        } else {
          var normalizePath = this.$normalizePath;
          workerUrl = workerUrl || normalizePath(acequire.toUrl("ace/worker/worker.js", null, "_"));
          var tlns = {};
          topLevelNamespaces.forEach(function(ns) {
            tlns[ns] = normalizePath(acequire.toUrl(ns, null, "_").replace(/(\.js)?(\?.*)?$/, ""));
          });
        }
        try {
          var workerSrc = mod.src;
          var Blob = require("npm:w3c-blob@0.0.1");
          var blob = new Blob([workerSrc], {type: 'application/javascript'});
          var blobUrl = (window.URL || window.webkitURL).createObjectURL(blob);
          this.$worker = new Worker(blobUrl);
        } catch (e) {
          if (e instanceof window.DOMException) {
            var blob = this.$workerBlob(workerUrl);
            var URL = window.URL || window.webkitURL;
            var blobURL = URL.createObjectURL(blob);
            this.$worker = new Worker(blobURL);
            URL.revokeObjectURL(blobURL);
          } else {
            throw e;
          }
        }
        this.$worker.postMessage({
          init: true,
          tlns: tlns,
          module: mod.id,
          classname: classname
        });
        this.callbackId = 1;
        this.callbacks = {};
        this.$worker.onmessage = this.onMessage;
      };
      (function() {
        oop.implement(this, EventEmitter);
        this.onMessage = function(e) {
          var msg = e.data;
          switch (msg.type) {
            case "event":
              this._signal(msg.name, {data: msg.data});
              break;
            case "call":
              var callback = this.callbacks[msg.id];
              if (callback) {
                callback(msg.data);
                delete this.callbacks[msg.id];
              }
              break;
            case "error":
              this.reportError(msg.data);
              break;
            case "log":
              window.console && console.log && console.log.apply(console, msg.data);
              break;
          }
        };
        this.reportError = function(err) {
          window.console && console.error && console.error(err);
        };
        this.$normalizePath = function(path) {
          return net.qualifyURL(path);
        };
        this.terminate = function() {
          this._signal("terminate", {});
          this.deltaQueue = null;
          this.$worker.terminate();
          this.$worker = null;
          if (this.$doc)
            this.$doc.off("change", this.changeListener);
          this.$doc = null;
        };
        this.send = function(cmd, args) {
          this.$worker.postMessage({
            command: cmd,
            args: args
          });
        };
        this.call = function(cmd, args, callback) {
          if (callback) {
            var id = this.callbackId++;
            this.callbacks[id] = callback;
            args.push(id);
          }
          this.send(cmd, args);
        };
        this.emit = function(event, data) {
          try {
            this.$worker.postMessage({
              event: event,
              data: {data: data.data}
            });
          } catch (ex) {
            console.error(ex.stack);
          }
        };
        this.attachToDocument = function(doc) {
          if (this.$doc)
            this.terminate();
          this.$doc = doc;
          this.call("setValue", [doc.getValue()]);
          doc.on("change", this.changeListener);
        };
        this.changeListener = function(e) {
          if (!this.deltaQueue) {
            this.deltaQueue = [e.data];
            setTimeout(this.$sendDeltaQueue, 0);
          } else
            this.deltaQueue.push(e.data);
        };
        this.$sendDeltaQueue = function() {
          var q = this.deltaQueue;
          if (!q)
            return ;
          this.deltaQueue = null;
          if (q.length > 20 && q.length > this.$doc.getLength() >> 1) {
            this.call("setValue", [this.$doc.getValue()]);
          } else
            this.emit("change", {data: q});
        };
        this.$workerBlob = function(workerUrl) {
          var script = "importScripts('" + net.qualifyURL(workerUrl) + "');";
          try {
            return new Blob([script], {"type": "application/javascript"});
          } catch (e) {
            var BlobBuilder = window.BlobBuilder || window.WebKitBlobBuilder || window.MozBlobBuilder;
            var blobBuilder = new BlobBuilder();
            blobBuilder.append(script);
            return blobBuilder.getBlob("application/javascript");
          }
        };
      }).call(WorkerClient.prototype);
      var UIWorkerClient = function(topLevelNamespaces, mod, classname) {
        this.$sendDeltaQueue = this.$sendDeltaQueue.bind(this);
        this.changeListener = this.changeListener.bind(this);
        this.callbackId = 1;
        this.callbacks = {};
        this.messageBuffer = [];
        var main = null;
        var emitSync = false;
        var sender = Object.create(EventEmitter);
        var _self = this;
        this.$worker = {};
        this.$worker.terminate = function() {};
        this.$worker.postMessage = function(e) {
          _self.messageBuffer.push(e);
          if (main) {
            if (emitSync)
              setTimeout(processNext);
            else
              processNext();
          }
        };
        this.setEmitSync = function(val) {
          emitSync = val;
        };
        var processNext = function() {
          var msg = _self.messageBuffer.shift();
          if (msg.command)
            main[msg.command].apply(main, msg.args);
          else if (msg.event)
            sender._signal(msg.event, msg.data);
        };
        sender.postMessage = function(msg) {
          _self.onMessage({data: msg});
        };
        sender.callback = function(data, callbackId) {
          this.postMessage({
            type: "call",
            id: callbackId,
            data: data
          });
        };
        sender.emit = function(name, data) {
          this.postMessage({
            type: "event",
            name: name,
            data: data
          });
        };
        config.loadModule(["worker", mod], function(Main) {
          main = new Main[classname](sender);
          while (_self.messageBuffer.length)
            processNext();
        });
      };
      UIWorkerClient.prototype = WorkerClient.prototype;
      exports.UIWorkerClient = UIWorkerClient;
      exports.WorkerClient = WorkerClient;
    });
    ace.define("ace/placeholder", ["require", "exports", "module", "ace/range", "ace/lib/event_emitter", "ace/lib/oop"], function(acequire, exports, module) {
      "use strict";
      var Range = acequire("./range").Range;
      var EventEmitter = acequire("./lib/event_emitter").EventEmitter;
      var oop = acequire("./lib/oop");
      var PlaceHolder = function(session, length, pos, others, mainClass, othersClass) {
        var _self = this;
        this.length = length;
        this.session = session;
        this.doc = session.getDocument();
        this.mainClass = mainClass;
        this.othersClass = othersClass;
        this.$onUpdate = this.onUpdate.bind(this);
        this.doc.on("change", this.$onUpdate);
        this.$others = others;
        this.$onCursorChange = function() {
          setTimeout(function() {
            _self.onCursorChange();
          });
        };
        this.$pos = pos;
        var undoStack = session.getUndoManager().$undoStack || session.getUndoManager().$undostack || {length: -1};
        this.$undoStackDepth = undoStack.length;
        this.setup();
        session.selection.on("changeCursor", this.$onCursorChange);
      };
      (function() {
        oop.implement(this, EventEmitter);
        this.setup = function() {
          var _self = this;
          var doc = this.doc;
          var session = this.session;
          var pos = this.$pos;
          this.selectionBefore = session.selection.toJSON();
          if (session.selection.inMultiSelectMode)
            session.selection.toSingleRange();
          this.pos = doc.createAnchor(pos.row, pos.column);
          this.markerId = session.addMarker(new Range(pos.row, pos.column, pos.row, pos.column + this.length), this.mainClass, null, false);
          this.pos.on("change", function(event) {
            session.removeMarker(_self.markerId);
            _self.markerId = session.addMarker(new Range(event.value.row, event.value.column, event.value.row, event.value.column + _self.length), _self.mainClass, null, false);
          });
          this.others = [];
          this.$others.forEach(function(other) {
            var anchor = doc.createAnchor(other.row, other.column);
            _self.others.push(anchor);
          });
          session.setUndoSelect(false);
        };
        this.showOtherMarkers = function() {
          if (this.othersActive)
            return ;
          var session = this.session;
          var _self = this;
          this.othersActive = true;
          this.others.forEach(function(anchor) {
            anchor.markerId = session.addMarker(new Range(anchor.row, anchor.column, anchor.row, anchor.column + _self.length), _self.othersClass, null, false);
            anchor.on("change", function(event) {
              session.removeMarker(anchor.markerId);
              anchor.markerId = session.addMarker(new Range(event.value.row, event.value.column, event.value.row, event.value.column + _self.length), _self.othersClass, null, false);
            });
          });
        };
        this.hideOtherMarkers = function() {
          if (!this.othersActive)
            return ;
          this.othersActive = false;
          for (var i = 0; i < this.others.length; i++) {
            this.session.removeMarker(this.others[i].markerId);
          }
        };
        this.onUpdate = function(event) {
          var delta = event.data;
          var range = delta.range;
          if (range.start.row !== range.end.row)
            return ;
          if (range.start.row !== this.pos.row)
            return ;
          if (this.$updating)
            return ;
          this.$updating = true;
          var lengthDiff = delta.action === "insertText" ? range.end.column - range.start.column : range.start.column - range.end.column;
          if (range.start.column >= this.pos.column && range.start.column <= this.pos.column + this.length + 1) {
            var distanceFromStart = range.start.column - this.pos.column;
            this.length += lengthDiff;
            if (!this.session.$fromUndo) {
              if (delta.action === "insertText") {
                for (var i = this.others.length - 1; i >= 0; i--) {
                  var otherPos = this.others[i];
                  var newPos = {
                    row: otherPos.row,
                    column: otherPos.column + distanceFromStart
                  };
                  if (otherPos.row === range.start.row && range.start.column < otherPos.column)
                    newPos.column += lengthDiff;
                  this.doc.insert(newPos, delta.text);
                }
              } else if (delta.action === "removeText") {
                for (var i = this.others.length - 1; i >= 0; i--) {
                  var otherPos = this.others[i];
                  var newPos = {
                    row: otherPos.row,
                    column: otherPos.column + distanceFromStart
                  };
                  if (otherPos.row === range.start.row && range.start.column < otherPos.column)
                    newPos.column += lengthDiff;
                  this.doc.remove(new Range(newPos.row, newPos.column, newPos.row, newPos.column - lengthDiff));
                }
              }
              if (range.start.column === this.pos.column && delta.action === "insertText") {
                setTimeout(function() {
                  this.pos.setPosition(this.pos.row, this.pos.column - lengthDiff);
                  for (var i = 0; i < this.others.length; i++) {
                    var other = this.others[i];
                    var newPos = {
                      row: other.row,
                      column: other.column - lengthDiff
                    };
                    if (other.row === range.start.row && range.start.column < other.column)
                      newPos.column += lengthDiff;
                    other.setPosition(newPos.row, newPos.column);
                  }
                }.bind(this), 0);
              } else if (range.start.column === this.pos.column && delta.action === "removeText") {
                setTimeout(function() {
                  for (var i = 0; i < this.others.length; i++) {
                    var other = this.others[i];
                    if (other.row === range.start.row && range.start.column < other.column) {
                      other.setPosition(other.row, other.column - lengthDiff);
                    }
                  }
                }.bind(this), 0);
              }
            }
            this.pos._emit("change", {value: this.pos});
            for (var i = 0; i < this.others.length; i++) {
              this.others[i]._emit("change", {value: this.others[i]});
            }
          }
          this.$updating = false;
        };
        this.onCursorChange = function(event) {
          if (this.$updating || !this.session)
            return ;
          var pos = this.session.selection.getCursor();
          if (pos.row === this.pos.row && pos.column >= this.pos.column && pos.column <= this.pos.column + this.length) {
            this.showOtherMarkers();
            this._emit("cursorEnter", event);
          } else {
            this.hideOtherMarkers();
            this._emit("cursorLeave", event);
          }
        };
        this.detach = function() {
          this.session.removeMarker(this.markerId);
          this.hideOtherMarkers();
          this.doc.removeEventListener("change", this.$onUpdate);
          this.session.selection.removeEventListener("changeCursor", this.$onCursorChange);
          this.pos.detach();
          for (var i = 0; i < this.others.length; i++) {
            this.others[i].detach();
          }
          this.session.setUndoSelect(true);
          this.session = null;
        };
        this.cancel = function() {
          if (this.$undoStackDepth === -1)
            throw Error("Canceling placeholders only supported with undo manager attached to session.");
          var undoManager = this.session.getUndoManager();
          var undosRequired = (undoManager.$undoStack || undoManager.$undostack).length - this.$undoStackDepth;
          for (var i = 0; i < undosRequired; i++) {
            undoManager.undo(true);
          }
          if (this.selectionBefore)
            this.session.selection.fromJSON(this.selectionBefore);
        };
      }).call(PlaceHolder.prototype);
      exports.PlaceHolder = PlaceHolder;
    });
    ace.define("ace/mouse/multi_select_handler", ["require", "exports", "module", "ace/lib/event", "ace/lib/useragent"], function(acequire, exports, module) {
      var event = acequire("../lib/event");
      var useragent = acequire("../lib/useragent");
      function isSamePoint(p1, p2) {
        return p1.row == p2.row && p1.column == p2.column;
      }
      function onMouseDown(e) {
        var ev = e.domEvent;
        var alt = ev.altKey;
        var shift = ev.shiftKey;
        var ctrl = ev.ctrlKey;
        var accel = e.getAccelKey();
        var button = e.getButton();
        if (ctrl && useragent.isMac)
          button = ev.button;
        if (e.editor.inMultiSelectMode && button == 2) {
          e.editor.textInput.onContextMenu(e.domEvent);
          return ;
        }
        if (!ctrl && !alt && !accel) {
          if (button === 0 && e.editor.inMultiSelectMode)
            e.editor.exitMultiSelectMode();
          return ;
        }
        if (button !== 0)
          return ;
        var editor = e.editor;
        var selection = editor.selection;
        var isMultiSelect = editor.inMultiSelectMode;
        var pos = e.getDocumentPosition();
        var cursor = selection.getCursor();
        var inSelection = e.inSelection() || (selection.isEmpty() && isSamePoint(pos, cursor));
        var mouseX = e.x,
            mouseY = e.y;
        var onMouseSelection = function(e) {
          mouseX = e.clientX;
          mouseY = e.clientY;
        };
        var session = editor.session;
        var screenAnchor = editor.renderer.pixelToScreenCoordinates(mouseX, mouseY);
        var screenCursor = screenAnchor;
        var selectionMode;
        if (editor.$mouseHandler.$enableJumpToDef) {
          if (ctrl && alt || accel && alt)
            selectionMode = "add";
          else if (alt)
            selectionMode = "block";
        } else {
          if (accel && !alt) {
            selectionMode = "add";
            if (!isMultiSelect && shift)
              return ;
          } else if (alt) {
            selectionMode = "block";
          }
        }
        if (selectionMode && useragent.isMac && ev.ctrlKey) {
          editor.$mouseHandler.cancelContextMenu();
        }
        if (selectionMode == "add") {
          if (!isMultiSelect && inSelection)
            return ;
          if (!isMultiSelect) {
            var range = selection.toOrientedRange();
            editor.addSelectionMarker(range);
          }
          var oldRange = selection.rangeList.rangeAtPoint(pos);
          editor.$blockScrolling++;
          editor.inVirtualSelectionMode = true;
          if (shift) {
            oldRange = null;
            range = selection.ranges[0];
            editor.removeSelectionMarker(range);
          }
          editor.once("mouseup", function() {
            var tmpSel = selection.toOrientedRange();
            if (oldRange && tmpSel.isEmpty() && isSamePoint(oldRange.cursor, tmpSel.cursor))
              selection.substractPoint(tmpSel.cursor);
            else {
              if (shift) {
                selection.substractPoint(range.cursor);
              } else if (range) {
                editor.removeSelectionMarker(range);
                selection.addRange(range);
              }
              selection.addRange(tmpSel);
            }
            editor.$blockScrolling--;
            editor.inVirtualSelectionMode = false;
          });
        } else if (selectionMode == "block") {
          e.stop();
          editor.inVirtualSelectionMode = true;
          var initialRange;
          var rectSel = [];
          var blockSelect = function() {
            var newCursor = editor.renderer.pixelToScreenCoordinates(mouseX, mouseY);
            var cursor = session.screenToDocumentPosition(newCursor.row, newCursor.column);
            if (isSamePoint(screenCursor, newCursor) && isSamePoint(cursor, selection.lead))
              return ;
            screenCursor = newCursor;
            editor.selection.moveToPosition(cursor);
            editor.renderer.scrollCursorIntoView();
            editor.removeSelectionMarkers(rectSel);
            rectSel = selection.rectangularRangeBlock(screenCursor, screenAnchor);
            if (editor.$mouseHandler.$clickSelection && rectSel.length == 1 && rectSel[0].isEmpty())
              rectSel[0] = editor.$mouseHandler.$clickSelection.clone();
            rectSel.forEach(editor.addSelectionMarker, editor);
            editor.updateSelectionMarkers();
          };
          if (isMultiSelect && !accel) {
            selection.toSingleRange();
          } else if (!isMultiSelect && accel) {
            initialRange = selection.toOrientedRange();
            editor.addSelectionMarker(initialRange);
          }
          if (shift)
            screenAnchor = session.documentToScreenPosition(selection.lead);
          else
            selection.moveToPosition(pos);
          screenCursor = {
            row: -1,
            column: -1
          };
          var onMouseSelectionEnd = function(e) {
            clearInterval(timerId);
            editor.removeSelectionMarkers(rectSel);
            if (!rectSel.length)
              rectSel = [selection.toOrientedRange()];
            editor.$blockScrolling++;
            if (initialRange) {
              editor.removeSelectionMarker(initialRange);
              selection.toSingleRange(initialRange);
            }
            for (var i = 0; i < rectSel.length; i++)
              selection.addRange(rectSel[i]);
            editor.inVirtualSelectionMode = false;
            editor.$mouseHandler.$clickSelection = null;
            editor.$blockScrolling--;
          };
          var onSelectionInterval = blockSelect;
          event.capture(editor.container, onMouseSelection, onMouseSelectionEnd);
          var timerId = setInterval(function() {
            onSelectionInterval();
          }, 20);
          return e.preventDefault();
        }
      }
      exports.onMouseDown = onMouseDown;
    });
    ace.define("ace/commands/multi_select_commands", ["require", "exports", "module", "ace/keyboard/hash_handler"], function(acequire, exports, module) {
      exports.defaultCommands = [{
        name: "addCursorAbove",
        exec: function(editor) {
          editor.selectMoreLines(-1);
        },
        bindKey: {
          win: "Ctrl-Alt-Up",
          mac: "Ctrl-Alt-Up"
        },
        readonly: true
      }, {
        name: "addCursorBelow",
        exec: function(editor) {
          editor.selectMoreLines(1);
        },
        bindKey: {
          win: "Ctrl-Alt-Down",
          mac: "Ctrl-Alt-Down"
        },
        readonly: true
      }, {
        name: "addCursorAboveSkipCurrent",
        exec: function(editor) {
          editor.selectMoreLines(-1, true);
        },
        bindKey: {
          win: "Ctrl-Alt-Shift-Up",
          mac: "Ctrl-Alt-Shift-Up"
        },
        readonly: true
      }, {
        name: "addCursorBelowSkipCurrent",
        exec: function(editor) {
          editor.selectMoreLines(1, true);
        },
        bindKey: {
          win: "Ctrl-Alt-Shift-Down",
          mac: "Ctrl-Alt-Shift-Down"
        },
        readonly: true
      }, {
        name: "selectMoreBefore",
        exec: function(editor) {
          editor.selectMore(-1);
        },
        bindKey: {
          win: "Ctrl-Alt-Left",
          mac: "Ctrl-Alt-Left"
        },
        readonly: true
      }, {
        name: "selectMoreAfter",
        exec: function(editor) {
          editor.selectMore(1);
        },
        bindKey: {
          win: "Ctrl-Alt-Right",
          mac: "Ctrl-Alt-Right"
        },
        readonly: true
      }, {
        name: "selectNextBefore",
        exec: function(editor) {
          editor.selectMore(-1, true);
        },
        bindKey: {
          win: "Ctrl-Alt-Shift-Left",
          mac: "Ctrl-Alt-Shift-Left"
        },
        readonly: true
      }, {
        name: "selectNextAfter",
        exec: function(editor) {
          editor.selectMore(1, true);
        },
        bindKey: {
          win: "Ctrl-Alt-Shift-Right",
          mac: "Ctrl-Alt-Shift-Right"
        },
        readonly: true
      }, {
        name: "splitIntoLines",
        exec: function(editor) {
          editor.multiSelect.splitIntoLines();
        },
        bindKey: {
          win: "Ctrl-Alt-L",
          mac: "Ctrl-Alt-L"
        },
        readonly: true
      }, {
        name: "alignCursors",
        exec: function(editor) {
          editor.alignCursors();
        },
        bindKey: {
          win: "Ctrl-Alt-A",
          mac: "Ctrl-Alt-A"
        }
      }, {
        name: "findAll",
        exec: function(editor) {
          editor.findAll();
        },
        bindKey: {
          win: "Ctrl-Alt-K",
          mac: "Ctrl-Alt-G"
        },
        readonly: true
      }];
      exports.multiSelectCommands = [{
        name: "singleSelection",
        bindKey: "esc",
        exec: function(editor) {
          editor.exitMultiSelectMode();
        },
        readonly: true,
        isAvailable: function(editor) {
          return editor && editor.inMultiSelectMode;
        }
      }];
      var HashHandler = acequire("../keyboard/hash_handler").HashHandler;
      exports.keyboardHandler = new HashHandler(exports.multiSelectCommands);
    });
    ace.define("ace/multi_select", ["require", "exports", "module", "ace/range_list", "ace/range", "ace/selection", "ace/mouse/multi_select_handler", "ace/lib/event", "ace/lib/lang", "ace/commands/multi_select_commands", "ace/search", "ace/edit_session", "ace/editor", "ace/config"], function(acequire, exports, module) {
      var RangeList = acequire("./range_list").RangeList;
      var Range = acequire("./range").Range;
      var Selection = acequire("./selection").Selection;
      var onMouseDown = acequire("./mouse/multi_select_handler").onMouseDown;
      var event = acequire("./lib/event");
      var lang = acequire("./lib/lang");
      var commands = acequire("./commands/multi_select_commands");
      exports.commands = commands.defaultCommands.concat(commands.multiSelectCommands);
      var Search = acequire("./search").Search;
      var search = new Search();
      function find(session, needle, dir) {
        search.$options.wrap = true;
        search.$options.needle = needle;
        search.$options.backwards = dir == -1;
        return search.find(session);
      }
      var EditSession = acequire("./edit_session").EditSession;
      (function() {
        this.getSelectionMarkers = function() {
          return this.$selectionMarkers;
        };
      }).call(EditSession.prototype);
      (function() {
        this.ranges = null;
        this.rangeList = null;
        this.addRange = function(range, $blockChangeEvents) {
          if (!range)
            return ;
          if (!this.inMultiSelectMode && this.rangeCount === 0) {
            var oldRange = this.toOrientedRange();
            this.rangeList.add(oldRange);
            this.rangeList.add(range);
            if (this.rangeList.ranges.length != 2) {
              this.rangeList.removeAll();
              return $blockChangeEvents || this.fromOrientedRange(range);
            }
            this.rangeList.removeAll();
            this.rangeList.add(oldRange);
            this.$onAddRange(oldRange);
          }
          if (!range.cursor)
            range.cursor = range.end;
          var removed = this.rangeList.add(range);
          this.$onAddRange(range);
          if (removed.length)
            this.$onRemoveRange(removed);
          if (this.rangeCount > 1 && !this.inMultiSelectMode) {
            this._signal("multiSelect");
            this.inMultiSelectMode = true;
            this.session.$undoSelect = false;
            this.rangeList.attach(this.session);
          }
          return $blockChangeEvents || this.fromOrientedRange(range);
        };
        this.toSingleRange = function(range) {
          range = range || this.ranges[0];
          var removed = this.rangeList.removeAll();
          if (removed.length)
            this.$onRemoveRange(removed);
          range && this.fromOrientedRange(range);
        };
        this.substractPoint = function(pos) {
          var removed = this.rangeList.substractPoint(pos);
          if (removed) {
            this.$onRemoveRange(removed);
            return removed[0];
          }
        };
        this.mergeOverlappingRanges = function() {
          var removed = this.rangeList.merge();
          if (removed.length)
            this.$onRemoveRange(removed);
          else if (this.ranges[0])
            this.fromOrientedRange(this.ranges[0]);
        };
        this.$onAddRange = function(range) {
          this.rangeCount = this.rangeList.ranges.length;
          this.ranges.unshift(range);
          this._signal("addRange", {range: range});
        };
        this.$onRemoveRange = function(removed) {
          this.rangeCount = this.rangeList.ranges.length;
          if (this.rangeCount == 1 && this.inMultiSelectMode) {
            var lastRange = this.rangeList.ranges.pop();
            removed.push(lastRange);
            this.rangeCount = 0;
          }
          for (var i = removed.length; i--; ) {
            var index = this.ranges.indexOf(removed[i]);
            this.ranges.splice(index, 1);
          }
          this._signal("removeRange", {ranges: removed});
          if (this.rangeCount === 0 && this.inMultiSelectMode) {
            this.inMultiSelectMode = false;
            this._signal("singleSelect");
            this.session.$undoSelect = true;
            this.rangeList.detach(this.session);
          }
          lastRange = lastRange || this.ranges[0];
          if (lastRange && !lastRange.isEqual(this.getRange()))
            this.fromOrientedRange(lastRange);
        };
        this.$initRangeList = function() {
          if (this.rangeList)
            return ;
          this.rangeList = new RangeList();
          this.ranges = [];
          this.rangeCount = 0;
        };
        this.getAllRanges = function() {
          return this.rangeCount ? this.rangeList.ranges.concat() : [this.getRange()];
        };
        this.splitIntoLines = function() {
          if (this.rangeCount > 1) {
            var ranges = this.rangeList.ranges;
            var lastRange = ranges[ranges.length - 1];
            var range = Range.fromPoints(ranges[0].start, lastRange.end);
            this.toSingleRange();
            this.setSelectionRange(range, lastRange.cursor == lastRange.start);
          } else {
            var range = this.getRange();
            var isBackwards = this.isBackwards();
            var startRow = range.start.row;
            var endRow = range.end.row;
            if (startRow == endRow) {
              if (isBackwards)
                var start = range.end,
                    end = range.start;
              else
                var start = range.start,
                    end = range.end;
              this.addRange(Range.fromPoints(end, end));
              this.addRange(Range.fromPoints(start, start));
              return ;
            }
            var rectSel = [];
            var r = this.getLineRange(startRow, true);
            r.start.column = range.start.column;
            rectSel.push(r);
            for (var i = startRow + 1; i < endRow; i++)
              rectSel.push(this.getLineRange(i, true));
            r = this.getLineRange(endRow, true);
            r.end.column = range.end.column;
            rectSel.push(r);
            rectSel.forEach(this.addRange, this);
          }
        };
        this.toggleBlockSelection = function() {
          if (this.rangeCount > 1) {
            var ranges = this.rangeList.ranges;
            var lastRange = ranges[ranges.length - 1];
            var range = Range.fromPoints(ranges[0].start, lastRange.end);
            this.toSingleRange();
            this.setSelectionRange(range, lastRange.cursor == lastRange.start);
          } else {
            var cursor = this.session.documentToScreenPosition(this.selectionLead);
            var anchor = this.session.documentToScreenPosition(this.selectionAnchor);
            var rectSel = this.rectangularRangeBlock(cursor, anchor);
            rectSel.forEach(this.addRange, this);
          }
        };
        this.rectangularRangeBlock = function(screenCursor, screenAnchor, includeEmptyLines) {
          var rectSel = [];
          var xBackwards = screenCursor.column < screenAnchor.column;
          if (xBackwards) {
            var startColumn = screenCursor.column;
            var endColumn = screenAnchor.column;
          } else {
            var startColumn = screenAnchor.column;
            var endColumn = screenCursor.column;
          }
          var yBackwards = screenCursor.row < screenAnchor.row;
          if (yBackwards) {
            var startRow = screenCursor.row;
            var endRow = screenAnchor.row;
          } else {
            var startRow = screenAnchor.row;
            var endRow = screenCursor.row;
          }
          if (startColumn < 0)
            startColumn = 0;
          if (startRow < 0)
            startRow = 0;
          if (startRow == endRow)
            includeEmptyLines = true;
          for (var row = startRow; row <= endRow; row++) {
            var range = Range.fromPoints(this.session.screenToDocumentPosition(row, startColumn), this.session.screenToDocumentPosition(row, endColumn));
            if (range.isEmpty()) {
              if (docEnd && isSamePoint(range.end, docEnd))
                break;
              var docEnd = range.end;
            }
            range.cursor = xBackwards ? range.start : range.end;
            rectSel.push(range);
          }
          if (yBackwards)
            rectSel.reverse();
          if (!includeEmptyLines) {
            var end = rectSel.length - 1;
            while (rectSel[end].isEmpty() && end > 0)
              end--;
            if (end > 0) {
              var start = 0;
              while (rectSel[start].isEmpty())
                start++;
            }
            for (var i = end; i >= start; i--) {
              if (rectSel[i].isEmpty())
                rectSel.splice(i, 1);
            }
          }
          return rectSel;
        };
      }).call(Selection.prototype);
      var Editor = acequire("./editor").Editor;
      (function() {
        this.updateSelectionMarkers = function() {
          this.renderer.updateCursor();
          this.renderer.updateBackMarkers();
        };
        this.addSelectionMarker = function(orientedRange) {
          if (!orientedRange.cursor)
            orientedRange.cursor = orientedRange.end;
          var style = this.getSelectionStyle();
          orientedRange.marker = this.session.addMarker(orientedRange, "ace_selection", style);
          this.session.$selectionMarkers.push(orientedRange);
          this.session.selectionMarkerCount = this.session.$selectionMarkers.length;
          return orientedRange;
        };
        this.removeSelectionMarker = function(range) {
          if (!range.marker)
            return ;
          this.session.removeMarker(range.marker);
          var index = this.session.$selectionMarkers.indexOf(range);
          if (index != -1)
            this.session.$selectionMarkers.splice(index, 1);
          this.session.selectionMarkerCount = this.session.$selectionMarkers.length;
        };
        this.removeSelectionMarkers = function(ranges) {
          var markerList = this.session.$selectionMarkers;
          for (var i = ranges.length; i--; ) {
            var range = ranges[i];
            if (!range.marker)
              continue;
            this.session.removeMarker(range.marker);
            var index = markerList.indexOf(range);
            if (index != -1)
              markerList.splice(index, 1);
          }
          this.session.selectionMarkerCount = markerList.length;
        };
        this.$onAddRange = function(e) {
          this.addSelectionMarker(e.range);
          this.renderer.updateCursor();
          this.renderer.updateBackMarkers();
        };
        this.$onRemoveRange = function(e) {
          this.removeSelectionMarkers(e.ranges);
          this.renderer.updateCursor();
          this.renderer.updateBackMarkers();
        };
        this.$onMultiSelect = function(e) {
          if (this.inMultiSelectMode)
            return ;
          this.inMultiSelectMode = true;
          this.setStyle("ace_multiselect");
          this.keyBinding.addKeyboardHandler(commands.keyboardHandler);
          this.commands.setDefaultHandler("exec", this.$onMultiSelectExec);
          this.renderer.updateCursor();
          this.renderer.updateBackMarkers();
        };
        this.$onSingleSelect = function(e) {
          if (this.session.multiSelect.inVirtualMode)
            return ;
          this.inMultiSelectMode = false;
          this.unsetStyle("ace_multiselect");
          this.keyBinding.removeKeyboardHandler(commands.keyboardHandler);
          this.commands.removeDefaultHandler("exec", this.$onMultiSelectExec);
          this.renderer.updateCursor();
          this.renderer.updateBackMarkers();
          this._emit("changeSelection");
        };
        this.$onMultiSelectExec = function(e) {
          var command = e.command;
          var editor = e.editor;
          if (!editor.multiSelect)
            return ;
          if (!command.multiSelectAction) {
            var result = command.exec(editor, e.args || {});
            editor.multiSelect.addRange(editor.multiSelect.toOrientedRange());
            editor.multiSelect.mergeOverlappingRanges();
          } else if (command.multiSelectAction == "forEach") {
            result = editor.forEachSelection(command, e.args);
          } else if (command.multiSelectAction == "forEachLine") {
            result = editor.forEachSelection(command, e.args, true);
          } else if (command.multiSelectAction == "single") {
            editor.exitMultiSelectMode();
            result = command.exec(editor, e.args || {});
          } else {
            result = command.multiSelectAction(editor, e.args || {});
          }
          return result;
        };
        this.forEachSelection = function(cmd, args, options) {
          if (this.inVirtualSelectionMode)
            return ;
          var keepOrder = options && options.keepOrder;
          var $byLines = options == true || options && options.$byLines;
          var session = this.session;
          var selection = this.selection;
          var rangeList = selection.rangeList;
          var ranges = (keepOrder ? selection : rangeList).ranges;
          var result;
          if (!ranges.length)
            return cmd.exec ? cmd.exec(this, args || {}) : cmd(this, args || {});
          var reg = selection._eventRegistry;
          selection._eventRegistry = {};
          var tmpSel = new Selection(session);
          this.inVirtualSelectionMode = true;
          for (var i = ranges.length; i--; ) {
            if ($byLines) {
              while (i > 0 && ranges[i].start.row == ranges[i - 1].end.row)
                i--;
            }
            tmpSel.fromOrientedRange(ranges[i]);
            tmpSel.index = i;
            this.selection = session.selection = tmpSel;
            var cmdResult = cmd.exec ? cmd.exec(this, args || {}) : cmd(this, args || {});
            if (!result && cmdResult !== undefined)
              result = cmdResult;
            tmpSel.toOrientedRange(ranges[i]);
          }
          tmpSel.detach();
          this.selection = session.selection = selection;
          this.inVirtualSelectionMode = false;
          selection._eventRegistry = reg;
          selection.mergeOverlappingRanges();
          var anim = this.renderer.$scrollAnimation;
          this.onCursorChange();
          this.onSelectionChange();
          if (anim && anim.from == anim.to)
            this.renderer.animateScrolling(anim.from);
          return result;
        };
        this.exitMultiSelectMode = function() {
          if (!this.inMultiSelectMode || this.inVirtualSelectionMode)
            return ;
          this.multiSelect.toSingleRange();
        };
        this.getSelectedText = function() {
          var text = "";
          if (this.inMultiSelectMode && !this.inVirtualSelectionMode) {
            var ranges = this.multiSelect.rangeList.ranges;
            var buf = [];
            for (var i = 0; i < ranges.length; i++) {
              buf.push(this.session.getTextRange(ranges[i]));
            }
            var nl = this.session.getDocument().getNewLineCharacter();
            text = buf.join(nl);
            if (text.length == (buf.length - 1) * nl.length)
              text = "";
          } else if (!this.selection.isEmpty()) {
            text = this.session.getTextRange(this.getSelectionRange());
          }
          return text;
        };
        this.$checkMultiselectChange = function(e, anchor) {
          if (this.inMultiSelectMode && !this.inVirtualSelectionMode) {
            var range = this.multiSelect.ranges[0];
            if (this.multiSelect.isEmpty() && anchor == this.multiSelect.anchor)
              return ;
            var pos = anchor == this.multiSelect.anchor ? range.cursor == range.start ? range.end : range.start : range.cursor;
            if (!isSamePoint(pos, anchor))
              this.multiSelect.toSingleRange(this.multiSelect.toOrientedRange());
          }
        };
        this.onPaste = function(text) {
          if (this.$readOnly)
            return ;
          var e = {text: text};
          this._signal("paste", e);
          text = e.text;
          if (!this.inMultiSelectMode || this.inVirtualSelectionMode)
            return this.insert(text);
          var lines = text.split(/\r\n|\r|\n/);
          var ranges = this.selection.rangeList.ranges;
          if (lines.length > ranges.length || lines.length < 2 || !lines[1])
            return this.commands.exec("insertstring", this, text);
          for (var i = ranges.length; i--; ) {
            var range = ranges[i];
            if (!range.isEmpty())
              this.session.remove(range);
            this.session.insert(range.start, lines[i]);
          }
        };
        this.findAll = function(needle, options, additive) {
          options = options || {};
          options.needle = needle || options.needle;
          if (options.needle == undefined) {
            var range = this.selection.isEmpty() ? this.selection.getWordRange() : this.selection.getRange();
            options.needle = this.session.getTextRange(range);
          }
          this.$search.set(options);
          var ranges = this.$search.findAll(this.session);
          if (!ranges.length)
            return 0;
          this.$blockScrolling += 1;
          var selection = this.multiSelect;
          if (!additive)
            selection.toSingleRange(ranges[0]);
          for (var i = ranges.length; i--; )
            selection.addRange(ranges[i], true);
          if (range && selection.rangeList.rangeAtPoint(range.start))
            selection.addRange(range, true);
          this.$blockScrolling -= 1;
          return ranges.length;
        };
        this.selectMoreLines = function(dir, skip) {
          var range = this.selection.toOrientedRange();
          var isBackwards = range.cursor == range.end;
          var screenLead = this.session.documentToScreenPosition(range.cursor);
          if (this.selection.$desiredColumn)
            screenLead.column = this.selection.$desiredColumn;
          var lead = this.session.screenToDocumentPosition(screenLead.row + dir, screenLead.column);
          if (!range.isEmpty()) {
            var screenAnchor = this.session.documentToScreenPosition(isBackwards ? range.end : range.start);
            var anchor = this.session.screenToDocumentPosition(screenAnchor.row + dir, screenAnchor.column);
          } else {
            var anchor = lead;
          }
          if (isBackwards) {
            var newRange = Range.fromPoints(lead, anchor);
            newRange.cursor = newRange.start;
          } else {
            var newRange = Range.fromPoints(anchor, lead);
            newRange.cursor = newRange.end;
          }
          newRange.desiredColumn = screenLead.column;
          if (!this.selection.inMultiSelectMode) {
            this.selection.addRange(range);
          } else {
            if (skip)
              var toRemove = range.cursor;
          }
          this.selection.addRange(newRange);
          if (toRemove)
            this.selection.substractPoint(toRemove);
        };
        this.transposeSelections = function(dir) {
          var session = this.session;
          var sel = session.multiSelect;
          var all = sel.ranges;
          for (var i = all.length; i--; ) {
            var range = all[i];
            if (range.isEmpty()) {
              var tmp = session.getWordRange(range.start.row, range.start.column);
              range.start.row = tmp.start.row;
              range.start.column = tmp.start.column;
              range.end.row = tmp.end.row;
              range.end.column = tmp.end.column;
            }
          }
          sel.mergeOverlappingRanges();
          var words = [];
          for (var i = all.length; i--; ) {
            var range = all[i];
            words.unshift(session.getTextRange(range));
          }
          if (dir < 0)
            words.unshift(words.pop());
          else
            words.push(words.shift());
          for (var i = all.length; i--; ) {
            var range = all[i];
            var tmp = range.clone();
            session.replace(range, words[i]);
            range.start.row = tmp.start.row;
            range.start.column = tmp.start.column;
          }
        };
        this.selectMore = function(dir, skip, stopAtFirst) {
          var session = this.session;
          var sel = session.multiSelect;
          var range = sel.toOrientedRange();
          if (range.isEmpty()) {
            range = session.getWordRange(range.start.row, range.start.column);
            range.cursor = dir == -1 ? range.start : range.end;
            this.multiSelect.addRange(range);
            if (stopAtFirst)
              return ;
          }
          var needle = session.getTextRange(range);
          var newRange = find(session, needle, dir);
          if (newRange) {
            newRange.cursor = dir == -1 ? newRange.start : newRange.end;
            this.$blockScrolling += 1;
            this.session.unfold(newRange);
            this.multiSelect.addRange(newRange);
            this.$blockScrolling -= 1;
            this.renderer.scrollCursorIntoView(null, 0.5);
          }
          if (skip)
            this.multiSelect.substractPoint(range.cursor);
        };
        this.alignCursors = function() {
          var session = this.session;
          var sel = session.multiSelect;
          var ranges = sel.ranges;
          var row = -1;
          var sameRowRanges = ranges.filter(function(r) {
            if (r.cursor.row == row)
              return true;
            row = r.cursor.row;
          });
          if (!ranges.length || sameRowRanges.length == ranges.length - 1) {
            var range = this.selection.getRange();
            var fr = range.start.row,
                lr = range.end.row;
            var guessRange = fr == lr;
            if (guessRange) {
              var max = this.session.getLength();
              var line;
              do {
                line = this.session.getLine(lr);
              } while (/[=:]/.test(line) && ++lr < max);
              do {
                line = this.session.getLine(fr);
              } while (/[=:]/.test(line) && --fr > 0);
              if (fr < 0)
                fr = 0;
              if (lr >= max)
                lr = max - 1;
            }
            var lines = this.session.doc.removeLines(fr, lr);
            lines = this.$reAlignText(lines, guessRange);
            this.session.doc.insert({
              row: fr,
              column: 0
            }, lines.join("\n") + "\n");
            if (!guessRange) {
              range.start.column = 0;
              range.end.column = lines[lines.length - 1].length;
            }
            this.selection.setRange(range);
          } else {
            sameRowRanges.forEach(function(r) {
              sel.substractPoint(r.cursor);
            });
            var maxCol = 0;
            var minSpace = Infinity;
            var spaceOffsets = ranges.map(function(r) {
              var p = r.cursor;
              var line = session.getLine(p.row);
              var spaceOffset = line.substr(p.column).search(/\S/g);
              if (spaceOffset == -1)
                spaceOffset = 0;
              if (p.column > maxCol)
                maxCol = p.column;
              if (spaceOffset < minSpace)
                minSpace = spaceOffset;
              return spaceOffset;
            });
            ranges.forEach(function(r, i) {
              var p = r.cursor;
              var l = maxCol - p.column;
              var d = spaceOffsets[i] - minSpace;
              if (l > d)
                session.insert(p, lang.stringRepeat(" ", l - d));
              else
                session.remove(new Range(p.row, p.column, p.row, p.column - l + d));
              r.start.column = r.end.column = maxCol;
              r.start.row = r.end.row = p.row;
              r.cursor = r.end;
            });
            sel.fromOrientedRange(ranges[0]);
            this.renderer.updateCursor();
            this.renderer.updateBackMarkers();
          }
        };
        this.$reAlignText = function(lines, forceLeft) {
          var isLeftAligned = true,
              isRightAligned = true;
          var startW,
              textW,
              endW;
          return lines.map(function(line) {
            var m = line.match(/(\s*)(.*?)(\s*)([=:].*)/);
            if (!m)
              return [line];
            if (startW == null) {
              startW = m[1].length;
              textW = m[2].length;
              endW = m[3].length;
              return m;
            }
            if (startW + textW + endW != m[1].length + m[2].length + m[3].length)
              isRightAligned = false;
            if (startW != m[1].length)
              isLeftAligned = false;
            if (startW > m[1].length)
              startW = m[1].length;
            if (textW < m[2].length)
              textW = m[2].length;
            if (endW > m[3].length)
              endW = m[3].length;
            return m;
          }).map(forceLeft ? alignLeft : isLeftAligned ? isRightAligned ? alignRight : alignLeft : unAlign);
          function spaces(n) {
            return lang.stringRepeat(" ", n);
          }
          function alignLeft(m) {
            return !m[2] ? m[0] : spaces(startW) + m[2] + spaces(textW - m[2].length + endW) + m[4].replace(/^([=:])\s+/, "$1 ");
          }
          function alignRight(m) {
            return !m[2] ? m[0] : spaces(startW + textW - m[2].length) + m[2] + spaces(endW, " ") + m[4].replace(/^([=:])\s+/, "$1 ");
          }
          function unAlign(m) {
            return !m[2] ? m[0] : spaces(startW) + m[2] + spaces(endW) + m[4].replace(/^([=:])\s+/, "$1 ");
          }
        };
      }).call(Editor.prototype);
      function isSamePoint(p1, p2) {
        return p1.row == p2.row && p1.column == p2.column;
      }
      exports.onSessionChange = function(e) {
        var session = e.session;
        if (session && !session.multiSelect) {
          session.$selectionMarkers = [];
          session.selection.$initRangeList();
          session.multiSelect = session.selection;
        }
        this.multiSelect = session && session.multiSelect;
        var oldSession = e.oldSession;
        if (oldSession) {
          oldSession.multiSelect.off("addRange", this.$onAddRange);
          oldSession.multiSelect.off("removeRange", this.$onRemoveRange);
          oldSession.multiSelect.off("multiSelect", this.$onMultiSelect);
          oldSession.multiSelect.off("singleSelect", this.$onSingleSelect);
          oldSession.multiSelect.lead.off("change", this.$checkMultiselectChange);
          oldSession.multiSelect.anchor.off("change", this.$checkMultiselectChange);
        }
        if (session) {
          session.multiSelect.on("addRange", this.$onAddRange);
          session.multiSelect.on("removeRange", this.$onRemoveRange);
          session.multiSelect.on("multiSelect", this.$onMultiSelect);
          session.multiSelect.on("singleSelect", this.$onSingleSelect);
          session.multiSelect.lead.on("change", this.$checkMultiselectChange);
          session.multiSelect.anchor.on("change", this.$checkMultiselectChange);
        }
        if (session && this.inMultiSelectMode != session.selection.inMultiSelectMode) {
          if (session.selection.inMultiSelectMode)
            this.$onMultiSelect();
          else
            this.$onSingleSelect();
        }
      };
      function MultiSelect(editor) {
        if (editor.$multiselectOnSessionChange)
          return ;
        editor.$onAddRange = editor.$onAddRange.bind(editor);
        editor.$onRemoveRange = editor.$onRemoveRange.bind(editor);
        editor.$onMultiSelect = editor.$onMultiSelect.bind(editor);
        editor.$onSingleSelect = editor.$onSingleSelect.bind(editor);
        editor.$multiselectOnSessionChange = exports.onSessionChange.bind(editor);
        editor.$checkMultiselectChange = editor.$checkMultiselectChange.bind(editor);
        editor.$multiselectOnSessionChange(editor);
        editor.on("changeSession", editor.$multiselectOnSessionChange);
        editor.on("mousedown", onMouseDown);
        editor.commands.addCommands(commands.defaultCommands);
        addAltCursorListeners(editor);
      }
      function addAltCursorListeners(editor) {
        var el = editor.textInput.getElement();
        var altCursor = false;
        event.addListener(el, "keydown", function(e) {
          if (e.keyCode == 18 && !(e.ctrlKey || e.shiftKey || e.metaKey)) {
            if (!altCursor) {
              editor.renderer.setMouseCursor("crosshair");
              altCursor = true;
            }
          } else if (altCursor) {
            reset();
          }
        });
        event.addListener(el, "keyup", reset);
        event.addListener(el, "blur", reset);
        function reset(e) {
          if (altCursor) {
            editor.renderer.setMouseCursor("");
            altCursor = false;
          }
        }
      }
      exports.MultiSelect = MultiSelect;
      acequire("./config").defineOptions(Editor.prototype, "editor", {enableMultiselect: {
          set: function(val) {
            MultiSelect(this);
            if (val) {
              this.on("changeSession", this.$multiselectOnSessionChange);
              this.on("mousedown", onMouseDown);
            } else {
              this.off("changeSession", this.$multiselectOnSessionChange);
              this.off("mousedown", onMouseDown);
            }
          },
          value: true
        }});
    });
    ace.define("ace/mode/folding/fold_mode", ["require", "exports", "module", "ace/range"], function(acequire, exports, module) {
      "use strict";
      var Range = acequire("../../range").Range;
      var FoldMode = exports.FoldMode = function() {};
      (function() {
        this.foldingStartMarker = null;
        this.foldingStopMarker = null;
        this.getFoldWidget = function(session, foldStyle, row) {
          var line = session.getLine(row);
          if (this.foldingStartMarker.test(line))
            return "start";
          if (foldStyle == "markbeginend" && this.foldingStopMarker && this.foldingStopMarker.test(line))
            return "end";
          return "";
        };
        this.getFoldWidgetRange = function(session, foldStyle, row) {
          return null;
        };
        this.indentationBlock = function(session, row, column) {
          var re = /\S/;
          var line = session.getLine(row);
          var startLevel = line.search(re);
          if (startLevel == -1)
            return ;
          var startColumn = column || line.length;
          var maxRow = session.getLength();
          var startRow = row;
          var endRow = row;
          while (++row < maxRow) {
            var level = session.getLine(row).search(re);
            if (level == -1)
              continue;
            if (level <= startLevel)
              break;
            endRow = row;
          }
          if (endRow > startRow) {
            var endColumn = session.getLine(endRow).length;
            return new Range(startRow, startColumn, endRow, endColumn);
          }
        };
        this.openingBracketBlock = function(session, bracket, row, column, typeRe) {
          var start = {
            row: row,
            column: column + 1
          };
          var end = session.$findClosingBracket(bracket, start, typeRe);
          if (!end)
            return ;
          var fw = session.foldWidgets[end.row];
          if (fw == null)
            fw = session.getFoldWidget(end.row);
          if (fw == "start" && end.row > start.row) {
            end.row--;
            end.column = session.getLine(end.row).length;
          }
          return Range.fromPoints(start, end);
        };
        this.closingBracketBlock = function(session, bracket, row, column, typeRe) {
          var end = {
            row: row,
            column: column
          };
          var start = session.$findOpeningBracket(bracket, end);
          if (!start)
            return ;
          start.column++;
          end.column--;
          return Range.fromPoints(start, end);
        };
      }).call(FoldMode.prototype);
    });
    ace.define("ace/theme/textmate", ["require", "exports", "module", "ace/lib/dom"], function(acequire, exports, module) {
      "use strict";
      exports.isDark = false;
      exports.cssClass = "ace-tm";
      exports.cssText = ".ace-tm .ace_gutter {\
background: #f0f0f0;\
color: #333;\
}\
.ace-tm .ace_print-margin {\
width: 1px;\
background: #e8e8e8;\
}\
.ace-tm .ace_fold {\
background-color: #6B72E6;\
}\
.ace-tm {\
background-color: #FFFFFF;\
color: black;\
}\
.ace-tm .ace_cursor {\
color: black;\
}\
.ace-tm .ace_invisible {\
color: rgb(191, 191, 191);\
}\
.ace-tm .ace_storage,\
.ace-tm .ace_keyword {\
color: blue;\
}\
.ace-tm .ace_constant {\
color: rgb(197, 6, 11);\
}\
.ace-tm .ace_constant.ace_buildin {\
color: rgb(88, 72, 246);\
}\
.ace-tm .ace_constant.ace_language {\
color: rgb(88, 92, 246);\
}\
.ace-tm .ace_constant.ace_library {\
color: rgb(6, 150, 14);\
}\
.ace-tm .ace_invalid {\
background-color: rgba(255, 0, 0, 0.1);\
color: red;\
}\
.ace-tm .ace_support.ace_function {\
color: rgb(60, 76, 114);\
}\
.ace-tm .ace_support.ace_constant {\
color: rgb(6, 150, 14);\
}\
.ace-tm .ace_support.ace_type,\
.ace-tm .ace_support.ace_class {\
color: rgb(109, 121, 222);\
}\
.ace-tm .ace_keyword.ace_operator {\
color: rgb(104, 118, 135);\
}\
.ace-tm .ace_string {\
color: rgb(3, 106, 7);\
}\
.ace-tm .ace_comment {\
color: rgb(76, 136, 107);\
}\
.ace-tm .ace_comment.ace_doc {\
color: rgb(0, 102, 255);\
}\
.ace-tm .ace_comment.ace_doc.ace_tag {\
color: rgb(128, 159, 191);\
}\
.ace-tm .ace_constant.ace_numeric {\
color: rgb(0, 0, 205);\
}\
.ace-tm .ace_variable {\
color: rgb(49, 132, 149);\
}\
.ace-tm .ace_xml-pe {\
color: rgb(104, 104, 91);\
}\
.ace-tm .ace_entity.ace_name.ace_function {\
color: #0000A2;\
}\
.ace-tm .ace_heading {\
color: rgb(12, 7, 255);\
}\
.ace-tm .ace_list {\
color:rgb(185, 6, 144);\
}\
.ace-tm .ace_meta.ace_tag {\
color:rgb(0, 22, 142);\
}\
.ace-tm .ace_string.ace_regex {\
color: rgb(255, 0, 0)\
}\
.ace-tm .ace_marker-layer .ace_selection {\
background: rgb(181, 213, 255);\
}\
.ace-tm.ace_multiselect .ace_selection.ace_start {\
box-shadow: 0 0 3px 0px white;\
border-radius: 2px;\
}\
.ace-tm .ace_marker-layer .ace_step {\
background: rgb(252, 255, 0);\
}\
.ace-tm .ace_marker-layer .ace_stack {\
background: rgb(164, 229, 101);\
}\
.ace-tm .ace_marker-layer .ace_bracket {\
margin: -1px 0 0 -1px;\
border: 1px solid rgb(192, 192, 192);\
}\
.ace-tm .ace_marker-layer .ace_active-line {\
background: rgba(0, 0, 0, 0.07);\
}\
.ace-tm .ace_gutter-active-line {\
background-color : #dcdcdc;\
}\
.ace-tm .ace_marker-layer .ace_selected-word {\
background: rgb(250, 250, 255);\
border: 1px solid rgb(200, 200, 250);\
}\
.ace-tm .ace_indent-guide {\
background: url(\"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAACCAYAAACZgbYnAAAAE0lEQVQImWP4////f4bLly//BwAmVgd1/w11/gAAAABJRU5ErkJggg==\") right repeat-y;\
}\
";
      var dom = acequire("../lib/dom");
      dom.importCssString(exports.cssText, exports.cssClass);
    });
    ace.define("ace/line_widgets", ["require", "exports", "module", "ace/lib/oop", "ace/lib/dom", "ace/range"], function(acequire, exports, module) {
      "use strict";
      var oop = acequire("./lib/oop");
      var dom = acequire("./lib/dom");
      var Range = acequire("./range").Range;
      function LineWidgets(session) {
        this.session = session;
        this.session.widgetManager = this;
        this.session.getRowLength = this.getRowLength;
        this.session.$getWidgetScreenLength = this.$getWidgetScreenLength;
        this.updateOnChange = this.updateOnChange.bind(this);
        this.renderWidgets = this.renderWidgets.bind(this);
        this.measureWidgets = this.measureWidgets.bind(this);
        this.session._changedWidgets = [];
        this.$onChangeEditor = this.$onChangeEditor.bind(this);
        this.session.on("change", this.updateOnChange);
        this.session.on("changeEditor", this.$onChangeEditor);
      }
      (function() {
        this.getRowLength = function(row) {
          var h;
          if (this.lineWidgets)
            h = this.lineWidgets[row] && this.lineWidgets[row].rowCount || 0;
          else
            h = 0;
          if (!this.$useWrapMode || !this.$wrapData[row]) {
            return 1 + h;
          } else {
            return this.$wrapData[row].length + 1 + h;
          }
        };
        this.$getWidgetScreenLength = function() {
          var screenRows = 0;
          this.lineWidgets.forEach(function(w) {
            if (w && w.rowCount)
              screenRows += w.rowCount;
          });
          return screenRows;
        };
        this.$onChangeEditor = function(e) {
          this.attach(e.editor);
        };
        this.attach = function(editor) {
          if (editor && editor.widgetManager && editor.widgetManager != this)
            editor.widgetManager.detach();
          if (this.editor == editor)
            return ;
          this.detach();
          this.editor = editor;
          if (editor) {
            editor.widgetManager = this;
            editor.renderer.on("beforeRender", this.measureWidgets);
            editor.renderer.on("afterRender", this.renderWidgets);
          }
        };
        this.detach = function(e) {
          var editor = this.editor;
          if (!editor)
            return ;
          this.editor = null;
          editor.widgetManager = null;
          editor.renderer.off("beforeRender", this.measureWidgets);
          editor.renderer.off("afterRender", this.renderWidgets);
          var lineWidgets = this.session.lineWidgets;
          lineWidgets && lineWidgets.forEach(function(w) {
            if (w && w.el && w.el.parentNode) {
              w._inDocument = false;
              w.el.parentNode.removeChild(w.el);
            }
          });
        };
        this.updateOnChange = function(e) {
          var lineWidgets = this.session.lineWidgets;
          if (!lineWidgets)
            return ;
          var delta = e.data;
          var range = delta.range;
          var startRow = range.start.row;
          var len = range.end.row - startRow;
          if (len === 0) {} else if (delta.action == "removeText" || delta.action == "removeLines") {
            var removed = lineWidgets.splice(startRow + 1, len);
            removed.forEach(function(w) {
              w && this.removeLineWidget(w);
            }, this);
            this.$updateRows();
          } else {
            var args = new Array(len);
            args.unshift(startRow, 0);
            lineWidgets.splice.apply(lineWidgets, args);
            this.$updateRows();
          }
        };
        this.$updateRows = function() {
          var lineWidgets = this.session.lineWidgets;
          if (!lineWidgets)
            return ;
          var noWidgets = true;
          lineWidgets.forEach(function(w, i) {
            if (w) {
              noWidgets = false;
              w.row = i;
            }
          });
          if (noWidgets)
            this.session.lineWidgets = null;
        };
        this.addLineWidget = function(w) {
          if (!this.session.lineWidgets)
            this.session.lineWidgets = new Array(this.session.getLength());
          this.session.lineWidgets[w.row] = w;
          var renderer = this.editor.renderer;
          if (w.html && !w.el) {
            w.el = dom.createElement("div");
            w.el.innerHTML = w.html;
          }
          if (w.el) {
            dom.addCssClass(w.el, "ace_lineWidgetContainer");
            w.el.style.position = "absolute";
            w.el.style.zIndex = 5;
            renderer.container.appendChild(w.el);
            w._inDocument = true;
          }
          if (!w.coverGutter) {
            w.el.style.zIndex = 3;
          }
          if (!w.pixelHeight) {
            w.pixelHeight = w.el.offsetHeight;
          }
          if (w.rowCount == null)
            w.rowCount = w.pixelHeight / renderer.layerConfig.lineHeight;
          this.session._emit("changeFold", {data: {start: {row: w.row}}});
          this.$updateRows();
          this.renderWidgets(null, renderer);
          return w;
        };
        this.removeLineWidget = function(w) {
          w._inDocument = false;
          if (w.el && w.el.parentNode)
            w.el.parentNode.removeChild(w.el);
          if (w.editor && w.editor.destroy)
            try {
              w.editor.destroy();
            } catch (e) {}
          if (this.session.lineWidgets)
            this.session.lineWidgets[w.row] = undefined;
          this.session._emit("changeFold", {data: {start: {row: w.row}}});
          this.$updateRows();
        };
        this.onWidgetChanged = function(w) {
          this.session._changedWidgets.push(w);
          this.editor && this.editor.renderer.updateFull();
        };
        this.measureWidgets = function(e, renderer) {
          var changedWidgets = this.session._changedWidgets;
          var config = renderer.layerConfig;
          if (!changedWidgets || !changedWidgets.length)
            return ;
          var min = Infinity;
          for (var i = 0; i < changedWidgets.length; i++) {
            var w = changedWidgets[i];
            if (!w._inDocument) {
              w._inDocument = true;
              renderer.container.appendChild(w.el);
            }
            w.h = w.el.offsetHeight;
            if (!w.fixedWidth) {
              w.w = w.el.offsetWidth;
              w.screenWidth = Math.ceil(w.w / config.characterWidth);
            }
            var rowCount = w.h / config.lineHeight;
            if (w.coverLine) {
              rowCount -= this.session.getRowLineCount(w.row);
              if (rowCount < 0)
                rowCount = 0;
            }
            if (w.rowCount != rowCount) {
              w.rowCount = rowCount;
              if (w.row < min)
                min = w.row;
            }
          }
          if (min != Infinity) {
            this.session._emit("changeFold", {data: {start: {row: min}}});
            this.session.lineWidgetWidth = null;
          }
          this.session._changedWidgets = [];
        };
        this.renderWidgets = function(e, renderer) {
          var config = renderer.layerConfig;
          var lineWidgets = this.session.lineWidgets;
          if (!lineWidgets)
            return ;
          var first = Math.min(this.firstRow, config.firstRow);
          var last = Math.max(this.lastRow, config.lastRow, lineWidgets.length);
          while (first > 0 && !lineWidgets[first])
            first--;
          this.firstRow = config.firstRow;
          this.lastRow = config.lastRow;
          renderer.$cursorLayer.config = config;
          for (var i = first; i <= last; i++) {
            var w = lineWidgets[i];
            if (!w || !w.el)
              continue;
            if (!w._inDocument) {
              w._inDocument = true;
              renderer.container.appendChild(w.el);
            }
            var top = renderer.$cursorLayer.getPixelPosition({
              row: i,
              column: 0
            }, true).top;
            if (!w.coverLine)
              top += config.lineHeight * this.session.getRowLineCount(w.row);
            w.el.style.top = top - config.offset + "px";
            var left = w.coverGutter ? 0 : renderer.gutterWidth;
            if (!w.fixedWidth)
              left -= renderer.scrollLeft;
            w.el.style.left = left + "px";
            if (w.fixedWidth) {
              w.el.style.right = renderer.scrollBar.getWidth() + "px";
            } else {
              w.el.style.right = "";
            }
          }
        };
      }).call(LineWidgets.prototype);
      exports.LineWidgets = LineWidgets;
    });
    ace.define("ace/ext/error_marker", ["require", "exports", "module", "ace/line_widgets", "ace/lib/dom", "ace/range"], function(acequire, exports, module) {
      "use strict";
      var LineWidgets = acequire("../line_widgets").LineWidgets;
      var dom = acequire("../lib/dom");
      var Range = acequire("../range").Range;
      function binarySearch(array, needle, comparator) {
        var first = 0;
        var last = array.length - 1;
        while (first <= last) {
          var mid = (first + last) >> 1;
          var c = comparator(needle, array[mid]);
          if (c > 0)
            first = mid + 1;
          else if (c < 0)
            last = mid - 1;
          else
            return mid;
        }
        return -(first + 1);
      }
      function findAnnotations(session, row, dir) {
        var annotations = session.getAnnotations().sort(Range.comparePoints);
        if (!annotations.length)
          return ;
        var i = binarySearch(annotations, {
          row: row,
          column: -1
        }, Range.comparePoints);
        if (i < 0)
          i = -i - 1;
        if (i >= annotations.length - 1)
          i = dir > 0 ? 0 : annotations.length - 1;
        else if (i === 0 && dir < 0)
          i = annotations.length - 1;
        var annotation = annotations[i];
        if (!annotation || !dir)
          return ;
        if (annotation.row === row) {
          do {
            annotation = annotations[i += dir];
          } while (annotation && annotation.row === row);
          if (!annotation)
            return annotations.slice();
        }
        var matched = [];
        row = annotation.row;
        do {
          matched[dir < 0 ? "unshift" : "push"](annotation);
          annotation = annotations[i += dir];
        } while (annotation && annotation.row == row);
        return matched.length && matched;
      }
      exports.showErrorMarker = function(editor, dir) {
        var session = editor.session;
        if (!session.widgetManager) {
          session.widgetManager = new LineWidgets(session);
          session.widgetManager.attach(editor);
        }
        var pos = editor.getCursorPosition();
        var row = pos.row;
        var oldWidget = session.lineWidgets && session.lineWidgets[row];
        if (oldWidget) {
          oldWidget.destroy();
        } else {
          row -= dir;
        }
        var annotations = findAnnotations(session, row, dir);
        var gutterAnno;
        if (annotations) {
          var annotation = annotations[0];
          pos.column = (annotation.pos && typeof annotation.column != "number" ? annotation.pos.sc : annotation.column) || 0;
          pos.row = annotation.row;
          gutterAnno = editor.renderer.$gutterLayer.$annotations[pos.row];
        } else if (oldWidget) {
          return ;
        } else {
          gutterAnno = {
            text: ["Looks good!"],
            className: "ace_ok"
          };
        }
        editor.session.unfold(pos.row);
        editor.selection.moveToPosition(pos);
        var w = {
          row: pos.row,
          fixedWidth: true,
          coverGutter: true,
          el: dom.createElement("div")
        };
        var el = w.el.appendChild(dom.createElement("div"));
        var arrow = w.el.appendChild(dom.createElement("div"));
        arrow.className = "error_widget_arrow " + gutterAnno.className;
        var left = editor.renderer.$cursorLayer.getPixelPosition(pos).left;
        arrow.style.left = left + editor.renderer.gutterWidth - 5 + "px";
        w.el.className = "error_widget_wrapper";
        el.className = "error_widget " + gutterAnno.className;
        el.innerHTML = gutterAnno.text.join("<br>");
        el.appendChild(dom.createElement("div"));
        var kb = function(_, hashId, keyString) {
          if (hashId === 0 && (keyString === "esc" || keyString === "return")) {
            w.destroy();
            return {command: "null"};
          }
        };
        w.destroy = function() {
          if (editor.$mouseHandler.isMousePressed)
            return ;
          editor.keyBinding.removeKeyboardHandler(kb);
          session.widgetManager.removeLineWidget(w);
          editor.off("changeSelection", w.destroy);
          editor.off("changeSession", w.destroy);
          editor.off("mouseup", w.destroy);
          editor.off("change", w.destroy);
        };
        editor.keyBinding.addKeyboardHandler(kb);
        editor.on("changeSelection", w.destroy);
        editor.on("changeSession", w.destroy);
        editor.on("mouseup", w.destroy);
        editor.on("change", w.destroy);
        editor.session.widgetManager.addLineWidget(w);
        w.el.onmousedown = editor.focus.bind(editor);
        editor.renderer.scrollCursorIntoView(null, 0.5, {bottom: w.el.offsetHeight});
      };
      dom.importCssString("\
    .error_widget_wrapper {\
        background: inherit;\
        color: inherit;\
        border:none\
    }\
    .error_widget {\
        border-top: solid 2px;\
        border-bottom: solid 2px;\
        margin: 5px 0;\
        padding: 10px 40px;\
        white-space: pre-wrap;\
    }\
    .error_widget.ace_error, .error_widget_arrow.ace_error{\
        border-color: #ff5a5a\
    }\
    .error_widget.ace_warning, .error_widget_arrow.ace_warning{\
        border-color: #F1D817\
    }\
    .error_widget.ace_info, .error_widget_arrow.ace_info{\
        border-color: #5a5a5a\
    }\
    .error_widget.ace_ok, .error_widget_arrow.ace_ok{\
        border-color: #5aaa5a\
    }\
    .error_widget_arrow {\
        position: absolute;\
        border: solid 5px;\
        border-top-color: transparent!important;\
        border-right-color: transparent!important;\
        border-left-color: transparent!important;\
        top: -5px;\
    }\
", "");
    });
    ace.define("ace/ace", ["require", "exports", "module", "ace/lib/fixoldbrowsers", "ace/lib/dom", "ace/lib/event", "ace/editor", "ace/edit_session", "ace/undomanager", "ace/virtual_renderer", "ace/worker/worker_client", "ace/keyboard/hash_handler", "ace/placeholder", "ace/multi_select", "ace/mode/folding/fold_mode", "ace/theme/textmate", "ace/ext/error_marker", "ace/config"], function(acequire, exports, module) {
      "use strict";
      acequire("./lib/fixoldbrowsers");
      var dom = acequire("./lib/dom");
      var event = acequire("./lib/event");
      var Editor = acequire("./editor").Editor;
      var EditSession = acequire("./edit_session").EditSession;
      var UndoManager = acequire("./undomanager").UndoManager;
      var Renderer = acequire("./virtual_renderer").VirtualRenderer;
      acequire("./worker/worker_client");
      acequire("./keyboard/hash_handler");
      acequire("./placeholder");
      acequire("./multi_select");
      acequire("./mode/folding/fold_mode");
      acequire("./theme/textmate");
      acequire("./ext/error_marker");
      exports.config = acequire("./config");
      exports.acequire = acequire;
      exports.edit = function(el) {
        if (typeof(el) == "string") {
          var _id = el;
          el = document.getElementById(_id);
          if (!el)
            throw new Error("ace.edit can't find div #" + _id);
        }
        if (el && el.env && el.env.editor instanceof Editor)
          return el.env.editor;
        var value = "";
        if (el && /input|textarea/i.test(el.tagName)) {
          var oldNode = el;
          value = oldNode.value;
          el = dom.createElement("pre");
          oldNode.parentNode.replaceChild(el, oldNode);
        } else {
          value = dom.getInnerText(el);
          el.innerHTML = '';
        }
        var doc = exports.createEditSession(value);
        var editor = new Editor(new Renderer(el));
        editor.setSession(doc);
        var env = {
          document: doc,
          editor: editor,
          onResize: editor.resize.bind(editor, null)
        };
        if (oldNode)
          env.textarea = oldNode;
        event.addListener(window, "resize", env.onResize);
        editor.on("destroy", function() {
          event.removeListener(window, "resize", env.onResize);
          env.editor.container.env = null;
        });
        editor.container.env = editor.env = env;
        return editor;
      };
      exports.createEditSession = function(text, mode) {
        var doc = new EditSession(text, mode);
        doc.setUndoManager(new UndoManager());
        return doc;
      };
      exports.EditSession = EditSession;
      exports.UndoManager = UndoManager;
    });
    (function() {
      ace.acequire(["ace/ace"], function(a) {
        a && a.config.init(true);
        if (!window.ace)
          window.ace = a;
        for (var key in a)
          if (a.hasOwnProperty(key))
            window.ace[key] = a[key];
      });
    })();
    module.exports = window.ace.acequire("ace/ace");
  })(require("github:jspm/nodelibs-process@0.1.1"));
  global.define = __define;
  return module.exports;
});



System.register("npm:buffer@3.0.3/index", ["npm:base64-js@0.0.8", "npm:ieee754@1.1.4", "npm:is-array@1.0.1"], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  var base64 = require("npm:base64-js@0.0.8");
  var ieee754 = require("npm:ieee754@1.1.4");
  var isArray = require("npm:is-array@1.0.1");
  exports.Buffer = Buffer;
  exports.SlowBuffer = SlowBuffer;
  exports.INSPECT_MAX_BYTES = 50;
  Buffer.poolSize = 8192;
  var kMaxLength = 0x3fffffff;
  var rootParent = {};
  Buffer.TYPED_ARRAY_SUPPORT = (function() {
    try {
      var buf = new ArrayBuffer(0);
      var arr = new Uint8Array(buf);
      arr.foo = function() {
        return 42;
      };
      return arr.foo() === 42 && typeof arr.subarray === 'function' && new Uint8Array(1).subarray(1, 1).byteLength === 0;
    } catch (e) {
      return false;
    }
  })();
  function Buffer(subject, encoding, noZero) {
    if (!(this instanceof Buffer))
      return new Buffer(subject, encoding, noZero);
    var type = typeof subject;
    var length;
    if (type === 'number') {
      length = +subject;
    } else if (type === 'string') {
      length = Buffer.byteLength(subject, encoding);
    } else if (type === 'object' && subject !== null) {
      if (subject.type === 'Buffer' && isArray(subject.data))
        subject = subject.data;
      length = +subject.length;
    } else {
      throw new TypeError('must start with number, buffer, array or string');
    }
    if (length > kMaxLength)
      throw new RangeError('Attempt to allocate Buffer larger than maximum ' + 'size: 0x' + kMaxLength.toString(16) + ' bytes');
    if (length < 0)
      length = 0;
    else
      length >>>= 0;
    var self = this;
    if (Buffer.TYPED_ARRAY_SUPPORT) {
      self = Buffer._augment(new Uint8Array(length));
    } else {
      self.length = length;
      self._isBuffer = true;
    }
    var i;
    if (Buffer.TYPED_ARRAY_SUPPORT && typeof subject.byteLength === 'number') {
      self._set(subject);
    } else if (isArrayish(subject)) {
      if (Buffer.isBuffer(subject)) {
        for (i = 0; i < length; i++)
          self[i] = subject.readUInt8(i);
      } else {
        for (i = 0; i < length; i++)
          self[i] = ((subject[i] % 256) + 256) % 256;
      }
    } else if (type === 'string') {
      self.write(subject, 0, encoding);
    } else if (type === 'number' && !Buffer.TYPED_ARRAY_SUPPORT && !noZero) {
      for (i = 0; i < length; i++) {
        self[i] = 0;
      }
    }
    if (length > 0 && length <= Buffer.poolSize)
      self.parent = rootParent;
    return self;
  }
  function SlowBuffer(subject, encoding, noZero) {
    if (!(this instanceof SlowBuffer))
      return new SlowBuffer(subject, encoding, noZero);
    var buf = new Buffer(subject, encoding, noZero);
    delete buf.parent;
    return buf;
  }
  Buffer.isBuffer = function(b) {
    return !!(b != null && b._isBuffer);
  };
  Buffer.compare = function(a, b) {
    if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b))
      throw new TypeError('Arguments must be Buffers');
    if (a === b)
      return 0;
    var x = a.length;
    var y = b.length;
    for (var i = 0,
        len = Math.min(x, y); i < len && a[i] === b[i]; i++) {}
    if (i !== len) {
      x = a[i];
      y = b[i];
    }
    if (x < y)
      return -1;
    if (y < x)
      return 1;
    return 0;
  };
  Buffer.isEncoding = function(encoding) {
    switch (String(encoding).toLowerCase()) {
      case 'hex':
      case 'utf8':
      case 'utf-8':
      case 'ascii':
      case 'binary':
      case 'base64':
      case 'raw':
      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return true;
      default:
        return false;
    }
  };
  Buffer.concat = function(list, totalLength) {
    if (!isArray(list))
      throw new TypeError('Usage: Buffer.concat(list[, length])');
    if (list.length === 0) {
      return new Buffer(0);
    } else if (list.length === 1) {
      return list[0];
    }
    var i;
    if (totalLength === undefined) {
      totalLength = 0;
      for (i = 0; i < list.length; i++) {
        totalLength += list[i].length;
      }
    }
    var buf = new Buffer(totalLength);
    var pos = 0;
    for (i = 0; i < list.length; i++) {
      var item = list[i];
      item.copy(buf, pos);
      pos += item.length;
    }
    return buf;
  };
  Buffer.byteLength = function(str, encoding) {
    var ret;
    str = str + '';
    switch (encoding || 'utf8') {
      case 'ascii':
      case 'binary':
      case 'raw':
        ret = str.length;
        break;
      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        ret = str.length * 2;
        break;
      case 'hex':
        ret = str.length >>> 1;
        break;
      case 'utf8':
      case 'utf-8':
        ret = utf8ToBytes(str).length;
        break;
      case 'base64':
        ret = base64ToBytes(str).length;
        break;
      default:
        ret = str.length;
    }
    return ret;
  };
  Buffer.prototype.length = undefined;
  Buffer.prototype.parent = undefined;
  Buffer.prototype.toString = function(encoding, start, end) {
    var loweredCase = false;
    start = start >>> 0;
    end = end === undefined || end === Infinity ? this.length : end >>> 0;
    if (!encoding)
      encoding = 'utf8';
    if (start < 0)
      start = 0;
    if (end > this.length)
      end = this.length;
    if (end <= start)
      return '';
    while (true) {
      switch (encoding) {
        case 'hex':
          return hexSlice(this, start, end);
        case 'utf8':
        case 'utf-8':
          return utf8Slice(this, start, end);
        case 'ascii':
          return asciiSlice(this, start, end);
        case 'binary':
          return binarySlice(this, start, end);
        case 'base64':
          return base64Slice(this, start, end);
        case 'ucs2':
        case 'ucs-2':
        case 'utf16le':
        case 'utf-16le':
          return utf16leSlice(this, start, end);
        default:
          if (loweredCase)
            throw new TypeError('Unknown encoding: ' + encoding);
          encoding = (encoding + '').toLowerCase();
          loweredCase = true;
      }
    }
  };
  Buffer.prototype.equals = function(b) {
    if (!Buffer.isBuffer(b))
      throw new TypeError('Argument must be a Buffer');
    if (this === b)
      return true;
    return Buffer.compare(this, b) === 0;
  };
  Buffer.prototype.inspect = function() {
    var str = '';
    var max = exports.INSPECT_MAX_BYTES;
    if (this.length > 0) {
      str = this.toString('hex', 0, max).match(/.{2}/g).join(' ');
      if (this.length > max)
        str += ' ... ';
    }
    return '<Buffer ' + str + '>';
  };
  Buffer.prototype.compare = function(b) {
    if (!Buffer.isBuffer(b))
      throw new TypeError('Argument must be a Buffer');
    if (this === b)
      return 0;
    return Buffer.compare(this, b);
  };
  Buffer.prototype.get = function(offset) {
    console.log('.get() is deprecated. Access using array indexes instead.');
    return this.readUInt8(offset);
  };
  Buffer.prototype.set = function(v, offset) {
    console.log('.set() is deprecated. Access using array indexes instead.');
    return this.writeUInt8(v, offset);
  };
  function hexWrite(buf, string, offset, length) {
    offset = Number(offset) || 0;
    var remaining = buf.length - offset;
    if (!length) {
      length = remaining;
    } else {
      length = Number(length);
      if (length > remaining) {
        length = remaining;
      }
    }
    var strLen = string.length;
    if (strLen % 2 !== 0)
      throw new Error('Invalid hex string');
    if (length > strLen / 2) {
      length = strLen / 2;
    }
    for (var i = 0; i < length; i++) {
      var byte = parseInt(string.substr(i * 2, 2), 16);
      if (isNaN(byte))
        throw new Error('Invalid hex string');
      buf[offset + i] = byte;
    }
    return i;
  }
  function utf8Write(buf, string, offset, length) {
    var charsWritten = blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length);
    return charsWritten;
  }
  function asciiWrite(buf, string, offset, length) {
    var charsWritten = blitBuffer(asciiToBytes(string), buf, offset, length);
    return charsWritten;
  }
  function binaryWrite(buf, string, offset, length) {
    return asciiWrite(buf, string, offset, length);
  }
  function base64Write(buf, string, offset, length) {
    var charsWritten = blitBuffer(base64ToBytes(string), buf, offset, length);
    return charsWritten;
  }
  function utf16leWrite(buf, string, offset, length) {
    var charsWritten = blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length);
    return charsWritten;
  }
  Buffer.prototype.write = function(string, offset, length, encoding) {
    if (isFinite(offset)) {
      if (!isFinite(length)) {
        encoding = length;
        length = undefined;
      }
    } else {
      var swap = encoding;
      encoding = offset;
      offset = length;
      length = swap;
    }
    offset = Number(offset) || 0;
    if (length < 0 || offset < 0 || offset > this.length)
      throw new RangeError('attempt to write outside buffer bounds');
    var remaining = this.length - offset;
    if (!length) {
      length = remaining;
    } else {
      length = Number(length);
      if (length > remaining) {
        length = remaining;
      }
    }
    encoding = String(encoding || 'utf8').toLowerCase();
    var ret;
    switch (encoding) {
      case 'hex':
        ret = hexWrite(this, string, offset, length);
        break;
      case 'utf8':
      case 'utf-8':
        ret = utf8Write(this, string, offset, length);
        break;
      case 'ascii':
        ret = asciiWrite(this, string, offset, length);
        break;
      case 'binary':
        ret = binaryWrite(this, string, offset, length);
        break;
      case 'base64':
        ret = base64Write(this, string, offset, length);
        break;
      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        ret = utf16leWrite(this, string, offset, length);
        break;
      default:
        throw new TypeError('Unknown encoding: ' + encoding);
    }
    return ret;
  };
  Buffer.prototype.toJSON = function() {
    return {
      type: 'Buffer',
      data: Array.prototype.slice.call(this._arr || this, 0)
    };
  };
  function base64Slice(buf, start, end) {
    if (start === 0 && end === buf.length) {
      return base64.fromByteArray(buf);
    } else {
      return base64.fromByteArray(buf.slice(start, end));
    }
  }
  function utf8Slice(buf, start, end) {
    var res = '';
    var tmp = '';
    end = Math.min(buf.length, end);
    for (var i = start; i < end; i++) {
      if (buf[i] <= 0x7F) {
        res += decodeUtf8Char(tmp) + String.fromCharCode(buf[i]);
        tmp = '';
      } else {
        tmp += '%' + buf[i].toString(16);
      }
    }
    return res + decodeUtf8Char(tmp);
  }
  function asciiSlice(buf, start, end) {
    var ret = '';
    end = Math.min(buf.length, end);
    for (var i = start; i < end; i++) {
      ret += String.fromCharCode(buf[i] & 0x7F);
    }
    return ret;
  }
  function binarySlice(buf, start, end) {
    var ret = '';
    end = Math.min(buf.length, end);
    for (var i = start; i < end; i++) {
      ret += String.fromCharCode(buf[i]);
    }
    return ret;
  }
  function hexSlice(buf, start, end) {
    var len = buf.length;
    if (!start || start < 0)
      start = 0;
    if (!end || end < 0 || end > len)
      end = len;
    var out = '';
    for (var i = start; i < end; i++) {
      out += toHex(buf[i]);
    }
    return out;
  }
  function utf16leSlice(buf, start, end) {
    var bytes = buf.slice(start, end);
    var res = '';
    for (var i = 0; i < bytes.length; i += 2) {
      res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256);
    }
    return res;
  }
  Buffer.prototype.slice = function(start, end) {
    var len = this.length;
    start = ~~start;
    end = end === undefined ? len : ~~end;
    if (start < 0) {
      start += len;
      if (start < 0)
        start = 0;
    } else if (start > len) {
      start = len;
    }
    if (end < 0) {
      end += len;
      if (end < 0)
        end = 0;
    } else if (end > len) {
      end = len;
    }
    if (end < start)
      end = start;
    var newBuf;
    if (Buffer.TYPED_ARRAY_SUPPORT) {
      newBuf = Buffer._augment(this.subarray(start, end));
    } else {
      var sliceLen = end - start;
      newBuf = new Buffer(sliceLen, undefined, true);
      for (var i = 0; i < sliceLen; i++) {
        newBuf[i] = this[i + start];
      }
    }
    if (newBuf.length)
      newBuf.parent = this.parent || this;
    return newBuf;
  };
  function checkOffset(offset, ext, length) {
    if ((offset % 1) !== 0 || offset < 0)
      throw new RangeError('offset is not uint');
    if (offset + ext > length)
      throw new RangeError('Trying to access beyond buffer length');
  }
  Buffer.prototype.readUIntLE = function(offset, byteLength, noAssert) {
    offset = offset >>> 0;
    byteLength = byteLength >>> 0;
    if (!noAssert)
      checkOffset(offset, byteLength, this.length);
    var val = this[offset];
    var mul = 1;
    var i = 0;
    while (++i < byteLength && (mul *= 0x100))
      val += this[offset + i] * mul;
    return val;
  };
  Buffer.prototype.readUIntBE = function(offset, byteLength, noAssert) {
    offset = offset >>> 0;
    byteLength = byteLength >>> 0;
    if (!noAssert)
      checkOffset(offset, byteLength, this.length);
    var val = this[offset + --byteLength];
    var mul = 1;
    while (byteLength > 0 && (mul *= 0x100))
      val += this[offset + --byteLength] * mul;
    return val;
  };
  Buffer.prototype.readUInt8 = function(offset, noAssert) {
    if (!noAssert)
      checkOffset(offset, 1, this.length);
    return this[offset];
  };
  Buffer.prototype.readUInt16LE = function(offset, noAssert) {
    if (!noAssert)
      checkOffset(offset, 2, this.length);
    return this[offset] | (this[offset + 1] << 8);
  };
  Buffer.prototype.readUInt16BE = function(offset, noAssert) {
    if (!noAssert)
      checkOffset(offset, 2, this.length);
    return (this[offset] << 8) | this[offset + 1];
  };
  Buffer.prototype.readUInt32LE = function(offset, noAssert) {
    if (!noAssert)
      checkOffset(offset, 4, this.length);
    return ((this[offset]) | (this[offset + 1] << 8) | (this[offset + 2] << 16)) + (this[offset + 3] * 0x1000000);
  };
  Buffer.prototype.readUInt32BE = function(offset, noAssert) {
    if (!noAssert)
      checkOffset(offset, 4, this.length);
    return (this[offset] * 0x1000000) + ((this[offset + 1] << 16) | (this[offset + 2] << 8) | this[offset + 3]);
  };
  Buffer.prototype.readIntLE = function(offset, byteLength, noAssert) {
    offset = offset >>> 0;
    byteLength = byteLength >>> 0;
    if (!noAssert)
      checkOffset(offset, byteLength, this.length);
    var val = this[offset];
    var mul = 1;
    var i = 0;
    while (++i < byteLength && (mul *= 0x100))
      val += this[offset + i] * mul;
    mul *= 0x80;
    if (val >= mul)
      val -= Math.pow(2, 8 * byteLength);
    return val;
  };
  Buffer.prototype.readIntBE = function(offset, byteLength, noAssert) {
    offset = offset >>> 0;
    byteLength = byteLength >>> 0;
    if (!noAssert)
      checkOffset(offset, byteLength, this.length);
    var i = byteLength;
    var mul = 1;
    var val = this[offset + --i];
    while (i > 0 && (mul *= 0x100))
      val += this[offset + --i] * mul;
    mul *= 0x80;
    if (val >= mul)
      val -= Math.pow(2, 8 * byteLength);
    return val;
  };
  Buffer.prototype.readInt8 = function(offset, noAssert) {
    if (!noAssert)
      checkOffset(offset, 1, this.length);
    if (!(this[offset] & 0x80))
      return (this[offset]);
    return ((0xff - this[offset] + 1) * -1);
  };
  Buffer.prototype.readInt16LE = function(offset, noAssert) {
    if (!noAssert)
      checkOffset(offset, 2, this.length);
    var val = this[offset] | (this[offset + 1] << 8);
    return (val & 0x8000) ? val | 0xFFFF0000 : val;
  };
  Buffer.prototype.readInt16BE = function(offset, noAssert) {
    if (!noAssert)
      checkOffset(offset, 2, this.length);
    var val = this[offset + 1] | (this[offset] << 8);
    return (val & 0x8000) ? val | 0xFFFF0000 : val;
  };
  Buffer.prototype.readInt32LE = function(offset, noAssert) {
    if (!noAssert)
      checkOffset(offset, 4, this.length);
    return (this[offset]) | (this[offset + 1] << 8) | (this[offset + 2] << 16) | (this[offset + 3] << 24);
  };
  Buffer.prototype.readInt32BE = function(offset, noAssert) {
    if (!noAssert)
      checkOffset(offset, 4, this.length);
    return (this[offset] << 24) | (this[offset + 1] << 16) | (this[offset + 2] << 8) | (this[offset + 3]);
  };
  Buffer.prototype.readFloatLE = function(offset, noAssert) {
    if (!noAssert)
      checkOffset(offset, 4, this.length);
    return ieee754.read(this, offset, true, 23, 4);
  };
  Buffer.prototype.readFloatBE = function(offset, noAssert) {
    if (!noAssert)
      checkOffset(offset, 4, this.length);
    return ieee754.read(this, offset, false, 23, 4);
  };
  Buffer.prototype.readDoubleLE = function(offset, noAssert) {
    if (!noAssert)
      checkOffset(offset, 8, this.length);
    return ieee754.read(this, offset, true, 52, 8);
  };
  Buffer.prototype.readDoubleBE = function(offset, noAssert) {
    if (!noAssert)
      checkOffset(offset, 8, this.length);
    return ieee754.read(this, offset, false, 52, 8);
  };
  function checkInt(buf, value, offset, ext, max, min) {
    if (!Buffer.isBuffer(buf))
      throw new TypeError('buffer must be a Buffer instance');
    if (value > max || value < min)
      throw new RangeError('value is out of bounds');
    if (offset + ext > buf.length)
      throw new RangeError('index out of range');
  }
  Buffer.prototype.writeUIntLE = function(value, offset, byteLength, noAssert) {
    value = +value;
    offset = offset >>> 0;
    byteLength = byteLength >>> 0;
    if (!noAssert)
      checkInt(this, value, offset, byteLength, Math.pow(2, 8 * byteLength), 0);
    var mul = 1;
    var i = 0;
    this[offset] = value & 0xFF;
    while (++i < byteLength && (mul *= 0x100))
      this[offset + i] = (value / mul) >>> 0 & 0xFF;
    return offset + byteLength;
  };
  Buffer.prototype.writeUIntBE = function(value, offset, byteLength, noAssert) {
    value = +value;
    offset = offset >>> 0;
    byteLength = byteLength >>> 0;
    if (!noAssert)
      checkInt(this, value, offset, byteLength, Math.pow(2, 8 * byteLength), 0);
    var i = byteLength - 1;
    var mul = 1;
    this[offset + i] = value & 0xFF;
    while (--i >= 0 && (mul *= 0x100))
      this[offset + i] = (value / mul) >>> 0 & 0xFF;
    return offset + byteLength;
  };
  Buffer.prototype.writeUInt8 = function(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert)
      checkInt(this, value, offset, 1, 0xff, 0);
    if (!Buffer.TYPED_ARRAY_SUPPORT)
      value = Math.floor(value);
    this[offset] = value;
    return offset + 1;
  };
  function objectWriteUInt16(buf, value, offset, littleEndian) {
    if (value < 0)
      value = 0xffff + value + 1;
    for (var i = 0,
        j = Math.min(buf.length - offset, 2); i < j; i++) {
      buf[offset + i] = (value & (0xff << (8 * (littleEndian ? i : 1 - i)))) >>> (littleEndian ? i : 1 - i) * 8;
    }
  }
  Buffer.prototype.writeUInt16LE = function(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert)
      checkInt(this, value, offset, 2, 0xffff, 0);
    if (Buffer.TYPED_ARRAY_SUPPORT) {
      this[offset] = value;
      this[offset + 1] = (value >>> 8);
    } else
      objectWriteUInt16(this, value, offset, true);
    return offset + 2;
  };
  Buffer.prototype.writeUInt16BE = function(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert)
      checkInt(this, value, offset, 2, 0xffff, 0);
    if (Buffer.TYPED_ARRAY_SUPPORT) {
      this[offset] = (value >>> 8);
      this[offset + 1] = value;
    } else
      objectWriteUInt16(this, value, offset, false);
    return offset + 2;
  };
  function objectWriteUInt32(buf, value, offset, littleEndian) {
    if (value < 0)
      value = 0xffffffff + value + 1;
    for (var i = 0,
        j = Math.min(buf.length - offset, 4); i < j; i++) {
      buf[offset + i] = (value >>> (littleEndian ? i : 3 - i) * 8) & 0xff;
    }
  }
  Buffer.prototype.writeUInt32LE = function(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert)
      checkInt(this, value, offset, 4, 0xffffffff, 0);
    if (Buffer.TYPED_ARRAY_SUPPORT) {
      this[offset + 3] = (value >>> 24);
      this[offset + 2] = (value >>> 16);
      this[offset + 1] = (value >>> 8);
      this[offset] = value;
    } else
      objectWriteUInt32(this, value, offset, true);
    return offset + 4;
  };
  Buffer.prototype.writeUInt32BE = function(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert)
      checkInt(this, value, offset, 4, 0xffffffff, 0);
    if (Buffer.TYPED_ARRAY_SUPPORT) {
      this[offset] = (value >>> 24);
      this[offset + 1] = (value >>> 16);
      this[offset + 2] = (value >>> 8);
      this[offset + 3] = value;
    } else
      objectWriteUInt32(this, value, offset, false);
    return offset + 4;
  };
  Buffer.prototype.writeIntLE = function(value, offset, byteLength, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) {
      checkInt(this, value, offset, byteLength, Math.pow(2, 8 * byteLength - 1) - 1, -Math.pow(2, 8 * byteLength - 1));
    }
    var i = 0;
    var mul = 1;
    var sub = value < 0 ? 1 : 0;
    this[offset] = value & 0xFF;
    while (++i < byteLength && (mul *= 0x100))
      this[offset + i] = ((value / mul) >> 0) - sub & 0xFF;
    return offset + byteLength;
  };
  Buffer.prototype.writeIntBE = function(value, offset, byteLength, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) {
      checkInt(this, value, offset, byteLength, Math.pow(2, 8 * byteLength - 1) - 1, -Math.pow(2, 8 * byteLength - 1));
    }
    var i = byteLength - 1;
    var mul = 1;
    var sub = value < 0 ? 1 : 0;
    this[offset + i] = value & 0xFF;
    while (--i >= 0 && (mul *= 0x100))
      this[offset + i] = ((value / mul) >> 0) - sub & 0xFF;
    return offset + byteLength;
  };
  Buffer.prototype.writeInt8 = function(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert)
      checkInt(this, value, offset, 1, 0x7f, -0x80);
    if (!Buffer.TYPED_ARRAY_SUPPORT)
      value = Math.floor(value);
    if (value < 0)
      value = 0xff + value + 1;
    this[offset] = value;
    return offset + 1;
  };
  Buffer.prototype.writeInt16LE = function(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert)
      checkInt(this, value, offset, 2, 0x7fff, -0x8000);
    if (Buffer.TYPED_ARRAY_SUPPORT) {
      this[offset] = value;
      this[offset + 1] = (value >>> 8);
    } else
      objectWriteUInt16(this, value, offset, true);
    return offset + 2;
  };
  Buffer.prototype.writeInt16BE = function(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert)
      checkInt(this, value, offset, 2, 0x7fff, -0x8000);
    if (Buffer.TYPED_ARRAY_SUPPORT) {
      this[offset] = (value >>> 8);
      this[offset + 1] = value;
    } else
      objectWriteUInt16(this, value, offset, false);
    return offset + 2;
  };
  Buffer.prototype.writeInt32LE = function(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert)
      checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000);
    if (Buffer.TYPED_ARRAY_SUPPORT) {
      this[offset] = value;
      this[offset + 1] = (value >>> 8);
      this[offset + 2] = (value >>> 16);
      this[offset + 3] = (value >>> 24);
    } else
      objectWriteUInt32(this, value, offset, true);
    return offset + 4;
  };
  Buffer.prototype.writeInt32BE = function(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert)
      checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000);
    if (value < 0)
      value = 0xffffffff + value + 1;
    if (Buffer.TYPED_ARRAY_SUPPORT) {
      this[offset] = (value >>> 24);
      this[offset + 1] = (value >>> 16);
      this[offset + 2] = (value >>> 8);
      this[offset + 3] = value;
    } else
      objectWriteUInt32(this, value, offset, false);
    return offset + 4;
  };
  function checkIEEE754(buf, value, offset, ext, max, min) {
    if (value > max || value < min)
      throw new RangeError('value is out of bounds');
    if (offset + ext > buf.length)
      throw new RangeError('index out of range');
    if (offset < 0)
      throw new RangeError('index out of range');
  }
  function writeFloat(buf, value, offset, littleEndian, noAssert) {
    if (!noAssert)
      checkIEEE754(buf, value, offset, 4, 3.4028234663852886e+38, -3.4028234663852886e+38);
    ieee754.write(buf, value, offset, littleEndian, 23, 4);
    return offset + 4;
  }
  Buffer.prototype.writeFloatLE = function(value, offset, noAssert) {
    return writeFloat(this, value, offset, true, noAssert);
  };
  Buffer.prototype.writeFloatBE = function(value, offset, noAssert) {
    return writeFloat(this, value, offset, false, noAssert);
  };
  function writeDouble(buf, value, offset, littleEndian, noAssert) {
    if (!noAssert)
      checkIEEE754(buf, value, offset, 8, 1.7976931348623157E+308, -1.7976931348623157E+308);
    ieee754.write(buf, value, offset, littleEndian, 52, 8);
    return offset + 8;
  }
  Buffer.prototype.writeDoubleLE = function(value, offset, noAssert) {
    return writeDouble(this, value, offset, true, noAssert);
  };
  Buffer.prototype.writeDoubleBE = function(value, offset, noAssert) {
    return writeDouble(this, value, offset, false, noAssert);
  };
  Buffer.prototype.copy = function(target, target_start, start, end) {
    var self = this;
    if (!start)
      start = 0;
    if (!end && end !== 0)
      end = this.length;
    if (target_start >= target.length)
      target_start = target.length;
    if (!target_start)
      target_start = 0;
    if (end > 0 && end < start)
      end = start;
    if (end === start)
      return 0;
    if (target.length === 0 || self.length === 0)
      return 0;
    if (target_start < 0)
      throw new RangeError('targetStart out of bounds');
    if (start < 0 || start >= self.length)
      throw new RangeError('sourceStart out of bounds');
    if (end < 0)
      throw new RangeError('sourceEnd out of bounds');
    if (end > this.length)
      end = this.length;
    if (target.length - target_start < end - start)
      end = target.length - target_start + start;
    var len = end - start;
    if (len < 1000 || !Buffer.TYPED_ARRAY_SUPPORT) {
      for (var i = 0; i < len; i++) {
        target[i + target_start] = this[i + start];
      }
    } else {
      target._set(this.subarray(start, start + len), target_start);
    }
    return len;
  };
  Buffer.prototype.fill = function(value, start, end) {
    if (!value)
      value = 0;
    if (!start)
      start = 0;
    if (!end)
      end = this.length;
    if (end < start)
      throw new RangeError('end < start');
    if (end === start)
      return ;
    if (this.length === 0)
      return ;
    if (start < 0 || start >= this.length)
      throw new RangeError('start out of bounds');
    if (end < 0 || end > this.length)
      throw new RangeError('end out of bounds');
    var i;
    if (typeof value === 'number') {
      for (i = start; i < end; i++) {
        this[i] = value;
      }
    } else {
      var bytes = utf8ToBytes(value.toString());
      var len = bytes.length;
      for (i = start; i < end; i++) {
        this[i] = bytes[i % len];
      }
    }
    return this;
  };
  Buffer.prototype.toArrayBuffer = function() {
    if (typeof Uint8Array !== 'undefined') {
      if (Buffer.TYPED_ARRAY_SUPPORT) {
        return (new Buffer(this)).buffer;
      } else {
        var buf = new Uint8Array(this.length);
        for (var i = 0,
            len = buf.length; i < len; i += 1) {
          buf[i] = this[i];
        }
        return buf.buffer;
      }
    } else {
      throw new TypeError('Buffer.toArrayBuffer not supported in this browser');
    }
  };
  var BP = Buffer.prototype;
  Buffer._augment = function(arr) {
    arr.constructor = Buffer;
    arr._isBuffer = true;
    arr._get = arr.get;
    arr._set = arr.set;
    arr.get = BP.get;
    arr.set = BP.set;
    arr.write = BP.write;
    arr.toString = BP.toString;
    arr.toLocaleString = BP.toString;
    arr.toJSON = BP.toJSON;
    arr.equals = BP.equals;
    arr.compare = BP.compare;
    arr.copy = BP.copy;
    arr.slice = BP.slice;
    arr.readUIntLE = BP.readUIntLE;
    arr.readUIntBE = BP.readUIntBE;
    arr.readUInt8 = BP.readUInt8;
    arr.readUInt16LE = BP.readUInt16LE;
    arr.readUInt16BE = BP.readUInt16BE;
    arr.readUInt32LE = BP.readUInt32LE;
    arr.readUInt32BE = BP.readUInt32BE;
    arr.readIntLE = BP.readIntLE;
    arr.readIntBE = BP.readIntBE;
    arr.readInt8 = BP.readInt8;
    arr.readInt16LE = BP.readInt16LE;
    arr.readInt16BE = BP.readInt16BE;
    arr.readInt32LE = BP.readInt32LE;
    arr.readInt32BE = BP.readInt32BE;
    arr.readFloatLE = BP.readFloatLE;
    arr.readFloatBE = BP.readFloatBE;
    arr.readDoubleLE = BP.readDoubleLE;
    arr.readDoubleBE = BP.readDoubleBE;
    arr.writeUInt8 = BP.writeUInt8;
    arr.writeUIntLE = BP.writeUIntLE;
    arr.writeUIntBE = BP.writeUIntBE;
    arr.writeUInt16LE = BP.writeUInt16LE;
    arr.writeUInt16BE = BP.writeUInt16BE;
    arr.writeUInt32LE = BP.writeUInt32LE;
    arr.writeUInt32BE = BP.writeUInt32BE;
    arr.writeIntLE = BP.writeIntLE;
    arr.writeIntBE = BP.writeIntBE;
    arr.writeInt8 = BP.writeInt8;
    arr.writeInt16LE = BP.writeInt16LE;
    arr.writeInt16BE = BP.writeInt16BE;
    arr.writeInt32LE = BP.writeInt32LE;
    arr.writeInt32BE = BP.writeInt32BE;
    arr.writeFloatLE = BP.writeFloatLE;
    arr.writeFloatBE = BP.writeFloatBE;
    arr.writeDoubleLE = BP.writeDoubleLE;
    arr.writeDoubleBE = BP.writeDoubleBE;
    arr.fill = BP.fill;
    arr.inspect = BP.inspect;
    arr.toArrayBuffer = BP.toArrayBuffer;
    return arr;
  };
  var INVALID_BASE64_RE = /[^+\/0-9A-z\-]/g;
  function base64clean(str) {
    str = stringtrim(str).replace(INVALID_BASE64_RE, '');
    if (str.length < 2)
      return '';
    while (str.length % 4 !== 0) {
      str = str + '=';
    }
    return str;
  }
  function stringtrim(str) {
    if (str.trim)
      return str.trim();
    return str.replace(/^\s+|\s+$/g, '');
  }
  function isArrayish(subject) {
    return isArray(subject) || Buffer.isBuffer(subject) || subject && typeof subject === 'object' && typeof subject.length === 'number';
  }
  function toHex(n) {
    if (n < 16)
      return '0' + n.toString(16);
    return n.toString(16);
  }
  function utf8ToBytes(string, units) {
    units = units || Infinity;
    var codePoint;
    var length = string.length;
    var leadSurrogate = null;
    var bytes = [];
    var i = 0;
    for (; i < length; i++) {
      codePoint = string.charCodeAt(i);
      if (codePoint > 0xD7FF && codePoint < 0xE000) {
        if (leadSurrogate) {
          if (codePoint < 0xDC00) {
            if ((units -= 3) > -1)
              bytes.push(0xEF, 0xBF, 0xBD);
            leadSurrogate = codePoint;
            continue;
          } else {
            codePoint = leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00 | 0x10000;
            leadSurrogate = null;
          }
        } else {
          if (codePoint > 0xDBFF) {
            if ((units -= 3) > -1)
              bytes.push(0xEF, 0xBF, 0xBD);
            continue;
          } else if (i + 1 === length) {
            if ((units -= 3) > -1)
              bytes.push(0xEF, 0xBF, 0xBD);
            continue;
          } else {
            leadSurrogate = codePoint;
            continue;
          }
        }
      } else if (leadSurrogate) {
        if ((units -= 3) > -1)
          bytes.push(0xEF, 0xBF, 0xBD);
        leadSurrogate = null;
      }
      if (codePoint < 0x80) {
        if ((units -= 1) < 0)
          break;
        bytes.push(codePoint);
      } else if (codePoint < 0x800) {
        if ((units -= 2) < 0)
          break;
        bytes.push(codePoint >> 0x6 | 0xC0, codePoint & 0x3F | 0x80);
      } else if (codePoint < 0x10000) {
        if ((units -= 3) < 0)
          break;
        bytes.push(codePoint >> 0xC | 0xE0, codePoint >> 0x6 & 0x3F | 0x80, codePoint & 0x3F | 0x80);
      } else if (codePoint < 0x200000) {
        if ((units -= 4) < 0)
          break;
        bytes.push(codePoint >> 0x12 | 0xF0, codePoint >> 0xC & 0x3F | 0x80, codePoint >> 0x6 & 0x3F | 0x80, codePoint & 0x3F | 0x80);
      } else {
        throw new Error('Invalid code point');
      }
    }
    return bytes;
  }
  function asciiToBytes(str) {
    var byteArray = [];
    for (var i = 0; i < str.length; i++) {
      byteArray.push(str.charCodeAt(i) & 0xFF);
    }
    return byteArray;
  }
  function utf16leToBytes(str, units) {
    var c,
        hi,
        lo;
    var byteArray = [];
    for (var i = 0; i < str.length; i++) {
      if ((units -= 2) < 0)
        break;
      c = str.charCodeAt(i);
      hi = c >> 8;
      lo = c % 256;
      byteArray.push(lo);
      byteArray.push(hi);
    }
    return byteArray;
  }
  function base64ToBytes(str) {
    return base64.toByteArray(base64clean(str));
  }
  function blitBuffer(src, dst, offset, length) {
    for (var i = 0; i < length; i++) {
      if ((i + offset >= dst.length) || (i >= src.length))
        break;
      dst[i + offset] = src[i];
    }
    return i;
  }
  function decodeUtf8Char(str) {
    try {
      return decodeURIComponent(str);
    } catch (err) {
      return String.fromCharCode(0xFFFD);
    }
  }
  global.define = __define;
  return module.exports;
});



System.register("app/node-component-finder", ["app/event", "app/nodes/function-declaration.jsx!github:floatdrop/plugin-jsx@0.1.1", "app/nodes/block-statement.jsx!github:floatdrop/plugin-jsx@0.1.1", "app/nodes/expression-statement.jsx!github:floatdrop/plugin-jsx@0.1.1", "app/nodes/call-expression.jsx!github:floatdrop/plugin-jsx@0.1.1", "app/nodes/member-expression.jsx!github:floatdrop/plugin-jsx@0.1.1", "app/nodes/literal.jsx!github:floatdrop/plugin-jsx@0.1.1", "app/nodes/identifier.jsx!github:floatdrop/plugin-jsx@0.1.1", "app/nodes/variable-declaration.jsx!github:floatdrop/plugin-jsx@0.1.1", "app/nodes/variable-declarator.jsx!github:floatdrop/plugin-jsx@0.1.1", "app/nodes/object-expression.jsx!github:floatdrop/plugin-jsx@0.1.1", "app/nodes/property.jsx!github:floatdrop/plugin-jsx@0.1.1", "app/nodes/function-expression.jsx!github:floatdrop/plugin-jsx@0.1.1", "app/nodes/assignment-expression.jsx!github:floatdrop/plugin-jsx@0.1.1", "app/nodes/this-expression.jsx!github:floatdrop/plugin-jsx@0.1.1", "app/nodes/return-statement.jsx!github:floatdrop/plugin-jsx@0.1.1", "app/nodes/binary-expression.jsx!github:floatdrop/plugin-jsx@0.1.1", "app/nodes/for-statement.jsx!github:floatdrop/plugin-jsx@0.1.1", "app/nodes/update-expression.jsx!github:floatdrop/plugin-jsx@0.1.1", "app/nodes/if-statement.jsx!github:floatdrop/plugin-jsx@0.1.1", "app/nodes/break-statement.jsx!github:floatdrop/plugin-jsx@0.1.1"], function($__export) {
  "use strict";
  var __moduleName = "app/node-component-finder";
  var emitter,
      FunctionDeclaration,
      BlockStatement,
      ExpressionStatement,
      CallExpression,
      MemberExpression,
      Literal,
      Identifier,
      VariableDeclaration,
      VariableDeclarator,
      ObjectExpression,
      Property,
      FunctionExpression,
      AssignmentExpression,
      ThisExpression,
      ReturnStatement,
      BinaryExpression,
      ForStatement,
      UpdateExpression,
      IfStatement,
      BreakStatement,
      NODE_COMPONENTS;
  return {
    setters: [function($__m) {
      emitter = $__m.default;
    }, function($__m) {
      FunctionDeclaration = $__m.default;
    }, function($__m) {
      BlockStatement = $__m.default;
    }, function($__m) {
      ExpressionStatement = $__m.default;
    }, function($__m) {
      CallExpression = $__m.default;
    }, function($__m) {
      MemberExpression = $__m.default;
    }, function($__m) {
      Literal = $__m.default;
    }, function($__m) {
      Identifier = $__m.default;
    }, function($__m) {
      VariableDeclaration = $__m.default;
    }, function($__m) {
      VariableDeclarator = $__m.default;
    }, function($__m) {
      ObjectExpression = $__m.default;
    }, function($__m) {
      Property = $__m.default;
    }, function($__m) {
      FunctionExpression = $__m.default;
    }, function($__m) {
      AssignmentExpression = $__m.default;
    }, function($__m) {
      ThisExpression = $__m.default;
    }, function($__m) {
      ReturnStatement = $__m.default;
    }, function($__m) {
      BinaryExpression = $__m.default;
    }, function($__m) {
      ForStatement = $__m.default;
    }, function($__m) {
      UpdateExpression = $__m.default;
    }, function($__m) {
      IfStatement = $__m.default;
    }, function($__m) {
      BreakStatement = $__m.default;
    }],
    execute: function() {
      NODE_COMPONENTS = {
        FunctionDeclaration: FunctionDeclaration,
        BlockStatement: BlockStatement,
        ExpressionStatement: ExpressionStatement,
        CallExpression: CallExpression,
        MemberExpression: MemberExpression,
        Literal: Literal,
        Identifier: Identifier,
        VariableDeclaration: VariableDeclaration,
        VariableDeclarator: VariableDeclarator,
        ObjectExpression: ObjectExpression,
        Property: Property,
        FunctionExpression: FunctionExpression,
        AssignmentExpression: AssignmentExpression,
        ThisExpression: ThisExpression,
        ReturnStatement: ReturnStatement,
        BinaryExpression: BinaryExpression,
        ForStatement: ForStatement,
        UpdateExpression: UpdateExpression,
        IfStatement: IfStatement,
        BreakStatement: BreakStatement
      };
      $__export('default', function(type) {
        var component = NODE_COMPONENTS[type];
        if (component)
          return component;
        throw new Error(("No Component found for " + type));
      });
      ;
    }
  };
});



System.register("github:jspm/nodelibs-process@0.1.1", ["github:jspm/nodelibs-process@0.1.1/index"], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  module.exports = require("github:jspm/nodelibs-process@0.1.1/index");
  global.define = __define;
  return module.exports;
});



System.register("npm:react@0.12.2/lib/traverseAllChildren", ["npm:react@0.12.2/lib/ReactElement", "npm:react@0.12.2/lib/ReactInstanceHandles", "npm:react@0.12.2/lib/invariant", "github:jspm/nodelibs-process@0.1.1"], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  (function(process) {
    "use strict";
    var ReactElement = require("npm:react@0.12.2/lib/ReactElement");
    var ReactInstanceHandles = require("npm:react@0.12.2/lib/ReactInstanceHandles");
    var invariant = require("npm:react@0.12.2/lib/invariant");
    var SEPARATOR = ReactInstanceHandles.SEPARATOR;
    var SUBSEPARATOR = ':';
    var userProvidedKeyEscaperLookup = {
      '=': '=0',
      '.': '=1',
      ':': '=2'
    };
    var userProvidedKeyEscapeRegex = /[=.:]/g;
    function userProvidedKeyEscaper(match) {
      return userProvidedKeyEscaperLookup[match];
    }
    function getComponentKey(component, index) {
      if (component && component.key != null) {
        return wrapUserProvidedKey(component.key);
      }
      return index.toString(36);
    }
    function escapeUserProvidedKey(text) {
      return ('' + text).replace(userProvidedKeyEscapeRegex, userProvidedKeyEscaper);
    }
    function wrapUserProvidedKey(key) {
      return '$' + escapeUserProvidedKey(key);
    }
    var traverseAllChildrenImpl = function(children, nameSoFar, indexSoFar, callback, traverseContext) {
      var nextName,
          nextIndex;
      var subtreeCount = 0;
      if (Array.isArray(children)) {
        for (var i = 0; i < children.length; i++) {
          var child = children[i];
          nextName = (nameSoFar + (nameSoFar ? SUBSEPARATOR : SEPARATOR) + getComponentKey(child, i));
          nextIndex = indexSoFar + subtreeCount;
          subtreeCount += traverseAllChildrenImpl(child, nextName, nextIndex, callback, traverseContext);
        }
      } else {
        var type = typeof children;
        var isOnlyChild = nameSoFar === '';
        var storageName = isOnlyChild ? SEPARATOR + getComponentKey(children, 0) : nameSoFar;
        if (children == null || type === 'boolean') {
          callback(traverseContext, null, storageName, indexSoFar);
          subtreeCount = 1;
        } else if (type === 'string' || type === 'number' || ReactElement.isValidElement(children)) {
          callback(traverseContext, children, storageName, indexSoFar);
          subtreeCount = 1;
        } else if (type === 'object') {
          ("production" !== process.env.NODE_ENV ? invariant(!children || children.nodeType !== 1, 'traverseAllChildren(...): Encountered an invalid child; DOM ' + 'elements are not valid children of React components.') : invariant(!children || children.nodeType !== 1));
          for (var key in children) {
            if (children.hasOwnProperty(key)) {
              nextName = (nameSoFar + (nameSoFar ? SUBSEPARATOR : SEPARATOR) + wrapUserProvidedKey(key) + SUBSEPARATOR + getComponentKey(children[key], 0));
              nextIndex = indexSoFar + subtreeCount;
              subtreeCount += traverseAllChildrenImpl(children[key], nextName, nextIndex, callback, traverseContext);
            }
          }
        }
      }
      return subtreeCount;
    };
    function traverseAllChildren(children, callback, traverseContext) {
      if (children == null) {
        return 0;
      }
      return traverseAllChildrenImpl(children, '', 0, callback, traverseContext);
    }
    module.exports = traverseAllChildren;
  })(require("github:jspm/nodelibs-process@0.1.1"));
  global.define = __define;
  return module.exports;
});



System.register("npm:react@0.12.2/lib/ReactMount", ["npm:react@0.12.2/lib/DOMProperty", "npm:react@0.12.2/lib/ReactBrowserEventEmitter", "npm:react@0.12.2/lib/ReactCurrentOwner", "npm:react@0.12.2/lib/ReactElement", "npm:react@0.12.2/lib/ReactLegacyElement", "npm:react@0.12.2/lib/ReactInstanceHandles", "npm:react@0.12.2/lib/ReactPerf", "npm:react@0.12.2/lib/containsNode", "npm:react@0.12.2/lib/deprecated", "npm:react@0.12.2/lib/getReactRootElementInContainer", "npm:react@0.12.2/lib/instantiateReactComponent", "npm:react@0.12.2/lib/invariant", "npm:react@0.12.2/lib/shouldUpdateReactComponent", "npm:react@0.12.2/lib/warning", "github:jspm/nodelibs-process@0.1.1"], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  (function(process) {
    "use strict";
    var DOMProperty = require("npm:react@0.12.2/lib/DOMProperty");
    var ReactBrowserEventEmitter = require("npm:react@0.12.2/lib/ReactBrowserEventEmitter");
    var ReactCurrentOwner = require("npm:react@0.12.2/lib/ReactCurrentOwner");
    var ReactElement = require("npm:react@0.12.2/lib/ReactElement");
    var ReactLegacyElement = require("npm:react@0.12.2/lib/ReactLegacyElement");
    var ReactInstanceHandles = require("npm:react@0.12.2/lib/ReactInstanceHandles");
    var ReactPerf = require("npm:react@0.12.2/lib/ReactPerf");
    var containsNode = require("npm:react@0.12.2/lib/containsNode");
    var deprecated = require("npm:react@0.12.2/lib/deprecated");
    var getReactRootElementInContainer = require("npm:react@0.12.2/lib/getReactRootElementInContainer");
    var instantiateReactComponent = require("npm:react@0.12.2/lib/instantiateReactComponent");
    var invariant = require("npm:react@0.12.2/lib/invariant");
    var shouldUpdateReactComponent = require("npm:react@0.12.2/lib/shouldUpdateReactComponent");
    var warning = require("npm:react@0.12.2/lib/warning");
    var createElement = ReactLegacyElement.wrapCreateElement(ReactElement.createElement);
    var SEPARATOR = ReactInstanceHandles.SEPARATOR;
    var ATTR_NAME = DOMProperty.ID_ATTRIBUTE_NAME;
    var nodeCache = {};
    var ELEMENT_NODE_TYPE = 1;
    var DOC_NODE_TYPE = 9;
    var instancesByReactRootID = {};
    var containersByReactRootID = {};
    if ("production" !== process.env.NODE_ENV) {
      var rootElementsByReactRootID = {};
    }
    var findComponentRootReusableArray = [];
    function getReactRootID(container) {
      var rootElement = getReactRootElementInContainer(container);
      return rootElement && ReactMount.getID(rootElement);
    }
    function getID(node) {
      var id = internalGetID(node);
      if (id) {
        if (nodeCache.hasOwnProperty(id)) {
          var cached = nodeCache[id];
          if (cached !== node) {
            ("production" !== process.env.NODE_ENV ? invariant(!isValid(cached, id), 'ReactMount: Two valid but unequal nodes with the same `%s`: %s', ATTR_NAME, id) : invariant(!isValid(cached, id)));
            nodeCache[id] = node;
          }
        } else {
          nodeCache[id] = node;
        }
      }
      return id;
    }
    function internalGetID(node) {
      return node && node.getAttribute && node.getAttribute(ATTR_NAME) || '';
    }
    function setID(node, id) {
      var oldID = internalGetID(node);
      if (oldID !== id) {
        delete nodeCache[oldID];
      }
      node.setAttribute(ATTR_NAME, id);
      nodeCache[id] = node;
    }
    function getNode(id) {
      if (!nodeCache.hasOwnProperty(id) || !isValid(nodeCache[id], id)) {
        nodeCache[id] = ReactMount.findReactNodeByID(id);
      }
      return nodeCache[id];
    }
    function isValid(node, id) {
      if (node) {
        ("production" !== process.env.NODE_ENV ? invariant(internalGetID(node) === id, 'ReactMount: Unexpected modification of `%s`', ATTR_NAME) : invariant(internalGetID(node) === id));
        var container = ReactMount.findReactContainerForID(id);
        if (container && containsNode(container, node)) {
          return true;
        }
      }
      return false;
    }
    function purgeID(id) {
      delete nodeCache[id];
    }
    var deepestNodeSoFar = null;
    function findDeepestCachedAncestorImpl(ancestorID) {
      var ancestor = nodeCache[ancestorID];
      if (ancestor && isValid(ancestor, ancestorID)) {
        deepestNodeSoFar = ancestor;
      } else {
        return false;
      }
    }
    function findDeepestCachedAncestor(targetID) {
      deepestNodeSoFar = null;
      ReactInstanceHandles.traverseAncestors(targetID, findDeepestCachedAncestorImpl);
      var foundNode = deepestNodeSoFar;
      deepestNodeSoFar = null;
      return foundNode;
    }
    var ReactMount = {
      _instancesByReactRootID: instancesByReactRootID,
      scrollMonitor: function(container, renderCallback) {
        renderCallback();
      },
      _updateRootComponent: function(prevComponent, nextComponent, container, callback) {
        var nextProps = nextComponent.props;
        ReactMount.scrollMonitor(container, function() {
          prevComponent.replaceProps(nextProps, callback);
        });
        if ("production" !== process.env.NODE_ENV) {
          rootElementsByReactRootID[getReactRootID(container)] = getReactRootElementInContainer(container);
        }
        return prevComponent;
      },
      _registerComponent: function(nextComponent, container) {
        ("production" !== process.env.NODE_ENV ? invariant(container && (container.nodeType === ELEMENT_NODE_TYPE || container.nodeType === DOC_NODE_TYPE), '_registerComponent(...): Target container is not a DOM element.') : invariant(container && (container.nodeType === ELEMENT_NODE_TYPE || container.nodeType === DOC_NODE_TYPE)));
        ReactBrowserEventEmitter.ensureScrollValueMonitoring();
        var reactRootID = ReactMount.registerContainer(container);
        instancesByReactRootID[reactRootID] = nextComponent;
        return reactRootID;
      },
      _renderNewRootComponent: ReactPerf.measure('ReactMount', '_renderNewRootComponent', function(nextComponent, container, shouldReuseMarkup) {
        ("production" !== process.env.NODE_ENV ? warning(ReactCurrentOwner.current == null, '_renderNewRootComponent(): Render methods should be a pure function ' + 'of props and state; triggering nested component updates from ' + 'render is not allowed. If necessary, trigger nested updates in ' + 'componentDidUpdate.') : null);
        var componentInstance = instantiateReactComponent(nextComponent, null);
        var reactRootID = ReactMount._registerComponent(componentInstance, container);
        componentInstance.mountComponentIntoNode(reactRootID, container, shouldReuseMarkup);
        if ("production" !== process.env.NODE_ENV) {
          rootElementsByReactRootID[reactRootID] = getReactRootElementInContainer(container);
        }
        return componentInstance;
      }),
      render: function(nextElement, container, callback) {
        ("production" !== process.env.NODE_ENV ? invariant(ReactElement.isValidElement(nextElement), 'renderComponent(): Invalid component element.%s', (typeof nextElement === 'string' ? ' Instead of passing an element string, make sure to instantiate ' + 'it by passing it to React.createElement.' : ReactLegacyElement.isValidFactory(nextElement) ? ' Instead of passing a component class, make sure to instantiate ' + 'it by passing it to React.createElement.' : typeof nextElement.props !== "undefined" ? ' This may be caused by unintentionally loading two independent ' + 'copies of React.' : '')) : invariant(ReactElement.isValidElement(nextElement)));
        var prevComponent = instancesByReactRootID[getReactRootID(container)];
        if (prevComponent) {
          var prevElement = prevComponent._currentElement;
          if (shouldUpdateReactComponent(prevElement, nextElement)) {
            return ReactMount._updateRootComponent(prevComponent, nextElement, container, callback);
          } else {
            ReactMount.unmountComponentAtNode(container);
          }
        }
        var reactRootElement = getReactRootElementInContainer(container);
        var containerHasReactMarkup = reactRootElement && ReactMount.isRenderedByReact(reactRootElement);
        var shouldReuseMarkup = containerHasReactMarkup && !prevComponent;
        var component = ReactMount._renderNewRootComponent(nextElement, container, shouldReuseMarkup);
        callback && callback.call(component);
        return component;
      },
      constructAndRenderComponent: function(constructor, props, container) {
        var element = createElement(constructor, props);
        return ReactMount.render(element, container);
      },
      constructAndRenderComponentByID: function(constructor, props, id) {
        var domNode = document.getElementById(id);
        ("production" !== process.env.NODE_ENV ? invariant(domNode, 'Tried to get element with id of "%s" but it is not present on the page.', id) : invariant(domNode));
        return ReactMount.constructAndRenderComponent(constructor, props, domNode);
      },
      registerContainer: function(container) {
        var reactRootID = getReactRootID(container);
        if (reactRootID) {
          reactRootID = ReactInstanceHandles.getReactRootIDFromNodeID(reactRootID);
        }
        if (!reactRootID) {
          reactRootID = ReactInstanceHandles.createReactRootID();
        }
        containersByReactRootID[reactRootID] = container;
        return reactRootID;
      },
      unmountComponentAtNode: function(container) {
        ("production" !== process.env.NODE_ENV ? warning(ReactCurrentOwner.current == null, 'unmountComponentAtNode(): Render methods should be a pure function of ' + 'props and state; triggering nested component updates from render is ' + 'not allowed. If necessary, trigger nested updates in ' + 'componentDidUpdate.') : null);
        var reactRootID = getReactRootID(container);
        var component = instancesByReactRootID[reactRootID];
        if (!component) {
          return false;
        }
        ReactMount.unmountComponentFromNode(component, container);
        delete instancesByReactRootID[reactRootID];
        delete containersByReactRootID[reactRootID];
        if ("production" !== process.env.NODE_ENV) {
          delete rootElementsByReactRootID[reactRootID];
        }
        return true;
      },
      unmountComponentFromNode: function(instance, container) {
        instance.unmountComponent();
        if (container.nodeType === DOC_NODE_TYPE) {
          container = container.documentElement;
        }
        while (container.lastChild) {
          container.removeChild(container.lastChild);
        }
      },
      findReactContainerForID: function(id) {
        var reactRootID = ReactInstanceHandles.getReactRootIDFromNodeID(id);
        var container = containersByReactRootID[reactRootID];
        if ("production" !== process.env.NODE_ENV) {
          var rootElement = rootElementsByReactRootID[reactRootID];
          if (rootElement && rootElement.parentNode !== container) {
            ("production" !== process.env.NODE_ENV ? invariant(internalGetID(rootElement) === reactRootID, 'ReactMount: Root element ID differed from reactRootID.') : invariant(internalGetID(rootElement) === reactRootID));
            var containerChild = container.firstChild;
            if (containerChild && reactRootID === internalGetID(containerChild)) {
              rootElementsByReactRootID[reactRootID] = containerChild;
            } else {
              console.warn('ReactMount: Root element has been removed from its original ' + 'container. New container:', rootElement.parentNode);
            }
          }
        }
        return container;
      },
      findReactNodeByID: function(id) {
        var reactRoot = ReactMount.findReactContainerForID(id);
        return ReactMount.findComponentRoot(reactRoot, id);
      },
      isRenderedByReact: function(node) {
        if (node.nodeType !== 1) {
          return false;
        }
        var id = ReactMount.getID(node);
        return id ? id.charAt(0) === SEPARATOR : false;
      },
      getFirstReactDOM: function(node) {
        var current = node;
        while (current && current.parentNode !== current) {
          if (ReactMount.isRenderedByReact(current)) {
            return current;
          }
          current = current.parentNode;
        }
        return null;
      },
      findComponentRoot: function(ancestorNode, targetID) {
        var firstChildren = findComponentRootReusableArray;
        var childIndex = 0;
        var deepestAncestor = findDeepestCachedAncestor(targetID) || ancestorNode;
        firstChildren[0] = deepestAncestor.firstChild;
        firstChildren.length = 1;
        while (childIndex < firstChildren.length) {
          var child = firstChildren[childIndex++];
          var targetChild;
          while (child) {
            var childID = ReactMount.getID(child);
            if (childID) {
              if (targetID === childID) {
                targetChild = child;
              } else if (ReactInstanceHandles.isAncestorIDOf(childID, targetID)) {
                firstChildren.length = childIndex = 0;
                firstChildren.push(child.firstChild);
              }
            } else {
              firstChildren.push(child.firstChild);
            }
            child = child.nextSibling;
          }
          if (targetChild) {
            firstChildren.length = 0;
            return targetChild;
          }
        }
        firstChildren.length = 0;
        ("production" !== process.env.NODE_ENV ? invariant(false, 'findComponentRoot(..., %s): Unable to find element. This probably ' + 'means the DOM was unexpectedly mutated (e.g., by the browser), ' + 'usually due to forgetting a <tbody> when using tables, nesting tags ' + 'like <form>, <p>, or <a>, or using non-SVG elements in an <svg> ' + 'parent. ' + 'Try inspecting the child nodes of the element with React ID `%s`.', targetID, ReactMount.getID(ancestorNode)) : invariant(false));
      },
      getReactRootID: getReactRootID,
      getID: getID,
      setID: setID,
      getNode: getNode,
      purgeID: purgeID
    };
    ReactMount.renderComponent = deprecated('ReactMount', 'renderComponent', 'render', this, ReactMount.render);
    module.exports = ReactMount;
  })(require("github:jspm/nodelibs-process@0.1.1"));
  global.define = __define;
  return module.exports;
});



System.register("npm:react@0.12.2/lib/BeforeInputEventPlugin", ["npm:react@0.12.2/lib/EventConstants", "npm:react@0.12.2/lib/EventPropagators", "npm:react@0.12.2/lib/ExecutionEnvironment", "npm:react@0.12.2/lib/SyntheticInputEvent", "npm:react@0.12.2/lib/keyOf"], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  "use strict";
  var EventConstants = require("npm:react@0.12.2/lib/EventConstants");
  var EventPropagators = require("npm:react@0.12.2/lib/EventPropagators");
  var ExecutionEnvironment = require("npm:react@0.12.2/lib/ExecutionEnvironment");
  var SyntheticInputEvent = require("npm:react@0.12.2/lib/SyntheticInputEvent");
  var keyOf = require("npm:react@0.12.2/lib/keyOf");
  var canUseTextInputEvent = (ExecutionEnvironment.canUseDOM && 'TextEvent' in window && !('documentMode' in document || isPresto()));
  function isPresto() {
    var opera = window.opera;
    return (typeof opera === 'object' && typeof opera.version === 'function' && parseInt(opera.version(), 10) <= 12);
  }
  var SPACEBAR_CODE = 32;
  var SPACEBAR_CHAR = String.fromCharCode(SPACEBAR_CODE);
  var topLevelTypes = EventConstants.topLevelTypes;
  var eventTypes = {beforeInput: {
      phasedRegistrationNames: {
        bubbled: keyOf({onBeforeInput: null}),
        captured: keyOf({onBeforeInputCapture: null})
      },
      dependencies: [topLevelTypes.topCompositionEnd, topLevelTypes.topKeyPress, topLevelTypes.topTextInput, topLevelTypes.topPaste]
    }};
  var fallbackChars = null;
  var hasSpaceKeypress = false;
  function isKeypressCommand(nativeEvent) {
    return ((nativeEvent.ctrlKey || nativeEvent.altKey || nativeEvent.metaKey) && !(nativeEvent.ctrlKey && nativeEvent.altKey));
  }
  var BeforeInputEventPlugin = {
    eventTypes: eventTypes,
    extractEvents: function(topLevelType, topLevelTarget, topLevelTargetID, nativeEvent) {
      var chars;
      if (canUseTextInputEvent) {
        switch (topLevelType) {
          case topLevelTypes.topKeyPress:
            var which = nativeEvent.which;
            if (which !== SPACEBAR_CODE) {
              return ;
            }
            hasSpaceKeypress = true;
            chars = SPACEBAR_CHAR;
            break;
          case topLevelTypes.topTextInput:
            chars = nativeEvent.data;
            if (chars === SPACEBAR_CHAR && hasSpaceKeypress) {
              return ;
            }
            break;
          default:
            return ;
        }
      } else {
        switch (topLevelType) {
          case topLevelTypes.topPaste:
            fallbackChars = null;
            break;
          case topLevelTypes.topKeyPress:
            if (nativeEvent.which && !isKeypressCommand(nativeEvent)) {
              fallbackChars = String.fromCharCode(nativeEvent.which);
            }
            break;
          case topLevelTypes.topCompositionEnd:
            fallbackChars = nativeEvent.data;
            break;
        }
        if (fallbackChars === null) {
          return ;
        }
        chars = fallbackChars;
      }
      if (!chars) {
        return ;
      }
      var event = SyntheticInputEvent.getPooled(eventTypes.beforeInput, topLevelTargetID, nativeEvent);
      event.data = chars;
      fallbackChars = null;
      EventPropagators.accumulateTwoPhaseDispatches(event);
      return event;
    }
  };
  module.exports = BeforeInputEventPlugin;
  global.define = __define;
  return module.exports;
});



System.register("npm:react@0.12.2/lib/CompositionEventPlugin", ["npm:react@0.12.2/lib/EventConstants", "npm:react@0.12.2/lib/EventPropagators", "npm:react@0.12.2/lib/ExecutionEnvironment", "npm:react@0.12.2/lib/ReactInputSelection", "npm:react@0.12.2/lib/SyntheticCompositionEvent", "npm:react@0.12.2/lib/getTextContentAccessor", "npm:react@0.12.2/lib/keyOf"], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  "use strict";
  var EventConstants = require("npm:react@0.12.2/lib/EventConstants");
  var EventPropagators = require("npm:react@0.12.2/lib/EventPropagators");
  var ExecutionEnvironment = require("npm:react@0.12.2/lib/ExecutionEnvironment");
  var ReactInputSelection = require("npm:react@0.12.2/lib/ReactInputSelection");
  var SyntheticCompositionEvent = require("npm:react@0.12.2/lib/SyntheticCompositionEvent");
  var getTextContentAccessor = require("npm:react@0.12.2/lib/getTextContentAccessor");
  var keyOf = require("npm:react@0.12.2/lib/keyOf");
  var END_KEYCODES = [9, 13, 27, 32];
  var START_KEYCODE = 229;
  var useCompositionEvent = (ExecutionEnvironment.canUseDOM && 'CompositionEvent' in window);
  var useFallbackData = (!useCompositionEvent || ('documentMode' in document && document.documentMode > 8 && document.documentMode <= 11));
  var topLevelTypes = EventConstants.topLevelTypes;
  var currentComposition = null;
  var eventTypes = {
    compositionEnd: {
      phasedRegistrationNames: {
        bubbled: keyOf({onCompositionEnd: null}),
        captured: keyOf({onCompositionEndCapture: null})
      },
      dependencies: [topLevelTypes.topBlur, topLevelTypes.topCompositionEnd, topLevelTypes.topKeyDown, topLevelTypes.topKeyPress, topLevelTypes.topKeyUp, topLevelTypes.topMouseDown]
    },
    compositionStart: {
      phasedRegistrationNames: {
        bubbled: keyOf({onCompositionStart: null}),
        captured: keyOf({onCompositionStartCapture: null})
      },
      dependencies: [topLevelTypes.topBlur, topLevelTypes.topCompositionStart, topLevelTypes.topKeyDown, topLevelTypes.topKeyPress, topLevelTypes.topKeyUp, topLevelTypes.topMouseDown]
    },
    compositionUpdate: {
      phasedRegistrationNames: {
        bubbled: keyOf({onCompositionUpdate: null}),
        captured: keyOf({onCompositionUpdateCapture: null})
      },
      dependencies: [topLevelTypes.topBlur, topLevelTypes.topCompositionUpdate, topLevelTypes.topKeyDown, topLevelTypes.topKeyPress, topLevelTypes.topKeyUp, topLevelTypes.topMouseDown]
    }
  };
  function getCompositionEventType(topLevelType) {
    switch (topLevelType) {
      case topLevelTypes.topCompositionStart:
        return eventTypes.compositionStart;
      case topLevelTypes.topCompositionEnd:
        return eventTypes.compositionEnd;
      case topLevelTypes.topCompositionUpdate:
        return eventTypes.compositionUpdate;
    }
  }
  function isFallbackStart(topLevelType, nativeEvent) {
    return (topLevelType === topLevelTypes.topKeyDown && nativeEvent.keyCode === START_KEYCODE);
  }
  function isFallbackEnd(topLevelType, nativeEvent) {
    switch (topLevelType) {
      case topLevelTypes.topKeyUp:
        return (END_KEYCODES.indexOf(nativeEvent.keyCode) !== -1);
      case topLevelTypes.topKeyDown:
        return (nativeEvent.keyCode !== START_KEYCODE);
      case topLevelTypes.topKeyPress:
      case topLevelTypes.topMouseDown:
      case topLevelTypes.topBlur:
        return true;
      default:
        return false;
    }
  }
  function FallbackCompositionState(root) {
    this.root = root;
    this.startSelection = ReactInputSelection.getSelection(root);
    this.startValue = this.getText();
  }
  FallbackCompositionState.prototype.getText = function() {
    return this.root.value || this.root[getTextContentAccessor()];
  };
  FallbackCompositionState.prototype.getData = function() {
    var endValue = this.getText();
    var prefixLength = this.startSelection.start;
    var suffixLength = this.startValue.length - this.startSelection.end;
    return endValue.substr(prefixLength, endValue.length - suffixLength - prefixLength);
  };
  var CompositionEventPlugin = {
    eventTypes: eventTypes,
    extractEvents: function(topLevelType, topLevelTarget, topLevelTargetID, nativeEvent) {
      var eventType;
      var data;
      if (useCompositionEvent) {
        eventType = getCompositionEventType(topLevelType);
      } else if (!currentComposition) {
        if (isFallbackStart(topLevelType, nativeEvent)) {
          eventType = eventTypes.compositionStart;
        }
      } else if (isFallbackEnd(topLevelType, nativeEvent)) {
        eventType = eventTypes.compositionEnd;
      }
      if (useFallbackData) {
        if (!currentComposition && eventType === eventTypes.compositionStart) {
          currentComposition = new FallbackCompositionState(topLevelTarget);
        } else if (eventType === eventTypes.compositionEnd) {
          if (currentComposition) {
            data = currentComposition.getData();
            currentComposition = null;
          }
        }
      }
      if (eventType) {
        var event = SyntheticCompositionEvent.getPooled(eventType, topLevelTargetID, nativeEvent);
        if (data) {
          event.data = data;
        }
        EventPropagators.accumulateTwoPhaseDispatches(event);
        return event;
      }
    }
  };
  module.exports = CompositionEventPlugin;
  global.define = __define;
  return module.exports;
});



System.register("npm:react@0.12.2/lib/Danger", ["npm:react@0.12.2/lib/ExecutionEnvironment", "npm:react@0.12.2/lib/createNodesFromMarkup", "npm:react@0.12.2/lib/emptyFunction", "npm:react@0.12.2/lib/getMarkupWrap", "npm:react@0.12.2/lib/invariant", "github:jspm/nodelibs-process@0.1.1"], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  (function(process) {
    "use strict";
    var ExecutionEnvironment = require("npm:react@0.12.2/lib/ExecutionEnvironment");
    var createNodesFromMarkup = require("npm:react@0.12.2/lib/createNodesFromMarkup");
    var emptyFunction = require("npm:react@0.12.2/lib/emptyFunction");
    var getMarkupWrap = require("npm:react@0.12.2/lib/getMarkupWrap");
    var invariant = require("npm:react@0.12.2/lib/invariant");
    var OPEN_TAG_NAME_EXP = /^(<[^ \/>]+)/;
    var RESULT_INDEX_ATTR = 'data-danger-index';
    function getNodeName(markup) {
      return markup.substring(1, markup.indexOf(' '));
    }
    var Danger = {
      dangerouslyRenderMarkup: function(markupList) {
        ("production" !== process.env.NODE_ENV ? invariant(ExecutionEnvironment.canUseDOM, 'dangerouslyRenderMarkup(...): Cannot render markup in a worker ' + 'thread. Make sure `window` and `document` are available globally ' + 'before requiring React when unit testing or use ' + 'React.renderToString for server rendering.') : invariant(ExecutionEnvironment.canUseDOM));
        var nodeName;
        var markupByNodeName = {};
        for (var i = 0; i < markupList.length; i++) {
          ("production" !== process.env.NODE_ENV ? invariant(markupList[i], 'dangerouslyRenderMarkup(...): Missing markup.') : invariant(markupList[i]));
          nodeName = getNodeName(markupList[i]);
          nodeName = getMarkupWrap(nodeName) ? nodeName : '*';
          markupByNodeName[nodeName] = markupByNodeName[nodeName] || [];
          markupByNodeName[nodeName][i] = markupList[i];
        }
        var resultList = [];
        var resultListAssignmentCount = 0;
        for (nodeName in markupByNodeName) {
          if (!markupByNodeName.hasOwnProperty(nodeName)) {
            continue;
          }
          var markupListByNodeName = markupByNodeName[nodeName];
          for (var resultIndex in markupListByNodeName) {
            if (markupListByNodeName.hasOwnProperty(resultIndex)) {
              var markup = markupListByNodeName[resultIndex];
              markupListByNodeName[resultIndex] = markup.replace(OPEN_TAG_NAME_EXP, '$1 ' + RESULT_INDEX_ATTR + '="' + resultIndex + '" ');
            }
          }
          var renderNodes = createNodesFromMarkup(markupListByNodeName.join(''), emptyFunction);
          for (i = 0; i < renderNodes.length; ++i) {
            var renderNode = renderNodes[i];
            if (renderNode.hasAttribute && renderNode.hasAttribute(RESULT_INDEX_ATTR)) {
              resultIndex = +renderNode.getAttribute(RESULT_INDEX_ATTR);
              renderNode.removeAttribute(RESULT_INDEX_ATTR);
              ("production" !== process.env.NODE_ENV ? invariant(!resultList.hasOwnProperty(resultIndex), 'Danger: Assigning to an already-occupied result index.') : invariant(!resultList.hasOwnProperty(resultIndex)));
              resultList[resultIndex] = renderNode;
              resultListAssignmentCount += 1;
            } else if ("production" !== process.env.NODE_ENV) {
              console.error("Danger: Discarding unexpected node:", renderNode);
            }
          }
        }
        ("production" !== process.env.NODE_ENV ? invariant(resultListAssignmentCount === resultList.length, 'Danger: Did not assign to every index of resultList.') : invariant(resultListAssignmentCount === resultList.length));
        ("production" !== process.env.NODE_ENV ? invariant(resultList.length === markupList.length, 'Danger: Expected markup to render %s nodes, but rendered %s.', markupList.length, resultList.length) : invariant(resultList.length === markupList.length));
        return resultList;
      },
      dangerouslyReplaceNodeWithMarkup: function(oldChild, markup) {
        ("production" !== process.env.NODE_ENV ? invariant(ExecutionEnvironment.canUseDOM, 'dangerouslyReplaceNodeWithMarkup(...): Cannot render markup in a ' + 'worker thread. Make sure `window` and `document` are available ' + 'globally before requiring React when unit testing or use ' + 'React.renderToString for server rendering.') : invariant(ExecutionEnvironment.canUseDOM));
        ("production" !== process.env.NODE_ENV ? invariant(markup, 'dangerouslyReplaceNodeWithMarkup(...): Missing markup.') : invariant(markup));
        ("production" !== process.env.NODE_ENV ? invariant(oldChild.tagName.toLowerCase() !== 'html', 'dangerouslyReplaceNodeWithMarkup(...): Cannot replace markup of the ' + '<html> node. This is because browser quirks make this unreliable ' + 'and/or slow. If you want to render to the root you must use ' + 'server rendering. See renderComponentToString().') : invariant(oldChild.tagName.toLowerCase() !== 'html'));
        var newChild = createNodesFromMarkup(markup, emptyFunction)[0];
        oldChild.parentNode.replaceChild(newChild, oldChild);
      }
    };
    module.exports = Danger;
  })(require("github:jspm/nodelibs-process@0.1.1"));
  global.define = __define;
  return module.exports;
});



System.register("npm:es5-ext@0.10.6/object/assign/index", ["npm:es5-ext@0.10.6/object/assign/is-implemented", "npm:es5-ext@0.10.6/object/assign/shim"], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  'use strict';
  module.exports = require("npm:es5-ext@0.10.6/object/assign/is-implemented")() ? Object.assign : require("npm:es5-ext@0.10.6/object/assign/shim");
  global.define = __define;
  return module.exports;
});



System.register("npm:brace@0.5.0", ["npm:brace@0.5.0/index"], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  module.exports = require("npm:brace@0.5.0/index");
  global.define = __define;
  return module.exports;
});



System.register("npm:buffer@3.0.3", ["npm:buffer@3.0.3/index"], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  module.exports = require("npm:buffer@3.0.3/index");
  global.define = __define;
  return module.exports;
});



System.register("app/ast-node.jsx!github:floatdrop/plugin-jsx@0.1.1", ["npm:react@0.12.2", "npm:lodash@3.3.1", "app/node-component-finder", "app/mixins/toggle", "app/path.jsx!github:floatdrop/plugin-jsx@0.1.1", "app/mixins/path", "app/event", "app/node-location.jsx!github:floatdrop/plugin-jsx@0.1.1", "app/null-nodes"], function($__export) {
  "use strict";
  var __moduleName = "app/ast-node.jsx!github:floatdrop/plugin-jsx@0.1.1";
  var React,
      _,
      componentFinder,
      ToggleMixin,
      Path,
      PathMixin,
      emitter,
      NodeLocation,
      NULL_NODE_TYPES;
  return {
    setters: [function($__m) {
      React = $__m.default;
    }, function($__m) {
      _ = $__m.default;
    }, function($__m) {
      componentFinder = $__m.default;
    }, function($__m) {
      ToggleMixin = $__m.default;
    }, function($__m) {
      Path = $__m.default;
    }, function($__m) {
      PathMixin = $__m.default;
    }, function($__m) {
      emitter = $__m.default;
    }, function($__m) {
      NodeLocation = $__m.default;
    }, function($__m) {
      NULL_NODE_TYPES = $__m.default;
    }],
    execute: function() {
      $__export('default', React.createClass({
        mixins: [ToggleMixin, PathMixin],
        onMouseEnter: function(e) {
          e.stopPropagation();
          emitter.emit('active-node', this.props.node);
          this.setState({isFocused: true});
        },
        onMouseLeave: function(e) {
          e.stopPropagation();
          emitter.emit('deactive-node', this.props.node);
          this.setState({isFocused: false});
        },
        getRenderedContent: function() {
          if (this._content)
            return this._content;
          var newElementComponent = componentFinder(this.props.node.type);
          if (newElementComponent) {
            this._content = React.createElement(newElementComponent, this.props);
            return this._content;
          } else {
            console.err('No element found for node', this.props.node);
          }
        },
        isNullNode: function() {
          return NULL_NODE_TYPES.indexOf(this.props.node.type) > -1;
        },
        renderKey: function() {
          if (!this.props.nodeKey)
            return null;
          return React.createElement("span", {className: "node-key"}, (this.props.nodeKey + ": "));
        },
        renderHeading: function() {
          return (React.createElement("h4", null, this.renderKey(), this.props.node.type, React.createElement(NodeLocation, {loc: this.props.node.loc})));
        },
        renderContent: function() {
          if (this.isNullNode())
            return null;
          return (React.createElement("div", {className: this.state.visible ? 'visible' : 'hidden'}, this.getRenderedContent()));
        },
        renderToggle: function() {
          var internalText = this.state.visible ? '-' : '+';
          if (this.isNullNode())
            return null;
          return (React.createElement("a", {
            href: "#",
            className: "toggle-icon",
            onClick: this.onToggleClick
          }, internalText));
        },
        render: function() {
          var outputProperties = this.getRenderedContent();
          return (React.createElement("div", {
            className: ("ast-node " + this.props.node.type),
            onMouseLeave: this.onMouseLeave,
            onMouseEnter: this.onMouseEnter
          }, React.createElement(Path, {
            path: this.path(),
            visible: this.state.isFocused
          }), React.createElement("div", {className: "ast-node-head"}, this.renderToggle(), this.renderHeading()), React.createElement("div", {className: "ast-node-children"}, this.renderContent())));
        }
      }));
    }
  };
});



System.register("npm:react@0.12.2/lib/invariant", ["github:jspm/nodelibs-process@0.1.1"], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  (function(process) {
    "use strict";
    var invariant = function(condition, format, a, b, c, d, e, f) {
      if ("production" !== process.env.NODE_ENV) {
        if (format === undefined) {
          throw new Error('invariant requires an error message argument');
        }
      }
      if (!condition) {
        var error;
        if (format === undefined) {
          error = new Error('Minified exception occurred; use the non-minified dev environment ' + 'for the full error message and additional helpful warnings.');
        } else {
          var args = [a, b, c, d, e, f];
          var argIndex = 0;
          error = new Error('Invariant Violation: ' + format.replace(/%s/g, function() {
            return args[argIndex++];
          }));
        }
        error.framesToPop = 1;
        throw error;
      }
    };
    module.exports = invariant;
  })(require("github:jspm/nodelibs-process@0.1.1"));
  global.define = __define;
  return module.exports;
});



System.register("npm:react@0.12.2/lib/ReactChildren", ["npm:react@0.12.2/lib/PooledClass", "npm:react@0.12.2/lib/traverseAllChildren", "npm:react@0.12.2/lib/warning", "github:jspm/nodelibs-process@0.1.1"], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  (function(process) {
    "use strict";
    var PooledClass = require("npm:react@0.12.2/lib/PooledClass");
    var traverseAllChildren = require("npm:react@0.12.2/lib/traverseAllChildren");
    var warning = require("npm:react@0.12.2/lib/warning");
    var twoArgumentPooler = PooledClass.twoArgumentPooler;
    var threeArgumentPooler = PooledClass.threeArgumentPooler;
    function ForEachBookKeeping(forEachFunction, forEachContext) {
      this.forEachFunction = forEachFunction;
      this.forEachContext = forEachContext;
    }
    PooledClass.addPoolingTo(ForEachBookKeeping, twoArgumentPooler);
    function forEachSingleChild(traverseContext, child, name, i) {
      var forEachBookKeeping = traverseContext;
      forEachBookKeeping.forEachFunction.call(forEachBookKeeping.forEachContext, child, i);
    }
    function forEachChildren(children, forEachFunc, forEachContext) {
      if (children == null) {
        return children;
      }
      var traverseContext = ForEachBookKeeping.getPooled(forEachFunc, forEachContext);
      traverseAllChildren(children, forEachSingleChild, traverseContext);
      ForEachBookKeeping.release(traverseContext);
    }
    function MapBookKeeping(mapResult, mapFunction, mapContext) {
      this.mapResult = mapResult;
      this.mapFunction = mapFunction;
      this.mapContext = mapContext;
    }
    PooledClass.addPoolingTo(MapBookKeeping, threeArgumentPooler);
    function mapSingleChildIntoContext(traverseContext, child, name, i) {
      var mapBookKeeping = traverseContext;
      var mapResult = mapBookKeeping.mapResult;
      var keyUnique = !mapResult.hasOwnProperty(name);
      ("production" !== process.env.NODE_ENV ? warning(keyUnique, 'ReactChildren.map(...): Encountered two children with the same key, ' + '`%s`. Child keys must be unique; when two children share a key, only ' + 'the first child will be used.', name) : null);
      if (keyUnique) {
        var mappedChild = mapBookKeeping.mapFunction.call(mapBookKeeping.mapContext, child, i);
        mapResult[name] = mappedChild;
      }
    }
    function mapChildren(children, func, context) {
      if (children == null) {
        return children;
      }
      var mapResult = {};
      var traverseContext = MapBookKeeping.getPooled(mapResult, func, context);
      traverseAllChildren(children, mapSingleChildIntoContext, traverseContext);
      MapBookKeeping.release(traverseContext);
      return mapResult;
    }
    function forEachSingleChildDummy(traverseContext, child, name, i) {
      return null;
    }
    function countChildren(children, context) {
      return traverseAllChildren(children, forEachSingleChildDummy, null);
    }
    var ReactChildren = {
      forEach: forEachChildren,
      map: mapChildren,
      count: countChildren
    };
    module.exports = ReactChildren;
  })(require("github:jspm/nodelibs-process@0.1.1"));
  global.define = __define;
  return module.exports;
});



System.register("npm:react@0.12.2/lib/ReactBrowserComponentMixin", ["npm:react@0.12.2/lib/ReactEmptyComponent", "npm:react@0.12.2/lib/ReactMount", "npm:react@0.12.2/lib/invariant", "github:jspm/nodelibs-process@0.1.1"], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  (function(process) {
    "use strict";
    var ReactEmptyComponent = require("npm:react@0.12.2/lib/ReactEmptyComponent");
    var ReactMount = require("npm:react@0.12.2/lib/ReactMount");
    var invariant = require("npm:react@0.12.2/lib/invariant");
    var ReactBrowserComponentMixin = {getDOMNode: function() {
        ("production" !== process.env.NODE_ENV ? invariant(this.isMounted(), 'getDOMNode(): A component must be mounted to have a DOM node.') : invariant(this.isMounted()));
        if (ReactEmptyComponent.isNullComponentID(this._rootNodeID)) {
          return null;
        }
        return ReactMount.getNode(this._rootNodeID);
      }};
    module.exports = ReactBrowserComponentMixin;
  })(require("github:jspm/nodelibs-process@0.1.1"));
  global.define = __define;
  return module.exports;
});



System.register("npm:react@0.12.2/lib/DOMChildrenOperations", ["npm:react@0.12.2/lib/Danger", "npm:react@0.12.2/lib/ReactMultiChildUpdateTypes", "npm:react@0.12.2/lib/getTextContentAccessor", "npm:react@0.12.2/lib/invariant", "github:jspm/nodelibs-process@0.1.1"], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  (function(process) {
    "use strict";
    var Danger = require("npm:react@0.12.2/lib/Danger");
    var ReactMultiChildUpdateTypes = require("npm:react@0.12.2/lib/ReactMultiChildUpdateTypes");
    var getTextContentAccessor = require("npm:react@0.12.2/lib/getTextContentAccessor");
    var invariant = require("npm:react@0.12.2/lib/invariant");
    var textContentAccessor = getTextContentAccessor();
    function insertChildAt(parentNode, childNode, index) {
      parentNode.insertBefore(childNode, parentNode.childNodes[index] || null);
    }
    var updateTextContent;
    if (textContentAccessor === 'textContent') {
      updateTextContent = function(node, text) {
        node.textContent = text;
      };
    } else {
      updateTextContent = function(node, text) {
        while (node.firstChild) {
          node.removeChild(node.firstChild);
        }
        if (text) {
          var doc = node.ownerDocument || document;
          node.appendChild(doc.createTextNode(text));
        }
      };
    }
    var DOMChildrenOperations = {
      dangerouslyReplaceNodeWithMarkup: Danger.dangerouslyReplaceNodeWithMarkup,
      updateTextContent: updateTextContent,
      processUpdates: function(updates, markupList) {
        var update;
        var initialChildren = null;
        var updatedChildren = null;
        for (var i = 0; update = updates[i]; i++) {
          if (update.type === ReactMultiChildUpdateTypes.MOVE_EXISTING || update.type === ReactMultiChildUpdateTypes.REMOVE_NODE) {
            var updatedIndex = update.fromIndex;
            var updatedChild = update.parentNode.childNodes[updatedIndex];
            var parentID = update.parentID;
            ("production" !== process.env.NODE_ENV ? invariant(updatedChild, 'processUpdates(): Unable to find child %s of element. This ' + 'probably means the DOM was unexpectedly mutated (e.g., by the ' + 'browser), usually due to forgetting a <tbody> when using tables, ' + 'nesting tags like <form>, <p>, or <a>, or using non-SVG elements ' + 'in an <svg> parent. Try inspecting the child nodes of the element ' + 'with React ID `%s`.', updatedIndex, parentID) : invariant(updatedChild));
            initialChildren = initialChildren || {};
            initialChildren[parentID] = initialChildren[parentID] || [];
            initialChildren[parentID][updatedIndex] = updatedChild;
            updatedChildren = updatedChildren || [];
            updatedChildren.push(updatedChild);
          }
        }
        var renderedMarkup = Danger.dangerouslyRenderMarkup(markupList);
        if (updatedChildren) {
          for (var j = 0; j < updatedChildren.length; j++) {
            updatedChildren[j].parentNode.removeChild(updatedChildren[j]);
          }
        }
        for (var k = 0; update = updates[k]; k++) {
          switch (update.type) {
            case ReactMultiChildUpdateTypes.INSERT_MARKUP:
              insertChildAt(update.parentNode, renderedMarkup[update.markupIndex], update.toIndex);
              break;
            case ReactMultiChildUpdateTypes.MOVE_EXISTING:
              insertChildAt(update.parentNode, initialChildren[update.parentID][update.fromIndex], update.toIndex);
              break;
            case ReactMultiChildUpdateTypes.TEXT_CONTENT:
              updateTextContent(update.parentNode, update.textContent);
              break;
            case ReactMultiChildUpdateTypes.REMOVE_NODE:
              break;
          }
        }
      }
    };
    module.exports = DOMChildrenOperations;
  })(require("github:jspm/nodelibs-process@0.1.1"));
  global.define = __define;
  return module.exports;
});



System.register("npm:es5-ext@0.10.6/object/assign", ["npm:es5-ext@0.10.6/object/assign/index"], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  module.exports = require("npm:es5-ext@0.10.6/object/assign/index");
  global.define = __define;
  return module.exports;
});



System.register("github:jspm/nodelibs-buffer@0.1.0/index", ["npm:buffer@3.0.3"], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  module.exports = System._nodeRequire ? System._nodeRequire('buffer') : require("npm:buffer@3.0.3");
  global.define = __define;
  return module.exports;
});



System.register("app/ast-output.jsx!github:floatdrop/plugin-jsx@0.1.1", ["npm:react@0.12.2", "npm:esprima@2.0.0", "app/ast-node.jsx!github:floatdrop/plugin-jsx@0.1.1"], function($__export) {
  "use strict";
  var __moduleName = "app/ast-output.jsx!github:floatdrop/plugin-jsx@0.1.1";
  var React,
      esprima,
      ASTNode;
  return {
    setters: [function($__m) {
      React = $__m.default;
    }, function($__m) {
      esprima = $__m.default;
    }, function($__m) {
      ASTNode = $__m.default;
    }],
    execute: function() {
      $__export('default', React.createClass({
        componentWillMount: function() {
          this.setState({tree: this.parseCode(this.props.code)});
        },
        componentWillReceiveProps: function(props) {
          this.setState({tree: this.parseCode(props.code)});
        },
        parseCode: function(code) {
          var tree = esprima.parse(code, {loc: true});
          console.log(tree);
          return tree;
        },
        render: function() {
          var nodes = this.state.tree.body.map((function(body, index) {
            return React.createElement("li", {key: JSON.stringify(body)}, React.createElement(ASTNode, {
              parentPath: ("/" + index),
              node: body
            }));
          }));
          return React.createElement("ul", null, nodes);
        }
      }));
    }
  };
});



System.register("npm:react@0.12.2/lib/DOMProperty", ["npm:react@0.12.2/lib/invariant", "github:jspm/nodelibs-process@0.1.1"], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  (function(process) {
    "use strict";
    var invariant = require("npm:react@0.12.2/lib/invariant");
    function checkMask(value, bitmask) {
      return (value & bitmask) === bitmask;
    }
    var DOMPropertyInjection = {
      MUST_USE_ATTRIBUTE: 0x1,
      MUST_USE_PROPERTY: 0x2,
      HAS_SIDE_EFFECTS: 0x4,
      HAS_BOOLEAN_VALUE: 0x8,
      HAS_NUMERIC_VALUE: 0x10,
      HAS_POSITIVE_NUMERIC_VALUE: 0x20 | 0x10,
      HAS_OVERLOADED_BOOLEAN_VALUE: 0x40,
      injectDOMPropertyConfig: function(domPropertyConfig) {
        var Properties = domPropertyConfig.Properties || {};
        var DOMAttributeNames = domPropertyConfig.DOMAttributeNames || {};
        var DOMPropertyNames = domPropertyConfig.DOMPropertyNames || {};
        var DOMMutationMethods = domPropertyConfig.DOMMutationMethods || {};
        if (domPropertyConfig.isCustomAttribute) {
          DOMProperty._isCustomAttributeFunctions.push(domPropertyConfig.isCustomAttribute);
        }
        for (var propName in Properties) {
          ("production" !== process.env.NODE_ENV ? invariant(!DOMProperty.isStandardName.hasOwnProperty(propName), 'injectDOMPropertyConfig(...): You\'re trying to inject DOM property ' + '\'%s\' which has already been injected. You may be accidentally ' + 'injecting the same DOM property config twice, or you may be ' + 'injecting two configs that have conflicting property names.', propName) : invariant(!DOMProperty.isStandardName.hasOwnProperty(propName)));
          DOMProperty.isStandardName[propName] = true;
          var lowerCased = propName.toLowerCase();
          DOMProperty.getPossibleStandardName[lowerCased] = propName;
          if (DOMAttributeNames.hasOwnProperty(propName)) {
            var attributeName = DOMAttributeNames[propName];
            DOMProperty.getPossibleStandardName[attributeName] = propName;
            DOMProperty.getAttributeName[propName] = attributeName;
          } else {
            DOMProperty.getAttributeName[propName] = lowerCased;
          }
          DOMProperty.getPropertyName[propName] = DOMPropertyNames.hasOwnProperty(propName) ? DOMPropertyNames[propName] : propName;
          if (DOMMutationMethods.hasOwnProperty(propName)) {
            DOMProperty.getMutationMethod[propName] = DOMMutationMethods[propName];
          } else {
            DOMProperty.getMutationMethod[propName] = null;
          }
          var propConfig = Properties[propName];
          DOMProperty.mustUseAttribute[propName] = checkMask(propConfig, DOMPropertyInjection.MUST_USE_ATTRIBUTE);
          DOMProperty.mustUseProperty[propName] = checkMask(propConfig, DOMPropertyInjection.MUST_USE_PROPERTY);
          DOMProperty.hasSideEffects[propName] = checkMask(propConfig, DOMPropertyInjection.HAS_SIDE_EFFECTS);
          DOMProperty.hasBooleanValue[propName] = checkMask(propConfig, DOMPropertyInjection.HAS_BOOLEAN_VALUE);
          DOMProperty.hasNumericValue[propName] = checkMask(propConfig, DOMPropertyInjection.HAS_NUMERIC_VALUE);
          DOMProperty.hasPositiveNumericValue[propName] = checkMask(propConfig, DOMPropertyInjection.HAS_POSITIVE_NUMERIC_VALUE);
          DOMProperty.hasOverloadedBooleanValue[propName] = checkMask(propConfig, DOMPropertyInjection.HAS_OVERLOADED_BOOLEAN_VALUE);
          ("production" !== process.env.NODE_ENV ? invariant(!DOMProperty.mustUseAttribute[propName] || !DOMProperty.mustUseProperty[propName], 'DOMProperty: Cannot require using both attribute and property: %s', propName) : invariant(!DOMProperty.mustUseAttribute[propName] || !DOMProperty.mustUseProperty[propName]));
          ("production" !== process.env.NODE_ENV ? invariant(DOMProperty.mustUseProperty[propName] || !DOMProperty.hasSideEffects[propName], 'DOMProperty: Properties that have side effects must use property: %s', propName) : invariant(DOMProperty.mustUseProperty[propName] || !DOMProperty.hasSideEffects[propName]));
          ("production" !== process.env.NODE_ENV ? invariant(!!DOMProperty.hasBooleanValue[propName] + !!DOMProperty.hasNumericValue[propName] + !!DOMProperty.hasOverloadedBooleanValue[propName] <= 1, 'DOMProperty: Value can be one of boolean, overloaded boolean, or ' + 'numeric value, but not a combination: %s', propName) : invariant(!!DOMProperty.hasBooleanValue[propName] + !!DOMProperty.hasNumericValue[propName] + !!DOMProperty.hasOverloadedBooleanValue[propName] <= 1));
        }
      }
    };
    var defaultValueCache = {};
    var DOMProperty = {
      ID_ATTRIBUTE_NAME: 'data-reactid',
      isStandardName: {},
      getPossibleStandardName: {},
      getAttributeName: {},
      getPropertyName: {},
      getMutationMethod: {},
      mustUseAttribute: {},
      mustUseProperty: {},
      hasSideEffects: {},
      hasBooleanValue: {},
      hasNumericValue: {},
      hasPositiveNumericValue: {},
      hasOverloadedBooleanValue: {},
      _isCustomAttributeFunctions: [],
      isCustomAttribute: function(attributeName) {
        for (var i = 0; i < DOMProperty._isCustomAttributeFunctions.length; i++) {
          var isCustomAttributeFn = DOMProperty._isCustomAttributeFunctions[i];
          if (isCustomAttributeFn(attributeName)) {
            return true;
          }
        }
        return false;
      },
      getDefaultValueForProperty: function(nodeName, prop) {
        var nodeDefaults = defaultValueCache[nodeName];
        var testElement;
        if (!nodeDefaults) {
          defaultValueCache[nodeName] = nodeDefaults = {};
        }
        if (!(prop in nodeDefaults)) {
          testElement = document.createElement(nodeName);
          nodeDefaults[prop] = testElement[prop];
        }
        return nodeDefaults[prop];
      },
      injection: DOMPropertyInjection
    };
    module.exports = DOMProperty;
  })(require("github:jspm/nodelibs-process@0.1.1"));
  global.define = __define;
  return module.exports;
});



System.register("npm:react@0.12.2/lib/ReactDOMComponent", ["npm:react@0.12.2/lib/CSSPropertyOperations", "npm:react@0.12.2/lib/DOMProperty", "npm:react@0.12.2/lib/DOMPropertyOperations", "npm:react@0.12.2/lib/ReactBrowserComponentMixin", "npm:react@0.12.2/lib/ReactComponent", "npm:react@0.12.2/lib/ReactBrowserEventEmitter", "npm:react@0.12.2/lib/ReactMount", "npm:react@0.12.2/lib/ReactMultiChild", "npm:react@0.12.2/lib/ReactPerf", "npm:react@0.12.2/lib/Object.assign", "npm:react@0.12.2/lib/escapeTextForBrowser", "npm:react@0.12.2/lib/invariant", "npm:react@0.12.2/lib/isEventSupported", "npm:react@0.12.2/lib/keyOf", "npm:react@0.12.2/lib/monitorCodeUse", "github:jspm/nodelibs-process@0.1.1"], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  (function(process) {
    "use strict";
    var CSSPropertyOperations = require("npm:react@0.12.2/lib/CSSPropertyOperations");
    var DOMProperty = require("npm:react@0.12.2/lib/DOMProperty");
    var DOMPropertyOperations = require("npm:react@0.12.2/lib/DOMPropertyOperations");
    var ReactBrowserComponentMixin = require("npm:react@0.12.2/lib/ReactBrowserComponentMixin");
    var ReactComponent = require("npm:react@0.12.2/lib/ReactComponent");
    var ReactBrowserEventEmitter = require("npm:react@0.12.2/lib/ReactBrowserEventEmitter");
    var ReactMount = require("npm:react@0.12.2/lib/ReactMount");
    var ReactMultiChild = require("npm:react@0.12.2/lib/ReactMultiChild");
    var ReactPerf = require("npm:react@0.12.2/lib/ReactPerf");
    var assign = require("npm:react@0.12.2/lib/Object.assign");
    var escapeTextForBrowser = require("npm:react@0.12.2/lib/escapeTextForBrowser");
    var invariant = require("npm:react@0.12.2/lib/invariant");
    var isEventSupported = require("npm:react@0.12.2/lib/isEventSupported");
    var keyOf = require("npm:react@0.12.2/lib/keyOf");
    var monitorCodeUse = require("npm:react@0.12.2/lib/monitorCodeUse");
    var deleteListener = ReactBrowserEventEmitter.deleteListener;
    var listenTo = ReactBrowserEventEmitter.listenTo;
    var registrationNameModules = ReactBrowserEventEmitter.registrationNameModules;
    var CONTENT_TYPES = {
      'string': true,
      'number': true
    };
    var STYLE = keyOf({style: null});
    var ELEMENT_NODE_TYPE = 1;
    function assertValidProps(props) {
      if (!props) {
        return ;
      }
      ("production" !== process.env.NODE_ENV ? invariant(props.children == null || props.dangerouslySetInnerHTML == null, 'Can only set one of `children` or `props.dangerouslySetInnerHTML`.') : invariant(props.children == null || props.dangerouslySetInnerHTML == null));
      if ("production" !== process.env.NODE_ENV) {
        if (props.contentEditable && props.children != null) {
          console.warn('A component is `contentEditable` and contains `children` managed by ' + 'React. It is now your responsibility to guarantee that none of those ' + 'nodes are unexpectedly modified or duplicated. This is probably not ' + 'intentional.');
        }
      }
      ("production" !== process.env.NODE_ENV ? invariant(props.style == null || typeof props.style === 'object', 'The `style` prop expects a mapping from style properties to values, ' + 'not a string.') : invariant(props.style == null || typeof props.style === 'object'));
    }
    function putListener(id, registrationName, listener, transaction) {
      if ("production" !== process.env.NODE_ENV) {
        if (registrationName === 'onScroll' && !isEventSupported('scroll', true)) {
          monitorCodeUse('react_no_scroll_event');
          console.warn('This browser doesn\'t support the `onScroll` event');
        }
      }
      var container = ReactMount.findReactContainerForID(id);
      if (container) {
        var doc = container.nodeType === ELEMENT_NODE_TYPE ? container.ownerDocument : container;
        listenTo(registrationName, doc);
      }
      transaction.getPutListenerQueue().enqueuePutListener(id, registrationName, listener);
    }
    var omittedCloseTags = {
      'area': true,
      'base': true,
      'br': true,
      'col': true,
      'embed': true,
      'hr': true,
      'img': true,
      'input': true,
      'keygen': true,
      'link': true,
      'meta': true,
      'param': true,
      'source': true,
      'track': true,
      'wbr': true
    };
    var VALID_TAG_REGEX = /^[a-zA-Z][a-zA-Z:_\.\-\d]*$/;
    var validatedTagCache = {};
    var hasOwnProperty = {}.hasOwnProperty;
    function validateDangerousTag(tag) {
      if (!hasOwnProperty.call(validatedTagCache, tag)) {
        ("production" !== process.env.NODE_ENV ? invariant(VALID_TAG_REGEX.test(tag), 'Invalid tag: %s', tag) : invariant(VALID_TAG_REGEX.test(tag)));
        validatedTagCache[tag] = true;
      }
    }
    function ReactDOMComponent(tag) {
      validateDangerousTag(tag);
      this._tag = tag;
      this.tagName = tag.toUpperCase();
    }
    ReactDOMComponent.displayName = 'ReactDOMComponent';
    ReactDOMComponent.Mixin = {
      mountComponent: ReactPerf.measure('ReactDOMComponent', 'mountComponent', function(rootID, transaction, mountDepth) {
        ReactComponent.Mixin.mountComponent.call(this, rootID, transaction, mountDepth);
        assertValidProps(this.props);
        var closeTag = omittedCloseTags[this._tag] ? '' : '</' + this._tag + '>';
        return (this._createOpenTagMarkupAndPutListeners(transaction) + this._createContentMarkup(transaction) + closeTag);
      }),
      _createOpenTagMarkupAndPutListeners: function(transaction) {
        var props = this.props;
        var ret = '<' + this._tag;
        for (var propKey in props) {
          if (!props.hasOwnProperty(propKey)) {
            continue;
          }
          var propValue = props[propKey];
          if (propValue == null) {
            continue;
          }
          if (registrationNameModules.hasOwnProperty(propKey)) {
            putListener(this._rootNodeID, propKey, propValue, transaction);
          } else {
            if (propKey === STYLE) {
              if (propValue) {
                propValue = props.style = assign({}, props.style);
              }
              propValue = CSSPropertyOperations.createMarkupForStyles(propValue);
            }
            var markup = DOMPropertyOperations.createMarkupForProperty(propKey, propValue);
            if (markup) {
              ret += ' ' + markup;
            }
          }
        }
        if (transaction.renderToStaticMarkup) {
          return ret + '>';
        }
        var markupForID = DOMPropertyOperations.createMarkupForID(this._rootNodeID);
        return ret + ' ' + markupForID + '>';
      },
      _createContentMarkup: function(transaction) {
        var innerHTML = this.props.dangerouslySetInnerHTML;
        if (innerHTML != null) {
          if (innerHTML.__html != null) {
            return innerHTML.__html;
          }
        } else {
          var contentToUse = CONTENT_TYPES[typeof this.props.children] ? this.props.children : null;
          var childrenToUse = contentToUse != null ? null : this.props.children;
          if (contentToUse != null) {
            return escapeTextForBrowser(contentToUse);
          } else if (childrenToUse != null) {
            var mountImages = this.mountChildren(childrenToUse, transaction);
            return mountImages.join('');
          }
        }
        return '';
      },
      receiveComponent: function(nextElement, transaction) {
        if (nextElement === this._currentElement && nextElement._owner != null) {
          return ;
        }
        ReactComponent.Mixin.receiveComponent.call(this, nextElement, transaction);
      },
      updateComponent: ReactPerf.measure('ReactDOMComponent', 'updateComponent', function(transaction, prevElement) {
        assertValidProps(this._currentElement.props);
        ReactComponent.Mixin.updateComponent.call(this, transaction, prevElement);
        this._updateDOMProperties(prevElement.props, transaction);
        this._updateDOMChildren(prevElement.props, transaction);
      }),
      _updateDOMProperties: function(lastProps, transaction) {
        var nextProps = this.props;
        var propKey;
        var styleName;
        var styleUpdates;
        for (propKey in lastProps) {
          if (nextProps.hasOwnProperty(propKey) || !lastProps.hasOwnProperty(propKey)) {
            continue;
          }
          if (propKey === STYLE) {
            var lastStyle = lastProps[propKey];
            for (styleName in lastStyle) {
              if (lastStyle.hasOwnProperty(styleName)) {
                styleUpdates = styleUpdates || {};
                styleUpdates[styleName] = '';
              }
            }
          } else if (registrationNameModules.hasOwnProperty(propKey)) {
            deleteListener(this._rootNodeID, propKey);
          } else if (DOMProperty.isStandardName[propKey] || DOMProperty.isCustomAttribute(propKey)) {
            ReactComponent.BackendIDOperations.deletePropertyByID(this._rootNodeID, propKey);
          }
        }
        for (propKey in nextProps) {
          var nextProp = nextProps[propKey];
          var lastProp = lastProps[propKey];
          if (!nextProps.hasOwnProperty(propKey) || nextProp === lastProp) {
            continue;
          }
          if (propKey === STYLE) {
            if (nextProp) {
              nextProp = nextProps.style = assign({}, nextProp);
            }
            if (lastProp) {
              for (styleName in lastProp) {
                if (lastProp.hasOwnProperty(styleName) && (!nextProp || !nextProp.hasOwnProperty(styleName))) {
                  styleUpdates = styleUpdates || {};
                  styleUpdates[styleName] = '';
                }
              }
              for (styleName in nextProp) {
                if (nextProp.hasOwnProperty(styleName) && lastProp[styleName] !== nextProp[styleName]) {
                  styleUpdates = styleUpdates || {};
                  styleUpdates[styleName] = nextProp[styleName];
                }
              }
            } else {
              styleUpdates = nextProp;
            }
          } else if (registrationNameModules.hasOwnProperty(propKey)) {
            putListener(this._rootNodeID, propKey, nextProp, transaction);
          } else if (DOMProperty.isStandardName[propKey] || DOMProperty.isCustomAttribute(propKey)) {
            ReactComponent.BackendIDOperations.updatePropertyByID(this._rootNodeID, propKey, nextProp);
          }
        }
        if (styleUpdates) {
          ReactComponent.BackendIDOperations.updateStylesByID(this._rootNodeID, styleUpdates);
        }
      },
      _updateDOMChildren: function(lastProps, transaction) {
        var nextProps = this.props;
        var lastContent = CONTENT_TYPES[typeof lastProps.children] ? lastProps.children : null;
        var nextContent = CONTENT_TYPES[typeof nextProps.children] ? nextProps.children : null;
        var lastHtml = lastProps.dangerouslySetInnerHTML && lastProps.dangerouslySetInnerHTML.__html;
        var nextHtml = nextProps.dangerouslySetInnerHTML && nextProps.dangerouslySetInnerHTML.__html;
        var lastChildren = lastContent != null ? null : lastProps.children;
        var nextChildren = nextContent != null ? null : nextProps.children;
        var lastHasContentOrHtml = lastContent != null || lastHtml != null;
        var nextHasContentOrHtml = nextContent != null || nextHtml != null;
        if (lastChildren != null && nextChildren == null) {
          this.updateChildren(null, transaction);
        } else if (lastHasContentOrHtml && !nextHasContentOrHtml) {
          this.updateTextContent('');
        }
        if (nextContent != null) {
          if (lastContent !== nextContent) {
            this.updateTextContent('' + nextContent);
          }
        } else if (nextHtml != null) {
          if (lastHtml !== nextHtml) {
            ReactComponent.BackendIDOperations.updateInnerHTMLByID(this._rootNodeID, nextHtml);
          }
        } else if (nextChildren != null) {
          this.updateChildren(nextChildren, transaction);
        }
      },
      unmountComponent: function() {
        this.unmountChildren();
        ReactBrowserEventEmitter.deleteAllListeners(this._rootNodeID);
        ReactComponent.Mixin.unmountComponent.call(this);
      }
    };
    assign(ReactDOMComponent.prototype, ReactComponent.Mixin, ReactDOMComponent.Mixin, ReactMultiChild.Mixin, ReactBrowserComponentMixin);
    module.exports = ReactDOMComponent;
  })(require("github:jspm/nodelibs-process@0.1.1"));
  global.define = __define;
  return module.exports;
});



System.register("npm:react@0.12.2/lib/ReactDOMIDOperations", ["npm:react@0.12.2/lib/CSSPropertyOperations", "npm:react@0.12.2/lib/DOMChildrenOperations", "npm:react@0.12.2/lib/DOMPropertyOperations", "npm:react@0.12.2/lib/ReactMount", "npm:react@0.12.2/lib/ReactPerf", "npm:react@0.12.2/lib/invariant", "npm:react@0.12.2/lib/setInnerHTML", "github:jspm/nodelibs-process@0.1.1"], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  (function(process) {
    "use strict";
    var CSSPropertyOperations = require("npm:react@0.12.2/lib/CSSPropertyOperations");
    var DOMChildrenOperations = require("npm:react@0.12.2/lib/DOMChildrenOperations");
    var DOMPropertyOperations = require("npm:react@0.12.2/lib/DOMPropertyOperations");
    var ReactMount = require("npm:react@0.12.2/lib/ReactMount");
    var ReactPerf = require("npm:react@0.12.2/lib/ReactPerf");
    var invariant = require("npm:react@0.12.2/lib/invariant");
    var setInnerHTML = require("npm:react@0.12.2/lib/setInnerHTML");
    var INVALID_PROPERTY_ERRORS = {
      dangerouslySetInnerHTML: '`dangerouslySetInnerHTML` must be set using `updateInnerHTMLByID()`.',
      style: '`style` must be set using `updateStylesByID()`.'
    };
    var ReactDOMIDOperations = {
      updatePropertyByID: ReactPerf.measure('ReactDOMIDOperations', 'updatePropertyByID', function(id, name, value) {
        var node = ReactMount.getNode(id);
        ("production" !== process.env.NODE_ENV ? invariant(!INVALID_PROPERTY_ERRORS.hasOwnProperty(name), 'updatePropertyByID(...): %s', INVALID_PROPERTY_ERRORS[name]) : invariant(!INVALID_PROPERTY_ERRORS.hasOwnProperty(name)));
        if (value != null) {
          DOMPropertyOperations.setValueForProperty(node, name, value);
        } else {
          DOMPropertyOperations.deleteValueForProperty(node, name);
        }
      }),
      deletePropertyByID: ReactPerf.measure('ReactDOMIDOperations', 'deletePropertyByID', function(id, name, value) {
        var node = ReactMount.getNode(id);
        ("production" !== process.env.NODE_ENV ? invariant(!INVALID_PROPERTY_ERRORS.hasOwnProperty(name), 'updatePropertyByID(...): %s', INVALID_PROPERTY_ERRORS[name]) : invariant(!INVALID_PROPERTY_ERRORS.hasOwnProperty(name)));
        DOMPropertyOperations.deleteValueForProperty(node, name, value);
      }),
      updateStylesByID: ReactPerf.measure('ReactDOMIDOperations', 'updateStylesByID', function(id, styles) {
        var node = ReactMount.getNode(id);
        CSSPropertyOperations.setValueForStyles(node, styles);
      }),
      updateInnerHTMLByID: ReactPerf.measure('ReactDOMIDOperations', 'updateInnerHTMLByID', function(id, html) {
        var node = ReactMount.getNode(id);
        setInnerHTML(node, html);
      }),
      updateTextContentByID: ReactPerf.measure('ReactDOMIDOperations', 'updateTextContentByID', function(id, content) {
        var node = ReactMount.getNode(id);
        DOMChildrenOperations.updateTextContent(node, content);
      }),
      dangerouslyReplaceNodeWithMarkupByID: ReactPerf.measure('ReactDOMIDOperations', 'dangerouslyReplaceNodeWithMarkupByID', function(id, markup) {
        var node = ReactMount.getNode(id);
        DOMChildrenOperations.dangerouslyReplaceNodeWithMarkup(node, markup);
      }),
      dangerouslyProcessChildrenUpdates: ReactPerf.measure('ReactDOMIDOperations', 'dangerouslyProcessChildrenUpdates', function(updates, markup) {
        for (var i = 0; i < updates.length; i++) {
          updates[i].parentNode = ReactMount.getNode(updates[i].parentID);
        }
        DOMChildrenOperations.processUpdates(updates, markup);
      })
    };
    module.exports = ReactDOMIDOperations;
  })(require("github:jspm/nodelibs-process@0.1.1"));
  global.define = __define;
  return module.exports;
});



System.register("npm:d@0.1.1/index", ["npm:es5-ext@0.10.6/object/assign", "npm:es5-ext@0.10.6/object/normalize-options", "npm:es5-ext@0.10.6/object/is-callable", "npm:es5-ext@0.10.6/string/#/contains"], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  'use strict';
  var assign = require("npm:es5-ext@0.10.6/object/assign"),
      normalizeOpts = require("npm:es5-ext@0.10.6/object/normalize-options"),
      isCallable = require("npm:es5-ext@0.10.6/object/is-callable"),
      contains = require("npm:es5-ext@0.10.6/string/#/contains"),
      d;
  d = module.exports = function(dscr, value) {
    var c,
        e,
        w,
        options,
        desc;
    if ((arguments.length < 2) || (typeof dscr !== 'string')) {
      options = value;
      value = dscr;
      dscr = null;
    } else {
      options = arguments[2];
    }
    if (dscr == null) {
      c = w = true;
      e = false;
    } else {
      c = contains.call(dscr, 'c');
      e = contains.call(dscr, 'e');
      w = contains.call(dscr, 'w');
    }
    desc = {
      value: value,
      configurable: c,
      enumerable: e,
      writable: w
    };
    return !options ? desc : assign(normalizeOpts(options), desc);
  };
  d.gs = function(dscr, get, set) {
    var c,
        e,
        options,
        desc;
    if (typeof dscr !== 'string') {
      options = set;
      set = get;
      get = dscr;
      dscr = null;
    } else {
      options = arguments[3];
    }
    if (get == null) {
      get = undefined;
    } else if (!isCallable(get)) {
      options = get;
      get = set = undefined;
    } else if (set == null) {
      set = undefined;
    } else if (!isCallable(set)) {
      options = set;
      set = undefined;
    }
    if (dscr == null) {
      c = true;
      e = false;
    } else {
      c = contains.call(dscr, 'c');
      e = contains.call(dscr, 'e');
    }
    desc = {
      get: get,
      set: set,
      configurable: c,
      enumerable: e
    };
    return !options ? desc : assign(normalizeOpts(options), desc);
  };
  global.define = __define;
  return module.exports;
});



System.register("github:jspm/nodelibs-buffer@0.1.0", ["github:jspm/nodelibs-buffer@0.1.0/index"], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  module.exports = require("github:jspm/nodelibs-buffer@0.1.0/index");
  global.define = __define;
  return module.exports;
});



System.register("npm:react@0.12.2/lib/DOMPropertyOperations", ["npm:react@0.12.2/lib/DOMProperty", "npm:react@0.12.2/lib/escapeTextForBrowser", "npm:react@0.12.2/lib/memoizeStringOnly", "npm:react@0.12.2/lib/warning", "github:jspm/nodelibs-process@0.1.1"], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  (function(process) {
    "use strict";
    var DOMProperty = require("npm:react@0.12.2/lib/DOMProperty");
    var escapeTextForBrowser = require("npm:react@0.12.2/lib/escapeTextForBrowser");
    var memoizeStringOnly = require("npm:react@0.12.2/lib/memoizeStringOnly");
    var warning = require("npm:react@0.12.2/lib/warning");
    function shouldIgnoreValue(name, value) {
      return value == null || (DOMProperty.hasBooleanValue[name] && !value) || (DOMProperty.hasNumericValue[name] && isNaN(value)) || (DOMProperty.hasPositiveNumericValue[name] && (value < 1)) || (DOMProperty.hasOverloadedBooleanValue[name] && value === false);
    }
    var processAttributeNameAndPrefix = memoizeStringOnly(function(name) {
      return escapeTextForBrowser(name) + '="';
    });
    if ("production" !== process.env.NODE_ENV) {
      var reactProps = {
        children: true,
        dangerouslySetInnerHTML: true,
        key: true,
        ref: true
      };
      var warnedProperties = {};
      var warnUnknownProperty = function(name) {
        if (reactProps.hasOwnProperty(name) && reactProps[name] || warnedProperties.hasOwnProperty(name) && warnedProperties[name]) {
          return ;
        }
        warnedProperties[name] = true;
        var lowerCasedName = name.toLowerCase();
        var standardName = (DOMProperty.isCustomAttribute(lowerCasedName) ? lowerCasedName : DOMProperty.getPossibleStandardName.hasOwnProperty(lowerCasedName) ? DOMProperty.getPossibleStandardName[lowerCasedName] : null);
        ("production" !== process.env.NODE_ENV ? warning(standardName == null, 'Unknown DOM property ' + name + '. Did you mean ' + standardName + '?') : null);
      };
    }
    var DOMPropertyOperations = {
      createMarkupForID: function(id) {
        return processAttributeNameAndPrefix(DOMProperty.ID_ATTRIBUTE_NAME) + escapeTextForBrowser(id) + '"';
      },
      createMarkupForProperty: function(name, value) {
        if (DOMProperty.isStandardName.hasOwnProperty(name) && DOMProperty.isStandardName[name]) {
          if (shouldIgnoreValue(name, value)) {
            return '';
          }
          var attributeName = DOMProperty.getAttributeName[name];
          if (DOMProperty.hasBooleanValue[name] || (DOMProperty.hasOverloadedBooleanValue[name] && value === true)) {
            return escapeTextForBrowser(attributeName);
          }
          return processAttributeNameAndPrefix(attributeName) + escapeTextForBrowser(value) + '"';
        } else if (DOMProperty.isCustomAttribute(name)) {
          if (value == null) {
            return '';
          }
          return processAttributeNameAndPrefix(name) + escapeTextForBrowser(value) + '"';
        } else if ("production" !== process.env.NODE_ENV) {
          warnUnknownProperty(name);
        }
        return null;
      },
      setValueForProperty: function(node, name, value) {
        if (DOMProperty.isStandardName.hasOwnProperty(name) && DOMProperty.isStandardName[name]) {
          var mutationMethod = DOMProperty.getMutationMethod[name];
          if (mutationMethod) {
            mutationMethod(node, value);
          } else if (shouldIgnoreValue(name, value)) {
            this.deleteValueForProperty(node, name);
          } else if (DOMProperty.mustUseAttribute[name]) {
            node.setAttribute(DOMProperty.getAttributeName[name], '' + value);
          } else {
            var propName = DOMProperty.getPropertyName[name];
            if (!DOMProperty.hasSideEffects[name] || ('' + node[propName]) !== ('' + value)) {
              node[propName] = value;
            }
          }
        } else if (DOMProperty.isCustomAttribute(name)) {
          if (value == null) {
            node.removeAttribute(name);
          } else {
            node.setAttribute(name, '' + value);
          }
        } else if ("production" !== process.env.NODE_ENV) {
          warnUnknownProperty(name);
        }
      },
      deleteValueForProperty: function(node, name) {
        if (DOMProperty.isStandardName.hasOwnProperty(name) && DOMProperty.isStandardName[name]) {
          var mutationMethod = DOMProperty.getMutationMethod[name];
          if (mutationMethod) {
            mutationMethod(node, undefined);
          } else if (DOMProperty.mustUseAttribute[name]) {
            node.removeAttribute(DOMProperty.getAttributeName[name]);
          } else {
            var propName = DOMProperty.getPropertyName[name];
            var defaultValue = DOMProperty.getDefaultValueForProperty(node.nodeName, propName);
            if (!DOMProperty.hasSideEffects[name] || ('' + node[propName]) !== defaultValue) {
              node[propName] = defaultValue;
            }
          }
        } else if (DOMProperty.isCustomAttribute(name)) {
          node.removeAttribute(name);
        } else if ("production" !== process.env.NODE_ENV) {
          warnUnknownProperty(name);
        }
      }
    };
    module.exports = DOMPropertyOperations;
  })(require("github:jspm/nodelibs-process@0.1.1"));
  global.define = __define;
  return module.exports;
});



System.register("npm:react@0.12.2/lib/ReactComponentBrowserEnvironment", ["npm:react@0.12.2/lib/ReactDOMIDOperations", "npm:react@0.12.2/lib/ReactMarkupChecksum", "npm:react@0.12.2/lib/ReactMount", "npm:react@0.12.2/lib/ReactPerf", "npm:react@0.12.2/lib/ReactReconcileTransaction", "npm:react@0.12.2/lib/getReactRootElementInContainer", "npm:react@0.12.2/lib/invariant", "npm:react@0.12.2/lib/setInnerHTML", "github:jspm/nodelibs-process@0.1.1"], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  (function(process) {
    "use strict";
    var ReactDOMIDOperations = require("npm:react@0.12.2/lib/ReactDOMIDOperations");
    var ReactMarkupChecksum = require("npm:react@0.12.2/lib/ReactMarkupChecksum");
    var ReactMount = require("npm:react@0.12.2/lib/ReactMount");
    var ReactPerf = require("npm:react@0.12.2/lib/ReactPerf");
    var ReactReconcileTransaction = require("npm:react@0.12.2/lib/ReactReconcileTransaction");
    var getReactRootElementInContainer = require("npm:react@0.12.2/lib/getReactRootElementInContainer");
    var invariant = require("npm:react@0.12.2/lib/invariant");
    var setInnerHTML = require("npm:react@0.12.2/lib/setInnerHTML");
    var ELEMENT_NODE_TYPE = 1;
    var DOC_NODE_TYPE = 9;
    var ReactComponentBrowserEnvironment = {
      ReactReconcileTransaction: ReactReconcileTransaction,
      BackendIDOperations: ReactDOMIDOperations,
      unmountIDFromEnvironment: function(rootNodeID) {
        ReactMount.purgeID(rootNodeID);
      },
      mountImageIntoNode: ReactPerf.measure('ReactComponentBrowserEnvironment', 'mountImageIntoNode', function(markup, container, shouldReuseMarkup) {
        ("production" !== process.env.NODE_ENV ? invariant(container && (container.nodeType === ELEMENT_NODE_TYPE || container.nodeType === DOC_NODE_TYPE), 'mountComponentIntoNode(...): Target container is not valid.') : invariant(container && (container.nodeType === ELEMENT_NODE_TYPE || container.nodeType === DOC_NODE_TYPE)));
        if (shouldReuseMarkup) {
          if (ReactMarkupChecksum.canReuseMarkup(markup, getReactRootElementInContainer(container))) {
            return ;
          } else {
            ("production" !== process.env.NODE_ENV ? invariant(container.nodeType !== DOC_NODE_TYPE, 'You\'re trying to render a component to the document using ' + 'server rendering but the checksum was invalid. This usually ' + 'means you rendered a different component type or props on ' + 'the client from the one on the server, or your render() ' + 'methods are impure. React cannot handle this case due to ' + 'cross-browser quirks by rendering at the document root. You ' + 'should look for environment dependent code in your components ' + 'and ensure the props are the same client and server side.') : invariant(container.nodeType !== DOC_NODE_TYPE));
            if ("production" !== process.env.NODE_ENV) {
              console.warn('React attempted to use reuse markup in a container but the ' + 'checksum was invalid. This generally means that you are ' + 'using server rendering and the markup generated on the ' + 'server was not what the client was expecting. React injected ' + 'new markup to compensate which works but you have lost many ' + 'of the benefits of server rendering. Instead, figure out ' + 'why the markup being generated is different on the client ' + 'or server.');
            }
          }
        }
        ("production" !== process.env.NODE_ENV ? invariant(container.nodeType !== DOC_NODE_TYPE, 'You\'re trying to render a component to the document but ' + 'you didn\'t use server rendering. We can\'t do this ' + 'without using server rendering due to cross-browser quirks. ' + 'See renderComponentToString() for server rendering.') : invariant(container.nodeType !== DOC_NODE_TYPE));
        setInnerHTML(container, markup);
      })
    };
    module.exports = ReactComponentBrowserEnvironment;
  })(require("github:jspm/nodelibs-process@0.1.1"));
  global.define = __define;
  return module.exports;
});



System.register("npm:d@0.1.1", ["npm:d@0.1.1/index"], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  module.exports = require("npm:d@0.1.1/index");
  global.define = __define;
  return module.exports;
});



System.register("npm:brace@0.5.0/worker/javascript", ["github:jspm/nodelibs-buffer@0.1.0", "github:jspm/nodelibs-process@0.1.1"], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  (function(Buffer, process) {
    module.exports.id = 'ace/mode/javascript_worker';
    module.exports.src = "\"no use strict\";(function(window){if(void 0===window.window||!window.document){window.console=function(){var msgs=Array.prototype.slice.call(arguments,0);postMessage({type:\"log\",data:msgs})},window.console.error=window.console.warn=window.console.log=window.console.trace=window.console,window.window=window,window.ace=window,window.onerror=function(message,file,line,col,err){postMessage({type:\"error\",data:{message:message,file:file,line:line,col:col,stack:err.stack}})},window.normalizeModule=function(parentId,moduleName){if(-1!==moduleName.indexOf(\"!\")){var chunks=moduleName.split(\"!\");return window.normalizeModule(parentId,chunks[0])+\"!\"+window.normalizeModule(parentId,chunks[1])}if(\".\"==moduleName.charAt(0)){var base=parentId.split(\"/\").slice(0,-1).join(\"/\");for(moduleName=(base?base+\"/\":\"\")+moduleName;-1!==moduleName.indexOf(\".\")&&previous!=moduleName;){var previous=moduleName;moduleName=moduleName.replace(/^\\.\\//,\"\").replace(/\\/\\.\\//,\"/\").replace(/[^\\/]+\\/\\.\\.\\//,\"\")}}return moduleName},window.acequire=function(parentId,id){if(id||(id=parentId,parentId=null),!id.charAt)throw Error(\"worker.js acequire() accepts only (parentId, id) as arguments\");id=window.normalizeModule(parentId,id);var module=window.acequire.modules[id];if(module)return module.initialized||(module.initialized=!0,module.exports=module.factory().exports),module.exports;var chunks=id.split(\"/\");if(!window.acequire.tlns)return console.log(\"unable to load \"+id);chunks[0]=window.acequire.tlns[chunks[0]]||chunks[0];var path=chunks.join(\"/\")+\".js\";return window.acequire.id=id,importScripts(path),window.acequire(parentId,id)},window.acequire.modules={},window.acequire.tlns={},window.define=function(id,deps,factory){if(2==arguments.length?(factory=deps,\"string\"!=typeof id&&(deps=id,id=window.acequire.id)):1==arguments.length&&(factory=id,deps=[],id=window.acequire.id),\"function\"!=typeof factory)return window.acequire.modules[id]={exports:factory,initialized:!0},void 0;deps.length||(deps=[\"require\",\"exports\",\"module\"]);var req=function(childId){return window.acequire(id,childId)};window.acequire.modules[id]={exports:{},factory:function(){var module=this,returnExports=factory.apply(this,deps.map(function(dep){switch(dep){case\"require\":return req;case\"exports\":return module.exports;case\"module\":return module;default:return req(dep)}}));return returnExports&&(module.exports=returnExports),module}}},window.define.amd={},window.initBaseUrls=function initBaseUrls(topLevelNamespaces){acequire.tlns=topLevelNamespaces},window.initSender=function initSender(){var EventEmitter=window.acequire(\"ace/lib/event_emitter\").EventEmitter,oop=window.acequire(\"ace/lib/oop\"),Sender=function(){};return function(){oop.implement(this,EventEmitter),this.callback=function(data,callbackId){postMessage({type:\"call\",id:callbackId,data:data})},this.emit=function(name,data){postMessage({type:\"event\",name:name,data:data})}}.call(Sender.prototype),new Sender};var main=window.main=null,sender=window.sender=null;window.onmessage=function(e){var msg=e.data;if(msg.command){if(!main[msg.command])throw Error(\"Unknown command:\"+msg.command);main[msg.command].apply(main,msg.args)}else if(msg.init){initBaseUrls(msg.tlns),acequire(\"ace/lib/es5-shim\"),sender=window.sender=initSender();var clazz=acequire(msg.module)[msg.classname];main=window.main=new clazz(sender)}else msg.event&&sender&&sender._signal(msg.event,msg.data)}}})(this),ace.define(\"ace/lib/oop\",[\"require\",\"exports\",\"module\"],function(acequire,exports){\"use strict\";exports.inherits=function(ctor,superCtor){ctor.super_=superCtor,ctor.prototype=Object.create(superCtor.prototype,{constructor:{value:ctor,enumerable:!1,writable:!0,configurable:!0}})},exports.mixin=function(obj,mixin){for(var key in mixin)obj[key]=mixin[key];return obj},exports.implement=function(proto,mixin){exports.mixin(proto,mixin)}}),ace.define(\"ace/lib/event_emitter\",[\"require\",\"exports\",\"module\"],function(acequire,exports){\"use strict\";var EventEmitter={},stopPropagation=function(){this.propagationStopped=!0},preventDefault=function(){this.defaultPrevented=!0};EventEmitter._emit=EventEmitter._dispatchEvent=function(eventName,e){this._eventRegistry||(this._eventRegistry={}),this._defaultHandlers||(this._defaultHandlers={});var listeners=this._eventRegistry[eventName]||[],defaultHandler=this._defaultHandlers[eventName];if(listeners.length||defaultHandler){\"object\"==typeof e&&e||(e={}),e.type||(e.type=eventName),e.stopPropagation||(e.stopPropagation=stopPropagation),e.preventDefault||(e.preventDefault=preventDefault),listeners=listeners.slice();for(var i=0;listeners.length>i&&(listeners[i](e,this),!e.propagationStopped);i++);return defaultHandler&&!e.defaultPrevented?defaultHandler(e,this):void 0}},EventEmitter._signal=function(eventName,e){var listeners=(this._eventRegistry||{})[eventName];if(listeners){listeners=listeners.slice();for(var i=0;listeners.length>i;i++)listeners[i](e,this)}},EventEmitter.once=function(eventName,callback){var _self=this;callback&&this.addEventListener(eventName,function newCallback(){_self.removeEventListener(eventName,newCallback),callback.apply(null,arguments)})},EventEmitter.setDefaultHandler=function(eventName,callback){var handlers=this._defaultHandlers;if(handlers||(handlers=this._defaultHandlers={_disabled_:{}}),handlers[eventName]){var old=handlers[eventName],disabled=handlers._disabled_[eventName];disabled||(handlers._disabled_[eventName]=disabled=[]),disabled.push(old);var i=disabled.indexOf(callback);-1!=i&&disabled.splice(i,1)}handlers[eventName]=callback},EventEmitter.removeDefaultHandler=function(eventName,callback){var handlers=this._defaultHandlers;if(handlers){var disabled=handlers._disabled_[eventName];if(handlers[eventName]==callback)handlers[eventName],disabled&&this.setDefaultHandler(eventName,disabled.pop());else if(disabled){var i=disabled.indexOf(callback);-1!=i&&disabled.splice(i,1)}}},EventEmitter.on=EventEmitter.addEventListener=function(eventName,callback,capturing){this._eventRegistry=this._eventRegistry||{};var listeners=this._eventRegistry[eventName];return listeners||(listeners=this._eventRegistry[eventName]=[]),-1==listeners.indexOf(callback)&&listeners[capturing?\"unshift\":\"push\"](callback),callback},EventEmitter.off=EventEmitter.removeListener=EventEmitter.removeEventListener=function(eventName,callback){this._eventRegistry=this._eventRegistry||{};var listeners=this._eventRegistry[eventName];if(listeners){var index=listeners.indexOf(callback);-1!==index&&listeners.splice(index,1)}},EventEmitter.removeAllListeners=function(eventName){this._eventRegistry&&(this._eventRegistry[eventName]=[])},exports.EventEmitter=EventEmitter}),ace.define(\"ace/range\",[\"require\",\"exports\",\"module\"],function(acequire,exports){\"use strict\";var comparePoints=function(p1,p2){return p1.row-p2.row||p1.column-p2.column},Range=function(startRow,startColumn,endRow,endColumn){this.start={row:startRow,column:startColumn},this.end={row:endRow,column:endColumn}};(function(){this.isEqual=function(range){return this.start.row===range.start.row&&this.end.row===range.end.row&&this.start.column===range.start.column&&this.end.column===range.end.column},this.toString=function(){return\"Range: [\"+this.start.row+\"/\"+this.start.column+\"] -> [\"+this.end.row+\"/\"+this.end.column+\"]\"},this.contains=function(row,column){return 0==this.compare(row,column)},this.compareRange=function(range){var cmp,end=range.end,start=range.start;return cmp=this.compare(end.row,end.column),1==cmp?(cmp=this.compare(start.row,start.column),1==cmp?2:0==cmp?1:0):-1==cmp?-2:(cmp=this.compare(start.row,start.column),-1==cmp?-1:1==cmp?42:0)},this.comparePoint=function(p){return this.compare(p.row,p.column)},this.containsRange=function(range){return 0==this.comparePoint(range.start)&&0==this.comparePoint(range.end)},this.intersects=function(range){var cmp=this.compareRange(range);return-1==cmp||0==cmp||1==cmp},this.isEnd=function(row,column){return this.end.row==row&&this.end.column==column},this.isStart=function(row,column){return this.start.row==row&&this.start.column==column},this.setStart=function(row,column){\"object\"==typeof row?(this.start.column=row.column,this.start.row=row.row):(this.start.row=row,this.start.column=column)},this.setEnd=function(row,column){\"object\"==typeof row?(this.end.column=row.column,this.end.row=row.row):(this.end.row=row,this.end.column=column)},this.inside=function(row,column){return 0==this.compare(row,column)?this.isEnd(row,column)||this.isStart(row,column)?!1:!0:!1},this.insideStart=function(row,column){return 0==this.compare(row,column)?this.isEnd(row,column)?!1:!0:!1},this.insideEnd=function(row,column){return 0==this.compare(row,column)?this.isStart(row,column)?!1:!0:!1},this.compare=function(row,column){return this.isMultiLine()||row!==this.start.row?this.start.row>row?-1:row>this.end.row?1:this.start.row===row?column>=this.start.column?0:-1:this.end.row===row?this.end.column>=column?0:1:0:this.start.column>column?-1:column>this.end.column?1:0},this.compareStart=function(row,column){return this.start.row==row&&this.start.column==column?-1:this.compare(row,column)},this.compareEnd=function(row,column){return this.end.row==row&&this.end.column==column?1:this.compare(row,column)},this.compareInside=function(row,column){return this.end.row==row&&this.end.column==column?1:this.start.row==row&&this.start.column==column?-1:this.compare(row,column)},this.clipRows=function(firstRow,lastRow){if(this.end.row>lastRow)var end={row:lastRow+1,column:0};else if(firstRow>this.end.row)var end={row:firstRow,column:0};if(this.start.row>lastRow)var start={row:lastRow+1,column:0};else if(firstRow>this.start.row)var start={row:firstRow,column:0};return Range.fromPoints(start||this.start,end||this.end)},this.extend=function(row,column){var cmp=this.compare(row,column);if(0==cmp)return this;if(-1==cmp)var start={row:row,column:column};else var end={row:row,column:column};return Range.fromPoints(start||this.start,end||this.end)},this.isEmpty=function(){return this.start.row===this.end.row&&this.start.column===this.end.column},this.isMultiLine=function(){return this.start.row!==this.end.row},this.clone=function(){return Range.fromPoints(this.start,this.end)},this.collapseRows=function(){return 0==this.end.column?new Range(this.start.row,0,Math.max(this.start.row,this.end.row-1),0):new Range(this.start.row,0,this.end.row,0)},this.toScreenRange=function(session){var screenPosStart=session.documentToScreenPosition(this.start),screenPosEnd=session.documentToScreenPosition(this.end);return new Range(screenPosStart.row,screenPosStart.column,screenPosEnd.row,screenPosEnd.column)},this.moveBy=function(row,column){this.start.row+=row,this.start.column+=column,this.end.row+=row,this.end.column+=column}}).call(Range.prototype),Range.fromPoints=function(start,end){return new Range(start.row,start.column,end.row,end.column)},Range.comparePoints=comparePoints,Range.comparePoints=function(p1,p2){return p1.row-p2.row||p1.column-p2.column},exports.Range=Range}),ace.define(\"ace/anchor\",[\"require\",\"exports\",\"module\",\"ace/lib/oop\",\"ace/lib/event_emitter\"],function(acequire,exports){\"use strict\";var oop=acequire(\"./lib/oop\"),EventEmitter=acequire(\"./lib/event_emitter\").EventEmitter,Anchor=exports.Anchor=function(doc,row,column){this.$onChange=this.onChange.bind(this),this.attach(doc),column===void 0?this.setPosition(row.row,row.column):this.setPosition(row,column)};(function(){oop.implement(this,EventEmitter),this.getPosition=function(){return this.$clipPositionToDocument(this.row,this.column)},this.getDocument=function(){return this.document},this.$insertRight=!1,this.onChange=function(e){var delta=e.data,range=delta.range;if(!(range.start.row==range.end.row&&range.start.row!=this.row||range.start.row>this.row||range.start.row==this.row&&range.start.column>this.column)){var row=this.row,column=this.column,start=range.start,end=range.end;\"insertText\"===delta.action?start.row===row&&column>=start.column?start.column===column&&this.$insertRight||(start.row===end.row?column+=end.column-start.column:(column-=start.column,row+=end.row-start.row)):start.row!==end.row&&row>start.row&&(row+=end.row-start.row):\"insertLines\"===delta.action?start.row===row&&0===column&&this.$insertRight||row>=start.row&&(row+=end.row-start.row):\"removeText\"===delta.action?start.row===row&&column>start.column?column=end.column>=column?start.column:Math.max(0,column-(end.column-start.column)):start.row!==end.row&&row>start.row?(end.row===row&&(column=Math.max(0,column-end.column)+start.column),row-=end.row-start.row):end.row===row&&(row-=end.row-start.row,column=Math.max(0,column-end.column)+start.column):\"removeLines\"==delta.action&&row>=start.row&&(row>=end.row?row-=end.row-start.row:(row=start.row,column=0)),this.setPosition(row,column,!0)}},this.setPosition=function(row,column,noClip){var pos;if(pos=noClip?{row:row,column:column}:this.$clipPositionToDocument(row,column),this.row!=pos.row||this.column!=pos.column){var old={row:this.row,column:this.column};this.row=pos.row,this.column=pos.column,this._signal(\"change\",{old:old,value:pos})}},this.detach=function(){this.document.removeEventListener(\"change\",this.$onChange)},this.attach=function(doc){this.document=doc||this.document,this.document.on(\"change\",this.$onChange)},this.$clipPositionToDocument=function(row,column){var pos={};return row>=this.document.getLength()?(pos.row=Math.max(0,this.document.getLength()-1),pos.column=this.document.getLine(pos.row).length):0>row?(pos.row=0,pos.column=0):(pos.row=row,pos.column=Math.min(this.document.getLine(pos.row).length,Math.max(0,column))),0>column&&(pos.column=0),pos}}).call(Anchor.prototype)}),ace.define(\"ace/document\",[\"require\",\"exports\",\"module\",\"ace/lib/oop\",\"ace/lib/event_emitter\",\"ace/range\",\"ace/anchor\"],function(acequire,exports){\"use strict\";var oop=acequire(\"./lib/oop\"),EventEmitter=acequire(\"./lib/event_emitter\").EventEmitter,Range=acequire(\"./range\").Range,Anchor=acequire(\"./anchor\").Anchor,Document=function(text){this.$lines=[],0===text.length?this.$lines=[\"\"]:Array.isArray(text)?this._insertLines(0,text):this.insert({row:0,column:0},text)};(function(){oop.implement(this,EventEmitter),this.setValue=function(text){var len=this.getLength();this.remove(new Range(0,0,len,this.getLine(len-1).length)),this.insert({row:0,column:0},text)},this.getValue=function(){return this.getAllLines().join(this.getNewLineCharacter())},this.createAnchor=function(row,column){return new Anchor(this,row,column)},this.$split=0===\"aaa\".split(/a/).length?function(text){return text.replace(/\\r\\n|\\r/g,\"\\n\").split(\"\\n\")}:function(text){return text.split(/\\r\\n|\\r|\\n/)},this.$detectNewLine=function(text){var match=text.match(/^.*?(\\r\\n|\\r|\\n)/m);this.$autoNewLine=match?match[1]:\"\\n\",this._signal(\"changeNewLineMode\")},this.getNewLineCharacter=function(){switch(this.$newLineMode){case\"windows\":return\"\\r\\n\";case\"unix\":return\"\\n\";default:return this.$autoNewLine||\"\\n\"}},this.$autoNewLine=\"\",this.$newLineMode=\"auto\",this.setNewLineMode=function(newLineMode){this.$newLineMode!==newLineMode&&(this.$newLineMode=newLineMode,this._signal(\"changeNewLineMode\"))},this.getNewLineMode=function(){return this.$newLineMode},this.isNewLine=function(text){return\"\\r\\n\"==text||\"\\r\"==text||\"\\n\"==text},this.getLine=function(row){return this.$lines[row]||\"\"},this.getLines=function(firstRow,lastRow){return this.$lines.slice(firstRow,lastRow+1)},this.getAllLines=function(){return this.getLines(0,this.getLength())},this.getLength=function(){return this.$lines.length},this.getTextRange=function(range){if(range.start.row==range.end.row)return this.getLine(range.start.row).substring(range.start.column,range.end.column);var lines=this.getLines(range.start.row,range.end.row);lines[0]=(lines[0]||\"\").substring(range.start.column);var l=lines.length-1;return range.end.row-range.start.row==l&&(lines[l]=lines[l].substring(0,range.end.column)),lines.join(this.getNewLineCharacter())},this.$clipPosition=function(position){var length=this.getLength();return position.row>=length?(position.row=Math.max(0,length-1),position.column=this.getLine(length-1).length):0>position.row&&(position.row=0),position},this.insert=function(position,text){if(!text||0===text.length)return position;position=this.$clipPosition(position),1>=this.getLength()&&this.$detectNewLine(text);var lines=this.$split(text),firstLine=lines.splice(0,1)[0],lastLine=0==lines.length?null:lines.splice(lines.length-1,1)[0];return position=this.insertInLine(position,firstLine),null!==lastLine&&(position=this.insertNewLine(position),position=this._insertLines(position.row,lines),position=this.insertInLine(position,lastLine||\"\")),position},this.insertLines=function(row,lines){return row>=this.getLength()?this.insert({row:row,column:0},\"\\n\"+lines.join(\"\\n\")):this._insertLines(Math.max(row,0),lines)},this._insertLines=function(row,lines){if(0==lines.length)return{row:row,column:0};for(;lines.length>61440;){var end=this._insertLines(row,lines.slice(0,61440));lines=lines.slice(61440),row=end.row}var args=[row,0];args.push.apply(args,lines),this.$lines.splice.apply(this.$lines,args);var range=new Range(row,0,row+lines.length,0),delta={action:\"insertLines\",range:range,lines:lines};return this._signal(\"change\",{data:delta}),range.end},this.insertNewLine=function(position){position=this.$clipPosition(position);var line=this.$lines[position.row]||\"\";this.$lines[position.row]=line.substring(0,position.column),this.$lines.splice(position.row+1,0,line.substring(position.column,line.length));var end={row:position.row+1,column:0},delta={action:\"insertText\",range:Range.fromPoints(position,end),text:this.getNewLineCharacter()};return this._signal(\"change\",{data:delta}),end},this.insertInLine=function(position,text){if(0==text.length)return position;var line=this.$lines[position.row]||\"\";this.$lines[position.row]=line.substring(0,position.column)+text+line.substring(position.column);var end={row:position.row,column:position.column+text.length},delta={action:\"insertText\",range:Range.fromPoints(position,end),text:text};return this._signal(\"change\",{data:delta}),end},this.remove=function(range){if(range instanceof Range||(range=Range.fromPoints(range.start,range.end)),range.start=this.$clipPosition(range.start),range.end=this.$clipPosition(range.end),range.isEmpty())return range.start;var firstRow=range.start.row,lastRow=range.end.row;if(range.isMultiLine()){var firstFullRow=0==range.start.column?firstRow:firstRow+1,lastFullRow=lastRow-1;range.end.column>0&&this.removeInLine(lastRow,0,range.end.column),lastFullRow>=firstFullRow&&this._removeLines(firstFullRow,lastFullRow),firstFullRow!=firstRow&&(this.removeInLine(firstRow,range.start.column,this.getLine(firstRow).length),this.removeNewLine(range.start.row))}else this.removeInLine(firstRow,range.start.column,range.end.column);return range.start},this.removeInLine=function(row,startColumn,endColumn){if(startColumn!=endColumn){var range=new Range(row,startColumn,row,endColumn),line=this.getLine(row),removed=line.substring(startColumn,endColumn),newLine=line.substring(0,startColumn)+line.substring(endColumn,line.length);this.$lines.splice(row,1,newLine);var delta={action:\"removeText\",range:range,text:removed};return this._signal(\"change\",{data:delta}),range.start}},this.removeLines=function(firstRow,lastRow){return 0>firstRow||lastRow>=this.getLength()?this.remove(new Range(firstRow,0,lastRow+1,0)):this._removeLines(firstRow,lastRow)},this._removeLines=function(firstRow,lastRow){var range=new Range(firstRow,0,lastRow+1,0),removed=this.$lines.splice(firstRow,lastRow-firstRow+1),delta={action:\"removeLines\",range:range,nl:this.getNewLineCharacter(),lines:removed};return this._signal(\"change\",{data:delta}),removed},this.removeNewLine=function(row){var firstLine=this.getLine(row),secondLine=this.getLine(row+1),range=new Range(row,firstLine.length,row+1,0),line=firstLine+secondLine;this.$lines.splice(row,2,line);var delta={action:\"removeText\",range:range,text:this.getNewLineCharacter()};this._signal(\"change\",{data:delta})},this.replace=function(range,text){if(range instanceof Range||(range=Range.fromPoints(range.start,range.end)),0==text.length&&range.isEmpty())return range.start;if(text==this.getTextRange(range))return range.end;if(this.remove(range),text)var end=this.insert(range.start,text);else end=range.start;return end},this.applyDeltas=function(deltas){for(var i=0;deltas.length>i;i++){var delta=deltas[i],range=Range.fromPoints(delta.range.start,delta.range.end);\"insertLines\"==delta.action?this.insertLines(range.start.row,delta.lines):\"insertText\"==delta.action?this.insert(range.start,delta.text):\"removeLines\"==delta.action?this._removeLines(range.start.row,range.end.row-1):\"removeText\"==delta.action&&this.remove(range)}},this.revertDeltas=function(deltas){for(var i=deltas.length-1;i>=0;i--){var delta=deltas[i],range=Range.fromPoints(delta.range.start,delta.range.end);\"insertLines\"==delta.action?this._removeLines(range.start.row,range.end.row-1):\"insertText\"==delta.action?this.remove(range):\"removeLines\"==delta.action?this._insertLines(range.start.row,delta.lines):\"removeText\"==delta.action&&this.insert(range.start,delta.text)}},this.indexToPosition=function(index,startRow){for(var lines=this.$lines||this.getAllLines(),newlineLength=this.getNewLineCharacter().length,i=startRow||0,l=lines.length;l>i;i++)if(index-=lines[i].length+newlineLength,0>index)return{row:i,column:index+lines[i].length+newlineLength};return{row:l-1,column:lines[l-1].length}},this.positionToIndex=function(pos,startRow){for(var lines=this.$lines||this.getAllLines(),newlineLength=this.getNewLineCharacter().length,index=0,row=Math.min(pos.row,lines.length),i=startRow||0;row>i;++i)index+=lines[i].length+newlineLength;return index+pos.column}}).call(Document.prototype),exports.Document=Document}),ace.define(\"ace/lib/lang\",[\"require\",\"exports\",\"module\"],function(acequire,exports){\"use strict\";exports.last=function(a){return a[a.length-1]},exports.stringReverse=function(string){return string.split(\"\").reverse().join(\"\")},exports.stringRepeat=function(string,count){for(var result=\"\";count>0;)1&count&&(result+=string),(count>>=1)&&(string+=string);return result};var trimBeginRegexp=/^\\s\\s*/,trimEndRegexp=/\\s\\s*$/;exports.stringTrimLeft=function(string){return string.replace(trimBeginRegexp,\"\")},exports.stringTrimRight=function(string){return string.replace(trimEndRegexp,\"\")},exports.copyObject=function(obj){var copy={};for(var key in obj)copy[key]=obj[key];return copy},exports.copyArray=function(array){for(var copy=[],i=0,l=array.length;l>i;i++)copy[i]=array[i]&&\"object\"==typeof array[i]?this.copyObject(array[i]):array[i];return copy},exports.deepCopy=function(obj){if(\"object\"!=typeof obj||!obj)return obj;var cons=obj.constructor;if(cons===RegExp)return obj;var copy=cons();for(var key in obj)copy[key]=\"object\"==typeof obj[key]?exports.deepCopy(obj[key]):obj[key];return copy},exports.arrayToMap=function(arr){for(var map={},i=0;arr.length>i;i++)map[arr[i]]=1;return map},exports.createMap=function(props){var map=Object.create(null);for(var i in props)map[i]=props[i];return map},exports.arrayRemove=function(array,value){for(var i=0;array.length>=i;i++)value===array[i]&&array.splice(i,1)},exports.escapeRegExp=function(str){return str.replace(/([.*+?^${}()|[\\]\\/\\\\])/g,\"\\\\$1\")},exports.escapeHTML=function(str){return str.replace(/&/g,\"&#38;\").replace(/\"/g,\"&#34;\").replace(/'/g,\"&#39;\").replace(/</g,\"&#60;\")},exports.getMatchOffsets=function(string,regExp){var matches=[];return string.replace(regExp,function(str){matches.push({offset:arguments[arguments.length-2],length:str.length})}),matches},exports.deferredCall=function(fcn){var timer=null,callback=function(){timer=null,fcn()},deferred=function(timeout){return deferred.cancel(),timer=setTimeout(callback,timeout||0),deferred};return deferred.schedule=deferred,deferred.call=function(){return this.cancel(),fcn(),deferred},deferred.cancel=function(){return clearTimeout(timer),timer=null,deferred},deferred.isPending=function(){return timer},deferred},exports.delayedCall=function(fcn,defaultTimeout){var timer=null,callback=function(){timer=null,fcn()},_self=function(timeout){null==timer&&(timer=setTimeout(callback,timeout||defaultTimeout))};return _self.delay=function(timeout){timer&&clearTimeout(timer),timer=setTimeout(callback,timeout||defaultTimeout)},_self.schedule=_self,_self.call=function(){this.cancel(),fcn()},_self.cancel=function(){timer&&clearTimeout(timer),timer=null},_self.isPending=function(){return timer},_self}}),ace.define(\"ace/worker/mirror\",[\"require\",\"exports\",\"module\",\"ace/document\",\"ace/lib/lang\"],function(acequire,exports){\"use strict\";var Document=acequire(\"../document\").Document,lang=acequire(\"../lib/lang\"),Mirror=exports.Mirror=function(sender){this.sender=sender;var doc=this.doc=new Document(\"\"),deferredUpdate=this.deferredUpdate=lang.delayedCall(this.onUpdate.bind(this)),_self=this;sender.on(\"change\",function(e){return doc.applyDeltas(e.data),_self.$timeout?deferredUpdate.schedule(_self.$timeout):(_self.onUpdate(),void 0)})};(function(){this.$timeout=500,this.setTimeout=function(timeout){this.$timeout=timeout},this.setValue=function(value){this.doc.setValue(value),this.deferredUpdate.schedule(this.$timeout)},this.getValue=function(callbackId){this.sender.callback(this.doc.getValue(),callbackId)},this.onUpdate=function(){},this.isPending=function(){return this.deferredUpdate.isPending()}}).call(Mirror.prototype)}),ace.define(\"ace/mode/javascript/jshint\",[\"require\",\"exports\",\"module\"],function(acequire,exports,module){module.exports=function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=\"function\"==typeof acequire&&acequire;if(!u&&a)return a(o,!0);if(i)return i(o,!0);throw Error(\"Cannot find module '\"+o+\"'\")}var f=n[o]={exports:{}};t[o][0].call(f.exports,function(e){var n=t[o][1][e];return s(n?n:e)},f,f.exports,e,t,n,r)}return n[o].exports}for(var i=\"function\"==typeof acequire&&acequire,o=0;r.length>o;o++)s(r[o]);return s}({1:[function(_dereq_,module){for(var identifierStartTable=[],i=0;128>i;i++)identifierStartTable[i]=36===i||i>=65&&90>=i||95===i||i>=97&&122>=i;for(var identifierPartTable=[],i=0;128>i;i++)identifierPartTable[i]=identifierStartTable[i]||i>=48&&57>=i;module.exports={asciiIdentifierStartTable:identifierStartTable,asciiIdentifierPartTable:identifierPartTable}},{}],2:[function(_dereq_,module,exports){(function(){var root=this,previousUnderscore=root._,breaker={},ArrayProto=Array.prototype,ObjProto=Object.prototype,FuncProto=Function.prototype,push=ArrayProto.push,slice=ArrayProto.slice,concat=ArrayProto.concat,toString=ObjProto.toString,hasOwnProperty=ObjProto.hasOwnProperty,nativeForEach=ArrayProto.forEach,nativeMap=ArrayProto.map,nativeReduce=ArrayProto.reduce,nativeReduceRight=ArrayProto.reduceRight,nativeFilter=ArrayProto.filter,nativeEvery=ArrayProto.every,nativeSome=ArrayProto.some,nativeIndexOf=ArrayProto.indexOf,nativeLastIndexOf=ArrayProto.lastIndexOf,nativeIsArray=Array.isArray,nativeKeys=Object.keys,nativeBind=FuncProto.bind,_=function(obj){return obj instanceof _?obj:this instanceof _?(this._wrapped=obj,void 0):new _(obj)};exports!==void 0?(module!==void 0&&module.exports&&(exports=module.exports=_),exports._=_):root._=_,_.VERSION=\"1.6.0\";var each=_.each=_.forEach=function(obj,iterator,context){if(null==obj)return obj;if(nativeForEach&&obj.forEach===nativeForEach)obj.forEach(iterator,context);else if(obj.length===+obj.length){for(var i=0,length=obj.length;length>i;i++)if(iterator.call(context,obj[i],i,obj)===breaker)return}else for(var keys=_.keys(obj),i=0,length=keys.length;length>i;i++)if(iterator.call(context,obj[keys[i]],keys[i],obj)===breaker)return;return obj};_.map=_.collect=function(obj,iterator,context){var results=[];return null==obj?results:nativeMap&&obj.map===nativeMap?obj.map(iterator,context):(each(obj,function(value,index,list){results.push(iterator.call(context,value,index,list))}),results)};var reduceError=\"Reduce of empty array with no initial value\";_.reduce=_.foldl=_.inject=function(obj,iterator,memo,context){var initial=arguments.length>2;if(null==obj&&(obj=[]),nativeReduce&&obj.reduce===nativeReduce)return context&&(iterator=_.bind(iterator,context)),initial?obj.reduce(iterator,memo):obj.reduce(iterator);if(each(obj,function(value,index,list){initial?memo=iterator.call(context,memo,value,index,list):(memo=value,initial=!0)}),!initial)throw new TypeError(reduceError);return memo},_.reduceRight=_.foldr=function(obj,iterator,memo,context){var initial=arguments.length>2;if(null==obj&&(obj=[]),nativeReduceRight&&obj.reduceRight===nativeReduceRight)return context&&(iterator=_.bind(iterator,context)),initial?obj.reduceRight(iterator,memo):obj.reduceRight(iterator);var length=obj.length;if(length!==+length){var keys=_.keys(obj);length=keys.length}if(each(obj,function(value,index,list){index=keys?keys[--length]:--length,initial?memo=iterator.call(context,memo,obj[index],index,list):(memo=obj[index],initial=!0)}),!initial)throw new TypeError(reduceError);return memo},_.find=_.detect=function(obj,predicate,context){var result;return any(obj,function(value,index,list){return predicate.call(context,value,index,list)?(result=value,!0):void 0}),result},_.filter=_.select=function(obj,predicate,context){var results=[];return null==obj?results:nativeFilter&&obj.filter===nativeFilter?obj.filter(predicate,context):(each(obj,function(value,index,list){predicate.call(context,value,index,list)&&results.push(value)}),results)},_.reject=function(obj,predicate,context){return _.filter(obj,function(value,index,list){return!predicate.call(context,value,index,list)},context)},_.every=_.all=function(obj,predicate,context){predicate||(predicate=_.identity);var result=!0;return null==obj?result:nativeEvery&&obj.every===nativeEvery?obj.every(predicate,context):(each(obj,function(value,index,list){return(result=result&&predicate.call(context,value,index,list))?void 0:breaker}),!!result)};var any=_.some=_.any=function(obj,predicate,context){predicate||(predicate=_.identity);var result=!1;return null==obj?result:nativeSome&&obj.some===nativeSome?obj.some(predicate,context):(each(obj,function(value,index,list){return result||(result=predicate.call(context,value,index,list))?breaker:void 0}),!!result)};_.contains=_.include=function(obj,target){return null==obj?!1:nativeIndexOf&&obj.indexOf===nativeIndexOf?-1!=obj.indexOf(target):any(obj,function(value){return value===target})},_.invoke=function(obj,method){var args=slice.call(arguments,2),isFunc=_.isFunction(method);return _.map(obj,function(value){return(isFunc?method:value[method]).apply(value,args)})},_.pluck=function(obj,key){return _.map(obj,_.property(key))},_.where=function(obj,attrs){return _.filter(obj,_.matches(attrs))},_.findWhere=function(obj,attrs){return _.find(obj,_.matches(attrs))},_.max=function(obj,iterator,context){if(!iterator&&_.isArray(obj)&&obj[0]===+obj[0]&&65535>obj.length)return Math.max.apply(Math,obj);var result=-1/0,lastComputed=-1/0;return each(obj,function(value,index,list){var computed=iterator?iterator.call(context,value,index,list):value;computed>lastComputed&&(result=value,lastComputed=computed)}),result},_.min=function(obj,iterator,context){if(!iterator&&_.isArray(obj)&&obj[0]===+obj[0]&&65535>obj.length)return Math.min.apply(Math,obj);var result=1/0,lastComputed=1/0;return each(obj,function(value,index,list){var computed=iterator?iterator.call(context,value,index,list):value;lastComputed>computed&&(result=value,lastComputed=computed)}),result},_.shuffle=function(obj){var rand,index=0,shuffled=[];return each(obj,function(value){rand=_.random(index++),shuffled[index-1]=shuffled[rand],shuffled[rand]=value}),shuffled},_.sample=function(obj,n,guard){return null==n||guard?(obj.length!==+obj.length&&(obj=_.values(obj)),obj[_.random(obj.length-1)]):_.shuffle(obj).slice(0,Math.max(0,n))};var lookupIterator=function(value){return null==value?_.identity:_.isFunction(value)?value:_.property(value)};_.sortBy=function(obj,iterator,context){return iterator=lookupIterator(iterator),_.pluck(_.map(obj,function(value,index,list){return{value:value,index:index,criteria:iterator.call(context,value,index,list)}\n}).sort(function(left,right){var a=left.criteria,b=right.criteria;if(a!==b){if(a>b||void 0===a)return 1;if(b>a||void 0===b)return-1}return left.index-right.index}),\"value\")};var group=function(behavior){return function(obj,iterator,context){var result={};return iterator=lookupIterator(iterator),each(obj,function(value,index){var key=iterator.call(context,value,index,obj);behavior(result,key,value)}),result}};_.groupBy=group(function(result,key,value){_.has(result,key)?result[key].push(value):result[key]=[value]}),_.indexBy=group(function(result,key,value){result[key]=value}),_.countBy=group(function(result,key){_.has(result,key)?result[key]++:result[key]=1}),_.sortedIndex=function(array,obj,iterator,context){iterator=lookupIterator(iterator);for(var value=iterator.call(context,obj),low=0,high=array.length;high>low;){var mid=low+high>>>1;value>iterator.call(context,array[mid])?low=mid+1:high=mid}return low},_.toArray=function(obj){return obj?_.isArray(obj)?slice.call(obj):obj.length===+obj.length?_.map(obj,_.identity):_.values(obj):[]},_.size=function(obj){return null==obj?0:obj.length===+obj.length?obj.length:_.keys(obj).length},_.first=_.head=_.take=function(array,n,guard){return null==array?void 0:null==n||guard?array[0]:0>n?[]:slice.call(array,0,n)},_.initial=function(array,n,guard){return slice.call(array,0,array.length-(null==n||guard?1:n))},_.last=function(array,n,guard){return null==array?void 0:null==n||guard?array[array.length-1]:slice.call(array,Math.max(array.length-n,0))},_.rest=_.tail=_.drop=function(array,n,guard){return slice.call(array,null==n||guard?1:n)},_.compact=function(array){return _.filter(array,_.identity)};var flatten=function(input,shallow,output){return shallow&&_.every(input,_.isArray)?concat.apply(output,input):(each(input,function(value){_.isArray(value)||_.isArguments(value)?shallow?push.apply(output,value):flatten(value,shallow,output):output.push(value)}),output)};_.flatten=function(array,shallow){return flatten(array,shallow,[])},_.without=function(array){return _.difference(array,slice.call(arguments,1))},_.partition=function(array,predicate){var pass=[],fail=[];return each(array,function(elem){(predicate(elem)?pass:fail).push(elem)}),[pass,fail]},_.uniq=_.unique=function(array,isSorted,iterator,context){_.isFunction(isSorted)&&(context=iterator,iterator=isSorted,isSorted=!1);var initial=iterator?_.map(array,iterator,context):array,results=[],seen=[];return each(initial,function(value,index){(isSorted?index&&seen[seen.length-1]===value:_.contains(seen,value))||(seen.push(value),results.push(array[index]))}),results},_.union=function(){return _.uniq(_.flatten(arguments,!0))},_.intersection=function(array){var rest=slice.call(arguments,1);return _.filter(_.uniq(array),function(item){return _.every(rest,function(other){return _.contains(other,item)})})},_.difference=function(array){var rest=concat.apply(ArrayProto,slice.call(arguments,1));return _.filter(array,function(value){return!_.contains(rest,value)})},_.zip=function(){for(var length=_.max(_.pluck(arguments,\"length\").concat(0)),results=Array(length),i=0;length>i;i++)results[i]=_.pluck(arguments,\"\"+i);return results},_.object=function(list,values){if(null==list)return{};for(var result={},i=0,length=list.length;length>i;i++)values?result[list[i]]=values[i]:result[list[i][0]]=list[i][1];return result},_.indexOf=function(array,item,isSorted){if(null==array)return-1;var i=0,length=array.length;if(isSorted){if(\"number\"!=typeof isSorted)return i=_.sortedIndex(array,item),array[i]===item?i:-1;i=0>isSorted?Math.max(0,length+isSorted):isSorted}if(nativeIndexOf&&array.indexOf===nativeIndexOf)return array.indexOf(item,isSorted);for(;length>i;i++)if(array[i]===item)return i;return-1},_.lastIndexOf=function(array,item,from){if(null==array)return-1;var hasIndex=null!=from;if(nativeLastIndexOf&&array.lastIndexOf===nativeLastIndexOf)return hasIndex?array.lastIndexOf(item,from):array.lastIndexOf(item);for(var i=hasIndex?from:array.length;i--;)if(array[i]===item)return i;return-1},_.range=function(start,stop,step){1>=arguments.length&&(stop=start||0,start=0),step=arguments[2]||1;for(var length=Math.max(Math.ceil((stop-start)/step),0),idx=0,range=Array(length);length>idx;)range[idx++]=start,start+=step;return range};var ctor=function(){};_.bind=function(func,context){var args,bound;if(nativeBind&&func.bind===nativeBind)return nativeBind.apply(func,slice.call(arguments,1));if(!_.isFunction(func))throw new TypeError;return args=slice.call(arguments,2),bound=function(){if(!(this instanceof bound))return func.apply(context,args.concat(slice.call(arguments)));ctor.prototype=func.prototype;var self=new ctor;ctor.prototype=null;var result=func.apply(self,args.concat(slice.call(arguments)));return Object(result)===result?result:self}},_.partial=function(func){var boundArgs=slice.call(arguments,1);return function(){for(var position=0,args=boundArgs.slice(),i=0,length=args.length;length>i;i++)args[i]===_&&(args[i]=arguments[position++]);for(;arguments.length>position;)args.push(arguments[position++]);return func.apply(this,args)}},_.bindAll=function(obj){var funcs=slice.call(arguments,1);if(0===funcs.length)throw Error(\"bindAll must be passed function names\");return each(funcs,function(f){obj[f]=_.bind(obj[f],obj)}),obj},_.memoize=function(func,hasher){var memo={};return hasher||(hasher=_.identity),function(){var key=hasher.apply(this,arguments);return _.has(memo,key)?memo[key]:memo[key]=func.apply(this,arguments)}},_.delay=function(func,wait){var args=slice.call(arguments,2);return setTimeout(function(){return func.apply(null,args)},wait)},_.defer=function(func){return _.delay.apply(_,[func,1].concat(slice.call(arguments,1)))},_.throttle=function(func,wait,options){var context,args,result,timeout=null,previous=0;options||(options={});var later=function(){previous=options.leading===!1?0:_.now(),timeout=null,result=func.apply(context,args),context=args=null};return function(){var now=_.now();previous||options.leading!==!1||(previous=now);var remaining=wait-(now-previous);return context=this,args=arguments,0>=remaining?(clearTimeout(timeout),timeout=null,previous=now,result=func.apply(context,args),context=args=null):timeout||options.trailing===!1||(timeout=setTimeout(later,remaining)),result}},_.debounce=function(func,wait,immediate){var timeout,args,context,timestamp,result,later=function(){var last=_.now()-timestamp;wait>last?timeout=setTimeout(later,wait-last):(timeout=null,immediate||(result=func.apply(context,args),context=args=null))};return function(){context=this,args=arguments,timestamp=_.now();var callNow=immediate&&!timeout;return timeout||(timeout=setTimeout(later,wait)),callNow&&(result=func.apply(context,args),context=args=null),result}},_.once=function(func){var memo,ran=!1;return function(){return ran?memo:(ran=!0,memo=func.apply(this,arguments),func=null,memo)}},_.wrap=function(func,wrapper){return _.partial(wrapper,func)},_.compose=function(){var funcs=arguments;return function(){for(var args=arguments,i=funcs.length-1;i>=0;i--)args=[funcs[i].apply(this,args)];return args[0]}},_.after=function(times,func){return function(){return 1>--times?func.apply(this,arguments):void 0}},_.keys=function(obj){if(!_.isObject(obj))return[];if(nativeKeys)return nativeKeys(obj);var keys=[];for(var key in obj)_.has(obj,key)&&keys.push(key);return keys},_.values=function(obj){for(var keys=_.keys(obj),length=keys.length,values=Array(length),i=0;length>i;i++)values[i]=obj[keys[i]];return values},_.pairs=function(obj){for(var keys=_.keys(obj),length=keys.length,pairs=Array(length),i=0;length>i;i++)pairs[i]=[keys[i],obj[keys[i]]];return pairs},_.invert=function(obj){for(var result={},keys=_.keys(obj),i=0,length=keys.length;length>i;i++)result[obj[keys[i]]]=keys[i];return result},_.functions=_.methods=function(obj){var names=[];for(var key in obj)_.isFunction(obj[key])&&names.push(key);return names.sort()},_.extend=function(obj){return each(slice.call(arguments,1),function(source){if(source)for(var prop in source)obj[prop]=source[prop]}),obj},_.pick=function(obj){var copy={},keys=concat.apply(ArrayProto,slice.call(arguments,1));return each(keys,function(key){key in obj&&(copy[key]=obj[key])}),copy},_.omit=function(obj){var copy={},keys=concat.apply(ArrayProto,slice.call(arguments,1));for(var key in obj)_.contains(keys,key)||(copy[key]=obj[key]);return copy},_.defaults=function(obj){return each(slice.call(arguments,1),function(source){if(source)for(var prop in source)void 0===obj[prop]&&(obj[prop]=source[prop])}),obj},_.clone=function(obj){return _.isObject(obj)?_.isArray(obj)?obj.slice():_.extend({},obj):obj},_.tap=function(obj,interceptor){return interceptor(obj),obj};var eq=function(a,b,aStack,bStack){if(a===b)return 0!==a||1/a==1/b;if(null==a||null==b)return a===b;a instanceof _&&(a=a._wrapped),b instanceof _&&(b=b._wrapped);var className=toString.call(a);if(className!=toString.call(b))return!1;switch(className){case\"[object String]\":return a==b+\"\";case\"[object Number]\":return a!=+a?b!=+b:0==a?1/a==1/b:a==+b;case\"[object Date]\":case\"[object Boolean]\":return+a==+b;case\"[object RegExp]\":return a.source==b.source&&a.global==b.global&&a.multiline==b.multiline&&a.ignoreCase==b.ignoreCase}if(\"object\"!=typeof a||\"object\"!=typeof b)return!1;for(var length=aStack.length;length--;)if(aStack[length]==a)return bStack[length]==b;var aCtor=a.constructor,bCtor=b.constructor;if(aCtor!==bCtor&&!(_.isFunction(aCtor)&&aCtor instanceof aCtor&&_.isFunction(bCtor)&&bCtor instanceof bCtor)&&\"constructor\"in a&&\"constructor\"in b)return!1;aStack.push(a),bStack.push(b);var size=0,result=!0;if(\"[object Array]\"==className){if(size=a.length,result=size==b.length)for(;size--&&(result=eq(a[size],b[size],aStack,bStack)););}else{for(var key in a)if(_.has(a,key)&&(size++,!(result=_.has(b,key)&&eq(a[key],b[key],aStack,bStack))))break;if(result){for(key in b)if(_.has(b,key)&&!size--)break;result=!size}}return aStack.pop(),bStack.pop(),result};_.isEqual=function(a,b){return eq(a,b,[],[])},_.isEmpty=function(obj){if(null==obj)return!0;if(_.isArray(obj)||_.isString(obj))return 0===obj.length;for(var key in obj)if(_.has(obj,key))return!1;return!0},_.isElement=function(obj){return!(!obj||1!==obj.nodeType)},_.isArray=nativeIsArray||function(obj){return\"[object Array]\"==toString.call(obj)},_.isObject=function(obj){return obj===Object(obj)},each([\"Arguments\",\"Function\",\"String\",\"Number\",\"Date\",\"RegExp\"],function(name){_[\"is\"+name]=function(obj){return toString.call(obj)==\"[object \"+name+\"]\"}}),_.isArguments(arguments)||(_.isArguments=function(obj){return!(!obj||!_.has(obj,\"callee\"))}),_.isFunction=function(obj){return\"function\"==typeof obj},_.isFinite=function(obj){return isFinite(obj)&&!isNaN(parseFloat(obj))},_.isNaN=function(obj){return _.isNumber(obj)&&obj!=+obj},_.isBoolean=function(obj){return obj===!0||obj===!1||\"[object Boolean]\"==toString.call(obj)},_.isNull=function(obj){return null===obj},_.isUndefined=function(obj){return void 0===obj},_.has=function(obj,key){return hasOwnProperty.call(obj,key)},_.noConflict=function(){return root._=previousUnderscore,this},_.identity=function(value){return value},_.constant=function(value){return function(){return value}},_.property=function(key){return function(obj){return obj[key]}},_.matches=function(attrs){return function(obj){if(obj===attrs)return!0;for(var key in attrs)if(attrs[key]!==obj[key])return!1;return!0}},_.times=function(n,iterator,context){for(var accum=Array(Math.max(0,n)),i=0;n>i;i++)accum[i]=iterator.call(context,i);return accum},_.random=function(min,max){return null==max&&(max=min,min=0),min+Math.floor(Math.random()*(max-min+1))},_.now=Date.now||function(){return(new Date).getTime()};var entityMap={escape:{\"&\":\"&amp;\",\"<\":\"&lt;\",\">\":\"&gt;\",'\"':\"&quot;\",\"'\":\"&#x27;\"}};entityMap.unescape=_.invert(entityMap.escape);var entityRegexes={escape:RegExp(\"[\"+_.keys(entityMap.escape).join(\"\")+\"]\",\"g\"),unescape:RegExp(\"(\"+_.keys(entityMap.unescape).join(\"|\")+\")\",\"g\")};_.each([\"escape\",\"unescape\"],function(method){_[method]=function(string){return null==string?\"\":(\"\"+string).replace(entityRegexes[method],function(match){return entityMap[method][match]})}}),_.result=function(object,property){if(null==object)return void 0;var value=object[property];return _.isFunction(value)?value.call(object):value},_.mixin=function(obj){each(_.functions(obj),function(name){var func=_[name]=obj[name];_.prototype[name]=function(){var args=[this._wrapped];return push.apply(args,arguments),result.call(this,func.apply(_,args))}})};var idCounter=0;_.uniqueId=function(prefix){var id=++idCounter+\"\";return prefix?prefix+id:id},_.templateSettings={evaluate:/<%([\\s\\S]+?)%>/g,interpolate:/<%=([\\s\\S]+?)%>/g,escape:/<%-([\\s\\S]+?)%>/g};var noMatch=/(.)^/,escapes={\"'\":\"'\",\"\\\\\":\"\\\\\",\"\\r\":\"r\",\"\\n\":\"n\",\"\t\":\"t\",\"\\u2028\":\"u2028\",\"\\u2029\":\"u2029\"},escaper=/\\\\|'|\\r|\\n|\\t|\\u2028|\\u2029/g;_.template=function(text,data,settings){var render;settings=_.defaults({},settings,_.templateSettings);var matcher=RegExp([(settings.escape||noMatch).source,(settings.interpolate||noMatch).source,(settings.evaluate||noMatch).source].join(\"|\")+\"|$\",\"g\"),index=0,source=\"__p+='\";text.replace(matcher,function(match,escape,interpolate,evaluate,offset){return source+=text.slice(index,offset).replace(escaper,function(match){return\"\\\\\"+escapes[match]}),escape&&(source+=\"'+\\n((__t=(\"+escape+\"))==null?'':_.escape(__t))+\\n'\"),interpolate&&(source+=\"'+\\n((__t=(\"+interpolate+\"))==null?'':__t)+\\n'\"),evaluate&&(source+=\"';\\n\"+evaluate+\"\\n__p+='\"),index=offset+match.length,match}),source+=\"';\\n\",settings.variable||(source=\"with(obj||{}){\\n\"+source+\"}\\n\"),source=\"var __t,__p='',__j=Array.prototype.join,print=function(){__p+=__j.call(arguments,'');};\\n\"+source+\"return __p;\\n\";try{render=Function(settings.variable||\"obj\",\"_\",source)}catch(e){throw e.source=source,e}if(data)return render(data,_);var template=function(data){return render.call(this,data,_)};return template.source=\"function(\"+(settings.variable||\"obj\")+\"){\\n\"+source+\"}\",template},_.chain=function(obj){return _(obj).chain()};var result=function(obj){return this._chain?_(obj).chain():obj};_.mixin(_),each([\"pop\",\"push\",\"reverse\",\"shift\",\"sort\",\"splice\",\"unshift\"],function(name){var method=ArrayProto[name];_.prototype[name]=function(){var obj=this._wrapped;return method.apply(obj,arguments),\"shift\"!=name&&\"splice\"!=name||0!==obj.length||delete obj[0],result.call(this,obj)}}),each([\"concat\",\"join\",\"slice\"],function(name){var method=ArrayProto[name];_.prototype[name]=function(){return result.call(this,method.apply(this._wrapped,arguments))}}),_.extend(_.prototype,{chain:function(){return this._chain=!0,this},value:function(){return this._wrapped}}),\"function\"==typeof define&&define.amd&&ace.define(\"underscore\",[],function(){return _})}).call(this)},{}],3:[function(_dereq_,module,exports){var _=_dereq_(\"underscore\"),events=_dereq_(\"events\"),vars=_dereq_(\"./vars.js\"),messages=_dereq_(\"./messages.js\"),Lexer=_dereq_(\"./lex.js\").Lexer,reg=_dereq_(\"./reg.js\"),state=_dereq_(\"./state.js\").state,style=_dereq_(\"./style.js\"),JSHINT=function(){\"use strict\";function checkOption(name,t){return name=name.trim(),/^[+-]W\\d{3}$/g.test(name)?!0:void 0!==valOptions[name]||void 0!==boolOptions[name]||\"jslint\"===t.type||removedOptions[name]?!0:(error(\"E001\",t,name),!1)}function isString(obj){return\"[object String]\"===Object.prototype.toString.call(obj)}function isIdentifier(tkn,value){return tkn?tkn.identifier&&tkn.value===value?!0:!1:!1}function isReserved(token){if(!token.reserved)return!1;var meta=token.meta;if(meta&&meta.isFutureReservedWord&&state.option.inES5()){if(!meta.es5)return!1;if(meta.strictOnly&&!state.option.strict&&!state.directive[\"use strict\"])return!1;if(token.isProperty)return!1}return!0}function supplant(str,data){return str.replace(/\\{([^{}]*)\\}/g,function(a,b){var r=data[b];return\"string\"==typeof r||\"number\"==typeof r?r:a})}function combine(dest,src){Object.keys(src).forEach(function(name){_.has(JSHINT.blacklist,name)||(dest[name]=src[name])})}function assume(){state.option.esnext&&combine(predefined,vars.newEcmaIdentifiers),state.option.couch&&combine(predefined,vars.couch),state.option.qunit&&combine(predefined,vars.qunit),state.option.rhino&&combine(predefined,vars.rhino),state.option.shelljs&&(combine(predefined,vars.shelljs),combine(predefined,vars.node)),state.option.typed&&combine(predefined,vars.typed),state.option.phantom&&combine(predefined,vars.phantom),state.option.prototypejs&&combine(predefined,vars.prototypejs),state.option.node&&(combine(predefined,vars.node),combine(predefined,vars.typed)),state.option.devel&&combine(predefined,vars.devel),state.option.dojo&&combine(predefined,vars.dojo),state.option.browser&&(combine(predefined,vars.browser),combine(predefined,vars.typed)),state.option.nonstandard&&combine(predefined,vars.nonstandard),state.option.jasmine&&combine(predefined,vars.jasmine),state.option.jquery&&combine(predefined,vars.jquery),state.option.mootools&&combine(predefined,vars.mootools),state.option.worker&&combine(predefined,vars.worker),state.option.wsh&&combine(predefined,vars.wsh),state.option.globalstrict&&state.option.strict!==!1&&(state.option.strict=!0),state.option.yui&&combine(predefined,vars.yui),state.option.mocha&&combine(predefined,vars.mocha),state.option.inMoz=function(){return state.option.moz},state.option.inESNext=function(){return state.option.moz||state.option.esnext},state.option.inES5=function(){return!state.option.es3},state.option.inES3=function(strict){return strict?!state.option.moz&&!state.option.esnext&&state.option.es3:state.option.es3}}function quit(code,line,chr){var percentage=Math.floor(100*(line/state.lines.length)),message=messages.errors[code].desc;throw{name:\"JSHintError\",line:line,character:chr,message:message+\" (\"+percentage+\"% scanned).\",raw:message,code:code}}function isundef(scope,code,token,a){return JSHINT.undefs.push([scope,code,token,a])}function removeIgnoredMessages(){var ignored=state.ignoredLines;_.isEmpty(ignored)||(JSHINT.errors=_.reject(JSHINT.errors,function(err){return ignored[err.line]}))}function warning(code,t,a,b,c,d){var ch,l,w,msg;if(/^W\\d{3}$/.test(code)){if(state.ignored[code])return;msg=messages.warnings[code]}else/E\\d{3}/.test(code)?msg=messages.errors[code]:/I\\d{3}/.test(code)&&(msg=messages.info[code]);return t=t||state.tokens.next,\"(end)\"===t.id&&(t=state.tokens.curr),l=t.line||0,ch=t.from||0,w={id:\"(error)\",raw:msg.desc,code:msg.code,evidence:state.lines[l-1]||\"\",line:l,character:ch,scope:JSHINT.scope,a:a,b:b,c:c,d:d},w.reason=supplant(msg.desc,w),JSHINT.errors.push(w),removeIgnoredMessages(),JSHINT.errors.length>=state.option.maxerr&&quit(\"E043\",l,ch),w}function warningAt(m,l,ch,a,b,c,d){return warning(m,{line:l,from:ch},a,b,c,d)}function error(m,t,a,b,c,d){warning(m,t,a,b,c,d)}function errorAt(m,l,ch,a,b,c,d){return error(m,{line:l,from:ch},a,b,c,d)}function addInternalSrc(elem,src){var i;return i={id:\"(internal)\",elem:elem,value:src},JSHINT.internals.push(i),i}function addlabel(name,opts){opts=opts||{};var type=opts.type,token=opts.token,islet=opts.islet;\"exception\"===type&&_.has(funct[\"(context)\"],name)&&(funct[name]===!0||state.option.node||warning(\"W002\",state.tokens.next,name)),_.has(funct,name)&&!funct[\"(global)\"]&&(funct[name]===!0?state.option.latedef&&(state.option.latedef===!0&&_.contains([funct[name],type],\"unction\")||!_.contains([funct[name],type],\"unction\"))&&warning(\"W003\",state.tokens.next,name):((!state.option.shadow||_.contains([\"inner\",\"outer\"],state.option.shadow))&&\"exception\"!==type||funct[\"(blockscope)\"].getlabel(name))&&warning(\"W004\",state.tokens.next,name)),funct[\"(context)\"]&&_.has(funct[\"(context)\"],name)&&\"function\"!==type&&\"outer\"===state.option.shadow&&warning(\"W123\",state.tokens.next,name),islet?funct[\"(blockscope)\"].current.add(name,type,state.tokens.curr):(funct[\"(blockscope)\"].shadow(name),funct[name]=type,token&&(funct[\"(tokens)\"][name]=token),setprop(funct,name,{unused:opts.unused||!1}),funct[\"(global)\"]?(global[name]=funct,_.has(implied,name)&&(state.option.latedef&&(state.option.latedef===!0&&_.contains([funct[name],type],\"unction\")||!_.contains([funct[name],type],\"unction\"))&&warning(\"W003\",state.tokens.next,name),delete implied[name])):scope[name]=funct)}function doOption(){var nt=state.tokens.next,body=nt.body.match(/(-\\s+)?[^\\s,:]+(?:\\s*:\\s*(-\\s+)?[^\\s,]+)?/g)||[],predef={};if(\"globals\"===nt.type){body.forEach(function(g){g=g.split(\":\");var key=(g[0]||\"\").trim(),val=(g[1]||\"\").trim();\"-\"===key.charAt(0)?(key=key.slice(1),val=!1,JSHINT.blacklist[key]=key,delete predefined[key]):predef[key]=\"true\"===val}),combine(predefined,predef);for(var key in predef)_.has(predef,key)&&(declared[key]=nt)}\"exported\"===nt.type&&body.forEach(function(e){exported[e]=!0}),\"members\"===nt.type&&(membersOnly=membersOnly||{},body.forEach(function(m){var ch1=m.charAt(0),ch2=m.charAt(m.length-1);ch1!==ch2||'\"'!==ch1&&\"'\"!==ch1||(m=m.substr(1,m.length-2).replace('\\\\\"','\"')),membersOnly[m]=!1}));var numvals=[\"maxstatements\",\"maxparams\",\"maxdepth\",\"maxcomplexity\",\"maxerr\",\"maxlen\",\"indent\"];(\"jshint\"===nt.type||\"jslint\"===nt.type)&&(body.forEach(function(g){g=g.split(\":\");var key=(g[0]||\"\").trim(),val=(g[1]||\"\").trim();if(checkOption(key,nt))if(numvals.indexOf(key)>=0)if(\"false\"!==val){if(val=+val,\"number\"!=typeof val||!isFinite(val)||0>=val||Math.floor(val)!==val)return error(\"E032\",nt,g[1].trim()),void 0;state.option[key]=val}else state.option[key]=\"indent\"===key?4:!1;else{if(\"validthis\"===key)return funct[\"(global)\"]?void error(\"E009\"):\"true\"!==val&&\"false\"!==val?void error(\"E002\",nt):(state.option.validthis=\"true\"===val,void 0);if(\"quotmark\"!==key)if(\"shadow\"!==key)if(\"unused\"!==key)if(\"latedef\"!==key){if(\"ignore\"!==key){var match=/^([+-])(W\\d{3})$/g.exec(key);if(match)return state.ignored[match[2]]=\"-\"===match[1],void 0;var tn;return\"true\"===val||\"false\"===val?(\"jslint\"===nt.type?(tn=renamedOptions[key]||key,state.option[tn]=\"true\"===val,void 0!==invertedOptions[tn]&&(state.option[tn]=!state.option[tn])):state.option[key]=\"true\"===val,\"newcap\"===key&&(state.option[\"(explicitNewcap)\"]=!0),void 0):(error(\"E002\",nt),void 0)}switch(val){case\"start\":state.ignoreLinterErrors=!0;break;case\"end\":state.ignoreLinterErrors=!1;break;case\"line\":state.ignoredLines[nt.line]=!0,removeIgnoredMessages();break;default:error(\"E002\",nt)}}else switch(val){case\"true\":state.option.latedef=!0;break;case\"false\":state.option.latedef=!1;break;case\"nofunc\":state.option.latedef=\"nofunc\";break;default:error(\"E002\",nt)}else switch(val){case\"true\":state.option.unused=!0;break;case\"false\":state.option.unused=!1;break;case\"vars\":case\"strict\":state.option.unused=val;break;default:error(\"E002\",nt)}else switch(val){case\"true\":state.option.shadow=!0;break;case\"outer\":state.option.shadow=\"outer\";break;case\"false\":case\"inner\":state.option.shadow=\"inner\";break;default:error(\"E002\",nt)}else switch(val){case\"true\":case\"false\":state.option.quotmark=\"true\"===val;break;case\"double\":case\"single\":state.option.quotmark=val;break;default:error(\"E002\",nt)}}}),assume())}function peek(p){for(var t,i=p||0,j=0;i>=j;)t=lookahead[j],t||(t=lookahead[j]=lex.token()),j+=1;return t}function advance(id,t){switch(state.tokens.curr.id){case\"(number)\":\".\"===state.tokens.next.id&&warning(\"W005\",state.tokens.curr);break;case\"-\":(\"-\"===state.tokens.next.id||\"--\"===state.tokens.next.id)&&warning(\"W006\");break;case\"+\":(\"+\"===state.tokens.next.id||\"++\"===state.tokens.next.id)&&warning(\"W007\")}for((\"(string)\"===state.tokens.curr.type||state.tokens.curr.identifier)&&(anonname=state.tokens.curr.value),id&&state.tokens.next.id!==id&&(t?\"(end)\"===state.tokens.next.id?error(\"E019\",t,t.id):error(\"E020\",state.tokens.next,id,t.id,t.line,state.tokens.next.value):(\"(identifier)\"!==state.tokens.next.type||state.tokens.next.value!==id)&&warning(\"W116\",state.tokens.next,id,state.tokens.next.value)),state.tokens.prev=state.tokens.curr,state.tokens.curr=state.tokens.next;;){if(state.tokens.next=lookahead.shift()||lex.token(),state.tokens.next||quit(\"E041\",state.tokens.curr.line),\"(end)\"===state.tokens.next.id||\"(error)\"===state.tokens.next.id)return;if(state.tokens.next.check&&state.tokens.next.check(),state.tokens.next.isSpecial)doOption();else if(\"(endline)\"!==state.tokens.next.id)break}}function isInfix(token){return token.infix||!token.identifier&&!!token.led}function isEndOfExpr(){var curr=state.tokens.curr,next=state.tokens.next;return\";\"===next.id||\"}\"===next.id||\":\"===next.id?!0:isInfix(next)===isInfix(curr)||\"yield\"===curr.id&&state.option.inMoz(!0)?curr.line!==next.line:!1}function expression(rbp,initial){var left,isArray=!1,isObject=!1,isLetExpr=!1;initial||\"let\"!==state.tokens.next.value||\"(\"!==peek(0).value||(state.option.inMoz(!0)||warning(\"W118\",state.tokens.next,\"let expressions\"),isLetExpr=!0,funct[\"(blockscope)\"].stack(),advance(\"let\"),advance(\"(\"),state.syntax.let.fud.call(state.syntax.let.fud,!1),advance(\")\")),\"(end)\"===state.tokens.next.id&&error(\"E006\",state.tokens.curr);var isDangerous=state.option.asi&&state.tokens.prev.line<state.tokens.curr.line&&_.contains([\"]\",\")\"],state.tokens.prev.id)&&_.contains([\"[\",\"(\"],state.tokens.curr.id);if(isDangerous&&warning(\"W014\",state.tokens.curr,state.tokens.curr.id),advance(),initial&&(anonname=\"anonymous\",funct[\"(verb)\"]=state.tokens.curr.value),initial===!0&&state.tokens.curr.fud)left=state.tokens.curr.fud();else for(state.tokens.curr.nud?left=state.tokens.curr.nud():error(\"E030\",state.tokens.curr,state.tokens.curr.id);state.tokens.next.lbp>rbp&&!isEndOfExpr();)isArray=\"Array\"===state.tokens.curr.value,isObject=\"Object\"===state.tokens.curr.value,left&&(left.value||left.first&&left.first.value)&&(\"new\"!==left.value||left.first&&left.first.value&&\".\"===left.first.value)&&(isArray=!1,left.value!==state.tokens.curr.value&&(isObject=!1)),advance(),isArray&&\"(\"===state.tokens.curr.id&&\")\"===state.tokens.next.id&&warning(\"W009\",state.tokens.curr),isObject&&\"(\"===state.tokens.curr.id&&\")\"===state.tokens.next.id&&warning(\"W010\",state.tokens.curr),left&&state.tokens.curr.led?left=state.tokens.curr.led(left):error(\"E033\",state.tokens.curr,state.tokens.curr.id);return isLetExpr&&funct[\"(blockscope)\"].unstack(),left}function nobreaknonadjacent(left,right){left=left||state.tokens.curr,right=right||state.tokens.next,state.option.laxbreak||left.line===right.line||warning(\"W014\",right,right.value)}function nolinebreak(t){t=t||state.tokens.curr,t.line!==state.tokens.next.line&&warning(\"E022\",t,t.value)}function nobreakcomma(left,right){left.line!==right.line&&(state.option.laxcomma||(comma.first&&(warning(\"I001\"),comma.first=!1),warning(\"W014\",left,right.value)))}function comma(opts){if(opts=opts||{},opts.peek?nobreakcomma(state.tokens.prev,state.tokens.curr):(nobreakcomma(state.tokens.curr,state.tokens.next),advance(\",\")),state.tokens.next.identifier&&(!opts.property||!state.option.inES5()))switch(state.tokens.next.value){case\"break\":case\"case\":case\"catch\":case\"continue\":case\"default\":case\"do\":case\"else\":case\"finally\":case\"for\":case\"if\":case\"in\":case\"instanceof\":case\"return\":case\"switch\":case\"throw\":case\"try\":case\"var\":case\"let\":case\"while\":case\"with\":return error(\"E024\",state.tokens.next,state.tokens.next.value),!1}if(\"(punctuator)\"===state.tokens.next.type)switch(state.tokens.next.value){case\"}\":case\"]\":case\",\":if(opts.allowTrailing)return!0;case\")\":return error(\"E024\",state.tokens.next,state.tokens.next.value),!1}return!0}function symbol(s,p){var x=state.syntax[s];return x&&\"object\"==typeof x||(state.syntax[s]=x={id:s,lbp:p,value:s}),x}function delim(s){return symbol(s,0)}function stmt(s,f){var x=delim(s);return x.identifier=x.reserved=!0,x.fud=f,x}function blockstmt(s,f){var x=stmt(s,f);return x.block=!0,x}function reserveName(x){var c=x.id.charAt(0);return(c>=\"a\"&&\"z\">=c||c>=\"A\"&&\"Z\">=c)&&(x.identifier=x.reserved=!0),x}function prefix(s,f){var x=symbol(s,150);return reserveName(x),x.nud=\"function\"==typeof f?f:function(){return this.right=expression(150),this.arity=\"unary\",(\"++\"===this.id||\"--\"===this.id)&&(state.option.plusplus?warning(\"W016\",this,this.id):!this.right||this.right.identifier&&!isReserved(this.right)||\".\"===this.right.id||\"[\"===this.right.id||warning(\"W017\",this)),this},x}function type(s,f){var x=delim(s);return x.type=s,x.nud=f,x}function reserve(name,func){var x=type(name,func);return x.identifier=!0,x.reserved=!0,x}function FutureReservedWord(name,meta){var x=type(name,meta&&meta.nud||function(){return this});return meta=meta||{},meta.isFutureReservedWord=!0,x.value=name,x.identifier=!0,x.reserved=!0,x.meta=meta,x}function reservevar(s,v){return reserve(s,function(){return\"function\"==typeof v&&v(this),this})}function infix(s,f,p,w){var x=symbol(s,p);return reserveName(x),x.infix=!0,x.led=function(left){return w||nobreaknonadjacent(state.tokens.prev,state.tokens.curr),\"in\"===s&&\"!\"===left.id&&warning(\"W018\",left,\"!\"),\"function\"==typeof f?f(left,this):(this.left=left,this.right=expression(p),this)},x}function application(s){var x=symbol(s,42);return x.led=function(left){return state.option.inESNext()||warning(\"W104\",state.tokens.curr,\"arrow function syntax (=>)\"),nobreaknonadjacent(state.tokens.prev,state.tokens.curr),this.left=left,this.right=doFunction(void 0,void 0,!1,left),this},x}function relation(s,f){var x=symbol(s,100);return x.led=function(left){nobreaknonadjacent(state.tokens.prev,state.tokens.curr);var right=expression(100);return isIdentifier(left,\"NaN\")||isIdentifier(right,\"NaN\")?warning(\"W019\",this):f&&f.apply(this,[left,right]),left&&right||quit(\"E041\",state.tokens.curr.line),\"!\"===left.id&&warning(\"W018\",left,\"!\"),\"!\"===right.id&&warning(\"W018\",right,\"!\"),this.left=left,this.right=right,this},x}function isPoorRelation(node){return node&&(\"(number)\"===node.type&&0===+node.value||\"(string)\"===node.type&&\"\"===node.value||\"null\"===node.type&&!state.option.eqnull||\"true\"===node.type||\"false\"===node.type||\"undefined\"===node.type)}function isTypoTypeof(left,right){if(state.option.notypeof)return!1;if(!left||!right)return!1;var values=[\"undefined\",\"object\",\"boolean\",\"number\",\"string\",\"function\",\"xml\",\"object\",\"unknown\"];return\"(identifier)\"===right.type&&\"typeof\"===right.value&&\"(string)\"===left.type?!_.contains(values,left.value):!1}function findNativePrototype(left){function walkPrototype(obj){return\"object\"==typeof obj?\"prototype\"===obj.right?obj:walkPrototype(obj.left):void 0}function walkNative(obj){for(;!obj.identifier&&\"object\"==typeof obj.left;)obj=obj.left;return obj.identifier&&natives.indexOf(obj.value)>=0?obj.value:void 0}var natives=[\"Array\",\"ArrayBuffer\",\"Boolean\",\"Collator\",\"DataView\",\"Date\",\"DateTimeFormat\",\"Error\",\"EvalError\",\"Float32Array\",\"Float64Array\",\"Function\",\"Infinity\",\"Intl\",\"Int16Array\",\"Int32Array\",\"Int8Array\",\"Iterator\",\"Number\",\"NumberFormat\",\"Object\",\"RangeError\",\"ReferenceError\",\"RegExp\",\"StopIteration\",\"String\",\"SyntaxError\",\"TypeError\",\"Uint16Array\",\"Uint32Array\",\"Uint8Array\",\"Uint8ClampedArray\",\"URIError\"],prototype=walkPrototype(left);return prototype?walkNative(prototype):void 0}function assignop(s,f,p){var x=infix(s,\"function\"==typeof f?f:function(left,that){if(that.left=left,left){if(state.option.freeze){var nativeObject=findNativePrototype(left);nativeObject&&warning(\"W121\",left,nativeObject)}if(predefined[left.value]===!1&&scope[left.value][\"(global)\"]===!0?warning(\"W020\",left):left[\"function\"]&&warning(\"W021\",left,left.value),\"const\"===funct[left.value]&&error(\"E013\",left,left.value),\".\"===left.id)return left.left?\"arguments\"!==left.left.value||state.directive[\"use strict\"]||warning(\"E031\",that):warning(\"E031\",that),that.right=expression(10),that;if(\"[\"===left.id)return state.tokens.curr.left.first?state.tokens.curr.left.first.forEach(function(t){t&&\"const\"===funct[t.value]&&error(\"E013\",t,t.value)}):left.left?\"arguments\"!==left.left.value||state.directive[\"use strict\"]||warning(\"E031\",that):warning(\"E031\",that),that.right=expression(10),that;if(left.identifier&&!isReserved(left))return\"exception\"===funct[left.value]&&warning(\"W022\",left),that.right=expression(10),that;left===state.syntax[\"function\"]&&warning(\"W023\",state.tokens.curr)\n}error(\"E031\",that)},p);return x.exps=!0,x.assign=!0,x}function bitwise(s,f,p){var x=symbol(s,p);return reserveName(x),x.led=\"function\"==typeof f?f:function(left){return state.option.bitwise&&warning(\"W016\",this,this.id),this.left=left,this.right=expression(p),this},x}function bitwiseassignop(s){return assignop(s,function(left,that){return state.option.bitwise&&warning(\"W016\",that,that.id),left?\".\"===left.id||\"[\"===left.id||left.identifier&&!isReserved(left)?(expression(10),that):(left===state.syntax[\"function\"]&&warning(\"W023\",state.tokens.curr),that):(error(\"E031\",that),void 0)},20)}function suffix(s){var x=symbol(s,150);return x.led=function(left){return state.option.plusplus?warning(\"W016\",this,this.id):left.identifier&&!isReserved(left)||\".\"===left.id||\"[\"===left.id||warning(\"W017\",this),this.left=left,this},x}function optionalidentifier(fnparam,prop){if(state.tokens.next.identifier){advance();var curr=state.tokens.curr,val=state.tokens.curr.value;return isReserved(curr)?prop&&state.option.inES5()?val:fnparam&&\"undefined\"===val?val:(warning(\"W024\",state.tokens.curr,state.tokens.curr.id),val):val}}function identifier(fnparam,prop){var i=optionalidentifier(fnparam,prop);return i?i:(\"function\"===state.tokens.curr.id&&\"(\"===state.tokens.next.id?warning(\"W025\"):error(\"E030\",state.tokens.next,state.tokens.next.value),void 0)}function reachable(s){var t,i=0;if(\";\"===state.tokens.next.id&&!noreach)for(;;){do t=peek(i),i+=1;while(\"(end)\"!=t.id&&\"(comment)\"===t.id);if(t.reach)return;if(\"(endline)\"!==t.id){if(\"function\"===t.id){state.option.latedef===!0&&warning(\"W026\",t);break}warning(\"W027\",t,t.value,s);break}}}function parseFinalSemicolon(){\";\"!==state.tokens.next.id?state.option.asi||state.option.lastsemic&&\"}\"===state.tokens.next.id&&state.tokens.next.line===state.tokens.curr.line||warningAt(\"W033\",state.tokens.curr.line,state.tokens.curr.character):advance(\";\")}function statement(){var values,r,i=indent,s=scope,t=state.tokens.next;if(\";\"===t.id)return advance(\";\"),void 0;var res=isReserved(t);if(res&&t.meta&&t.meta.isFutureReservedWord&&\":\"===peek().id&&(warning(\"W024\",t,t.id),res=!1),\"module\"===t.value&&\"(identifier)\"===t.type&&\"(identifier)\"===peek().type){state.option.inESNext()||warning(\"W119\",state.tokens.curr,\"module\"),advance(\"module\");var name=identifier();return addlabel(name,{type:\"unused\",token:state.tokens.curr}),advance(\"from\"),advance(\"(string)\"),parseFinalSemicolon(),void 0}if(_.has([\"[\",\"{\"],t.value)&&lookupBlockType().isDestAssign)return state.option.inESNext()||warning(\"W104\",state.tokens.curr,\"destructuring expression\"),values=destructuringExpression(),values.forEach(function(tok){isundef(funct,\"W117\",tok.token,tok.id)}),advance(\"=\"),destructuringExpressionMatch(values,expression(10,!0)),advance(\";\"),void 0;if(t.identifier&&!res&&\":\"===peek().id&&(advance(),advance(\":\"),scope=Object.create(s),addlabel(t.value,{type:\"label\"}),state.tokens.next.labelled||\"{\"===state.tokens.next.value||warning(\"W028\",state.tokens.next,t.value,state.tokens.next.value),state.tokens.next.label=t.value,t=state.tokens.next),\"{\"===t.id){var iscase=\"case\"===funct[\"(verb)\"]&&\":\"===state.tokens.curr.value;return block(!0,!0,!1,!1,iscase),void 0}return r=expression(0,!0),!r||r.identifier&&\"function\"===r.value||\"(punctuator)\"===r.type||!state.directive[\"use strict\"]&&state.option.globalstrict&&state.option.strict&&warning(\"E007\"),t.block||(state.option.expr||r&&r.exps?state.option.nonew&&r&&r.left&&\"(\"===r.id&&\"new\"===r.left.id&&warning(\"W031\",t):warning(\"W030\",state.tokens.curr),parseFinalSemicolon()),indent=i,scope=s,r}function statements(startLine){for(var p,a=[];!state.tokens.next.reach&&\"(end)\"!==state.tokens.next.id;)\";\"===state.tokens.next.id?(p=peek(),(!p||\"(\"!==p.id&&\"[\"!==p.id)&&warning(\"W032\"),advance(\";\")):a.push(statement(startLine===state.tokens.next.line));return a}function directives(){for(var i,p,pn;\"(string)\"===state.tokens.next.id;){if(p=peek(0),\"(endline)\"===p.id){i=1;do pn=peek(i),i+=1;while(\"(endline)\"===pn.id);if(\";\"!==pn.id){if(\"(string)\"!==pn.id&&\"(number)\"!==pn.id&&\"(regexp)\"!==pn.id&&pn.identifier!==!0&&\"}\"!==pn.id)break;warning(\"W033\",state.tokens.next)}else p=pn}else if(\"}\"===p.id)warning(\"W033\",p);else if(\";\"!==p.id)break;advance(),state.directive[state.tokens.curr.value]&&warning(\"W034\",state.tokens.curr,state.tokens.curr.value),\"use strict\"===state.tokens.curr.value&&(state.option[\"(explicitNewcap)\"]||(state.option.newcap=!0),state.option.undef=!0),state.directive[state.tokens.curr.value]=!0,\";\"===p.id&&advance(\";\")}}function block(ordinary,stmt,isfunc,isfatarrow,iscase){var a,m,t,line,d,b=inblock,old_indent=indent,s=scope;inblock=ordinary,ordinary&&state.option.funcscope||(scope=Object.create(scope)),t=state.tokens.next;var metrics=funct[\"(metrics)\"];if(metrics.nestedBlockDepth+=1,metrics.verifyMaxNestedBlockDepthPerFunction(),\"{\"===state.tokens.next.id){if(advance(\"{\"),funct[\"(blockscope)\"].stack(),line=state.tokens.curr.line,\"}\"!==state.tokens.next.id){for(indent+=state.option.indent;!ordinary&&state.tokens.next.from>indent;)indent+=state.option.indent;if(isfunc){m={};for(d in state.directive)_.has(state.directive,d)&&(m[d]=state.directive[d]);directives(),state.option.strict&&funct[\"(context)\"][\"(global)\"]&&(m[\"use strict\"]||state.directive[\"use strict\"]||warning(\"E007\"))}a=statements(line),metrics.statementCount+=a.length,isfunc&&(state.directive=m),indent-=state.option.indent}advance(\"}\",t),funct[\"(blockscope)\"].unstack(),indent=old_indent}else if(ordinary)funct[\"(nolet)\"]=!0,(!stmt||state.option.curly)&&warning(\"W116\",state.tokens.next,\"{\",state.tokens.next.value),noreach=!0,indent+=state.option.indent,a=[statement()],indent-=state.option.indent,noreach=!1,delete funct[\"(nolet)\"];else if(isfunc){if(m={},!stmt||isfatarrow||state.option.inMoz(!0)||error(\"W118\",state.tokens.curr,\"function closure expressions\"),!stmt)for(d in state.directive)_.has(state.directive,d)&&(m[d]=state.directive[d]);expression(10),state.option.strict&&funct[\"(context)\"][\"(global)\"]&&(m[\"use strict\"]||state.directive[\"use strict\"]||warning(\"E007\"))}else error(\"E021\",state.tokens.next,\"{\",state.tokens.next.value);switch(funct[\"(verb)\"]){case\"break\":case\"continue\":case\"return\":case\"throw\":if(iscase)break;default:funct[\"(verb)\"]=null}return ordinary&&state.option.funcscope||(scope=s),inblock=b,!ordinary||!state.option.noempty||a&&0!==a.length||warning(\"W035\"),metrics.nestedBlockDepth-=1,a}function countMember(m){membersOnly&&\"boolean\"!=typeof membersOnly[m]&&warning(\"W036\",state.tokens.curr,m),\"number\"==typeof member[m]?member[m]+=1:member[m]=1}function note_implied(tkn){var name=tkn.value,desc=Object.getOwnPropertyDescriptor(implied,name);desc?desc.value.push(tkn.line):implied[name]=[tkn.line]}function comprehensiveArrayExpression(){var res={};res.exps=!0,funct[\"(comparray)\"].stack();var reversed=!1;return\"for\"!==state.tokens.next.value&&(reversed=!0,state.option.inMoz(!0)||warning(\"W116\",state.tokens.next,\"for\",state.tokens.next.value),funct[\"(comparray)\"].setState(\"use\"),res.right=expression(10)),advance(\"for\"),\"each\"===state.tokens.next.value&&(advance(\"each\"),state.option.inMoz(!0)||warning(\"W118\",state.tokens.curr,\"for each\")),advance(\"(\"),funct[\"(comparray)\"].setState(\"define\"),res.left=expression(130),_.contains([\"in\",\"of\"],state.tokens.next.value)?advance():error(\"E045\",state.tokens.curr),funct[\"(comparray)\"].setState(\"generate\"),expression(10),advance(\")\"),\"if\"===state.tokens.next.value&&(advance(\"if\"),advance(\"(\"),funct[\"(comparray)\"].setState(\"filter\"),res.filter=expression(10),advance(\")\")),reversed||(funct[\"(comparray)\"].setState(\"use\"),res.right=expression(10)),advance(\"]\"),funct[\"(comparray)\"].unstack(),res}function property_name(){var id=optionalidentifier(!1,!0);return id||(\"(string)\"===state.tokens.next.id?(id=state.tokens.next.value,advance()):\"(number)\"===state.tokens.next.id&&(id=\"\"+state.tokens.next.value,advance())),\"hasOwnProperty\"===id&&warning(\"W001\"),id}function functionparams(parsed){var curr,next,ident,t,params=[],tokens=[],pastDefault=!1;if(parsed){if(Array.isArray(parsed)){for(var i in parsed)curr=parsed[i],\"...\"!==curr.value?\",\"!==curr.value&&(params.push(curr.value),addlabel(curr.value,{type:\"unused\",token:curr})):state.option.inESNext()||warning(\"W104\",curr,\"spread/rest operator\");return params}if(parsed.identifier===!0)return addlabel(parsed.value,{type:\"unused\",token:parsed}),[parsed]}if(next=state.tokens.next,advance(\"(\"),\")\"===state.tokens.next.id)return advance(\")\"),void 0;for(;;){if(_.contains([\"{\",\"[\"],state.tokens.next.id)){tokens=destructuringExpression();for(t in tokens)t=tokens[t],t.id&&(params.push(t.id),addlabel(t.id,{type:\"unused\",token:t.token}))}else\"...\"===state.tokens.next.value?(state.option.inESNext()||warning(\"W104\",state.tokens.next,\"spread/rest operator\"),advance(\"...\"),ident=identifier(!0),params.push(ident),addlabel(ident,{type:\"unused\",token:state.tokens.curr})):(ident=identifier(!0),params.push(ident),addlabel(ident,{type:\"unused\",token:state.tokens.curr}));if(pastDefault&&\"=\"!==state.tokens.next.id&&error(\"E051\",state.tokens.current),\"=\"===state.tokens.next.id&&(state.option.inESNext()||warning(\"W119\",state.tokens.next,\"default parameters\"),advance(\"=\"),pastDefault=!0,expression(10)),\",\"!==state.tokens.next.id)return advance(\")\",next),params;comma()}}function setprop(funct,name,values){funct[\"(properties)\"][name]||(funct[\"(properties)\"][name]={unused:!1}),_.extend(funct[\"(properties)\"][name],values)}function getprop(funct,name,prop){return funct[\"(properties)\"][name]?funct[\"(properties)\"][name][prop]||null:null}function functor(name,token,scope,overwrites){var funct={\"(name)\":name,\"(breakage)\":0,\"(loopage)\":0,\"(scope)\":scope,\"(tokens)\":{},\"(properties)\":{},\"(catch)\":!1,\"(global)\":!1,\"(line)\":null,\"(character)\":null,\"(metrics)\":null,\"(statement)\":null,\"(context)\":null,\"(blockscope)\":null,\"(comparray)\":null,\"(generator)\":null,\"(params)\":null};return token&&_.extend(funct,{\"(line)\":token.line,\"(character)\":token.character,\"(metrics)\":createMetrics(token)}),_.extend(funct,overwrites),funct[\"(context)\"]&&(funct[\"(blockscope)\"]=funct[\"(context)\"][\"(blockscope)\"],funct[\"(comparray)\"]=funct[\"(context)\"][\"(comparray)\"]),funct}function doFunction(name,statement,generator,fatarrowparams){var f,oldOption=state.option,oldIgnored=state.ignored,oldScope=scope;return state.option=Object.create(state.option),state.ignored=Object.create(state.ignored),scope=Object.create(scope),funct=functor(name||'\"'+anonname+'\"',state.tokens.next,scope,{\"(statement)\":statement,\"(context)\":funct,\"(generator)\":generator?!0:null}),f=funct,state.tokens.curr.funct=funct,functions.push(funct),name&&addlabel(name,{type:\"function\"}),funct[\"(params)\"]=functionparams(fatarrowparams),funct[\"(metrics)\"].verifyMaxParametersPerFunction(funct[\"(params)\"]),JSHINT.undefs=_.filter(JSHINT.undefs,function(item){return!_.contains(_.union(fatarrowparams),item[2])}),block(!1,!0,!0,fatarrowparams?!0:!1),!state.option.noyield&&generator&&\"yielded\"!==funct[\"(generator)\"]&&warning(\"W124\",state.tokens.curr),funct[\"(metrics)\"].verifyMaxStatementsPerFunction(),funct[\"(metrics)\"].verifyMaxComplexityPerFunction(),funct[\"(unusedOption)\"]=state.option.unused,scope=oldScope,state.option=oldOption,state.ignored=oldIgnored,funct[\"(last)\"]=state.tokens.curr.line,funct[\"(lastcharacter)\"]=state.tokens.curr.character,_.map(Object.keys(funct),function(key){\"(\"!==key[0]&&funct[\"(blockscope)\"].unshadow(key)}),funct=funct[\"(context)\"],f}function createMetrics(functionStartToken){return{statementCount:0,nestedBlockDepth:-1,ComplexityCount:1,verifyMaxStatementsPerFunction:function(){state.option.maxstatements&&this.statementCount>state.option.maxstatements&&warning(\"W071\",functionStartToken,this.statementCount)},verifyMaxParametersPerFunction:function(params){params=params||[],state.option.maxparams&&params.length>state.option.maxparams&&warning(\"W072\",functionStartToken,params.length)},verifyMaxNestedBlockDepthPerFunction:function(){state.option.maxdepth&&this.nestedBlockDepth>0&&this.nestedBlockDepth===state.option.maxdepth+1&&warning(\"W073\",null,this.nestedBlockDepth)},verifyMaxComplexityPerFunction:function(){var max=state.option.maxcomplexity,cc=this.ComplexityCount;max&&cc>max&&warning(\"W074\",functionStartToken,cc)}}}function increaseComplexityCount(){funct[\"(metrics)\"].ComplexityCount+=1}function checkCondAssignment(expr){var id,paren;switch(expr&&(id=expr.id,paren=expr.paren,\",\"===id&&(expr=expr.exprs[expr.exprs.length-1])&&(id=expr.id,paren=paren||expr.paren)),id){case\"=\":case\"+=\":case\"-=\":case\"*=\":case\"%=\":case\"&=\":case\"|=\":case\"^=\":case\"/=\":paren||state.option.boss||warning(\"W084\")}}function destructuringExpression(){var id,ids,identifiers=[];state.option.inESNext()||warning(\"W104\",state.tokens.curr,\"destructuring expression\");var nextInnerDE=function(){var ident;if(_.contains([\"[\",\"{\"],state.tokens.next.value)){ids=destructuringExpression();for(var id in ids)id=ids[id],identifiers.push({id:id.id,token:id.token})}else\",\"===state.tokens.next.value?identifiers.push({id:null,token:state.tokens.curr}):\"(\"===state.tokens.next.value?(advance(\"(\"),nextInnerDE(),advance(\")\")):(ident=identifier(),ident&&identifiers.push({id:ident,token:state.tokens.curr}))};if(\"[\"===state.tokens.next.value){for(advance(\"[\"),nextInnerDE();\"]\"!==state.tokens.next.value;)advance(\",\"),nextInnerDE();advance(\"]\")}else if(\"{\"===state.tokens.next.value){for(advance(\"{\"),id=identifier(),\":\"===state.tokens.next.value?(advance(\":\"),nextInnerDE()):identifiers.push({id:id,token:state.tokens.curr});\"}\"!==state.tokens.next.value;)advance(\",\"),id=identifier(),\":\"===state.tokens.next.value?(advance(\":\"),nextInnerDE()):identifiers.push({id:id,token:state.tokens.curr});advance(\"}\")}return identifiers}function destructuringExpressionMatch(tokens,value){var first=value.first;first&&_.zip(tokens,Array.isArray(first)?first:[first]).forEach(function(val){var token=val[0],value=val[1];token&&value?token.first=value:token&&token.first&&!value&&warning(\"W080\",token.first,token.first.value)})}function classdef(stmt){return state.option.inESNext()||warning(\"W104\",state.tokens.curr,\"class\"),stmt?(this.name=identifier(),addlabel(this.name,{type:\"unused\",token:state.tokens.curr})):state.tokens.next.identifier&&\"extends\"!==state.tokens.next.value&&(this.name=identifier()),classtail(this),this}function classtail(c){var strictness=state.directive[\"use strict\"];\"extends\"===state.tokens.next.value&&(advance(\"extends\"),c.heritage=expression(10)),state.directive[\"use strict\"]=!0,advance(\"{\"),c.body=state.syntax[\"{\"].nud(!0),state.directive[\"use strict\"]=strictness}function destructuringAssignOrJsonValue(){var block=lookupBlockType();block.notJson?(!state.option.inESNext()&&block.isDestAssign&&warning(\"W104\",state.tokens.curr,\"destructuring assignment\"),statements()):(state.option.laxbreak=!0,state.jsonMode=!0,jsonValue())}function jsonValue(){function jsonObject(){var o={},t=state.tokens.next;if(advance(\"{\"),\"}\"!==state.tokens.next.id)for(;;){if(\"(end)\"===state.tokens.next.id)error(\"E026\",state.tokens.next,t.line);else{if(\"}\"===state.tokens.next.id){warning(\"W094\",state.tokens.curr);break}\",\"===state.tokens.next.id?error(\"E028\",state.tokens.next):\"(string)\"!==state.tokens.next.id&&warning(\"W095\",state.tokens.next,state.tokens.next.value)}if(o[state.tokens.next.value]===!0?warning(\"W075\",state.tokens.next,state.tokens.next.value):\"__proto__\"===state.tokens.next.value&&!state.option.proto||\"__iterator__\"===state.tokens.next.value&&!state.option.iterator?warning(\"W096\",state.tokens.next,state.tokens.next.value):o[state.tokens.next.value]=!0,advance(),advance(\":\"),jsonValue(),\",\"!==state.tokens.next.id)break;advance(\",\")}advance(\"}\")}function jsonArray(){var t=state.tokens.next;if(advance(\"[\"),\"]\"!==state.tokens.next.id)for(;;){if(\"(end)\"===state.tokens.next.id)error(\"E027\",state.tokens.next,t.line);else{if(\"]\"===state.tokens.next.id){warning(\"W094\",state.tokens.curr);break}\",\"===state.tokens.next.id&&error(\"E028\",state.tokens.next)}if(jsonValue(),\",\"!==state.tokens.next.id)break;advance(\",\")}advance(\"]\")}switch(state.tokens.next.id){case\"{\":jsonObject();break;case\"[\":jsonArray();break;case\"true\":case\"false\":case\"null\":case\"(number)\":case\"(string)\":advance();break;case\"-\":advance(\"-\"),advance(\"(number)\");break;default:error(\"E003\",state.tokens.next)}}var anonname,api,declared,exported,funct,functions,global,implied,inblock,indent,lookahead,lex,member,membersOnly,noreach,predefined,scope,stack,unuseds,urls,bang={\"<\":!0,\"<=\":!0,\"==\":!0,\"===\":!0,\"!==\":!0,\"!=\":!0,\">\":!0,\">=\":!0,\"+\":!0,\"-\":!0,\"*\":!0,\"/\":!0,\"%\":!0},boolOptions={asi:!0,bitwise:!0,boss:!0,browser:!0,camelcase:!0,couch:!0,curly:!0,debug:!0,devel:!0,dojo:!0,eqeqeq:!0,eqnull:!0,notypeof:!0,es3:!0,es5:!0,esnext:!0,moz:!0,evil:!0,expr:!0,forin:!0,funcscope:!0,globalstrict:!0,immed:!0,iterator:!0,jasmine:!0,jquery:!0,lastsemic:!0,laxbreak:!0,laxcomma:!0,loopfunc:!0,mootools:!0,multistr:!0,freeze:!0,newcap:!0,noarg:!0,node:!0,noempty:!0,nonbsp:!0,nonew:!0,nonstandard:!0,phantom:!0,plusplus:!0,proto:!0,prototypejs:!0,qunit:!0,rhino:!0,shelljs:!0,typed:!0,undef:!0,scripturl:!0,strict:!0,sub:!0,supernew:!0,validthis:!0,withstmt:!0,worker:!0,wsh:!0,yui:!0,mocha:!0,noyield:!0,onecase:!0,regexp:!0,regexdash:!0},valOptions={maxlen:!1,indent:!1,maxerr:!1,predef:!1,globals:!1,quotmark:!1,scope:!1,maxstatements:!1,maxdepth:!1,maxparams:!1,maxcomplexity:!1,shadow:!1,unused:!0,latedef:!1,ignore:!1},invertedOptions={bitwise:!0,forin:!0,newcap:!0,plusplus:!0,regexp:!0,undef:!0,eqeqeq:!0,strict:!0},renamedOptions={eqeq:\"eqeqeq\",windows:\"wsh\",sloppy:\"strict\"},removedOptions={nomen:!0,onevar:!0,passfail:!0,white:!0,gcl:!0,smarttabs:!0,trailing:!0},functionicity=[\"closure\",\"exception\",\"global\",\"label\",\"outer\",\"unused\",\"var\"],extraModules=[],emitter=new events.EventEmitter;type(\"(number)\",function(){return this}),type(\"(string)\",function(){return this}),type(\"(template)\",function(){return this}),state.syntax[\"(identifier)\"]={type:\"(identifier)\",lbp:0,identifier:!0,nud:function(){var f,block,v=this.value,s=scope[v];if(\"function\"==typeof s?s=void 0:funct[\"(blockscope)\"].current.has(v)||\"boolean\"!=typeof s||(f=funct,funct=functions[0],addlabel(v,{type:\"var\"}),s=funct,funct=f),block=funct[\"(blockscope)\"].getlabel(v),funct===s||block)switch(block?block[v][\"(type)\"]:funct[v]){case\"unused\":block?block[v][\"(type)\"]=\"var\":funct[v]=\"var\";break;case\"unction\":block?block[v][\"(type)\"]=\"function\":funct[v]=\"function\",this[\"function\"]=!0;break;case\"const\":setprop(funct,v,{unused:!1});break;case\"function\":this[\"function\"]=!0;break;case\"label\":warning(\"W037\",state.tokens.curr,v)}else if(funct[\"(global)\"])\"boolean\"!=typeof predefined[v]&&(\"typeof\"!==anonname&&\"delete\"!==anonname||state.tokens.next&&(\".\"===state.tokens.next.value||\"[\"===state.tokens.next.value))&&(funct[\"(comparray)\"].check(v)||isundef(funct,\"W117\",state.tokens.curr,v)),note_implied(state.tokens.curr);else switch(funct[v]){case\"closure\":case\"function\":case\"var\":case\"unused\":warning(\"W038\",state.tokens.curr,v);break;case\"label\":warning(\"W037\",state.tokens.curr,v);break;case\"outer\":case\"global\":break;default:if(s===!0)funct[v]=!0;else if(null===s)warning(\"W039\",state.tokens.curr,v),note_implied(state.tokens.curr);else if(\"object\"!=typeof s)(\"typeof\"!==anonname&&\"delete\"!==anonname||state.tokens.next&&(\".\"===state.tokens.next.value||\"[\"===state.tokens.next.value))&&isundef(funct,\"W117\",state.tokens.curr,v),funct[v]=!0,note_implied(state.tokens.curr);else switch(s[v]){case\"function\":case\"unction\":this[\"function\"]=!0,s[v]=\"closure\",funct[v]=s[\"(global)\"]?\"global\":\"outer\";break;case\"var\":case\"unused\":s[v]=\"closure\",funct[v]=s[\"(global)\"]?\"global\":\"outer\";break;case\"const\":setprop(s,v,{unused:!1});break;case\"closure\":funct[v]=s[\"(global)\"]?\"global\":\"outer\";break;case\"label\":warning(\"W037\",state.tokens.curr,v)}}return this},led:function(){error(\"E033\",state.tokens.next,state.tokens.next.value)}},type(\"(regexp)\",function(){return this}),delim(\"(endline)\"),delim(\"(begin)\"),delim(\"(end)\").reach=!0,delim(\"(error)\").reach=!0,delim(\"}\").reach=!0,delim(\")\"),delim(\"]\"),delim('\"').reach=!0,delim(\"'\").reach=!0,delim(\";\"),delim(\":\").reach=!0,delim(\"#\"),reserve(\"else\"),reserve(\"case\").reach=!0,reserve(\"catch\"),reserve(\"default\").reach=!0,reserve(\"finally\"),reservevar(\"arguments\",function(x){state.directive[\"use strict\"]&&funct[\"(global)\"]&&warning(\"E008\",x)}),reservevar(\"eval\"),reservevar(\"false\"),reservevar(\"Infinity\"),reservevar(\"null\"),reservevar(\"this\",function(x){state.directive[\"use strict\"]&&!state.option.validthis&&(funct[\"(statement)\"]&&funct[\"(name)\"].charAt(0)>\"Z\"||funct[\"(global)\"])&&warning(\"W040\",x)}),reservevar(\"true\"),reservevar(\"undefined\"),assignop(\"=\",\"assign\",20),assignop(\"+=\",\"assignadd\",20),assignop(\"-=\",\"assignsub\",20),assignop(\"*=\",\"assignmult\",20),assignop(\"/=\",\"assigndiv\",20).nud=function(){error(\"E014\")},assignop(\"%=\",\"assignmod\",20),bitwiseassignop(\"&=\",\"assignbitand\",20),bitwiseassignop(\"|=\",\"assignbitor\",20),bitwiseassignop(\"^=\",\"assignbitxor\",20),bitwiseassignop(\"<<=\",\"assignshiftleft\",20),bitwiseassignop(\">>=\",\"assignshiftright\",20),bitwiseassignop(\">>>=\",\"assignshiftrightunsigned\",20),infix(\",\",function(left,that){var expr;if(that.exprs=[left],!comma({peek:!0}))return that;for(;;){if(!(expr=expression(10)))break;if(that.exprs.push(expr),\",\"!==state.tokens.next.value||!comma())break}return that},10,!0),infix(\"?\",function(left,that){return increaseComplexityCount(),that.left=left,that.right=expression(10),advance(\":\"),that[\"else\"]=expression(10),that},30);var orPrecendence=40;infix(\"||\",function(left,that){return increaseComplexityCount(),that.left=left,that.right=expression(orPrecendence),that},orPrecendence),infix(\"&&\",\"and\",50),bitwise(\"|\",\"bitor\",70),bitwise(\"^\",\"bitxor\",80),bitwise(\"&\",\"bitand\",90),relation(\"==\",function(left,right){var eqnull=state.option.eqnull&&(\"null\"===left.value||\"null\"===right.value);switch(!0){case!eqnull&&state.option.eqeqeq:this.from=this.character,warning(\"W116\",this,\"===\",\"==\");break;case isPoorRelation(left):warning(\"W041\",this,\"===\",left.value);break;case isPoorRelation(right):warning(\"W041\",this,\"===\",right.value);break;case isTypoTypeof(right,left):warning(\"W122\",this,right.value);break;case isTypoTypeof(left,right):warning(\"W122\",this,left.value)}return this}),relation(\"===\",function(left,right){return isTypoTypeof(right,left)?warning(\"W122\",this,right.value):isTypoTypeof(left,right)&&warning(\"W122\",this,left.value),this}),relation(\"!=\",function(left,right){var eqnull=state.option.eqnull&&(\"null\"===left.value||\"null\"===right.value);return!eqnull&&state.option.eqeqeq?(this.from=this.character,warning(\"W116\",this,\"!==\",\"!=\")):isPoorRelation(left)?warning(\"W041\",this,\"!==\",left.value):isPoorRelation(right)?warning(\"W041\",this,\"!==\",right.value):isTypoTypeof(right,left)?warning(\"W122\",this,right.value):isTypoTypeof(left,right)&&warning(\"W122\",this,left.value),this}),relation(\"!==\",function(left,right){return isTypoTypeof(right,left)?warning(\"W122\",this,right.value):isTypoTypeof(left,right)&&warning(\"W122\",this,left.value),this}),relation(\"<\"),relation(\">\"),relation(\"<=\"),relation(\">=\"),bitwise(\"<<\",\"shiftleft\",120),bitwise(\">>\",\"shiftright\",120),bitwise(\">>>\",\"shiftrightunsigned\",120),infix(\"in\",\"in\",120),infix(\"instanceof\",\"instanceof\",120),infix(\"+\",function(left,that){var right=expression(130);return left&&right&&\"(string)\"===left.id&&\"(string)\"===right.id?(left.value+=right.value,left.character=right.character,!state.option.scripturl&&reg.javascriptURL.test(left.value)&&warning(\"W050\",left),left):(that.left=left,that.right=right,that)},130),prefix(\"+\",\"num\"),prefix(\"+++\",function(){return warning(\"W007\"),this.right=expression(150),this.arity=\"unary\",this}),infix(\"+++\",function(left){return warning(\"W007\"),this.left=left,this.right=expression(130),this},130),infix(\"-\",\"sub\",130),prefix(\"-\",\"neg\"),prefix(\"---\",function(){return warning(\"W006\"),this.right=expression(150),this.arity=\"unary\",this}),infix(\"---\",function(left){return warning(\"W006\"),this.left=left,this.right=expression(130),this},130),infix(\"*\",\"mult\",140),infix(\"/\",\"div\",140),infix(\"%\",\"mod\",140),suffix(\"++\",\"postinc\"),prefix(\"++\",\"preinc\"),state.syntax[\"++\"].exps=!0,suffix(\"--\",\"postdec\"),prefix(\"--\",\"predec\"),state.syntax[\"--\"].exps=!0,prefix(\"delete\",function(){var p=expression(10);return(!p||\".\"!==p.id&&\"[\"!==p.id)&&warning(\"W051\"),this.first=p,this}).exps=!0,prefix(\"~\",function(){return state.option.bitwise&&warning(\"W052\",this,\"~\"),expression(150),this}),prefix(\"...\",function(){return state.option.inESNext()||warning(\"W104\",this,\"spread/rest operator\"),state.tokens.next.identifier||error(\"E030\",state.tokens.next,state.tokens.next.value),expression(150),this}),prefix(\"!\",function(){return this.right=expression(150),this.arity=\"unary\",this.right||quit(\"E041\",this.line||0),bang[this.right.id]===!0&&warning(\"W018\",this,\"!\"),this}),prefix(\"typeof\",\"typeof\"),prefix(\"new\",function(){var i,c=expression(155);if(c&&\"function\"!==c.id)if(c.identifier)switch(c[\"new\"]=!0,c.value){case\"Number\":case\"String\":case\"Boolean\":case\"Math\":case\"JSON\":warning(\"W053\",state.tokens.prev,c.value);break;case\"Function\":state.option.evil||warning(\"W054\");break;case\"Date\":case\"RegExp\":case\"this\":break;default:\"function\"!==c.id&&(i=c.value.substr(0,1),state.option.newcap&&(\"A\">i||i>\"Z\")&&!_.has(global,c.value)&&warning(\"W055\",state.tokens.curr))}else\".\"!==c.id&&\"[\"!==c.id&&\"(\"!==c.id&&warning(\"W056\",state.tokens.curr);else state.option.supernew||warning(\"W057\",this);return\"(\"===state.tokens.next.id||state.option.supernew||warning(\"W058\",state.tokens.curr,state.tokens.curr.value),this.first=c,this}),state.syntax[\"new\"].exps=!0,prefix(\"void\").exps=!0,infix(\".\",function(left,that){var m=identifier(!1,!0);return\"string\"==typeof m&&countMember(m),that.left=left,that.right=m,m&&\"hasOwnProperty\"===m&&\"=\"===state.tokens.next.value&&warning(\"W001\"),!left||\"arguments\"!==left.value||\"callee\"!==m&&\"caller\"!==m?state.option.evil||!left||\"document\"!==left.value||\"write\"!==m&&\"writeln\"!==m||warning(\"W060\",left):state.option.noarg?warning(\"W059\",left,m):state.directive[\"use strict\"]&&error(\"E008\"),state.option.evil||\"eval\"!==m&&\"execScript\"!==m||warning(\"W061\"),that},160,!0),infix(\"(\",function(left,that){state.option.immed&&left&&!left.immed&&\"function\"===left.id&&warning(\"W062\");var n=0,p=[];if(left&&\"(identifier)\"===left.type&&left.value.match(/^[A-Z]([A-Z0-9_$]*[a-z][A-Za-z0-9_$]*)?$/)&&-1===\"Number String Boolean Date Object Error\".indexOf(left.value)&&(\"Math\"===left.value?warning(\"W063\",left):state.option.newcap&&warning(\"W064\",left)),\")\"!==state.tokens.next.id)for(;p[p.length]=expression(10),n+=1,\",\"===state.tokens.next.id;)comma();return advance(\")\"),\"object\"==typeof left&&(state.option.inES3()&&\"parseInt\"===left.value&&1===n&&warning(\"W065\",state.tokens.curr),state.option.evil||(\"eval\"===left.value||\"Function\"===left.value||\"execScript\"===left.value?(warning(\"W061\",left),p[0]&&\"(string)\"===[0].id&&addInternalSrc(left,p[0].value)):!p[0]||\"(string)\"!==p[0].id||\"setTimeout\"!==left.value&&\"setInterval\"!==left.value?!p[0]||\"(string)\"!==p[0].id||\".\"!==left.value||\"window\"!==left.left.value||\"setTimeout\"!==left.right&&\"setInterval\"!==left.right||(warning(\"W066\",left),addInternalSrc(left,p[0].value)):(warning(\"W066\",left),addInternalSrc(left,p[0].value))),left.identifier||\".\"===left.id||\"[\"===left.id||\"(\"===left.id||\"&&\"===left.id||\"||\"===left.id||\"?\"===left.id||warning(\"W067\",left)),that.left=left,that},155,!0).exps=!0,prefix(\"(\",function(){var bracket,pn,pn1,ret,brackets=[],i=0,parens=1;do pn=peek(i),\"(\"===pn.value?parens+=1:\")\"===pn.value&&(parens-=1),i+=1,pn1=peek(i);while((0!==parens||\")\"!==pn.value)&&\"=>\"!==pn1.value&&\";\"!==pn1.value&&\"(end)\"!==pn1.type);\"function\"===state.tokens.next.id&&(state.tokens.next.immed=!0);var exprs=[];if(\")\"!==state.tokens.next.id)for(;;){if(\"=>\"===pn1.value&&_.contains([\"{\",\"[\"],state.tokens.next.value)){bracket=state.tokens.next,bracket.left=destructuringExpression(),brackets.push(bracket);for(var t in bracket.left)exprs.push(bracket.left[t].token)}else exprs.push(expression(10));if(\",\"!==state.tokens.next.id)break;comma()}return advance(\")\",this),state.option.immed&&exprs[0]&&\"function\"===exprs[0].id&&\"(\"!==state.tokens.next.id&&(\".\"!==state.tokens.next.id||\"call\"!==peek().value&&\"apply\"!==peek().value)&&warning(\"W068\",this),\"=>\"===state.tokens.next.value?exprs:exprs.length?(exprs.length>1?(ret=Object.create(state.syntax[\",\"]),ret.exprs=exprs):ret=exprs[0],ret&&(ret.paren=!0),ret):void 0}),application(\"=>\"),infix(\"[\",function(left,that){var s,e=expression(10);return e&&\"(string)\"===e.type&&(state.option.evil||\"eval\"!==e.value&&\"execScript\"!==e.value||warning(\"W061\",that),countMember(e.value),!state.option.sub&&reg.identifier.test(e.value)&&(s=state.syntax[e.value],s&&isReserved(s)||warning(\"W069\",state.tokens.prev,e.value))),advance(\"]\",that),e&&\"hasOwnProperty\"===e.value&&\"=\"===state.tokens.next.value&&warning(\"W001\"),that.left=left,that.right=e,that},160,!0),prefix(\"[\",function(){var blocktype=lookupBlockType(!0);if(blocktype.isCompArray)return state.option.inESNext()||warning(\"W119\",state.tokens.curr,\"array comprehension\"),comprehensiveArrayExpression();blocktype.isDestAssign&&!state.option.inESNext()&&warning(\"W104\",state.tokens.curr,\"destructuring assignment\");var b=state.tokens.curr.line!==state.tokens.next.line;for(this.first=[],b&&(indent+=state.option.indent,state.tokens.next.from===indent+state.option.indent&&(indent+=state.option.indent));\"(end)\"!==state.tokens.next.id;){for(;\",\"===state.tokens.next.id;)state.option.inES5()||warning(\"W070\"),advance(\",\");if(\"]\"===state.tokens.next.id)break;if(this.first.push(expression(10)),\",\"!==state.tokens.next.id)break;if(comma({allowTrailing:!0}),\"]\"===state.tokens.next.id&&!state.option.inES5(!0)){warning(\"W070\",state.tokens.curr);break}}return b&&(indent-=state.option.indent),advance(\"]\",this),this},160),function(x){x.nud=function(isclassdef){function saveProperty(name,tkn){props[name]&&_.has(props,name)?warning(\"W075\",state.tokens.next,i):props[name]={},props[name].basic=!0,props[name].basictkn=tkn}function saveSetter(name,tkn){props[name]&&_.has(props,name)?(props[name].basic||props[name].setter)&&warning(\"W075\",state.tokens.next,i):props[name]={},props[name].setter=!0,props[name].setterToken=tkn}function saveGetter(name){props[name]&&_.has(props,name)?(props[name].basic||props[name].getter)&&warning(\"W075\",state.tokens.next,i):props[name]={},props[name].getter=!0,props[name].getterToken=state.tokens.curr}var b,f,i,p,t,g,props={},tag=\"\";for(b=state.tokens.curr.line!==state.tokens.next.line,b&&(indent+=state.option.indent,state.tokens.next.from===indent+state.option.indent&&(indent+=state.option.indent));\"}\"!==state.tokens.next.id;){if(isclassdef&&\"static\"===state.tokens.next.value&&(advance(\"static\"),tag=\"static \"),\"get\"===state.tokens.next.value&&\":\"!==peek().id)advance(\"get\"),state.option.inES5(!isclassdef)||error(\"E034\"),i=property_name(),i||state.option.inESNext()||error(\"E035\"),isclassdef&&\"constructor\"===i&&error(\"E049\",state.tokens.next,\"class getter method\",i),i&&saveGetter(tag+i),t=state.tokens.next,f=doFunction(),p=f[\"(params)\"],i&&p&&warning(\"W076\",t,p[0],i);else if(\"set\"===state.tokens.next.value&&\":\"!==peek().id)advance(\"set\"),state.option.inES5(!isclassdef)||error(\"E034\"),i=property_name(),i||state.option.inESNext()||error(\"E035\"),isclassdef&&\"constructor\"===i&&error(\"E049\",state.tokens.next,\"class setter method\",i),i&&saveSetter(tag+i,state.tokens.next),t=state.tokens.next,f=doFunction(),p=f[\"(params)\"],!i||p&&1===p.length||warning(\"W077\",t,i);else{if(g=!1,\"*\"===state.tokens.next.value&&\"(punctuator)\"===state.tokens.next.type&&(state.option.inESNext()||warning(\"W104\",state.tokens.next,\"generator functions\"),advance(\"*\"),g=!0),i=property_name(),saveProperty(tag+i,state.tokens.next),\"string\"!=typeof i)break;\"(\"===state.tokens.next.value?(state.option.inESNext()||warning(\"W104\",state.tokens.curr,\"concise methods\"),doFunction(i,void 0,g)):isclassdef||(advance(\":\"),expression(10))}if(isclassdef&&\"prototype\"===i&&error(\"E049\",state.tokens.next,\"class method\",i),countMember(i),isclassdef)tag=\"\";\nelse{if(\",\"!==state.tokens.next.id)break;comma({allowTrailing:!0,property:!0}),\",\"===state.tokens.next.id?warning(\"W070\",state.tokens.curr):\"}\"!==state.tokens.next.id||state.option.inES5(!0)||warning(\"W070\",state.tokens.curr)}}if(b&&(indent-=state.option.indent),advance(\"}\",this),state.option.inES5())for(var name in props)_.has(props,name)&&props[name].setter&&!props[name].getter&&warning(\"W078\",props[name].setterToken);return this},x.fud=function(){error(\"E036\",state.tokens.curr)}}(delim(\"{\"));var conststatement=stmt(\"const\",function(prefix){var tokens,value,lone;for(state.option.inESNext()||warning(\"W104\",state.tokens.curr,\"const\"),this.first=[];;){var names=[];_.contains([\"{\",\"[\"],state.tokens.next.value)?(tokens=destructuringExpression(),lone=!1):(tokens=[{id:identifier(),token:state.tokens.curr}],lone=!0);for(var t in tokens)tokens.hasOwnProperty(t)&&(t=tokens[t],\"const\"===funct[t.id]&&warning(\"E011\",null,t.id),funct[\"(global)\"]&&predefined[t.id]===!1&&warning(\"W079\",t.token,t.id),t.id&&(addlabel(t.id,{token:t.token,type:\"const\",unused:!0}),names.push(t.token)));if(prefix)break;if(this.first=this.first.concat(names),\"=\"!==state.tokens.next.id&&warning(\"E012\",state.tokens.curr,state.tokens.curr.value),\"=\"===state.tokens.next.id&&(advance(\"=\"),\"undefined\"===state.tokens.next.id&&warning(\"W080\",state.tokens.prev,state.tokens.prev.value),\"=\"===peek(0).id&&state.tokens.next.identifier&&warning(\"W120\",state.tokens.next,state.tokens.next.value),value=expression(10),lone?tokens[0].first=value:destructuringExpressionMatch(names,value)),\",\"!==state.tokens.next.id)break;comma()}return this});conststatement.exps=!0;var varstatement=stmt(\"var\",function(prefix){var tokens,lone,value;for(this.first=[];;){var names=[];_.contains([\"{\",\"[\"],state.tokens.next.value)?(tokens=destructuringExpression(),lone=!1):(tokens=[{id:identifier(),token:state.tokens.curr}],lone=!0);for(var t in tokens)tokens.hasOwnProperty(t)&&(t=tokens[t],state.option.inESNext()&&\"const\"===funct[t.id]&&warning(\"E011\",null,t.id),funct[\"(global)\"]&&predefined[t.id]===!1&&warning(\"W079\",t.token,t.id),t.id&&(addlabel(t.id,{type:\"unused\",token:t.token}),names.push(t.token)));if(prefix)break;if(this.first=this.first.concat(names),\"=\"===state.tokens.next.id&&(advance(\"=\"),\"undefined\"===state.tokens.next.id&&warning(\"W080\",state.tokens.prev,state.tokens.prev.value),\"=\"===peek(0).id&&state.tokens.next.identifier&&warning(\"W120\",state.tokens.next,state.tokens.next.value),value=expression(10),lone?tokens[0].first=value:destructuringExpressionMatch(names,value)),\",\"!==state.tokens.next.id)break;comma()}return this});varstatement.exps=!0;var letstatement=stmt(\"let\",function(prefix){var tokens,lone,value,letblock;for(state.option.inESNext()||warning(\"W104\",state.tokens.curr,\"let\"),\"(\"===state.tokens.next.value?(state.option.inMoz(!0)||warning(\"W118\",state.tokens.next,\"let block\"),advance(\"(\"),funct[\"(blockscope)\"].stack(),letblock=!0):funct[\"(nolet)\"]&&error(\"E048\",state.tokens.curr),this.first=[];;){var names=[];_.contains([\"{\",\"[\"],state.tokens.next.value)?(tokens=destructuringExpression(),lone=!1):(tokens=[{id:identifier(),token:state.tokens.curr.value}],lone=!0);for(var t in tokens)tokens.hasOwnProperty(t)&&(t=tokens[t],state.option.inESNext()&&\"const\"===funct[t.id]&&warning(\"E011\",null,t.id),funct[\"(global)\"]&&predefined[t.id]===!1&&warning(\"W079\",t.token,t.id),t.id&&!funct[\"(nolet)\"]&&(addlabel(t.id,{type:\"unused\",token:t.token,islet:!0}),names.push(t.token)));if(prefix)break;if(this.first=this.first.concat(names),\"=\"===state.tokens.next.id&&(advance(\"=\"),\"undefined\"===state.tokens.next.id&&warning(\"W080\",state.tokens.prev,state.tokens.prev.value),\"=\"===peek(0).id&&state.tokens.next.identifier&&warning(\"W120\",state.tokens.next,state.tokens.next.value),value=expression(10),lone?tokens[0].first=value:destructuringExpressionMatch(names,value)),\",\"!==state.tokens.next.id)break;comma()}return letblock&&(advance(\")\"),block(!0,!0),this.block=!0,funct[\"(blockscope)\"].unstack()),this});letstatement.exps=!0,blockstmt(\"class\",function(){return classdef.call(this,!0)}),blockstmt(\"function\",function(){var generator=!1;\"*\"===state.tokens.next.value&&(advance(\"*\"),state.option.inESNext(!0)?generator=!0:warning(\"W119\",state.tokens.curr,\"function*\")),inblock&&warning(\"W082\",state.tokens.curr);var i=identifier();return\"const\"===funct[i]&&warning(\"E011\",null,i),addlabel(i,{type:\"unction\",token:state.tokens.curr}),doFunction(i,{statement:!0},generator),\"(\"===state.tokens.next.id&&state.tokens.next.line===state.tokens.curr.line&&error(\"E039\"),this}),prefix(\"function\",function(){var generator=!1;\"*\"===state.tokens.next.value&&(state.option.inESNext()||warning(\"W119\",state.tokens.curr,\"function*\"),advance(\"*\"),generator=!0);var i=optionalidentifier();return doFunction(i,void 0,generator),!state.option.loopfunc&&funct[\"(loopage)\"]&&warning(\"W083\"),this}),blockstmt(\"if\",function(){var t=state.tokens.next;return increaseComplexityCount(),state.condition=!0,advance(\"(\"),checkCondAssignment(expression(0)),advance(\")\",t),state.condition=!1,block(!0,!0),\"else\"===state.tokens.next.id&&(advance(\"else\"),\"if\"===state.tokens.next.id||\"switch\"===state.tokens.next.id?statement(!0):block(!0,!0)),this}),blockstmt(\"try\",function(){function doCatch(){var e,oldScope=scope;advance(\"catch\"),advance(\"(\"),scope=Object.create(oldScope),e=state.tokens.next.value,\"(identifier)\"!==state.tokens.next.type&&(e=null,warning(\"E030\",state.tokens.next,e)),advance(),funct=functor(\"(catch)\",state.tokens.next,scope,{\"(context)\":funct,\"(breakage)\":funct[\"(breakage)\"],\"(loopage)\":funct[\"(loopage)\"],\"(statement)\":!1,\"(catch)\":!0}),e&&addlabel(e,{type:\"exception\"}),\"if\"===state.tokens.next.value&&(state.option.inMoz(!0)||warning(\"W118\",state.tokens.curr,\"catch filter\"),advance(\"if\"),expression(0)),advance(\")\"),state.tokens.curr.funct=funct,functions.push(funct),block(!1),scope=oldScope,funct[\"(last)\"]=state.tokens.curr.line,funct[\"(lastcharacter)\"]=state.tokens.curr.character,funct=funct[\"(context)\"]}var b;for(block(!0);\"catch\"===state.tokens.next.id;)increaseComplexityCount(),b&&!state.option.inMoz(!0)&&warning(\"W118\",state.tokens.next,\"multiple catch blocks\"),doCatch(),b=!0;return\"finally\"===state.tokens.next.id?(advance(\"finally\"),block(!0),void 0):(b||error(\"E021\",state.tokens.next,\"catch\",state.tokens.next.value),this)}),blockstmt(\"while\",function(){var t=state.tokens.next;return funct[\"(breakage)\"]+=1,funct[\"(loopage)\"]+=1,increaseComplexityCount(),advance(\"(\"),checkCondAssignment(expression(0)),advance(\")\",t),block(!0,!0),funct[\"(breakage)\"]-=1,funct[\"(loopage)\"]-=1,this}).labelled=!0,blockstmt(\"with\",function(){var t=state.tokens.next;return state.directive[\"use strict\"]?error(\"E010\",state.tokens.curr):state.option.withstmt||warning(\"W085\",state.tokens.curr),advance(\"(\"),expression(0),advance(\")\",t),block(!0,!0),this}),blockstmt(\"switch\",function(){var t=state.tokens.next,g=!1,noindent=!1;for(funct[\"(breakage)\"]+=1,advance(\"(\"),checkCondAssignment(expression(0)),advance(\")\",t),t=state.tokens.next,advance(\"{\"),state.tokens.next.from===indent&&(noindent=!0),noindent||(indent+=state.option.indent),this.cases=[];;)switch(state.tokens.next.id){case\"case\":switch(funct[\"(verb)\"]){case\"yield\":case\"break\":case\"case\":case\"continue\":case\"return\":case\"switch\":case\"throw\":break;default:reg.fallsThrough.test(state.lines[state.tokens.next.line-2])||warning(\"W086\",state.tokens.curr,\"case\")}advance(\"case\"),this.cases.push(expression(0)),increaseComplexityCount(),g=!0,advance(\":\"),funct[\"(verb)\"]=\"case\";break;case\"default\":switch(funct[\"(verb)\"]){case\"yield\":case\"break\":case\"continue\":case\"return\":case\"throw\":break;default:this.cases.length&&(reg.fallsThrough.test(state.lines[state.tokens.next.line-2])||warning(\"W086\",state.tokens.curr,\"default\"))}advance(\"default\"),g=!0,advance(\":\");break;case\"}\":return noindent||(indent-=state.option.indent),advance(\"}\",t),funct[\"(breakage)\"]-=1,funct[\"(verb)\"]=void 0,void 0;case\"(end)\":return error(\"E023\",state.tokens.next,\"}\"),void 0;default:if(indent+=state.option.indent,g)switch(state.tokens.curr.id){case\",\":return error(\"E040\"),void 0;case\":\":g=!1,statements();break;default:return error(\"E025\",state.tokens.curr),void 0}else{if(\":\"!==state.tokens.curr.id)return error(\"E021\",state.tokens.next,\"case\",state.tokens.next.value),void 0;advance(\":\"),error(\"E024\",state.tokens.curr,\":\"),statements()}indent-=state.option.indent}}).labelled=!0,stmt(\"debugger\",function(){return state.option.debug||warning(\"W087\",this),this}).exps=!0,function(){var x=stmt(\"do\",function(){funct[\"(breakage)\"]+=1,funct[\"(loopage)\"]+=1,increaseComplexityCount(),this.first=block(!0,!0),advance(\"while\");var t=state.tokens.next;return advance(\"(\"),checkCondAssignment(expression(0)),advance(\")\",t),funct[\"(breakage)\"]-=1,funct[\"(loopage)\"]-=1,this});x.labelled=!0,x.exps=!0}(),blockstmt(\"for\",function(){var s,t=state.tokens.next,letscope=!1,foreachtok=null;\"each\"===t.value&&(foreachtok=t,advance(\"each\"),state.option.inMoz(!0)||warning(\"W118\",state.tokens.curr,\"for each\")),funct[\"(breakage)\"]+=1,funct[\"(loopage)\"]+=1,increaseComplexityCount(),advance(\"(\");var nextop,i=0,inof=[\"in\",\"of\"];do nextop=peek(i),++i;while(!_.contains(inof,nextop.value)&&\";\"!==nextop.value&&\"(end)\"!==nextop.type);if(_.contains(inof,nextop.value)){if(state.option.inESNext()||\"of\"!==nextop.value||error(\"W104\",nextop,\"for of\"),\"var\"===state.tokens.next.id)advance(\"var\"),state.syntax[\"var\"].fud.call(state.syntax[\"var\"].fud,!0);else if(\"let\"===state.tokens.next.id)advance(\"let\"),letscope=!0,funct[\"(blockscope)\"].stack(),state.syntax.let.fud.call(state.syntax.let.fud,!0);else if(state.tokens.next.identifier){switch(funct[state.tokens.next.value]){case\"unused\":funct[state.tokens.next.value]=\"var\";break;case\"var\":break;default:funct[\"(blockscope)\"].getlabel(state.tokens.next.value)||warning(\"W088\",state.tokens.next,state.tokens.next.value)}advance()}else error(\"E030\",state.tokens.next,state.tokens.next.type),advance();advance(nextop.value),expression(20),advance(\")\",t),s=block(!0,!0),state.option.forin&&s&&(s.length>1||\"object\"!=typeof s[0]||\"if\"!==s[0].value)&&warning(\"W089\",this),funct[\"(breakage)\"]-=1,funct[\"(loopage)\"]-=1}else{if(foreachtok&&error(\"E045\",foreachtok),\";\"!==state.tokens.next.id)if(\"var\"===state.tokens.next.id)advance(\"var\"),state.syntax[\"var\"].fud.call(state.syntax[\"var\"].fud);else if(\"let\"===state.tokens.next.id)advance(\"let\"),letscope=!0,funct[\"(blockscope)\"].stack(),state.syntax.let.fud.call(state.syntax.let.fud);else for(;expression(0,\"for\"),\",\"===state.tokens.next.id;)comma();if(nolinebreak(state.tokens.curr),advance(\";\"),\";\"!==state.tokens.next.id&&checkCondAssignment(expression(0)),nolinebreak(state.tokens.curr),advance(\";\"),\";\"===state.tokens.next.id&&error(\"E021\",state.tokens.next,\")\",\";\"),\")\"!==state.tokens.next.id)for(;expression(0,\"for\"),\",\"===state.tokens.next.id;)comma();advance(\")\",t),block(!0,!0),funct[\"(breakage)\"]-=1,funct[\"(loopage)\"]-=1}return letscope&&funct[\"(blockscope)\"].unstack(),this}).labelled=!0,stmt(\"break\",function(){var v=state.tokens.next.value;return 0===funct[\"(breakage)\"]&&warning(\"W052\",state.tokens.next,this.value),state.option.asi||nolinebreak(this),\";\"===state.tokens.next.id||state.tokens.next.reach||state.tokens.curr.line===state.tokens.next.line&&(\"label\"!==funct[v]?warning(\"W090\",state.tokens.next,v):scope[v]!==funct&&warning(\"W091\",state.tokens.next,v),this.first=state.tokens.next,advance()),reachable(\"break\"),this}).exps=!0,stmt(\"continue\",function(){var v=state.tokens.next.value;return 0===funct[\"(breakage)\"]&&warning(\"W052\",state.tokens.next,this.value),state.option.asi||nolinebreak(this),\";\"===state.tokens.next.id||state.tokens.next.reach?funct[\"(loopage)\"]||warning(\"W052\",state.tokens.next,this.value):state.tokens.curr.line===state.tokens.next.line&&(\"label\"!==funct[v]?warning(\"W090\",state.tokens.next,v):scope[v]!==funct&&warning(\"W091\",state.tokens.next,v),this.first=state.tokens.next,advance()),reachable(\"continue\"),this}).exps=!0,stmt(\"return\",function(){return this.line===state.tokens.next.line?\";\"===state.tokens.next.id||state.tokens.next.reach||(this.first=expression(0),!this.first||\"(punctuator)\"!==this.first.type||\"=\"!==this.first.value||this.first.paren||state.option.boss||warningAt(\"W093\",this.first.line,this.first.character)):\"(punctuator)\"===state.tokens.next.type&&[\"[\",\"{\",\"+\",\"-\"].indexOf(state.tokens.next.value)>-1&&nolinebreak(this),reachable(\"return\"),this}).exps=!0,function(x){x.exps=!0,x.lbp=25}(prefix(\"yield\",function(){var prev=state.tokens.prev;return state.option.inESNext(!0)&&!funct[\"(generator)\"]?\"(catch)\"===funct[\"(name)\"]&&funct[\"(context)\"][\"(generator)\"]||error(\"E046\",state.tokens.curr,\"yield\"):state.option.inESNext()||warning(\"W104\",state.tokens.curr,\"yield\"),funct[\"(generator)\"]=\"yielded\",this.line!==state.tokens.next.line&&state.option.inMoz(!0)?state.option.asi||nolinebreak(this):(\";\"!==state.tokens.next.id&&!state.tokens.next.reach&&state.tokens.next.nud&&(nobreaknonadjacent(state.tokens.curr,state.tokens.next),this.first=expression(10),\"(punctuator)\"!==this.first.type||\"=\"!==this.first.value||this.first.paren||state.option.boss||warningAt(\"W093\",this.first.line,this.first.character)),state.option.inMoz(!0)&&\")\"!==state.tokens.next.id&&(prev.lbp>30||!prev.assign&&!isEndOfExpr()||\"yield\"===prev.id)&&error(\"E050\",this)),this})),stmt(\"throw\",function(){return nolinebreak(this),this.first=expression(20),reachable(\"throw\"),this}).exps=!0,stmt(\"import\",function(){if(state.option.inESNext()||warning(\"W119\",state.tokens.curr,\"import\"),\"(string)\"===state.tokens.next.type)return advance(\"(string)\"),this;if(state.tokens.next.identifier)this.name=identifier(),addlabel(this.name,{type:\"unused\",token:state.tokens.curr});else for(advance(\"{\");;){if(\"}\"===state.tokens.next.value){advance(\"}\");break}var importName;if(\"default\"===state.tokens.next.type?(importName=\"default\",advance(\"default\")):importName=identifier(),\"as\"===state.tokens.next.value&&(advance(\"as\"),importName=identifier()),addlabel(importName,{type:\"unused\",token:state.tokens.curr}),\",\"!==state.tokens.next.value){if(\"}\"===state.tokens.next.value){advance(\"}\");break}error(\"E024\",state.tokens.next,state.tokens.next.value);break}advance(\",\")}return advance(\"from\"),advance(\"(string)\"),this}).exps=!0,stmt(\"export\",function(){if(state.option.inESNext()||warning(\"W119\",state.tokens.curr,\"export\"),\"default\"===state.tokens.next.type)return advance(\"default\"),(\"function\"===state.tokens.next.id||\"class\"===state.tokens.next.id)&&(this.block=!0),this.exportee=expression(10),this;if(\"{\"===state.tokens.next.value){for(advance(\"{\");;){if(exported[identifier()]=!0,\",\"!==state.tokens.next.value){if(\"}\"===state.tokens.next.value){advance(\"}\");break}error(\"E024\",state.tokens.next,state.tokens.next.value);break}advance(\",\")}return this}return\"var\"===state.tokens.next.id?(advance(\"var\"),exported[state.tokens.next.value]=!0,state.syntax[\"var\"].fud.call(state.syntax[\"var\"].fud)):\"let\"===state.tokens.next.id?(advance(\"let\"),exported[state.tokens.next.value]=!0,state.syntax.let.fud.call(state.syntax.let.fud)):\"const\"===state.tokens.next.id?(advance(\"const\"),exported[state.tokens.next.value]=!0,state.syntax[\"const\"].fud.call(state.syntax[\"const\"].fud)):\"function\"===state.tokens.next.id?(this.block=!0,advance(\"function\"),exported[state.tokens.next.value]=!0,state.syntax[\"function\"].fud()):\"class\"===state.tokens.next.id?(this.block=!0,advance(\"class\"),exported[state.tokens.next.value]=!0,state.syntax[\"class\"].fud()):error(\"E024\",state.tokens.next,state.tokens.next.value),this}).exps=!0,FutureReservedWord(\"abstract\"),FutureReservedWord(\"boolean\"),FutureReservedWord(\"byte\"),FutureReservedWord(\"char\"),FutureReservedWord(\"class\",{es5:!0,nud:classdef}),FutureReservedWord(\"double\"),FutureReservedWord(\"enum\",{es5:!0}),FutureReservedWord(\"export\",{es5:!0}),FutureReservedWord(\"extends\",{es5:!0}),FutureReservedWord(\"final\"),FutureReservedWord(\"float\"),FutureReservedWord(\"goto\"),FutureReservedWord(\"implements\",{es5:!0,strictOnly:!0}),FutureReservedWord(\"import\",{es5:!0}),FutureReservedWord(\"int\"),FutureReservedWord(\"interface\",{es5:!0,strictOnly:!0}),FutureReservedWord(\"long\"),FutureReservedWord(\"native\"),FutureReservedWord(\"package\",{es5:!0,strictOnly:!0}),FutureReservedWord(\"private\",{es5:!0,strictOnly:!0}),FutureReservedWord(\"protected\",{es5:!0,strictOnly:!0}),FutureReservedWord(\"public\",{es5:!0,strictOnly:!0}),FutureReservedWord(\"short\"),FutureReservedWord(\"static\",{es5:!0,strictOnly:!0}),FutureReservedWord(\"super\",{es5:!0}),FutureReservedWord(\"synchronized\"),FutureReservedWord(\"transient\"),FutureReservedWord(\"volatile\");var lookupBlockType=function(){var pn,pn1,i=-1,bracketStack=0,ret={};_.contains([\"[\",\"{\"],state.tokens.curr.value)&&(bracketStack+=1);do{if(pn=-1===i?state.tokens.next:peek(i),pn1=peek(i+1),i+=1,_.contains([\"[\",\"{\"],pn.value)?bracketStack+=1:_.contains([\"]\",\"}\"],pn.value)&&(bracketStack-=1),pn.identifier&&\"for\"===pn.value&&1===bracketStack){ret.isCompArray=!0,ret.notJson=!0;break}if(_.contains([\"}\",\"]\"],pn.value)&&\"=\"===pn1.value&&0===bracketStack){ret.isDestAssign=!0,ret.notJson=!0;break}\";\"===pn.value&&(ret.isBlock=!0,ret.notJson=!0)}while(bracketStack>0&&\"(end)\"!==pn.id&&15>i);return ret},arrayComprehension=function(){function declare(v){var l=_current.variables.filter(function(elt){return elt.value===v?(elt.undef=!1,v):void 0}).length;return 0!==l}function use(v){var l=_current.variables.filter(function(elt){return elt.value!==v||elt.undef?void 0:(elt.unused===!0&&(elt.unused=!1),v)}).length;return 0===l}var _current,CompArray=function(){this.mode=\"use\",this.variables=[]},_carrays=[];return{stack:function(){_current=new CompArray,_carrays.push(_current)},unstack:function(){_current.variables.filter(function(v){v.unused&&warning(\"W098\",v.token,v.value),v.undef&&isundef(v.funct,\"W117\",v.token,v.value)}),_carrays.splice(-1,1),_current=_carrays[_carrays.length-1]},setState:function(s){_.contains([\"use\",\"define\",\"generate\",\"filter\"],s)&&(_current.mode=s)},check:function(v){return _current?_current&&\"use\"===_current.mode?(use(v)&&_current.variables.push({funct:funct,token:state.tokens.curr,value:v,undef:!0,unused:!1}),!0):_current&&\"define\"===_current.mode?(declare(v)||_current.variables.push({funct:funct,token:state.tokens.curr,value:v,undef:!1,unused:!0}),!0):_current&&\"generate\"===_current.mode?(isundef(funct,\"W117\",state.tokens.curr,v),!0):_current&&\"filter\"===_current.mode?(use(v)&&isundef(funct,\"W117\",state.tokens.curr,v),!0):!1:void 0}}},blockScope=function(){function _checkBlockLabels(){for(var t in _current)if(\"unused\"===_current[t][\"(type)\"]&&state.option.unused){var tkn=_current[t][\"(token)\"],line=tkn.line,chr=tkn.character;warningAt(\"W098\",line,chr,t)}}var _current={},_variables=[_current];return{stack:function(){_current={},_variables.push(_current)},unstack:function(){_checkBlockLabels(),_variables.splice(_variables.length-1,1),_current=_.last(_variables)},getlabel:function(l){for(var i=_variables.length-1;i>=0;--i)if(_.has(_variables[i],l)&&!_variables[i][l][\"(shadowed)\"])return _variables[i]},shadow:function(name){for(var i=_variables.length-1;i>=0;i--)_.has(_variables[i],name)&&(_variables[i][name][\"(shadowed)\"]=!0)},unshadow:function(name){for(var i=_variables.length-1;i>=0;i--)_.has(_variables[i],name)&&(_variables[i][name][\"(shadowed)\"]=!1)},current:{has:function(t){return _.has(_current,t)},add:function(t,type,tok){_current[t]={\"(type)\":type,\"(token)\":tok,\"(shadowed)\":!1}}}}},itself=function(s,o,g){function each(obj,cb){obj&&(Array.isArray(obj)||\"object\"!=typeof obj||(obj=Object.keys(obj)),obj.forEach(cb))}var i,k,x,optionKeys,newOptionObj={},newIgnoredObj={};if(o=_.clone(o),state.reset(),o&&o.scope?JSHINT.scope=o.scope:(JSHINT.errors=[],JSHINT.undefs=[],JSHINT.internals=[],JSHINT.blacklist={},JSHINT.scope=\"(main)\"),predefined=Object.create(null),combine(predefined,vars.ecmaIdentifiers),combine(predefined,vars.reservedVars),combine(predefined,g||{}),declared=Object.create(null),exported=Object.create(null),o)for(each(o.predef||null,function(item){var slice,prop;\"-\"===item[0]?(slice=item.slice(1),JSHINT.blacklist[slice]=slice):(prop=Object.getOwnPropertyDescriptor(o.predef,item),predefined[item]=prop?prop.value:!1)}),each(o.exported||null,function(item){exported[item]=!0}),delete o.predef,delete o.exported,optionKeys=Object.keys(o),x=0;optionKeys.length>x;x++)/^-W\\d{3}$/g.test(optionKeys[x])?newIgnoredObj[optionKeys[x].slice(1)]=!0:(newOptionObj[optionKeys[x]]=o[optionKeys[x]],\"newcap\"===optionKeys[x]&&o[optionKeys[x]]===!1&&(newOptionObj[\"(explicitNewcap)\"]=!0));if(state.option=newOptionObj,state.ignored=newIgnoredObj,state.option.indent=state.option.indent||4,state.option.maxerr=state.option.maxerr||50,indent=1,global=Object.create(predefined),scope=global,funct=functor(\"(global)\",null,scope,{\"(global)\":!0,\"(blockscope)\":blockScope(),\"(comparray)\":arrayComprehension(),\"(metrics)\":createMetrics(state.tokens.next)}),functions=[funct],urls=[],stack=null,member={},membersOnly=null,implied={},inblock=!1,lookahead=[],unuseds=[],!isString(s)&&!Array.isArray(s))return errorAt(\"E004\",0),!1;api={get isJSON(){return state.jsonMode},getOption:function(name){return state.option[name]||null},getCache:function(name){return state.cache[name]},setCache:function(name,value){state.cache[name]=value},warn:function(code,data){warningAt.apply(null,[code,data.line,data.char].concat(data.data))},on:function(names,listener){names.split(\" \").forEach(function(name){emitter.on(name,listener)}.bind(this))}},emitter.removeAllListeners(),(extraModules||[]).forEach(function(func){func(api)}),state.tokens.prev=state.tokens.curr=state.tokens.next=state.syntax[\"(begin)\"],lex=new Lexer(s),lex.on(\"warning\",function(ev){warningAt.apply(null,[ev.code,ev.line,ev.character].concat(ev.data))}),lex.on(\"error\",function(ev){errorAt.apply(null,[ev.code,ev.line,ev.character].concat(ev.data))}),lex.on(\"fatal\",function(ev){quit(\"E041\",ev.line,ev.from)}),lex.on(\"Identifier\",function(ev){emitter.emit(\"Identifier\",ev)}),lex.on(\"String\",function(ev){emitter.emit(\"String\",ev)}),lex.on(\"Number\",function(ev){emitter.emit(\"Number\",ev)}),lex.start();for(var name in o)_.has(o,name)&&checkOption(name,state.tokens.curr);assume(),combine(predefined,g||{}),comma.first=!0;try{switch(advance(),state.tokens.next.id){case\"{\":case\"[\":destructuringAssignOrJsonValue();break;default:directives(),state.directive[\"use strict\"]&&(state.option.globalstrict||state.option.node||state.option.phantom||warning(\"W097\",state.tokens.prev)),statements()}advance(state.tokens.next&&\".\"!==state.tokens.next.value?\"(end)\":void 0),funct[\"(blockscope)\"].unstack();var markDefined=function(name,context){do{if(\"string\"==typeof context[name])return\"unused\"===context[name]?context[name]=\"var\":\"unction\"===context[name]&&(context[name]=\"closure\"),!0;context=context[\"(context)\"]}while(context);return!1},clearImplied=function(name,line){if(implied[name]){for(var newImplied=[],i=0;implied[name].length>i;i+=1)implied[name][i]!==line&&newImplied.push(implied[name][i]);0===newImplied.length?delete implied[name]:implied[name]=newImplied}},warnUnused=function(name,tkn,type,unused_opt){var line=tkn.line,chr=tkn.character;void 0===unused_opt&&(unused_opt=state.option.unused),unused_opt===!0&&(unused_opt=\"last-param\");var warnable_types={vars:[\"var\"],\"last-param\":[\"var\",\"param\"],strict:[\"var\",\"param\",\"last-param\"]};unused_opt&&warnable_types[unused_opt]&&-1!==warnable_types[unused_opt].indexOf(type)&&warningAt(\"W098\",line,chr,name),unuseds.push({name:name,line:line,character:chr})},checkUnused=function(func,key){var type=func[key],tkn=func[\"(tokens)\"][key];\"(\"!==key.charAt(0)&&(\"unused\"===type||\"unction\"===type||\"const\"===type)&&(func[\"(params)\"]&&-1!==func[\"(params)\"].indexOf(key)||func[\"(global)\"]&&_.has(exported,key)||(\"const\"!==type||getprop(func,key,\"unused\"))&&warnUnused(key,tkn,\"var\"))};for(i=0;JSHINT.undefs.length>i;i+=1)k=JSHINT.undefs[i].slice(0),markDefined(k[2].value,k[0])?clearImplied(k[2].value,k[2].line):state.option.undef&&warning.apply(warning,k.slice(1));functions.forEach(function(func){if(func[\"(unusedOption)\"]!==!1){for(var key in func)_.has(func,key)&&checkUnused(func,key);if(func[\"(params)\"])for(var type,unused_opt,params=func[\"(params)\"].slice(),param=params.pop();param;){if(type=func[param],unused_opt=func[\"(unusedOption)\"]||state.option.unused,unused_opt=unused_opt===!0?\"last-param\":unused_opt,\"undefined\"===param)return;if(\"unused\"===type||\"unction\"===type)warnUnused(param,func[\"(tokens)\"][param],\"param\",func[\"(unusedOption)\"]);else if(\"last-param\"===unused_opt)return;param=params.pop()}}});for(var key in declared)!_.has(declared,key)||_.has(global,key)||_.has(exported,key)||warnUnused(key,declared[key],\"var\")}catch(err){if(!err||\"JSHintError\"!==err.name)throw err;var nt=state.tokens.next||{};JSHINT.errors.push({scope:\"(main)\",raw:err.raw,code:err.code,reason:err.message,line:err.line||nt.line,character:err.character||nt.from},null)}if(\"(main)\"===JSHINT.scope)for(o=o||{},i=0;JSHINT.internals.length>i;i+=1)k=JSHINT.internals[i],o.scope=k.elem,itself(k.value,o,g);return 0===JSHINT.errors.length};return itself.addModule=function(func){extraModules.push(func)},itself.addModule(style.register),itself.data=function(){var fu,f,i,j,n,globals,data={functions:[],options:state.option},implieds=[],members=[];itself.errors.length&&(data.errors=itself.errors),state.jsonMode&&(data.json=!0);for(n in implied)_.has(implied,n)&&implieds.push({name:n,line:implied[n]});for(implieds.length>0&&(data.implieds=implieds),urls.length>0&&(data.urls=urls),globals=Object.keys(scope),globals.length>0&&(data.globals=globals),i=1;functions.length>i;i+=1){for(f=functions[i],fu={},j=0;functionicity.length>j;j+=1)fu[functionicity[j]]=[];for(j=0;functionicity.length>j;j+=1)0===fu[functionicity[j]].length&&delete fu[functionicity[j]];fu.name=f[\"(name)\"],fu.param=f[\"(params)\"],fu.line=f[\"(line)\"],fu.character=f[\"(character)\"],fu.last=f[\"(last)\"],fu.lastcharacter=f[\"(lastcharacter)\"],fu.metrics={complexity:f[\"(metrics)\"].ComplexityCount,parameters:(f[\"(params)\"]||[]).length,statements:f[\"(metrics)\"].statementCount},data.functions.push(fu)}unuseds.length>0&&(data.unused=unuseds),members=[];for(n in member)if(\"number\"==typeof member[n]){data.member=member;break}return data},itself.jshint=itself,itself}();\"object\"==typeof exports&&exports&&(exports.JSHINT=JSHINT)},{\"./lex.js\":4,\"./messages.js\":5,\"./reg.js\":6,\"./state.js\":7,\"./style.js\":8,\"./vars.js\":9,events:10,underscore:2}],4:[function(_dereq_,module,exports){\"use strict\";function asyncTrigger(){var _checks=[];return{push:function(fn){_checks.push(fn)},check:function(){for(var check=0;_checks.length>check;++check)_checks[check]();_checks.splice(0,_checks.length)}}}function Lexer(source){var lines=source;\"string\"==typeof lines&&(lines=lines.replace(/\\r\\n/g,\"\\n\").replace(/\\r/g,\"\\n\").split(\"\\n\")),lines[0]&&\"#!\"===lines[0].substr(0,2)&&(-1!==lines[0].indexOf(\"node\")&&(state.option.node=!0),lines[0]=\"\"),this.emitter=new events.EventEmitter,this.source=source,this.setLines(lines),this.prereg=!0,this.line=0,this.char=1,this.from=1,this.input=\"\",this.inComment=!1;for(var i=0;state.option.indent>i;i+=1)state.tab+=\" \"}var _=_dereq_(\"underscore\"),events=_dereq_(\"events\"),reg=_dereq_(\"./reg.js\"),state=_dereq_(\"./state.js\").state,unicodeData=_dereq_(\"../data/ascii-identifier-data.js\"),asciiIdentifierStartTable=unicodeData.asciiIdentifierStartTable,asciiIdentifierPartTable=unicodeData.asciiIdentifierPartTable,Token={Identifier:1,Punctuator:2,NumericLiteral:3,StringLiteral:4,Comment:5,Keyword:6,NullLiteral:7,BooleanLiteral:8,RegExp:9,TemplateLiteral:10};Lexer.prototype={_lines:[],getLines:function(){return this._lines=state.lines,this._lines},setLines:function(val){this._lines=val,state.lines=this._lines},peek:function(i){return this.input.charAt(i||0)},skip:function(i){i=i||1,this.char+=i,this.input=this.input.slice(i)},on:function(names,listener){names.split(\" \").forEach(function(name){this.emitter.on(name,listener)}.bind(this))},trigger:function(){this.emitter.emit.apply(this.emitter,Array.prototype.slice.call(arguments))},triggerAsync:function(type,args,checks,fn){checks.push(function(){fn()&&this.trigger(type,args)}.bind(this))},scanPunctuator:function(){var ch2,ch3,ch4,ch1=this.peek();switch(ch1){case\".\":if(/^[0-9]$/.test(this.peek(1)))return null;if(\".\"===this.peek(1)&&\".\"===this.peek(2))return{type:Token.Punctuator,value:\"...\"};case\"(\":case\")\":case\";\":case\",\":case\"{\":case\"}\":case\"[\":case\"]\":case\":\":case\"~\":case\"?\":return{type:Token.Punctuator,value:ch1};case\"#\":return{type:Token.Punctuator,value:ch1};case\"\":return null}return ch2=this.peek(1),ch3=this.peek(2),ch4=this.peek(3),\">\"===ch1&&\">\"===ch2&&\">\"===ch3&&\"=\"===ch4?{type:Token.Punctuator,value:\">>>=\"}:\"=\"===ch1&&\"=\"===ch2&&\"=\"===ch3?{type:Token.Punctuator,value:\"===\"}:\"!\"===ch1&&\"=\"===ch2&&\"=\"===ch3?{type:Token.Punctuator,value:\"!==\"}:\">\"===ch1&&\">\"===ch2&&\">\"===ch3?{type:Token.Punctuator,value:\">>>\"}:\"<\"===ch1&&\"<\"===ch2&&\"=\"===ch3?{type:Token.Punctuator,value:\"<<=\"}:\">\"===ch1&&\">\"===ch2&&\"=\"===ch3?{type:Token.Punctuator,value:\">>=\"}:\"=\"===ch1&&\">\"===ch2?{type:Token.Punctuator,value:ch1+ch2}:ch1===ch2&&\"+-<>&|\".indexOf(ch1)>=0?{type:Token.Punctuator,value:ch1+ch2}:\"<>=!+-*%&|^\".indexOf(ch1)>=0?\"=\"===ch2?{type:Token.Punctuator,value:ch1+ch2}:{type:Token.Punctuator,value:ch1}:\"/\"===ch1?\"=\"===ch2&&/\\/=(?!(\\S*\\/[gim]?))/.test(this.input)?{type:Token.Punctuator,value:\"/=\"}:{type:Token.Punctuator,value:\"/\"}:null},scanComments:function(){function commentToken(label,body,opt){var special=[\"jshint\",\"jslint\",\"members\",\"member\",\"globals\",\"global\",\"exported\"],isSpecial=!1,value=label+body,commentType=\"plain\";return opt=opt||{},opt.isMultiline&&(value+=\"*/\"),special.forEach(function(str){if(!isSpecial&&(\"//\"!==label||\"jshint\"===str)&&(body.substr(0,str.length)===str&&(isSpecial=!0,label+=str,body=body.substr(str.length)),isSpecial||\" \"!==body.charAt(0)||body.substr(1,str.length)!==str||(isSpecial=!0,label=label+\" \"+str,body=body.substr(str.length+1)),isSpecial))switch(str){case\"member\":commentType=\"members\";break;case\"global\":commentType=\"globals\";break;default:commentType=str}}),{type:Token.Comment,commentType:commentType,value:value,body:body,isSpecial:isSpecial,isMultiline:opt.isMultiline||!1,isMalformed:opt.isMalformed||!1}}var ch1=this.peek(),ch2=this.peek(1),rest=this.input.substr(2),startLine=this.line,startChar=this.char;if(\"*\"===ch1&&\"/\"===ch2)return this.trigger(\"error\",{code:\"E018\",line:startLine,character:startChar}),this.skip(2),null;if(\"/\"!==ch1||\"*\"!==ch2&&\"/\"!==ch2)return null;if(\"/\"===ch2)return this.skip(this.input.length),commentToken(\"//\",rest);var body=\"\";if(\"*\"===ch2){for(this.inComment=!0,this.skip(2);\"*\"!==this.peek()||\"/\"!==this.peek(1);)if(\"\"===this.peek()){if(body+=\"\\n\",!this.nextLine())return this.trigger(\"error\",{code:\"E017\",line:startLine,character:startChar}),this.inComment=!1,commentToken(\"/*\",body,{isMultiline:!0,isMalformed:!0})}else body+=this.peek(),this.skip();return this.skip(2),this.inComment=!1,commentToken(\"/*\",body,{isMultiline:!0})}},scanKeyword:function(){var result=/^[a-zA-Z_$][a-zA-Z0-9_$]*/.exec(this.input),keywords=[\"if\",\"in\",\"do\",\"var\",\"for\",\"new\",\"try\",\"let\",\"this\",\"else\",\"case\",\"void\",\"with\",\"enum\",\"while\",\"break\",\"catch\",\"throw\",\"const\",\"yield\",\"class\",\"super\",\"return\",\"typeof\",\"delete\",\"switch\",\"export\",\"import\",\"default\",\"finally\",\"extends\",\"function\",\"continue\",\"debugger\",\"instanceof\"];return result&&keywords.indexOf(result[0])>=0?{type:Token.Keyword,value:result[0]}:null},scanIdentifier:function(){function isNonAsciiIdentifierStart(code){return code>256}function isNonAsciiIdentifierPart(code){return code>256}function isHexDigit(str){return/^[0-9a-fA-F]$/.test(str)}var type,char,id=\"\",index=0,readUnicodeEscapeSequence=function(){if(index+=1,\"u\"!==this.peek(index))return null;var code,ch1=this.peek(index+1),ch2=this.peek(index+2),ch3=this.peek(index+3),ch4=this.peek(index+4);return isHexDigit(ch1)&&isHexDigit(ch2)&&isHexDigit(ch3)&&isHexDigit(ch4)?(code=parseInt(ch1+ch2+ch3+ch4,16),asciiIdentifierPartTable[code]||isNonAsciiIdentifierPart(code)?(index+=5,\"\\\\u\"+ch1+ch2+ch3+ch4):null):null\n}.bind(this),getIdentifierStart=function(){var chr=this.peek(index),code=chr.charCodeAt(0);return 92===code?readUnicodeEscapeSequence():128>code?asciiIdentifierStartTable[code]?(index+=1,chr):null:isNonAsciiIdentifierStart(code)?(index+=1,chr):null}.bind(this),getIdentifierPart=function(){var chr=this.peek(index),code=chr.charCodeAt(0);return 92===code?readUnicodeEscapeSequence():128>code?asciiIdentifierPartTable[code]?(index+=1,chr):null:isNonAsciiIdentifierPart(code)?(index+=1,chr):null}.bind(this);if(char=getIdentifierStart(),null===char)return null;for(id=char;char=getIdentifierPart(),null!==char;)id+=char;switch(id){case\"true\":case\"false\":type=Token.BooleanLiteral;break;case\"null\":type=Token.NullLiteral;break;default:type=Token.Identifier}return{type:type,value:id}},scanNumericLiteral:function(){function isDecimalDigit(str){return/^[0-9]$/.test(str)}function isOctalDigit(str){return/^[0-7]$/.test(str)}function isHexDigit(str){return/^[0-9a-fA-F]$/.test(str)}function isIdentifierStart(ch){return\"$\"===ch||\"_\"===ch||\"\\\\\"===ch||ch>=\"a\"&&\"z\">=ch||ch>=\"A\"&&\"Z\">=ch}var bad,index=0,value=\"\",length=this.input.length,char=this.peek(index);if(\".\"!==char&&!isDecimalDigit(char))return null;if(\".\"!==char){if(value=this.peek(index),index+=1,char=this.peek(index),\"0\"===value){if(\"x\"===char||\"X\"===char){for(index+=1,value+=char;length>index&&(char=this.peek(index),isHexDigit(char));)value+=char,index+=1;return 2>=value.length?{type:Token.NumericLiteral,value:value,isMalformed:!0}:length>index&&(char=this.peek(index),isIdentifierStart(char))?null:{type:Token.NumericLiteral,value:value,base:16,isMalformed:!1}}if(isOctalDigit(char)){for(index+=1,value+=char,bad=!1;length>index;){if(char=this.peek(index),isDecimalDigit(char))bad=!0;else if(!isOctalDigit(char))break;value+=char,index+=1}return length>index&&(char=this.peek(index),isIdentifierStart(char))?null:{type:Token.NumericLiteral,value:value,base:8,isMalformed:!1}}isDecimalDigit(char)&&(index+=1,value+=char)}for(;length>index&&(char=this.peek(index),isDecimalDigit(char));)value+=char,index+=1}if(\".\"===char)for(value+=char,index+=1;length>index&&(char=this.peek(index),isDecimalDigit(char));)value+=char,index+=1;if(\"e\"===char||\"E\"===char){if(value+=char,index+=1,char=this.peek(index),(\"+\"===char||\"-\"===char)&&(value+=this.peek(index),index+=1),char=this.peek(index),!isDecimalDigit(char))return null;for(value+=char,index+=1;length>index&&(char=this.peek(index),isDecimalDigit(char));)value+=char,index+=1}return length>index&&(char=this.peek(index),isIdentifierStart(char))?null:{type:Token.NumericLiteral,value:value,base:10,isMalformed:!isFinite(value)}},scanTemplateLiteral:function(){if(!state.option.esnext||\"`\"!==this.peek())return null;var startLine=this.line,startChar=this.char,jump=1,value=\"\";for(this.skip();\"`\"!==this.peek();){for(;\"\"===this.peek();){if(!this.nextLine())return this.trigger(\"error\",{code:\"E052\",line:startLine,character:startChar}),{type:Token.TemplateLiteral,value:value,isUnclosed:!0};value+=\"\\n\"}var char=this.peek();this.skip(jump),value+=char}return this.skip(),{type:Token.TemplateLiteral,value:value,isUnclosed:!1}},scanStringLiteral:function(checks){var quote=this.peek();if('\"'!==quote&&\"'\"!==quote)return null;this.triggerAsync(\"warning\",{code:\"W108\",line:this.line,character:this.char},checks,function(){return state.jsonMode&&'\"'!==quote});var value=\"\",startLine=this.line,startChar=this.char,allowNewLine=!1;this.skip();outer:for(;this.peek()!==quote;){for(;\"\"===this.peek();){if(allowNewLine?(allowNewLine=!1,this.triggerAsync(\"warning\",{code:\"W043\",line:this.line,character:this.char},checks,function(){return!state.option.multistr}),this.triggerAsync(\"warning\",{code:\"W042\",line:this.line,character:this.char},checks,function(){return state.jsonMode&&state.option.multistr})):this.trigger(\"warning\",{code:\"W112\",line:this.line,character:this.char}),!this.nextLine())return this.trigger(\"error\",{code:\"E029\",line:startLine,character:startChar}),{type:Token.StringLiteral,value:value,isUnclosed:!0,quote:quote};if(this.peek()==quote)break outer}allowNewLine=!1;var char=this.peek(),jump=1;if(\" \">char&&this.trigger(\"warning\",{code:\"W113\",line:this.line,character:this.char,data:[\"<non-printable>\"]}),\"\\\\\"===char)switch(this.skip(),char=this.peek()){case\"'\":this.triggerAsync(\"warning\",{code:\"W114\",line:this.line,character:this.char,data:[\"\\\\'\"]},checks,function(){return state.jsonMode});break;case\"b\":char=\"\\\\b\";break;case\"f\":char=\"\\\\f\";break;case\"n\":char=\"\\\\n\";break;case\"r\":char=\"\\\\r\";break;case\"t\":char=\"\\\\t\";break;case\"0\":char=\"\\\\0\";var n=parseInt(this.peek(1),10);this.triggerAsync(\"warning\",{code:\"W115\",line:this.line,character:this.char},checks,function(){return n>=0&&7>=n&&state.directive[\"use strict\"]});break;case\"u\":char=String.fromCharCode(parseInt(this.input.substr(1,4),16)),jump=5;break;case\"v\":this.triggerAsync(\"warning\",{code:\"W114\",line:this.line,character:this.char,data:[\"\\\\v\"]},checks,function(){return state.jsonMode}),char=\"\u000b\";break;case\"x\":var x=parseInt(this.input.substr(1,2),16);this.triggerAsync(\"warning\",{code:\"W114\",line:this.line,character:this.char,data:[\"\\\\x-\"]},checks,function(){return state.jsonMode}),char=String.fromCharCode(x),jump=3;break;case\"\\\\\":char=\"\\\\\\\\\";break;case'\"':char='\\\\\"';break;case\"/\":break;case\"\":allowNewLine=!0,char=\"\";break;case\"!\":if(\"<\"===value.slice(value.length-2))break;default:this.trigger(\"warning\",{code:\"W044\",line:this.line,character:this.char})}value+=char,this.skip(jump)}return this.skip(),{type:Token.StringLiteral,value:value,isUnclosed:!1,quote:quote}},scanRegExp:function(){var terminated,index=0,length=this.input.length,char=this.peek(),value=char,body=\"\",flags=[],malformed=!1,isCharSet=!1,scanUnexpectedChars=function(){\" \">char&&(malformed=!0,this.trigger(\"warning\",{code:\"W048\",line:this.line,character:this.char})),\"<\"===char&&(malformed=!0,this.trigger(\"warning\",{code:\"W049\",line:this.line,character:this.char,data:[char]}))}.bind(this);if(!this.prereg||\"/\"!==char)return null;for(index+=1,terminated=!1;length>index;)if(char=this.peek(index),value+=char,body+=char,isCharSet)\"]\"===char&&(\"\\\\\"!==this.peek(index-1)||\"\\\\\"===this.peek(index-2))&&(isCharSet=!1),\"\\\\\"===char&&(index+=1,char=this.peek(index),body+=char,value+=char,scanUnexpectedChars()),index+=1;else{if(\"\\\\\"===char){if(index+=1,char=this.peek(index),body+=char,value+=char,scanUnexpectedChars(),\"/\"===char){index+=1;continue}if(\"[\"===char){index+=1;continue}}if(\"[\"!==char){if(\"/\"===char){body=body.substr(0,body.length-1),terminated=!0,index+=1;break}index+=1}else isCharSet=!0,index+=1}if(!terminated)return this.trigger(\"error\",{code:\"E015\",line:this.line,character:this.from}),void this.trigger(\"fatal\",{line:this.line,from:this.from});for(;length>index&&(char=this.peek(index),/[gim]/.test(char));)flags.push(char),value+=char,index+=1;try{RegExp(body,flags.join(\"\"))}catch(err){malformed=!0,this.trigger(\"error\",{code:\"E016\",line:this.line,character:this.char,data:[err.message]})}return{type:Token.RegExp,value:value,flags:flags,isMalformed:malformed}},scanNonBreakingSpaces:function(){return state.option.nonbsp?this.input.search(/(\\u00A0)/):-1},scanUnsafeChars:function(){return this.input.search(reg.unsafeChars)},next:function(checks){this.from=this.char;var start;if(/\\s/.test(this.peek()))for(start=this.char;/\\s/.test(this.peek());)this.from+=1,this.skip();var match=this.scanComments()||this.scanStringLiteral(checks)||this.scanTemplateLiteral();return match?match:(match=this.scanRegExp()||this.scanPunctuator()||this.scanKeyword()||this.scanIdentifier()||this.scanNumericLiteral(),match?(this.skip(match.value.length),match):null)},nextLine:function(){var char;if(this.line>=this.getLines().length)return!1;this.input=this.getLines()[this.line],this.line+=1,this.char=1,this.from=1;var inputTrimmed=this.input.trim(),startsWith=function(){return _.some(arguments,function(prefix){return 0===inputTrimmed.indexOf(prefix)})},endsWith=function(){return _.some(arguments,function(suffix){return-1!==inputTrimmed.indexOf(suffix,inputTrimmed.length-suffix.length)})};if(state.ignoreLinterErrors===!0&&(startsWith(\"/*\",\"//\")||endsWith(\"*/\")||(this.input=\"\")),char=this.scanNonBreakingSpaces(),char>=0&&this.trigger(\"warning\",{code:\"W125\",line:this.line,character:char+1}),this.input=this.input.replace(/\\t/g,state.tab),char=this.scanUnsafeChars(),char>=0&&this.trigger(\"warning\",{code:\"W100\",line:this.line,character:char}),state.option.maxlen&&state.option.maxlen<this.input.length){var inComment=this.inComment||startsWith.call(inputTrimmed,\"//\")||startsWith.call(inputTrimmed,\"/*\"),shouldTriggerError=!inComment||!reg.maxlenException.test(inputTrimmed);shouldTriggerError&&this.trigger(\"warning\",{code:\"W101\",line:this.line,character:this.input.length})}return!0},start:function(){this.nextLine()},token:function(){function isReserved(token,isProperty){if(!token.reserved)return!1;var meta=token.meta;if(meta&&meta.isFutureReservedWord&&state.option.inES5()){if(!meta.es5)return!1;if(meta.strictOnly&&!state.option.strict&&!state.directive[\"use strict\"])return!1;if(isProperty)return!1}return!0}for(var token,checks=asyncTrigger(),create=function(type,value,isProperty){var obj;if(\"(endline)\"!==type&&\"(end)\"!==type&&(this.prereg=!1),\"(punctuator)\"===type){switch(value){case\".\":case\")\":case\"~\":case\"#\":case\"]\":this.prereg=!1;break;default:this.prereg=!0}obj=Object.create(state.syntax[value]||state.syntax[\"(error)\"])}return\"(identifier)\"===type&&((\"return\"===value||\"case\"===value||\"typeof\"===value)&&(this.prereg=!0),_.has(state.syntax,value)&&(obj=Object.create(state.syntax[value]||state.syntax[\"(error)\"]),isReserved(obj,isProperty&&\"(identifier)\"===type)||(obj=null))),obj||(obj=Object.create(state.syntax[type])),obj.identifier=\"(identifier)\"===type,obj.type=obj.type||type,obj.value=value,obj.line=this.line,obj.character=this.char,obj.from=this.from,isProperty&&obj.identifier&&(obj.isProperty=isProperty),obj.check=checks.check,obj}.bind(this);;){if(!this.input.length)return create(this.nextLine()?\"(endline)\":\"(end)\",\"\");if(token=this.next(checks))switch(token.type){case Token.StringLiteral:return this.triggerAsync(\"String\",{line:this.line,\"char\":this.char,from:this.from,value:token.value,quote:token.quote},checks,function(){return!0}),create(\"(string)\",token.value);case Token.TemplateLiteral:return this.trigger(\"Template\",{line:this.line,\"char\":this.char,from:this.from,value:token.value}),create(\"(template)\",token.value);case Token.Identifier:this.trigger(\"Identifier\",{line:this.line,\"char\":this.char,from:this.form,name:token.value,isProperty:\".\"===state.tokens.curr.id});case Token.Keyword:case Token.NullLiteral:case Token.BooleanLiteral:return create(\"(identifier)\",token.value,\".\"===state.tokens.curr.id);case Token.NumericLiteral:return token.isMalformed&&this.trigger(\"warning\",{code:\"W045\",line:this.line,character:this.char,data:[token.value]}),this.triggerAsync(\"warning\",{code:\"W114\",line:this.line,character:this.char,data:[\"0x-\"]},checks,function(){return 16===token.base&&state.jsonMode}),this.triggerAsync(\"warning\",{code:\"W115\",line:this.line,character:this.char},checks,function(){return state.directive[\"use strict\"]&&8===token.base}),this.trigger(\"Number\",{line:this.line,\"char\":this.char,from:this.from,value:token.value,base:token.base,isMalformed:token.malformed}),create(\"(number)\",token.value);case Token.RegExp:return create(\"(regexp)\",token.value);case Token.Comment:if(state.tokens.curr.comment=!0,token.isSpecial)return{id:\"(comment)\",value:token.value,body:token.body,type:token.commentType,isSpecial:token.isSpecial,line:this.line,character:this.char,from:this.from};break;case\"\":break;default:return create(\"(punctuator)\",token.value)}else this.input.length&&(this.trigger(\"error\",{code:\"E024\",line:this.line,character:this.char,data:[this.peek()]}),this.input=\"\")}}},exports.Lexer=Lexer},{\"../data/ascii-identifier-data.js\":1,\"./reg.js\":6,\"./state.js\":7,events:10,underscore:2}],5:[function(_dereq_,module,exports){\"use strict\";var _=_dereq_(\"underscore\"),errors={E001:\"Bad option: '{a}'.\",E002:\"Bad option value.\",E003:\"Expected a JSON value.\",E004:\"Input is neither a string nor an array of strings.\",E005:\"Input is empty.\",E006:\"Unexpected early end of program.\",E007:'Missing \"use strict\" statement.',E008:\"Strict violation.\",E009:\"Option 'validthis' can't be used in a global scope.\",E010:\"'with' is not allowed in strict mode.\",E011:\"const '{a}' has already been declared.\",E012:\"const '{a}' is initialized to 'undefined'.\",E013:\"Attempting to override '{a}' which is a constant.\",E014:\"A regular expression literal can be confused with '/='.\",E015:\"Unclosed regular expression.\",E016:\"Invalid regular expression.\",E017:\"Unclosed comment.\",E018:\"Unbegun comment.\",E019:\"Unmatched '{a}'.\",E020:\"Expected '{a}' to match '{b}' from line {c} and instead saw '{d}'.\",E021:\"Expected '{a}' and instead saw '{b}'.\",E022:\"Line breaking error '{a}'.\",E023:\"Missing '{a}'.\",E024:\"Unexpected '{a}'.\",E025:\"Missing ':' on a case clause.\",E026:\"Missing '}' to match '{' from line {a}.\",E027:\"Missing ']' to match '[' from line {a}.\",E028:\"Illegal comma.\",E029:\"Unclosed string.\",E030:\"Expected an identifier and instead saw '{a}'.\",E031:\"Bad assignment.\",E032:\"Expected a small integer or 'false' and instead saw '{a}'.\",E033:\"Expected an operator and instead saw '{a}'.\",E034:\"get/set are ES5 features.\",E035:\"Missing property name.\",E036:\"Expected to see a statement and instead saw a block.\",E037:null,E038:null,E039:\"Function declarations are not invocable. Wrap the whole function invocation in parens.\",E040:\"Each value should have its own case label.\",E041:\"Unrecoverable syntax error.\",E042:\"Stopping.\",E043:\"Too many errors.\",E044:null,E045:\"Invalid for each loop.\",E046:\"A yield statement shall be within a generator function (with syntax: `function*`)\",E047:null,E048:\"Let declaration not directly within block.\",E049:\"A {a} cannot be named '{b}'.\",E050:\"Mozilla acequires the yield expression to be parenthesized here.\",E051:\"Regular parameters cannot come after default parameters.\",E052:\"Unclosed template literal.\"},warnings={W001:\"'hasOwnProperty' is a really bad name.\",W002:\"Value of '{a}' may be overwritten in IE 8 and earlier.\",W003:\"'{a}' was used before it was defined.\",W004:\"'{a}' is already defined.\",W005:\"A dot following a number can be confused with a decimal point.\",W006:\"Confusing minuses.\",W007:\"Confusing plusses.\",W008:\"A leading decimal point can be confused with a dot: '{a}'.\",W009:\"The array literal notation [] is preferable.\",W010:\"The object literal notation {} is preferable.\",W011:null,W012:null,W013:null,W014:\"Bad line breaking before '{a}'.\",W015:null,W016:\"Unexpected use of '{a}'.\",W017:\"Bad operand.\",W018:\"Confusing use of '{a}'.\",W019:\"Use the isNaN function to compare with NaN.\",W020:\"Read only.\",W021:\"'{a}' is a function.\",W022:\"Do not assign to the exception parameter.\",W023:\"Expected an identifier in an assignment and instead saw a function invocation.\",W024:\"Expected an identifier and instead saw '{a}' (a reserved word).\",W025:\"Missing name in function declaration.\",W026:\"Inner functions should be listed at the top of the outer function.\",W027:\"Unreachable '{a}' after '{b}'.\",W028:\"Label '{a}' on {b} statement.\",W030:\"Expected an assignment or function call and instead saw an expression.\",W031:\"Do not use 'new' for side effects.\",W032:\"Unnecessary semicolon.\",W033:\"Missing semicolon.\",W034:'Unnecessary directive \"{a}\".',W035:\"Empty block.\",W036:\"Unexpected /*member '{a}'.\",W037:\"'{a}' is a statement label.\",W038:\"'{a}' used out of scope.\",W039:\"'{a}' is not allowed.\",W040:\"Possible strict violation.\",W041:\"Use '{a}' to compare with '{b}'.\",W042:\"Avoid EOL escaping.\",W043:\"Bad escaping of EOL. Use option multistr if needed.\",W044:\"Bad or unnecessary escaping.\",W045:\"Bad number '{a}'.\",W046:\"Don't use extra leading zeros '{a}'.\",W047:\"A trailing decimal point can be confused with a dot: '{a}'.\",W048:\"Unexpected control character in regular expression.\",W049:\"Unexpected escaped character '{a}' in regular expression.\",W050:\"JavaScript URL.\",W051:\"Variables should not be deleted.\",W052:\"Unexpected '{a}'.\",W053:\"Do not use {a} as a constructor.\",W054:\"The Function constructor is a form of eval.\",W055:\"A constructor name should start with an uppercase letter.\",W056:\"Bad constructor.\",W057:\"Weird construction. Is 'new' necessary?\",W058:\"Missing '()' invoking a constructor.\",W059:\"Avoid arguments.{a}.\",W060:\"document.write can be a form of eval.\",W061:\"eval can be harmful.\",W062:\"Wrap an immediate function invocation in parens to assist the reader in understanding that the expression is the result of a function, and not the function itself.\",W063:\"Math is not a function.\",W064:\"Missing 'new' prefix when invoking a constructor.\",W065:\"Missing radix parameter.\",W066:\"Implied eval. Consider passing a function instead of a string.\",W067:\"Bad invocation.\",W068:\"Wrapping non-IIFE function literals in parens is unnecessary.\",W069:\"['{a}'] is better written in dot notation.\",W070:\"Extra comma. (it breaks older versions of IE)\",W071:\"This function has too many statements. ({a})\",W072:\"This function has too many parameters. ({a})\",W073:\"Blocks are nested too deeply. ({a})\",W074:\"This function's cyclomatic complexity is too high. ({a})\",W075:\"Duplicate key '{a}'.\",W076:\"Unexpected parameter '{a}' in get {b} function.\",W077:\"Expected a single parameter in set {a} function.\",W078:\"Setter is defined without getter.\",W079:\"Redefinition of '{a}'.\",W080:\"It's not necessary to initialize '{a}' to 'undefined'.\",W081:null,W082:\"Function declarations should not be placed in blocks. Use a function expression or move the statement to the top of the outer function.\",W083:\"Don't make functions within a loop.\",W084:\"Assignment in conditional expression\",W085:\"Don't use 'with'.\",W086:\"Expected a 'break' statement before '{a}'.\",W087:\"Forgotten 'debugger' statement?\",W088:\"Creating global 'for' variable. Should be 'for (var {a} ...'.\",W089:\"The body of a for in should be wrapped in an if statement to filter unwanted properties from the prototype.\",W090:\"'{a}' is not a statement label.\",W091:\"'{a}' is out of scope.\",W093:\"Did you mean to return a conditional instead of an assignment?\",W094:\"Unexpected comma.\",W095:\"Expected a string and instead saw {a}.\",W096:\"The '{a}' key may produce unexpected results.\",W097:'Use the function form of \"use strict\".',W098:\"'{a}' is defined but never used.\",W099:null,W100:\"This character may get silently deleted by one or more browsers.\",W101:\"Line is too long.\",W102:null,W103:\"The '{a}' property is deprecated.\",W104:\"'{a}' is available in ES6 (use esnext option) or Mozilla JS extensions (use moz).\",W105:\"Unexpected {a} in '{b}'.\",W106:\"Identifier '{a}' is not in camel case.\",W107:\"Script URL.\",W108:\"Strings must use doublequote.\",W109:\"Strings must use singlequote.\",W110:\"Mixed double and single quotes.\",W112:\"Unclosed string.\",W113:\"Control character in string: {a}.\",W114:\"Avoid {a}.\",W115:\"Octal literals are not allowed in strict mode.\",W116:\"Expected '{a}' and instead saw '{b}'.\",W117:\"'{a}' is not defined.\",W118:\"'{a}' is only available in Mozilla JavaScript extensions (use moz option).\",W119:\"'{a}' is only available in ES6 (use esnext option).\",W120:\"You might be leaking a variable ({a}) here.\",W121:\"Extending prototype of native object: '{a}'.\",W122:\"Invalid typeof value '{a}'\",W123:\"'{a}' is already defined in outer scope.\",W124:\"A generator function shall contain a yield statement.\",W125:\"This line contains non-breaking spaces: http://jshint.com/doc/options/#nonbsp\"},info={I001:\"Comma warnings can be turned off with 'laxcomma'.\",I002:null,I003:\"ES5 option is now set per default\"};exports.errors={},exports.warnings={},exports.info={},_.each(errors,function(desc,code){exports.errors[code]={code:code,desc:desc}}),_.each(warnings,function(desc,code){exports.warnings[code]={code:code,desc:desc}}),_.each(info,function(desc,code){exports.info[code]={code:code,desc:desc}})},{underscore:2}],6:[function(_dereq_,module,exports){\"use string\";exports.unsafeString=/@cc|<\\/?|script|\\]\\s*\\]|<\\s*!|&lt/i,exports.unsafeChars=/[\\u0000-\\u001f\\u007f-\\u009f\\u00ad\\u0600-\\u0604\\u070f\\u17b4\\u17b5\\u200c-\\u200f\\u2028-\\u202f\\u2060-\\u206f\\ufeff\\ufff0-\\uffff]/,exports.needEsc=/[\\u0000-\\u001f&<\"\\/\\\\\\u007f-\\u009f\\u00ad\\u0600-\\u0604\\u070f\\u17b4\\u17b5\\u200c-\\u200f\\u2028-\\u202f\\u2060-\\u206f\\ufeff\\ufff0-\\uffff]/,exports.needEscGlobal=/[\\u0000-\\u001f&<\"\\/\\\\\\u007f-\\u009f\\u00ad\\u0600-\\u0604\\u070f\\u17b4\\u17b5\\u200c-\\u200f\\u2028-\\u202f\\u2060-\\u206f\\ufeff\\ufff0-\\uffff]/g,exports.starSlash=/\\*\\//,exports.identifier=/^([a-zA-Z_$][a-zA-Z0-9_$]*)$/,exports.javascriptURL=/^(?:javascript|jscript|ecmascript|vbscript|livescript)\\s*:/i,exports.fallsThrough=/^\\s*\\/\\*\\s*falls?\\sthrough\\s*\\*\\/\\s*$/,exports.maxlenException=/^(?:(?:\\/\\/|\\/\\*|\\*) ?)?[^ ]+$/},{}],7:[function(_dereq_,module,exports){\"use strict\";var state={syntax:{},reset:function(){this.tokens={prev:null,next:null,curr:null},this.option={},this.ignored={},this.directive={},this.jsonMode=!1,this.jsonWarnings=[],this.lines=[],this.tab=\"\",this.cache={},this.ignoredLines={},this.ignoreLinterErrors=!1}};exports.state=state},{}],8:[function(_dereq_,module,exports){\"use strict\";exports.register=function(linter){linter.on(\"Identifier\",function(data){linter.getOption(\"proto\")||\"__proto__\"===data.name&&linter.warn(\"W103\",{line:data.line,\"char\":data.char,data:[data.name]})}),linter.on(\"Identifier\",function(data){linter.getOption(\"iterator\")||\"__iterator__\"===data.name&&linter.warn(\"W104\",{line:data.line,\"char\":data.char,data:[data.name]})}),linter.on(\"Identifier\",function(data){linter.getOption(\"camelcase\")&&data.name.replace(/^_+|_+$/g,\"\").indexOf(\"_\")>-1&&!data.name.match(/^[A-Z0-9_]*$/)&&linter.warn(\"W106\",{line:data.line,\"char\":data.from,data:[data.name]})}),linter.on(\"String\",function(data){var code,quotmark=linter.getOption(\"quotmark\");quotmark&&(\"single\"===quotmark&&\"'\"!==data.quote&&(code=\"W109\"),\"double\"===quotmark&&'\"'!==data.quote&&(code=\"W108\"),quotmark===!0&&(linter.getCache(\"quotmark\")||linter.setCache(\"quotmark\",data.quote),linter.getCache(\"quotmark\")!==data.quote&&(code=\"W110\")),code&&linter.warn(code,{line:data.line,\"char\":data.char}))}),linter.on(\"Number\",function(data){\".\"===data.value.charAt(0)&&linter.warn(\"W008\",{line:data.line,\"char\":data.char,data:[data.value]}),\".\"===data.value.substr(data.value.length-1)&&linter.warn(\"W047\",{line:data.line,\"char\":data.char,data:[data.value]}),/^00+/.test(data.value)&&linter.warn(\"W046\",{line:data.line,\"char\":data.char,data:[data.value]})}),linter.on(\"String\",function(data){var re=/^(?:javascript|jscript|ecmascript|vbscript|livescript)\\s*:/i;linter.getOption(\"scripturl\")||re.test(data.value)&&linter.warn(\"W107\",{line:data.line,\"char\":data.char})})}},{}],9:[function(_dereq_,module,exports){\"use strict\";exports.reservedVars={arguments:!1,NaN:!1},exports.ecmaIdentifiers={Array:!1,Boolean:!1,Date:!1,decodeURI:!1,decodeURIComponent:!1,encodeURI:!1,encodeURIComponent:!1,Error:!1,eval:!1,EvalError:!1,Function:!1,hasOwnProperty:!1,isFinite:!1,isNaN:!1,JSON:!1,Math:!1,Number:!1,Object:!1,parseInt:!1,parseFloat:!1,RangeError:!1,ReferenceError:!1,RegExp:!1,String:!1,SyntaxError:!1,TypeError:!1,URIError:!1},exports.newEcmaIdentifiers={Set:!1,Map:!1,WeakMap:!1,WeakSet:!1,Proxy:!1,Promise:!1},exports.browser={Audio:!1,Blob:!1,addEventListener:!1,applicationCache:!1,atob:!1,blur:!1,btoa:!1,CanvasGradient:!1,CanvasPattern:!1,CanvasRenderingContext2D:!1,clearInterval:!1,clearTimeout:!1,close:!1,closed:!1,CustomEvent:!1,DOMParser:!1,defaultStatus:!1,document:!1,Element:!1,ElementTimeControl:!1,event:!1,FileReader:!1,FormData:!1,focus:!1,frames:!1,getComputedStyle:!1,HTMLElement:!1,HTMLAnchorElement:!1,HTMLBaseElement:!1,HTMLBlockquoteElement:!1,HTMLBodyElement:!1,HTMLBRElement:!1,HTMLButtonElement:!1,HTMLCanvasElement:!1,HTMLDirectoryElement:!1,HTMLDivElement:!1,HTMLDListElement:!1,HTMLFieldSetElement:!1,HTMLFontElement:!1,HTMLFormElement:!1,HTMLFrameElement:!1,HTMLFrameSetElement:!1,HTMLHeadElement:!1,HTMLHeadingElement:!1,HTMLHRElement:!1,HTMLHtmlElement:!1,HTMLIFrameElement:!1,HTMLImageElement:!1,HTMLInputElement:!1,HTMLIsIndexElement:!1,HTMLLabelElement:!1,HTMLLayerElement:!1,HTMLLegendElement:!1,HTMLLIElement:!1,HTMLLinkElement:!1,HTMLMapElement:!1,HTMLMenuElement:!1,HTMLMetaElement:!1,HTMLModElement:!1,HTMLObjectElement:!1,HTMLOListElement:!1,HTMLOptGroupElement:!1,HTMLOptionElement:!1,HTMLParagraphElement:!1,HTMLParamElement:!1,HTMLPreElement:!1,HTMLQuoteElement:!1,HTMLScriptElement:!1,HTMLSelectElement:!1,HTMLStyleElement:!1,HTMLTableCaptionElement:!1,HTMLTableCellElement:!1,HTMLTableColElement:!1,HTMLTableElement:!1,HTMLTableRowElement:!1,HTMLTableSectionElement:!1,HTMLTextAreaElement:!1,HTMLTitleElement:!1,HTMLUListElement:!1,HTMLVideoElement:!1,history:!1,Image:!1,length:!1,localStorage:!1,location:!1,matchMedia:!1,MessageChannel:!1,MessageEvent:!1,MessagePort:!1,MouseEvent:!1,moveBy:!1,moveTo:!1,MutationObserver:!1,name:!1,Node:!1,NodeFilter:!1,NodeList:!1,navigator:!1,onbeforeunload:!0,onblur:!0,onerror:!0,onfocus:!0,onload:!0,onresize:!0,onunload:!0,open:!1,openDatabase:!1,opener:!1,Option:!1,parent:!1,print:!1,removeEventListener:!1,resizeBy:!1,resizeTo:!1,screen:!1,scroll:!1,scrollBy:!1,scrollTo:!1,sessionStorage:!1,setInterval:!1,setTimeout:!1,SharedWorker:!1,status:!1,SVGAElement:!1,SVGAltGlyphDefElement:!1,SVGAltGlyphElement:!1,SVGAltGlyphItemElement:!1,SVGAngle:!1,SVGAnimateColorElement:!1,SVGAnimateElement:!1,SVGAnimateMotionElement:!1,SVGAnimateTransformElement:!1,SVGAnimatedAngle:!1,SVGAnimatedBoolean:!1,SVGAnimatedEnumeration:!1,SVGAnimatedInteger:!1,SVGAnimatedLength:!1,SVGAnimatedLengthList:!1,SVGAnimatedNumber:!1,SVGAnimatedNumberList:!1,SVGAnimatedPathData:!1,SVGAnimatedPoints:!1,SVGAnimatedPreserveAspectRatio:!1,SVGAnimatedRect:!1,SVGAnimatedString:!1,SVGAnimatedTransformList:!1,SVGAnimationElement:!1,SVGCSSRule:!1,SVGCircleElement:!1,SVGClipPathElement:!1,SVGColor:!1,SVGColorProfileElement:!1,SVGColorProfileRule:!1,SVGComponentTransferFunctionElement:!1,SVGCursorElement:!1,SVGDefsElement:!1,SVGDescElement:!1,SVGDocument:!1,SVGElement:!1,SVGElementInstance:!1,SVGElementInstanceList:!1,SVGEllipseElement:!1,SVGExternalResourcesRequired:!1,SVGFEBlendElement:!1,SVGFEColorMatrixElement:!1,SVGFEComponentTransferElement:!1,SVGFECompositeElement:!1,SVGFEConvolveMatrixElement:!1,SVGFEDiffuseLightingElement:!1,SVGFEDisplacementMapElement:!1,SVGFEDistantLightElement:!1,SVGFEFloodElement:!1,SVGFEFuncAElement:!1,SVGFEFuncBElement:!1,SVGFEFuncGElement:!1,SVGFEFuncRElement:!1,SVGFEGaussianBlurElement:!1,SVGFEImageElement:!1,SVGFEMergeElement:!1,SVGFEMergeNodeElement:!1,SVGFEMorphologyElement:!1,SVGFEOffsetElement:!1,SVGFEPointLightElement:!1,SVGFESpecularLightingElement:!1,SVGFESpotLightElement:!1,SVGFETileElement:!1,SVGFETurbulenceElement:!1,SVGFilterElement:!1,SVGFilterPrimitiveStandardAttributes:!1,SVGFitToViewBox:!1,SVGFontElement:!1,SVGFontFaceElement:!1,SVGFontFaceFormatElement:!1,SVGFontFaceNameElement:!1,SVGFontFaceSrcElement:!1,SVGFontFaceUriElement:!1,SVGForeignObjectElement:!1,SVGGElement:!1,SVGGlyphElement:!1,SVGGlyphRefElement:!1,SVGGradientElement:!1,SVGHKernElement:!1,SVGICCColor:!1,SVGImageElement:!1,SVGLangSpace:!1,SVGLength:!1,SVGLengthList:!1,SVGLineElement:!1,SVGLinearGradientElement:!1,SVGLocatable:!1,SVGMPathElement:!1,SVGMarkerElement:!1,SVGMaskElement:!1,SVGMatrix:!1,SVGMetadataElement:!1,SVGMissingGlyphElement:!1,SVGNumber:!1,SVGNumberList:!1,SVGPaint:!1,SVGPathElement:!1,SVGPathSeg:!1,SVGPathSegArcAbs:!1,SVGPathSegArcRel:!1,SVGPathSegClosePath:!1,SVGPathSegCurvetoCubicAbs:!1,SVGPathSegCurvetoCubicRel:!1,SVGPathSegCurvetoCubicSmoothAbs:!1,SVGPathSegCurvetoCubicSmoothRel:!1,SVGPathSegCurvetoQuadraticAbs:!1,SVGPathSegCurvetoQuadraticRel:!1,SVGPathSegCurvetoQuadraticSmoothAbs:!1,SVGPathSegCurvetoQuadraticSmoothRel:!1,SVGPathSegLinetoAbs:!1,SVGPathSegLinetoHorizontalAbs:!1,SVGPathSegLinetoHorizontalRel:!1,SVGPathSegLinetoRel:!1,SVGPathSegLinetoVerticalAbs:!1,SVGPathSegLinetoVerticalRel:!1,SVGPathSegList:!1,SVGPathSegMovetoAbs:!1,SVGPathSegMovetoRel:!1,SVGPatternElement:!1,SVGPoint:!1,SVGPointList:!1,SVGPolygonElement:!1,SVGPolylineElement:!1,SVGPreserveAspectRatio:!1,SVGRadialGradientElement:!1,SVGRect:!1,SVGRectElement:!1,SVGRenderingIntent:!1,SVGSVGElement:!1,SVGScriptElement:!1,SVGSetElement:!1,SVGStopElement:!1,SVGStringList:!1,SVGStylable:!1,SVGStyleElement:!1,SVGSwitchElement:!1,SVGSymbolElement:!1,SVGTRefElement:!1,SVGTSpanElement:!1,SVGTests:!1,SVGTextContentElement:!1,SVGTextElement:!1,SVGTextPathElement:!1,SVGTextPositioningElement:!1,SVGTitleElement:!1,SVGTransform:!1,SVGTransformList:!1,SVGTransformable:!1,SVGURIReference:!1,SVGUnitTypes:!1,SVGUseElement:!1,SVGVKernElement:!1,SVGViewElement:!1,SVGViewSpec:!1,SVGZoomAndPan:!1,TimeEvent:!1,top:!1,URL:!1,WebSocket:!1,window:!1,Worker:!1,XMLHttpRequest:!1,XMLSerializer:!1,XPathEvaluator:!1,XPathException:!1,XPathExpression:!1,XPathNamespace:!1,XPathNSResolver:!1,XPathResult:!1},exports.devel={alert:!1,confirm:!1,console:!1,Debug:!1,opera:!1,prompt:!1},exports.worker={importScripts:!0,postMessage:!0,self:!0},exports.nonstandard={escape:!1,unescape:!1},exports.couch={require:!1,respond:!1,getRow:!1,emit:!1,send:!1,start:!1,sum:!1,log:!1,exports:!1,module:!1,provides:!1},exports.node={__filename:!1,__dirname:!1,GLOBAL:!1,global:!1,module:!1,acequire:!1,Buffer:!0,console:!0,exports:!0,process:!0,setTimeout:!0,clearTimeout:!0,setInterval:!0,clearInterval:!0,setImmediate:!0,clearImmediate:!0},exports.phantom={phantom:!0,acequire:!0,WebPage:!0,console:!0,exports:!0},exports.qunit={asyncTest:!1,deepEqual:!1,equal:!1,expect:!1,module:!1,notDeepEqual:!1,notEqual:!1,notPropEqual:!1,notStrictEqual:!1,ok:!1,propEqual:!1,QUnit:!1,raises:!1,start:!1,stop:!1,strictEqual:!1,test:!1,\"throws\":!1},exports.rhino={defineClass:!1,deserialize:!1,gc:!1,help:!1,importClass:!1,importPackage:!1,java:!1,load:!1,loadClass:!1,Packages:!1,print:!1,quit:!1,readFile:!1,readUrl:!1,runCommand:!1,seal:!1,serialize:!1,spawn:!1,sync:!1,toint32:!1,version:!1},exports.shelljs={target:!1,echo:!1,exit:!1,cd:!1,pwd:!1,ls:!1,find:!1,cp:!1,rm:!1,mv:!1,mkdir:!1,test:!1,cat:!1,sed:!1,grep:!1,which:!1,dirs:!1,pushd:!1,popd:!1,env:!1,exec:!1,chmod:!1,config:!1,error:!1,tempdir:!1},exports.typed={ArrayBuffer:!1,ArrayBufferView:!1,DataView:!1,Float32Array:!1,Float64Array:!1,Int16Array:!1,Int32Array:!1,Int8Array:!1,Uint16Array:!1,Uint32Array:!1,Uint8Array:!1,Uint8ClampedArray:!1},exports.wsh={ActiveXObject:!0,Enumerator:!0,GetObject:!0,ScriptEngine:!0,ScriptEngineBuildVersion:!0,ScriptEngineMajorVersion:!0,ScriptEngineMinorVersion:!0,VBArray:!0,WSH:!0,WScript:!0,XDomainRequest:!0},exports.dojo={dojo:!1,dijit:!1,dojox:!1,define:!1,require:!1},exports.jquery={$:!1,jQuery:!1},exports.mootools={$:!1,$$:!1,Asset:!1,Browser:!1,Chain:!1,Class:!1,Color:!1,Cookie:!1,Core:!1,Document:!1,DomReady:!1,DOMEvent:!1,DOMReady:!1,Drag:!1,Element:!1,Elements:!1,Event:!1,Events:!1,Fx:!1,Group:!1,Hash:!1,HtmlTable:!1,IFrame:!1,IframeShim:!1,InputValidator:!1,instanceOf:!1,Keyboard:!1,Locale:!1,Mask:!1,MooTools:!1,Native:!1,Options:!1,OverText:!1,Request:!1,Scroller:!1,Slick:!1,Slider:!1,Sortables:!1,Spinner:!1,Swiff:!1,Tips:!1,Type:!1,typeOf:!1,URI:!1,Window:!1},exports.prototypejs={$:!1,$$:!1,$A:!1,$F:!1,$H:!1,$R:!1,$break:!1,$continue:!1,$w:!1,Abstract:!1,Ajax:!1,Class:!1,Enumerable:!1,Element:!1,Event:!1,Field:!1,Form:!1,Hash:!1,Insertion:!1,ObjectRange:!1,PeriodicalExecuter:!1,Position:!1,Prototype:!1,Selector:!1,Template:!1,Toggle:!1,Try:!1,Autocompleter:!1,Builder:!1,Control:!1,Draggable:!1,Draggables:!1,Droppables:!1,Effect:!1,Sortable:!1,SortableObserver:!1,Sound:!1,Scriptaculous:!1},exports.yui={YUI:!1,Y:!1,YUI_config:!1},exports.mocha={describe:!1,it:!1,before:!1,after:!1,beforeEach:!1,afterEach:!1,suite:!1,test:!1,setup:!1,teardown:!1},exports.jasmine={jasmine:!1,describe:!1,it:!1,xit:!1,beforeEach:!1,afterEach:!1,setFixtures:!1,loadFixtures:!1,spyOn:!1,expect:!1,runs:!1,waitsFor:!1,waits:!1}},{}],10:[function(_dereq_,module){function EventEmitter(){this._events=this._events||{},this._maxListeners=this._maxListeners||void 0\n}function isFunction(arg){return\"function\"==typeof arg}function isNumber(arg){return\"number\"==typeof arg}function isObject(arg){return\"object\"==typeof arg&&null!==arg}function isUndefined(arg){return void 0===arg}module.exports=EventEmitter,EventEmitter.EventEmitter=EventEmitter,EventEmitter.prototype._events=void 0,EventEmitter.prototype._maxListeners=void 0,EventEmitter.defaultMaxListeners=10,EventEmitter.prototype.setMaxListeners=function(n){if(!isNumber(n)||0>n||isNaN(n))throw TypeError(\"n must be a positive number\");return this._maxListeners=n,this},EventEmitter.prototype.emit=function(type){var er,handler,len,args,i,listeners;if(this._events||(this._events={}),\"error\"===type&&(!this._events.error||isObject(this._events.error)&&!this._events.error.length))throw er=arguments[1],er instanceof Error?er:TypeError('Uncaught, unspecified \"error\" event.');if(handler=this._events[type],isUndefined(handler))return!1;if(isFunction(handler))switch(arguments.length){case 1:handler.call(this);break;case 2:handler.call(this,arguments[1]);break;case 3:handler.call(this,arguments[1],arguments[2]);break;default:for(len=arguments.length,args=Array(len-1),i=1;len>i;i++)args[i-1]=arguments[i];handler.apply(this,args)}else if(isObject(handler)){for(len=arguments.length,args=Array(len-1),i=1;len>i;i++)args[i-1]=arguments[i];for(listeners=handler.slice(),len=listeners.length,i=0;len>i;i++)listeners[i].apply(this,args)}return!0},EventEmitter.prototype.addListener=function(type,listener){var m;if(!isFunction(listener))throw TypeError(\"listener must be a function\");if(this._events||(this._events={}),this._events.newListener&&this.emit(\"newListener\",type,isFunction(listener.listener)?listener.listener:listener),this._events[type]?isObject(this._events[type])?this._events[type].push(listener):this._events[type]=[this._events[type],listener]:this._events[type]=listener,isObject(this._events[type])&&!this._events[type].warned){var m;m=isUndefined(this._maxListeners)?EventEmitter.defaultMaxListeners:this._maxListeners,m&&m>0&&this._events[type].length>m&&(this._events[type].warned=!0,console.error(\"(node) warning: possible EventEmitter memory leak detected. %d listeners added. Use emitter.setMaxListeners() to increase limit.\",this._events[type].length),console.trace())}return this},EventEmitter.prototype.on=EventEmitter.prototype.addListener,EventEmitter.prototype.once=function(type,listener){function g(){this.removeListener(type,g),fired||(fired=!0,listener.apply(this,arguments))}if(!isFunction(listener))throw TypeError(\"listener must be a function\");var fired=!1;return g.listener=listener,this.on(type,g),this},EventEmitter.prototype.removeListener=function(type,listener){var list,position,length,i;if(!isFunction(listener))throw TypeError(\"listener must be a function\");if(!this._events||!this._events[type])return this;if(list=this._events[type],length=list.length,position=-1,list===listener||isFunction(list.listener)&&list.listener===listener)delete this._events[type],this._events.removeListener&&this.emit(\"removeListener\",type,listener);else if(isObject(list)){for(i=length;i-->0;)if(list[i]===listener||list[i].listener&&list[i].listener===listener){position=i;break}if(0>position)return this;1===list.length?(list.length=0,delete this._events[type]):list.splice(position,1),this._events.removeListener&&this.emit(\"removeListener\",type,listener)}return this},EventEmitter.prototype.removeAllListeners=function(type){var key,listeners;if(!this._events)return this;if(!this._events.removeListener)return 0===arguments.length?this._events={}:this._events[type]&&delete this._events[type],this;if(0===arguments.length){for(key in this._events)\"removeListener\"!==key&&this.removeAllListeners(key);return this.removeAllListeners(\"removeListener\"),this._events={},this}if(listeners=this._events[type],isFunction(listeners))this.removeListener(type,listeners);else for(;listeners.length;)this.removeListener(type,listeners[listeners.length-1]);return delete this._events[type],this},EventEmitter.prototype.listeners=function(type){var ret;return ret=this._events&&this._events[type]?isFunction(this._events[type])?[this._events[type]]:this._events[type].slice():[]},EventEmitter.listenerCount=function(emitter,type){var ret;return ret=emitter._events&&emitter._events[type]?isFunction(emitter._events[type])?1:emitter._events[type].length:0}},{}]},{},[3])(3)}),ace.define(\"ace/mode/javascript_worker\",[\"require\",\"exports\",\"module\",\"ace/lib/oop\",\"ace/worker/mirror\",\"ace/mode/javascript/jshint\"],function(acequire,exports,module){\"use strict\";function startRegex(arr){return RegExp(\"^(\"+arr.join(\"|\")+\")\")}var oop=acequire(\"../lib/oop\"),Mirror=acequire(\"../worker/mirror\").Mirror,lint=acequire(\"./javascript/jshint\").JSHINT,disabledWarningsRe=startRegex([\"Bad for in variable '(.+)'.\",'Missing \"use strict\"']),errorsRe=startRegex([\"Unexpected\",\"Expected \",\"Confusing (plus|minus)\",\"\\\\{a\\\\} unterminated regular expression\",\"Unclosed \",\"Unmatched \",\"Unbegun comment\",\"Bad invocation\",\"Missing space after\",\"Missing operator at\"]),infoRe=startRegex([\"Expected an assignment\",\"Bad escapement of EOL\",\"Unexpected comma\",\"Unexpected space\",\"Missing radix parameter.\",\"A leading decimal point can\",\"\\\\['{a}'\\\\] is better written in dot notation.\",\"'{a}' used out of scope\"]),JavaScriptWorker=exports.JavaScriptWorker=function(sender){Mirror.call(this,sender),this.setTimeout(500),this.setOptions()};oop.inherits(JavaScriptWorker,Mirror),function(){this.setOptions=function(options){this.options=options||{esnext:!0,moz:!0,devel:!0,browser:!0,node:!0,laxcomma:!0,laxbreak:!0,lastsemic:!0,onevar:!1,passfail:!1,maxerr:100,expr:!0,multistr:!0,globalstrict:!0},this.doc.getValue()&&this.deferredUpdate.schedule(100)},this.changeOptions=function(newOptions){oop.mixin(this.options,newOptions),this.doc.getValue()&&this.deferredUpdate.schedule(100)},this.isValidJS=function(str){try{eval(\"throw 0;\"+str)}catch(e){if(0===e)return!0}return!1},this.onUpdate=function(){var value=this.doc.getValue();if(value=value.replace(/^#!.*\\n/,\"\\n\"),!value)return this.sender.emit(\"jslint\",[]),void 0;var errors=[],maxErrorLevel=this.isValidJS(value)?\"warning\":\"error\";lint(value,this.options);for(var results=lint.errors,errorAdded=!1,i=0;results.length>i;i++){var error=results[i];if(error){var raw=error.raw,type=\"warning\";if(\"Missing semicolon.\"==raw){var str=error.evidence.substr(error.character);str=str.charAt(str.search(/\\S/)),\"error\"==maxErrorLevel&&str&&/[\\w\\d{(['\"]/.test(str)?(error.reason='Missing \";\" before statement',type=\"error\"):type=\"info\"}else{if(disabledWarningsRe.test(raw))continue;infoRe.test(raw)?type=\"info\":errorsRe.test(raw)?(errorAdded=!0,type=maxErrorLevel):\"'{a}' is not defined.\"==raw?type=\"warning\":\"'{a}' is defined but never used.\"==raw&&(type=\"info\")}errors.push({row:error.line-1,column:error.character-1,text:error.reason,type:type,raw:raw})}}this.sender.emit(\"jslint\",errors)}}.call(JavaScriptWorker.prototype)}),ace.define(\"ace/lib/es5-shim\",[\"require\",\"exports\",\"module\"],function(){function Empty(){}function doesDefinePropertyWork(object){try{return Object.defineProperty(object,\"sentinel\",{}),\"sentinel\"in object}catch(exception){}}function toInteger(n){return n=+n,n!==n?n=0:0!==n&&n!==1/0&&n!==-(1/0)&&(n=(n>0||-1)*Math.floor(Math.abs(n))),n}Function.prototype.bind||(Function.prototype.bind=function(that){var target=this;if(\"function\"!=typeof target)throw new TypeError(\"Function.prototype.bind called on incompatible \"+target);var args=slice.call(arguments,1),bound=function(){if(this instanceof bound){var result=target.apply(this,args.concat(slice.call(arguments)));return Object(result)===result?result:this}return target.apply(that,args.concat(slice.call(arguments)))};return target.prototype&&(Empty.prototype=target.prototype,bound.prototype=new Empty,Empty.prototype=null),bound});var defineGetter,defineSetter,lookupGetter,lookupSetter,supportsAccessors,call=Function.prototype.call,prototypeOfArray=Array.prototype,prototypeOfObject=Object.prototype,slice=prototypeOfArray.slice,_toString=call.bind(prototypeOfObject.toString),owns=call.bind(prototypeOfObject.hasOwnProperty);if((supportsAccessors=owns(prototypeOfObject,\"__defineGetter__\"))&&(defineGetter=call.bind(prototypeOfObject.__defineGetter__),defineSetter=call.bind(prototypeOfObject.__defineSetter__),lookupGetter=call.bind(prototypeOfObject.__lookupGetter__),lookupSetter=call.bind(prototypeOfObject.__lookupSetter__)),2!=[1,2].splice(0).length)if(function(){function makeArray(l){var a=Array(l+2);return a[0]=a[1]=0,a}var lengthBefore,array=[];return array.splice.apply(array,makeArray(20)),array.splice.apply(array,makeArray(26)),lengthBefore=array.length,array.splice(5,0,\"XXX\"),lengthBefore+1==array.length,lengthBefore+1==array.length?!0:void 0}()){var array_splice=Array.prototype.splice;Array.prototype.splice=function(start,deleteCount){return arguments.length?array_splice.apply(this,[void 0===start?0:start,void 0===deleteCount?this.length-start:deleteCount].concat(slice.call(arguments,2))):[]}}else Array.prototype.splice=function(pos,removeCount){var length=this.length;pos>0?pos>length&&(pos=length):void 0==pos?pos=0:0>pos&&(pos=Math.max(length+pos,0)),length>pos+removeCount||(removeCount=length-pos);var removed=this.slice(pos,pos+removeCount),insert=slice.call(arguments,2),add=insert.length;if(pos===length)add&&this.push.apply(this,insert);else{var remove=Math.min(removeCount,length-pos),tailOldPos=pos+remove,tailNewPos=tailOldPos+add-remove,tailCount=length-tailOldPos,lengthAfterRemove=length-remove;if(tailOldPos>tailNewPos)for(var i=0;tailCount>i;++i)this[tailNewPos+i]=this[tailOldPos+i];else if(tailNewPos>tailOldPos)for(i=tailCount;i--;)this[tailNewPos+i]=this[tailOldPos+i];if(add&&pos===lengthAfterRemove)this.length=lengthAfterRemove,this.push.apply(this,insert);else for(this.length=lengthAfterRemove+add,i=0;add>i;++i)this[pos+i]=insert[i]}return removed};Array.isArray||(Array.isArray=function(obj){return\"[object Array]\"==_toString(obj)});var boxedString=Object(\"a\"),splitString=\"a\"!=boxedString[0]||!(0 in boxedString);if(Array.prototype.forEach||(Array.prototype.forEach=function(fun){var object=toObject(this),self=splitString&&\"[object String]\"==_toString(this)?this.split(\"\"):object,thisp=arguments[1],i=-1,length=self.length>>>0;if(\"[object Function]\"!=_toString(fun))throw new TypeError;for(;length>++i;)i in self&&fun.call(thisp,self[i],i,object)}),Array.prototype.map||(Array.prototype.map=function(fun){var object=toObject(this),self=splitString&&\"[object String]\"==_toString(this)?this.split(\"\"):object,length=self.length>>>0,result=Array(length),thisp=arguments[1];if(\"[object Function]\"!=_toString(fun))throw new TypeError(fun+\" is not a function\");for(var i=0;length>i;i++)i in self&&(result[i]=fun.call(thisp,self[i],i,object));return result}),Array.prototype.filter||(Array.prototype.filter=function(fun){var value,object=toObject(this),self=splitString&&\"[object String]\"==_toString(this)?this.split(\"\"):object,length=self.length>>>0,result=[],thisp=arguments[1];if(\"[object Function]\"!=_toString(fun))throw new TypeError(fun+\" is not a function\");for(var i=0;length>i;i++)i in self&&(value=self[i],fun.call(thisp,value,i,object)&&result.push(value));return result}),Array.prototype.every||(Array.prototype.every=function(fun){var object=toObject(this),self=splitString&&\"[object String]\"==_toString(this)?this.split(\"\"):object,length=self.length>>>0,thisp=arguments[1];if(\"[object Function]\"!=_toString(fun))throw new TypeError(fun+\" is not a function\");for(var i=0;length>i;i++)if(i in self&&!fun.call(thisp,self[i],i,object))return!1;return!0}),Array.prototype.some||(Array.prototype.some=function(fun){var object=toObject(this),self=splitString&&\"[object String]\"==_toString(this)?this.split(\"\"):object,length=self.length>>>0,thisp=arguments[1];if(\"[object Function]\"!=_toString(fun))throw new TypeError(fun+\" is not a function\");for(var i=0;length>i;i++)if(i in self&&fun.call(thisp,self[i],i,object))return!0;return!1}),Array.prototype.reduce||(Array.prototype.reduce=function(fun){var object=toObject(this),self=splitString&&\"[object String]\"==_toString(this)?this.split(\"\"):object,length=self.length>>>0;if(\"[object Function]\"!=_toString(fun))throw new TypeError(fun+\" is not a function\");if(!length&&1==arguments.length)throw new TypeError(\"reduce of empty array with no initial value\");var result,i=0;if(arguments.length>=2)result=arguments[1];else for(;;){if(i in self){result=self[i++];break}if(++i>=length)throw new TypeError(\"reduce of empty array with no initial value\")}for(;length>i;i++)i in self&&(result=fun.call(void 0,result,self[i],i,object));return result}),Array.prototype.reduceRight||(Array.prototype.reduceRight=function(fun){var object=toObject(this),self=splitString&&\"[object String]\"==_toString(this)?this.split(\"\"):object,length=self.length>>>0;if(\"[object Function]\"!=_toString(fun))throw new TypeError(fun+\" is not a function\");if(!length&&1==arguments.length)throw new TypeError(\"reduceRight of empty array with no initial value\");var result,i=length-1;if(arguments.length>=2)result=arguments[1];else for(;;){if(i in self){result=self[i--];break}if(0>--i)throw new TypeError(\"reduceRight of empty array with no initial value\")}do i in this&&(result=fun.call(void 0,result,self[i],i,object));while(i--);return result}),Array.prototype.indexOf&&-1==[0,1].indexOf(1,2)||(Array.prototype.indexOf=function(sought){var self=splitString&&\"[object String]\"==_toString(this)?this.split(\"\"):toObject(this),length=self.length>>>0;if(!length)return-1;var i=0;for(arguments.length>1&&(i=toInteger(arguments[1])),i=i>=0?i:Math.max(0,length+i);length>i;i++)if(i in self&&self[i]===sought)return i;return-1}),Array.prototype.lastIndexOf&&-1==[0,1].lastIndexOf(0,-3)||(Array.prototype.lastIndexOf=function(sought){var self=splitString&&\"[object String]\"==_toString(this)?this.split(\"\"):toObject(this),length=self.length>>>0;if(!length)return-1;var i=length-1;for(arguments.length>1&&(i=Math.min(i,toInteger(arguments[1]))),i=i>=0?i:length-Math.abs(i);i>=0;i--)if(i in self&&sought===self[i])return i;return-1}),Object.getPrototypeOf||(Object.getPrototypeOf=function(object){return object.__proto__||(object.constructor?object.constructor.prototype:prototypeOfObject)}),!Object.getOwnPropertyDescriptor){var ERR_NON_OBJECT=\"Object.getOwnPropertyDescriptor called on a non-object: \";Object.getOwnPropertyDescriptor=function(object,property){if(\"object\"!=typeof object&&\"function\"!=typeof object||null===object)throw new TypeError(ERR_NON_OBJECT+object);if(owns(object,property)){var descriptor,getter,setter;if(descriptor={enumerable:!0,configurable:!0},supportsAccessors){var prototype=object.__proto__;object.__proto__=prototypeOfObject;var getter=lookupGetter(object,property),setter=lookupSetter(object,property);if(object.__proto__=prototype,getter||setter)return getter&&(descriptor.get=getter),setter&&(descriptor.set=setter),descriptor}return descriptor.value=object[property],descriptor}}}if(Object.getOwnPropertyNames||(Object.getOwnPropertyNames=function(object){return Object.keys(object)}),!Object.create){var createEmpty;createEmpty=null===Object.prototype.__proto__?function(){return{__proto__:null}}:function(){var empty={};for(var i in empty)empty[i]=null;return empty.constructor=empty.hasOwnProperty=empty.propertyIsEnumerable=empty.isPrototypeOf=empty.toLocaleString=empty.toString=empty.valueOf=empty.__proto__=null,empty},Object.create=function(prototype,properties){var object;if(null===prototype)object=createEmpty();else{if(\"object\"!=typeof prototype)throw new TypeError(\"typeof prototype[\"+typeof prototype+\"] != 'object'\");var Type=function(){};Type.prototype=prototype,object=new Type,object.__proto__=prototype}return void 0!==properties&&Object.defineProperties(object,properties),object}}if(Object.defineProperty){var definePropertyWorksOnObject=doesDefinePropertyWork({}),definePropertyWorksOnDom=\"undefined\"==typeof document||doesDefinePropertyWork(document.createElement(\"div\"));if(!definePropertyWorksOnObject||!definePropertyWorksOnDom)var definePropertyFallback=Object.defineProperty}if(!Object.defineProperty||definePropertyFallback){var ERR_NON_OBJECT_DESCRIPTOR=\"Property description must be an object: \",ERR_NON_OBJECT_TARGET=\"Object.defineProperty called on non-object: \",ERR_ACCESSORS_NOT_SUPPORTED=\"getters & setters can not be defined on this javascript engine\";Object.defineProperty=function(object,property,descriptor){if(\"object\"!=typeof object&&\"function\"!=typeof object||null===object)throw new TypeError(ERR_NON_OBJECT_TARGET+object);if(\"object\"!=typeof descriptor&&\"function\"!=typeof descriptor||null===descriptor)throw new TypeError(ERR_NON_OBJECT_DESCRIPTOR+descriptor);if(definePropertyFallback)try{return definePropertyFallback.call(Object,object,property,descriptor)}catch(exception){}if(owns(descriptor,\"value\"))if(supportsAccessors&&(lookupGetter(object,property)||lookupSetter(object,property))){var prototype=object.__proto__;object.__proto__=prototypeOfObject,delete object[property],object[property]=descriptor.value,object.__proto__=prototype}else object[property]=descriptor.value;else{if(!supportsAccessors)throw new TypeError(ERR_ACCESSORS_NOT_SUPPORTED);owns(descriptor,\"get\")&&defineGetter(object,property,descriptor.get),owns(descriptor,\"set\")&&defineSetter(object,property,descriptor.set)}return object}}Object.defineProperties||(Object.defineProperties=function(object,properties){for(var property in properties)owns(properties,property)&&Object.defineProperty(object,property,properties[property]);return object}),Object.seal||(Object.seal=function(object){return object}),Object.freeze||(Object.freeze=function(object){return object});try{Object.freeze(function(){})}catch(exception){Object.freeze=function(freezeObject){return function(object){return\"function\"==typeof object?object:freezeObject(object)}}(Object.freeze)}if(Object.preventExtensions||(Object.preventExtensions=function(object){return object}),Object.isSealed||(Object.isSealed=function(){return!1}),Object.isFrozen||(Object.isFrozen=function(){return!1}),Object.isExtensible||(Object.isExtensible=function(object){if(Object(object)===object)throw new TypeError;for(var name=\"\";owns(object,name);)name+=\"?\";object[name]=!0;var returnValue=owns(object,name);return delete object[name],returnValue}),!Object.keys){var hasDontEnumBug=!0,dontEnums=[\"toString\",\"toLocaleString\",\"valueOf\",\"hasOwnProperty\",\"isPrototypeOf\",\"propertyIsEnumerable\",\"constructor\"],dontEnumsLength=dontEnums.length;for(var key in{toString:null})hasDontEnumBug=!1;Object.keys=function(object){if(\"object\"!=typeof object&&\"function\"!=typeof object||null===object)throw new TypeError(\"Object.keys called on a non-object\");var keys=[];for(var name in object)owns(object,name)&&keys.push(name);if(hasDontEnumBug)for(var i=0,ii=dontEnumsLength;ii>i;i++){var dontEnum=dontEnums[i];owns(object,dontEnum)&&keys.push(dontEnum)}return keys}}Date.now||(Date.now=function(){return(new Date).getTime()});var ws=\"\t\\n\u000b\\f\\r \\u2028\\u2029\";if(!String.prototype.trim||ws.trim()){ws=\"[\"+ws+\"]\";var trimBeginRegexp=RegExp(\"^\"+ws+ws+\"*\"),trimEndRegexp=RegExp(ws+ws+\"*$\");String.prototype.trim=function(){return(this+\"\").replace(trimBeginRegexp,\"\").replace(trimEndRegexp,\"\")}}var toObject=function(o){if(null==o)throw new TypeError(\"can't convert \"+o+\" to object\");return Object(o)}});";
  })(require("github:jspm/nodelibs-buffer@0.1.0").Buffer, require("github:jspm/nodelibs-process@0.1.1"));
  global.define = __define;
  return module.exports;
});



System.register("npm:react@0.12.2/lib/ReactDefaultInjection", ["npm:react@0.12.2/lib/BeforeInputEventPlugin", "npm:react@0.12.2/lib/ChangeEventPlugin", "npm:react@0.12.2/lib/ClientReactRootIndex", "npm:react@0.12.2/lib/CompositionEventPlugin", "npm:react@0.12.2/lib/DefaultEventPluginOrder", "npm:react@0.12.2/lib/EnterLeaveEventPlugin", "npm:react@0.12.2/lib/ExecutionEnvironment", "npm:react@0.12.2/lib/HTMLDOMPropertyConfig", "npm:react@0.12.2/lib/MobileSafariClickEventPlugin", "npm:react@0.12.2/lib/ReactBrowserComponentMixin", "npm:react@0.12.2/lib/ReactComponentBrowserEnvironment", "npm:react@0.12.2/lib/ReactDefaultBatchingStrategy", "npm:react@0.12.2/lib/ReactDOMComponent", "npm:react@0.12.2/lib/ReactDOMButton", "npm:react@0.12.2/lib/ReactDOMForm", "npm:react@0.12.2/lib/ReactDOMImg", "npm:react@0.12.2/lib/ReactDOMInput", "npm:react@0.12.2/lib/ReactDOMOption", "npm:react@0.12.2/lib/ReactDOMSelect", "npm:react@0.12.2/lib/ReactDOMTextarea", "npm:react@0.12.2/lib/ReactEventListener", "npm:react@0.12.2/lib/ReactInjection", "npm:react@0.12.2/lib/ReactInstanceHandles", "npm:react@0.12.2/lib/ReactMount", "npm:react@0.12.2/lib/SelectEventPlugin", "npm:react@0.12.2/lib/ServerReactRootIndex", "npm:react@0.12.2/lib/SimpleEventPlugin", "npm:react@0.12.2/lib/SVGDOMPropertyConfig", "npm:react@0.12.2/lib/createFullPageComponent", "npm:react@0.12.2/lib/ReactDefaultPerf", "github:jspm/nodelibs-process@0.1.1"], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  (function(process) {
    "use strict";
    var BeforeInputEventPlugin = require("npm:react@0.12.2/lib/BeforeInputEventPlugin");
    var ChangeEventPlugin = require("npm:react@0.12.2/lib/ChangeEventPlugin");
    var ClientReactRootIndex = require("npm:react@0.12.2/lib/ClientReactRootIndex");
    var CompositionEventPlugin = require("npm:react@0.12.2/lib/CompositionEventPlugin");
    var DefaultEventPluginOrder = require("npm:react@0.12.2/lib/DefaultEventPluginOrder");
    var EnterLeaveEventPlugin = require("npm:react@0.12.2/lib/EnterLeaveEventPlugin");
    var ExecutionEnvironment = require("npm:react@0.12.2/lib/ExecutionEnvironment");
    var HTMLDOMPropertyConfig = require("npm:react@0.12.2/lib/HTMLDOMPropertyConfig");
    var MobileSafariClickEventPlugin = require("npm:react@0.12.2/lib/MobileSafariClickEventPlugin");
    var ReactBrowserComponentMixin = require("npm:react@0.12.2/lib/ReactBrowserComponentMixin");
    var ReactComponentBrowserEnvironment = require("npm:react@0.12.2/lib/ReactComponentBrowserEnvironment");
    var ReactDefaultBatchingStrategy = require("npm:react@0.12.2/lib/ReactDefaultBatchingStrategy");
    var ReactDOMComponent = require("npm:react@0.12.2/lib/ReactDOMComponent");
    var ReactDOMButton = require("npm:react@0.12.2/lib/ReactDOMButton");
    var ReactDOMForm = require("npm:react@0.12.2/lib/ReactDOMForm");
    var ReactDOMImg = require("npm:react@0.12.2/lib/ReactDOMImg");
    var ReactDOMInput = require("npm:react@0.12.2/lib/ReactDOMInput");
    var ReactDOMOption = require("npm:react@0.12.2/lib/ReactDOMOption");
    var ReactDOMSelect = require("npm:react@0.12.2/lib/ReactDOMSelect");
    var ReactDOMTextarea = require("npm:react@0.12.2/lib/ReactDOMTextarea");
    var ReactEventListener = require("npm:react@0.12.2/lib/ReactEventListener");
    var ReactInjection = require("npm:react@0.12.2/lib/ReactInjection");
    var ReactInstanceHandles = require("npm:react@0.12.2/lib/ReactInstanceHandles");
    var ReactMount = require("npm:react@0.12.2/lib/ReactMount");
    var SelectEventPlugin = require("npm:react@0.12.2/lib/SelectEventPlugin");
    var ServerReactRootIndex = require("npm:react@0.12.2/lib/ServerReactRootIndex");
    var SimpleEventPlugin = require("npm:react@0.12.2/lib/SimpleEventPlugin");
    var SVGDOMPropertyConfig = require("npm:react@0.12.2/lib/SVGDOMPropertyConfig");
    var createFullPageComponent = require("npm:react@0.12.2/lib/createFullPageComponent");
    function inject() {
      ReactInjection.EventEmitter.injectReactEventListener(ReactEventListener);
      ReactInjection.EventPluginHub.injectEventPluginOrder(DefaultEventPluginOrder);
      ReactInjection.EventPluginHub.injectInstanceHandle(ReactInstanceHandles);
      ReactInjection.EventPluginHub.injectMount(ReactMount);
      ReactInjection.EventPluginHub.injectEventPluginsByName({
        SimpleEventPlugin: SimpleEventPlugin,
        EnterLeaveEventPlugin: EnterLeaveEventPlugin,
        ChangeEventPlugin: ChangeEventPlugin,
        CompositionEventPlugin: CompositionEventPlugin,
        MobileSafariClickEventPlugin: MobileSafariClickEventPlugin,
        SelectEventPlugin: SelectEventPlugin,
        BeforeInputEventPlugin: BeforeInputEventPlugin
      });
      ReactInjection.NativeComponent.injectGenericComponentClass(ReactDOMComponent);
      ReactInjection.NativeComponent.injectComponentClasses({
        'button': ReactDOMButton,
        'form': ReactDOMForm,
        'img': ReactDOMImg,
        'input': ReactDOMInput,
        'option': ReactDOMOption,
        'select': ReactDOMSelect,
        'textarea': ReactDOMTextarea,
        'html': createFullPageComponent('html'),
        'head': createFullPageComponent('head'),
        'body': createFullPageComponent('body')
      });
      ReactInjection.CompositeComponent.injectMixin(ReactBrowserComponentMixin);
      ReactInjection.DOMProperty.injectDOMPropertyConfig(HTMLDOMPropertyConfig);
      ReactInjection.DOMProperty.injectDOMPropertyConfig(SVGDOMPropertyConfig);
      ReactInjection.EmptyComponent.injectEmptyComponent('noscript');
      ReactInjection.Updates.injectReconcileTransaction(ReactComponentBrowserEnvironment.ReactReconcileTransaction);
      ReactInjection.Updates.injectBatchingStrategy(ReactDefaultBatchingStrategy);
      ReactInjection.RootIndex.injectCreateReactRootIndex(ExecutionEnvironment.canUseDOM ? ClientReactRootIndex.createReactRootIndex : ServerReactRootIndex.createReactRootIndex);
      ReactInjection.Component.injectEnvironment(ReactComponentBrowserEnvironment);
      if ("production" !== process.env.NODE_ENV) {
        var url = (ExecutionEnvironment.canUseDOM && window.location.href) || '';
        if ((/[?&]react_perf\b/).test(url)) {
          var ReactDefaultPerf = require("npm:react@0.12.2/lib/ReactDefaultPerf");
          ReactDefaultPerf.start();
        }
      }
    }
    module.exports = {inject: inject};
  })(require("github:jspm/nodelibs-process@0.1.1"));
  global.define = __define;
  return module.exports;
});



System.register("npm:event-emitter@0.3.3/index", ["npm:d@0.1.1", "npm:es5-ext@0.10.6/object/valid-callable"], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  'use strict';
  var d = require("npm:d@0.1.1"),
      callable = require("npm:es5-ext@0.10.6/object/valid-callable"),
      apply = Function.prototype.apply,
      call = Function.prototype.call,
      create = Object.create,
      defineProperty = Object.defineProperty,
      defineProperties = Object.defineProperties,
      hasOwnProperty = Object.prototype.hasOwnProperty,
      descriptor = {
        configurable: true,
        enumerable: false,
        writable: true
      },
      on,
      once,
      off,
      emit,
      methods,
      descriptors,
      base;
  on = function(type, listener) {
    var data;
    callable(listener);
    if (!hasOwnProperty.call(this, '__ee__')) {
      data = descriptor.value = create(null);
      defineProperty(this, '__ee__', descriptor);
      descriptor.value = null;
    } else {
      data = this.__ee__;
    }
    if (!data[type])
      data[type] = listener;
    else if (typeof data[type] === 'object')
      data[type].push(listener);
    else
      data[type] = [data[type], listener];
    return this;
  };
  once = function(type, listener) {
    var once,
        self;
    callable(listener);
    self = this;
    on.call(this, type, once = function() {
      off.call(self, type, once);
      apply.call(listener, this, arguments);
    });
    once.__eeOnceListener__ = listener;
    return this;
  };
  off = function(type, listener) {
    var data,
        listeners,
        candidate,
        i;
    callable(listener);
    if (!hasOwnProperty.call(this, '__ee__'))
      return this;
    data = this.__ee__;
    if (!data[type])
      return this;
    listeners = data[type];
    if (typeof listeners === 'object') {
      for (i = 0; (candidate = listeners[i]); ++i) {
        if ((candidate === listener) || (candidate.__eeOnceListener__ === listener)) {
          if (listeners.length === 2)
            data[type] = listeners[i ? 0 : 1];
          else
            listeners.splice(i, 1);
        }
      }
    } else {
      if ((listeners === listener) || (listeners.__eeOnceListener__ === listener)) {
        delete data[type];
      }
    }
    return this;
  };
  emit = function(type) {
    var i,
        l,
        listener,
        listeners,
        args;
    if (!hasOwnProperty.call(this, '__ee__'))
      return ;
    listeners = this.__ee__[type];
    if (!listeners)
      return ;
    if (typeof listeners === 'object') {
      l = arguments.length;
      args = new Array(l - 1);
      for (i = 1; i < l; ++i)
        args[i - 1] = arguments[i];
      listeners = listeners.slice();
      for (i = 0; (listener = listeners[i]); ++i) {
        apply.call(listener, this, args);
      }
    } else {
      switch (arguments.length) {
        case 1:
          call.call(listeners, this);
          break;
        case 2:
          call.call(listeners, this, arguments[1]);
          break;
        case 3:
          call.call(listeners, this, arguments[1], arguments[2]);
          break;
        default:
          l = arguments.length;
          args = new Array(l - 1);
          for (i = 1; i < l; ++i) {
            args[i - 1] = arguments[i];
          }
          apply.call(listeners, this, args);
      }
    }
  };
  methods = {
    on: on,
    once: once,
    off: off,
    emit: emit
  };
  descriptors = {
    on: d(on),
    once: d(once),
    off: d(off),
    emit: d(emit)
  };
  base = defineProperties({}, descriptors);
  module.exports = exports = function(o) {
    return (o == null) ? create(base) : defineProperties(Object(o), descriptors);
  };
  exports.methods = methods;
  global.define = __define;
  return module.exports;
});



System.register("npm:brace@0.5.0/mode/javascript", ["npm:brace@0.5.0/worker/javascript"], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  ace.define("ace/mode/doc_comment_highlight_rules", ["require", "exports", "module", "ace/lib/oop", "ace/mode/text_highlight_rules"], function(acequire, exports, module) {
    "use strict";
    var oop = acequire("../lib/oop");
    var TextHighlightRules = acequire("./text_highlight_rules").TextHighlightRules;
    var DocCommentHighlightRules = function() {
      this.$rules = {"start": [{
          token: "comment.doc.tag",
          regex: "@[\\w\\d_]+"
        }, DocCommentHighlightRules.getTagRule(), {
          defaultToken: "comment.doc",
          caseInsensitive: true
        }]};
    };
    oop.inherits(DocCommentHighlightRules, TextHighlightRules);
    DocCommentHighlightRules.getTagRule = function(start) {
      return {
        token: "comment.doc.tag.storage.type",
        regex: "\\b(?:TODO|FIXME|XXX|HACK)\\b"
      };
    };
    DocCommentHighlightRules.getStartRule = function(start) {
      return {
        token: "comment.doc",
        regex: "\\/\\*(?=\\*)",
        next: start
      };
    };
    DocCommentHighlightRules.getEndRule = function(start) {
      return {
        token: "comment.doc",
        regex: "\\*\\/",
        next: start
      };
    };
    exports.DocCommentHighlightRules = DocCommentHighlightRules;
  });
  ace.define("ace/mode/javascript_highlight_rules", ["require", "exports", "module", "ace/lib/oop", "ace/mode/doc_comment_highlight_rules", "ace/mode/text_highlight_rules"], function(acequire, exports, module) {
    "use strict";
    var oop = acequire("../lib/oop");
    var DocCommentHighlightRules = acequire("./doc_comment_highlight_rules").DocCommentHighlightRules;
    var TextHighlightRules = acequire("./text_highlight_rules").TextHighlightRules;
    var JavaScriptHighlightRules = function(options) {
      var keywordMapper = this.createKeywordMapper({
        "variable.language": "Array|Boolean|Date|Function|Iterator|Number|Object|RegExp|String|Proxy|" + "Namespace|QName|XML|XMLList|" + "ArrayBuffer|Float32Array|Float64Array|Int16Array|Int32Array|Int8Array|" + "Uint16Array|Uint32Array|Uint8Array|Uint8ClampedArray|" + "Error|EvalError|InternalError|RangeError|ReferenceError|StopIteration|" + "SyntaxError|TypeError|URIError|" + "decodeURI|decodeURIComponent|encodeURI|encodeURIComponent|eval|isFinite|" + "isNaN|parseFloat|parseInt|" + "JSON|Math|" + "this|arguments|prototype|window|document",
        "keyword": "const|yield|import|get|set|" + "break|case|catch|continue|default|delete|do|else|finally|for|function|" + "if|in|instanceof|new|return|switch|throw|try|typeof|let|var|while|with|debugger|" + "__parent__|__count__|escape|unescape|with|__proto__|" + "class|enum|extends|super|export|implements|private|public|interface|package|protected|static",
        "storage.type": "const|let|var|function",
        "constant.language": "null|Infinity|NaN|undefined",
        "support.function": "alert",
        "constant.language.boolean": "true|false"
      }, "identifier");
      var kwBeforeRe = "case|do|else|finally|in|instanceof|return|throw|try|typeof|yield|void";
      var identifierRe = "[a-zA-Z\\$_\u00a1-\uffff][a-zA-Z\\d\\$_\u00a1-\uffff]*\\b";
      var escapedRe = "\\\\(?:x[0-9a-fA-F]{2}|" + "u[0-9a-fA-F]{4}|" + "[0-2][0-7]{0,2}|" + "3[0-6][0-7]?|" + "37[0-7]?|" + "[4-7][0-7]?|" + ".)";
      this.$rules = {
        "no_regex": [{
          token: "comment",
          regex: "\\/\\/",
          next: "line_comment"
        }, DocCommentHighlightRules.getStartRule("doc-start"), {
          token: "comment",
          regex: /\/\*/,
          next: "comment"
        }, {
          token: "string",
          regex: "'(?=.)",
          next: "qstring"
        }, {
          token: "string",
          regex: '"(?=.)',
          next: "qqstring"
        }, {
          token: "constant.numeric",
          regex: /0[xX][0-9a-fA-F]+\b/
        }, {
          token: "constant.numeric",
          regex: /[+-]?\d+(?:(?:\.\d*)?(?:[eE][+-]?\d+)?)?\b/
        }, {
          token: ["storage.type", "punctuation.operator", "support.function", "punctuation.operator", "entity.name.function", "text", "keyword.operator"],
          regex: "(" + identifierRe + ")(\\.)(prototype)(\\.)(" + identifierRe + ")(\\s*)(=)",
          next: "function_arguments"
        }, {
          token: ["storage.type", "punctuation.operator", "entity.name.function", "text", "keyword.operator", "text", "storage.type", "text", "paren.lparen"],
          regex: "(" + identifierRe + ")(\\.)(" + identifierRe + ")(\\s*)(=)(\\s*)(function)(\\s*)(\\()",
          next: "function_arguments"
        }, {
          token: ["entity.name.function", "text", "keyword.operator", "text", "storage.type", "text", "paren.lparen"],
          regex: "(" + identifierRe + ")(\\s*)(=)(\\s*)(function)(\\s*)(\\()",
          next: "function_arguments"
        }, {
          token: ["storage.type", "punctuation.operator", "entity.name.function", "text", "keyword.operator", "text", "storage.type", "text", "entity.name.function", "text", "paren.lparen"],
          regex: "(" + identifierRe + ")(\\.)(" + identifierRe + ")(\\s*)(=)(\\s*)(function)(\\s+)(\\w+)(\\s*)(\\()",
          next: "function_arguments"
        }, {
          token: ["storage.type", "text", "entity.name.function", "text", "paren.lparen"],
          regex: "(function)(\\s+)(" + identifierRe + ")(\\s*)(\\()",
          next: "function_arguments"
        }, {
          token: ["entity.name.function", "text", "punctuation.operator", "text", "storage.type", "text", "paren.lparen"],
          regex: "(" + identifierRe + ")(\\s*)(:)(\\s*)(function)(\\s*)(\\()",
          next: "function_arguments"
        }, {
          token: ["text", "text", "storage.type", "text", "paren.lparen"],
          regex: "(:)(\\s*)(function)(\\s*)(\\()",
          next: "function_arguments"
        }, {
          token: "keyword",
          regex: "(?:" + kwBeforeRe + ")\\b",
          next: "start"
        }, {
          token: ["punctuation.operator", "support.function"],
          regex: /(\.)(s(?:h(?:ift|ow(?:Mod(?:elessDialog|alDialog)|Help))|croll(?:X|By(?:Pages|Lines)?|Y|To)?|t(?:op|rike)|i(?:n|zeToContent|debar|gnText)|ort|u(?:p|b(?:str(?:ing)?)?)|pli(?:ce|t)|e(?:nd|t(?:Re(?:sizable|questHeader)|M(?:i(?:nutes|lliseconds)|onth)|Seconds|Ho(?:tKeys|urs)|Year|Cursor|Time(?:out)?|Interval|ZOptions|Date|UTC(?:M(?:i(?:nutes|lliseconds)|onth)|Seconds|Hours|Date|FullYear)|FullYear|Active)|arch)|qrt|lice|avePreferences|mall)|h(?:ome|andleEvent)|navigate|c(?:har(?:CodeAt|At)|o(?:s|n(?:cat|textual|firm)|mpile)|eil|lear(?:Timeout|Interval)?|a(?:ptureEvents|ll)|reate(?:StyleSheet|Popup|EventObject))|t(?:o(?:GMTString|S(?:tring|ource)|U(?:TCString|pperCase)|Lo(?:caleString|werCase))|est|a(?:n|int(?:Enabled)?))|i(?:s(?:NaN|Finite)|ndexOf|talics)|d(?:isableExternalCapture|ump|etachEvent)|u(?:n(?:shift|taint|escape|watch)|pdateCommands)|j(?:oin|avaEnabled)|p(?:o(?:p|w)|ush|lugins.refresh|a(?:ddings|rse(?:Int|Float)?)|r(?:int|ompt|eference))|e(?:scape|nableExternalCapture|val|lementFromPoint|x(?:p|ec(?:Script|Command)?))|valueOf|UTC|queryCommand(?:State|Indeterm|Enabled|Value)|f(?:i(?:nd|le(?:ModifiedDate|Size|CreatedDate|UpdatedDate)|xed)|o(?:nt(?:size|color)|rward)|loor|romCharCode)|watch|l(?:ink|o(?:ad|g)|astIndexOf)|a(?:sin|nchor|cos|t(?:tachEvent|ob|an(?:2)?)|pply|lert|b(?:s|ort))|r(?:ou(?:nd|teEvents)|e(?:size(?:By|To)|calc|turnValue|place|verse|l(?:oad|ease(?:Capture|Events)))|andom)|g(?:o|et(?:ResponseHeader|M(?:i(?:nutes|lliseconds)|onth)|Se(?:conds|lection)|Hours|Year|Time(?:zoneOffset)?|Da(?:y|te)|UTC(?:M(?:i(?:nutes|lliseconds)|onth)|Seconds|Hours|Da(?:y|te)|FullYear)|FullYear|A(?:ttention|llResponseHeaders)))|m(?:in|ove(?:B(?:y|elow)|To(?:Absolute)?|Above)|ergeAttributes|a(?:tch|rgins|x))|b(?:toa|ig|o(?:ld|rderWidths)|link|ack))\b(?=\()/
        }, {
          token: ["punctuation.operator", "support.function.dom"],
          regex: /(\.)(s(?:ub(?:stringData|mit)|plitText|e(?:t(?:NamedItem|Attribute(?:Node)?)|lect))|has(?:ChildNodes|Feature)|namedItem|c(?:l(?:ick|o(?:se|neNode))|reate(?:C(?:omment|DATASection|aption)|T(?:Head|extNode|Foot)|DocumentFragment|ProcessingInstruction|E(?:ntityReference|lement)|Attribute))|tabIndex|i(?:nsert(?:Row|Before|Cell|Data)|tem)|open|delete(?:Row|C(?:ell|aption)|T(?:Head|Foot)|Data)|focus|write(?:ln)?|a(?:dd|ppend(?:Child|Data))|re(?:set|place(?:Child|Data)|move(?:NamedItem|Child|Attribute(?:Node)?)?)|get(?:NamedItem|Element(?:sBy(?:Name|TagName)|ById)|Attribute(?:Node)?)|blur)\b(?=\()/
        }, {
          token: ["punctuation.operator", "support.constant"],
          regex: /(\.)(s(?:ystemLanguage|cr(?:ipts|ollbars|een(?:X|Y|Top|Left))|t(?:yle(?:Sheets)?|atus(?:Text|bar)?)|ibling(?:Below|Above)|ource|uffixes|e(?:curity(?:Policy)?|l(?:ection|f)))|h(?:istory|ost(?:name)?|as(?:h|Focus))|y|X(?:MLDocument|SLDocument)|n(?:ext|ame(?:space(?:s|URI)|Prop))|M(?:IN_VALUE|AX_VALUE)|c(?:haracterSet|o(?:n(?:structor|trollers)|okieEnabled|lorDepth|mp(?:onents|lete))|urrent|puClass|l(?:i(?:p(?:boardData)?|entInformation)|osed|asses)|alle(?:e|r)|rypto)|t(?:o(?:olbar|p)|ext(?:Transform|Indent|Decoration|Align)|ags)|SQRT(?:1_2|2)|i(?:n(?:ner(?:Height|Width)|put)|ds|gnoreCase)|zIndex|o(?:scpu|n(?:readystatechange|Line)|uter(?:Height|Width)|p(?:sProfile|ener)|ffscreenBuffering)|NEGATIVE_INFINITY|d(?:i(?:splay|alog(?:Height|Top|Width|Left|Arguments)|rectories)|e(?:scription|fault(?:Status|Ch(?:ecked|arset)|View)))|u(?:ser(?:Profile|Language|Agent)|n(?:iqueID|defined)|pdateInterval)|_content|p(?:ixelDepth|ort|ersonalbar|kcs11|l(?:ugins|atform)|a(?:thname|dding(?:Right|Bottom|Top|Left)|rent(?:Window|Layer)?|ge(?:X(?:Offset)?|Y(?:Offset)?))|r(?:o(?:to(?:col|type)|duct(?:Sub)?|mpter)|e(?:vious|fix)))|e(?:n(?:coding|abledPlugin)|x(?:ternal|pando)|mbeds)|v(?:isibility|endor(?:Sub)?|Linkcolor)|URLUnencoded|P(?:I|OSITIVE_INFINITY)|f(?:ilename|o(?:nt(?:Size|Family|Weight)|rmName)|rame(?:s|Element)|gColor)|E|whiteSpace|l(?:i(?:stStyleType|n(?:eHeight|kColor))|o(?:ca(?:tion(?:bar)?|lName)|wsrc)|e(?:ngth|ft(?:Context)?)|a(?:st(?:M(?:odified|atch)|Index|Paren)|yer(?:s|X)|nguage))|a(?:pp(?:MinorVersion|Name|Co(?:deName|re)|Version)|vail(?:Height|Top|Width|Left)|ll|r(?:ity|guments)|Linkcolor|bove)|r(?:ight(?:Context)?|e(?:sponse(?:XML|Text)|adyState))|global|x|m(?:imeTypes|ultiline|enubar|argin(?:Right|Bottom|Top|Left))|L(?:N(?:10|2)|OG(?:10E|2E))|b(?:o(?:ttom|rder(?:Width|RightWidth|BottomWidth|Style|Color|TopWidth|LeftWidth))|ufferDepth|elow|ackground(?:Color|Image)))\b/
        }, {
          token: ["support.constant"],
          regex: /that\b/
        }, {
          token: ["storage.type", "punctuation.operator", "support.function.firebug"],
          regex: /(console)(\.)(warn|info|log|error|time|trace|timeEnd|assert)\b/
        }, {
          token: keywordMapper,
          regex: identifierRe
        }, {
          token: "keyword.operator",
          regex: /--|\+\+|===|==|=|!=|!==|<=|>=|<<=|>>=|>>>=|<>|<|>|!|&&|\|\||\?\:|[!$%&*+\-~\/^]=?/,
          next: "start"
        }, {
          token: "punctuation.operator",
          regex: /[?:,;.]/,
          next: "start"
        }, {
          token: "paren.lparen",
          regex: /[\[({]/,
          next: "start"
        }, {
          token: "paren.rparen",
          regex: /[\])}]/
        }, {
          token: "comment",
          regex: /^#!.*$/
        }],
        "start": [DocCommentHighlightRules.getStartRule("doc-start"), {
          token: "comment",
          regex: "\\/\\*",
          next: "comment_regex_allowed"
        }, {
          token: "comment",
          regex: "\\/\\/",
          next: "line_comment_regex_allowed"
        }, {
          token: "string.regexp",
          regex: "\\/",
          next: "regex"
        }, {
          token: "text",
          regex: "\\s+|^$",
          next: "start"
        }, {
          token: "empty",
          regex: "",
          next: "no_regex"
        }],
        "regex": [{
          token: "regexp.keyword.operator",
          regex: "\\\\(?:u[\\da-fA-F]{4}|x[\\da-fA-F]{2}|.)"
        }, {
          token: "string.regexp",
          regex: "/[sxngimy]*",
          next: "no_regex"
        }, {
          token: "invalid",
          regex: /\{\d+\b,?\d*\}[+*]|[+*$^?][+*]|[$^][?]|\?{3,}/
        }, {
          token: "constant.language.escape",
          regex: /\(\?[:=!]|\)|\{\d+\b,?\d*\}|[+*]\?|[()$^+*?.]/
        }, {
          token: "constant.language.delimiter",
          regex: /\|/
        }, {
          token: "constant.language.escape",
          regex: /\[\^?/,
          next: "regex_character_class"
        }, {
          token: "empty",
          regex: "$",
          next: "no_regex"
        }, {defaultToken: "string.regexp"}],
        "regex_character_class": [{
          token: "regexp.charclass.keyword.operator",
          regex: "\\\\(?:u[\\da-fA-F]{4}|x[\\da-fA-F]{2}|.)"
        }, {
          token: "constant.language.escape",
          regex: "]",
          next: "regex"
        }, {
          token: "constant.language.escape",
          regex: "-"
        }, {
          token: "empty",
          regex: "$",
          next: "no_regex"
        }, {defaultToken: "string.regexp.charachterclass"}],
        "function_arguments": [{
          token: "variable.parameter",
          regex: identifierRe
        }, {
          token: "punctuation.operator",
          regex: "[, ]+"
        }, {
          token: "punctuation.operator",
          regex: "$"
        }, {
          token: "empty",
          regex: "",
          next: "no_regex"
        }],
        "comment_regex_allowed": [DocCommentHighlightRules.getTagRule(), {
          token: "comment",
          regex: "\\*\\/",
          next: "start"
        }, {
          defaultToken: "comment",
          caseInsensitive: true
        }],
        "comment": [DocCommentHighlightRules.getTagRule(), {
          token: "comment",
          regex: "\\*\\/",
          next: "no_regex"
        }, {
          defaultToken: "comment",
          caseInsensitive: true
        }],
        "line_comment_regex_allowed": [DocCommentHighlightRules.getTagRule(), {
          token: "comment",
          regex: "$|^",
          next: "start"
        }, {
          defaultToken: "comment",
          caseInsensitive: true
        }],
        "line_comment": [DocCommentHighlightRules.getTagRule(), {
          token: "comment",
          regex: "$|^",
          next: "no_regex"
        }, {
          defaultToken: "comment",
          caseInsensitive: true
        }],
        "qqstring": [{
          token: "constant.language.escape",
          regex: escapedRe
        }, {
          token: "string",
          regex: "\\\\$",
          next: "qqstring"
        }, {
          token: "string",
          regex: '"|$',
          next: "no_regex"
        }, {defaultToken: "string"}],
        "qstring": [{
          token: "constant.language.escape",
          regex: escapedRe
        }, {
          token: "string",
          regex: "\\\\$",
          next: "qstring"
        }, {
          token: "string",
          regex: "'|$",
          next: "no_regex"
        }, {defaultToken: "string"}]
      };
      if (!options || !options.noES6) {
        this.$rules.no_regex.unshift({
          regex: "[{}]",
          onMatch: function(val, state, stack) {
            this.next = val == "{" ? this.nextState : "";
            if (val == "{" && stack.length) {
              stack.unshift("start", state);
              return "paren";
            }
            if (val == "}" && stack.length) {
              stack.shift();
              this.next = stack.shift();
              if (this.next.indexOf("string") != -1)
                return "paren.quasi.end";
            }
            return val == "{" ? "paren.lparen" : "paren.rparen";
          },
          nextState: "start"
        }, {
          token: "string.quasi.start",
          regex: /`/,
          push: [{
            token: "constant.language.escape",
            regex: escapedRe
          }, {
            token: "paren.quasi.start",
            regex: /\${/,
            push: "start"
          }, {
            token: "string.quasi.end",
            regex: /`/,
            next: "pop"
          }, {defaultToken: "string.quasi"}]
        });
      }
      this.embedRules(DocCommentHighlightRules, "doc-", [DocCommentHighlightRules.getEndRule("no_regex")]);
      this.normalizeRules();
    };
    oop.inherits(JavaScriptHighlightRules, TextHighlightRules);
    exports.JavaScriptHighlightRules = JavaScriptHighlightRules;
  });
  ace.define("ace/mode/matching_brace_outdent", ["require", "exports", "module", "ace/range"], function(acequire, exports, module) {
    "use strict";
    var Range = acequire("../range").Range;
    var MatchingBraceOutdent = function() {};
    (function() {
      this.checkOutdent = function(line, input) {
        if (!/^\s+$/.test(line))
          return false;
        return /^\s*\}/.test(input);
      };
      this.autoOutdent = function(doc, row) {
        var line = doc.getLine(row);
        var match = line.match(/^(\s*\})/);
        if (!match)
          return 0;
        var column = match[1].length;
        var openBracePos = doc.findMatchingBracket({
          row: row,
          column: column
        });
        if (!openBracePos || openBracePos.row == row)
          return 0;
        var indent = this.$getIndent(doc.getLine(openBracePos.row));
        doc.replace(new Range(row, 0, row, column - 1), indent);
      };
      this.$getIndent = function(line) {
        return line.match(/^\s*/)[0];
      };
    }).call(MatchingBraceOutdent.prototype);
    exports.MatchingBraceOutdent = MatchingBraceOutdent;
  });
  ace.define("ace/mode/behaviour/cstyle", ["require", "exports", "module", "ace/lib/oop", "ace/mode/behaviour", "ace/token_iterator", "ace/lib/lang"], function(acequire, exports, module) {
    "use strict";
    var oop = acequire("../../lib/oop");
    var Behaviour = acequire("../behaviour").Behaviour;
    var TokenIterator = acequire("../../token_iterator").TokenIterator;
    var lang = acequire("../../lib/lang");
    var SAFE_INSERT_IN_TOKENS = ["text", "paren.rparen", "punctuation.operator"];
    var SAFE_INSERT_BEFORE_TOKENS = ["text", "paren.rparen", "punctuation.operator", "comment"];
    var context;
    var contextCache = {};
    var initContext = function(editor) {
      var id = -1;
      if (editor.multiSelect) {
        id = editor.selection.index;
        if (contextCache.rangeCount != editor.multiSelect.rangeCount)
          contextCache = {rangeCount: editor.multiSelect.rangeCount};
      }
      if (contextCache[id])
        return context = contextCache[id];
      context = contextCache[id] = {
        autoInsertedBrackets: 0,
        autoInsertedRow: -1,
        autoInsertedLineEnd: "",
        maybeInsertedBrackets: 0,
        maybeInsertedRow: -1,
        maybeInsertedLineStart: "",
        maybeInsertedLineEnd: ""
      };
    };
    var CstyleBehaviour = function() {
      this.add("braces", "insertion", function(state, action, editor, session, text) {
        var cursor = editor.getCursorPosition();
        var line = session.doc.getLine(cursor.row);
        if (text == '{') {
          initContext(editor);
          var selection = editor.getSelectionRange();
          var selected = session.doc.getTextRange(selection);
          if (selected !== "" && selected !== "{" && editor.getWrapBehavioursEnabled()) {
            return {
              text: '{' + selected + '}',
              selection: false
            };
          } else if (CstyleBehaviour.isSaneInsertion(editor, session)) {
            if (/[\]\}\)]/.test(line[cursor.column]) || editor.inMultiSelectMode) {
              CstyleBehaviour.recordAutoInsert(editor, session, "}");
              return {
                text: '{}',
                selection: [1, 1]
              };
            } else {
              CstyleBehaviour.recordMaybeInsert(editor, session, "{");
              return {
                text: '{',
                selection: [1, 1]
              };
            }
          }
        } else if (text == '}') {
          initContext(editor);
          var rightChar = line.substring(cursor.column, cursor.column + 1);
          if (rightChar == '}') {
            var matching = session.$findOpeningBracket('}', {
              column: cursor.column + 1,
              row: cursor.row
            });
            if (matching !== null && CstyleBehaviour.isAutoInsertedClosing(cursor, line, text)) {
              CstyleBehaviour.popAutoInsertedClosing();
              return {
                text: '',
                selection: [1, 1]
              };
            }
          }
        } else if (text == "\n" || text == "\r\n") {
          initContext(editor);
          var closing = "";
          if (CstyleBehaviour.isMaybeInsertedClosing(cursor, line)) {
            closing = lang.stringRepeat("}", context.maybeInsertedBrackets);
            CstyleBehaviour.clearMaybeInsertedClosing();
          }
          var rightChar = line.substring(cursor.column, cursor.column + 1);
          if (rightChar === '}') {
            var openBracePos = session.findMatchingBracket({
              row: cursor.row,
              column: cursor.column + 1
            }, '}');
            if (!openBracePos)
              return null;
            var next_indent = this.$getIndent(session.getLine(openBracePos.row));
          } else if (closing) {
            var next_indent = this.$getIndent(line);
          } else {
            CstyleBehaviour.clearMaybeInsertedClosing();
            return ;
          }
          var indent = next_indent + session.getTabString();
          return {
            text: '\n' + indent + '\n' + next_indent + closing,
            selection: [1, indent.length, 1, indent.length]
          };
        } else {
          CstyleBehaviour.clearMaybeInsertedClosing();
        }
      });
      this.add("braces", "deletion", function(state, action, editor, session, range) {
        var selected = session.doc.getTextRange(range);
        if (!range.isMultiLine() && selected == '{') {
          initContext(editor);
          var line = session.doc.getLine(range.start.row);
          var rightChar = line.substring(range.end.column, range.end.column + 1);
          if (rightChar == '}') {
            range.end.column++;
            return range;
          } else {
            context.maybeInsertedBrackets--;
          }
        }
      });
      this.add("parens", "insertion", function(state, action, editor, session, text) {
        if (text == '(') {
          initContext(editor);
          var selection = editor.getSelectionRange();
          var selected = session.doc.getTextRange(selection);
          if (selected !== "" && editor.getWrapBehavioursEnabled()) {
            return {
              text: '(' + selected + ')',
              selection: false
            };
          } else if (CstyleBehaviour.isSaneInsertion(editor, session)) {
            CstyleBehaviour.recordAutoInsert(editor, session, ")");
            return {
              text: '()',
              selection: [1, 1]
            };
          }
        } else if (text == ')') {
          initContext(editor);
          var cursor = editor.getCursorPosition();
          var line = session.doc.getLine(cursor.row);
          var rightChar = line.substring(cursor.column, cursor.column + 1);
          if (rightChar == ')') {
            var matching = session.$findOpeningBracket(')', {
              column: cursor.column + 1,
              row: cursor.row
            });
            if (matching !== null && CstyleBehaviour.isAutoInsertedClosing(cursor, line, text)) {
              CstyleBehaviour.popAutoInsertedClosing();
              return {
                text: '',
                selection: [1, 1]
              };
            }
          }
        }
      });
      this.add("parens", "deletion", function(state, action, editor, session, range) {
        var selected = session.doc.getTextRange(range);
        if (!range.isMultiLine() && selected == '(') {
          initContext(editor);
          var line = session.doc.getLine(range.start.row);
          var rightChar = line.substring(range.start.column + 1, range.start.column + 2);
          if (rightChar == ')') {
            range.end.column++;
            return range;
          }
        }
      });
      this.add("brackets", "insertion", function(state, action, editor, session, text) {
        if (text == '[') {
          initContext(editor);
          var selection = editor.getSelectionRange();
          var selected = session.doc.getTextRange(selection);
          if (selected !== "" && editor.getWrapBehavioursEnabled()) {
            return {
              text: '[' + selected + ']',
              selection: false
            };
          } else if (CstyleBehaviour.isSaneInsertion(editor, session)) {
            CstyleBehaviour.recordAutoInsert(editor, session, "]");
            return {
              text: '[]',
              selection: [1, 1]
            };
          }
        } else if (text == ']') {
          initContext(editor);
          var cursor = editor.getCursorPosition();
          var line = session.doc.getLine(cursor.row);
          var rightChar = line.substring(cursor.column, cursor.column + 1);
          if (rightChar == ']') {
            var matching = session.$findOpeningBracket(']', {
              column: cursor.column + 1,
              row: cursor.row
            });
            if (matching !== null && CstyleBehaviour.isAutoInsertedClosing(cursor, line, text)) {
              CstyleBehaviour.popAutoInsertedClosing();
              return {
                text: '',
                selection: [1, 1]
              };
            }
          }
        }
      });
      this.add("brackets", "deletion", function(state, action, editor, session, range) {
        var selected = session.doc.getTextRange(range);
        if (!range.isMultiLine() && selected == '[') {
          initContext(editor);
          var line = session.doc.getLine(range.start.row);
          var rightChar = line.substring(range.start.column + 1, range.start.column + 2);
          if (rightChar == ']') {
            range.end.column++;
            return range;
          }
        }
      });
      this.add("string_dquotes", "insertion", function(state, action, editor, session, text) {
        if (text == '"' || text == "'") {
          initContext(editor);
          var quote = text;
          var selection = editor.getSelectionRange();
          var selected = session.doc.getTextRange(selection);
          if (selected !== "" && selected !== "'" && selected != '"' && editor.getWrapBehavioursEnabled()) {
            return {
              text: quote + selected + quote,
              selection: false
            };
          } else {
            var cursor = editor.getCursorPosition();
            var line = session.doc.getLine(cursor.row);
            var leftChar = line.substring(cursor.column - 1, cursor.column);
            if (leftChar == '\\') {
              return null;
            }
            var tokens = session.getTokens(selection.start.row);
            var col = 0,
                token;
            var quotepos = -1;
            for (var x = 0; x < tokens.length; x++) {
              token = tokens[x];
              if (token.type == "string") {
                quotepos = -1;
              } else if (quotepos < 0) {
                quotepos = token.value.indexOf(quote);
              }
              if ((token.value.length + col) > selection.start.column) {
                break;
              }
              col += tokens[x].value.length;
            }
            if (!token || (quotepos < 0 && token.type !== "comment" && (token.type !== "string" || ((selection.start.column !== token.value.length + col - 1) && token.value.lastIndexOf(quote) === token.value.length - 1)))) {
              if (!CstyleBehaviour.isSaneInsertion(editor, session))
                return ;
              return {
                text: quote + quote,
                selection: [1, 1]
              };
            } else if (token && token.type === "string") {
              var rightChar = line.substring(cursor.column, cursor.column + 1);
              if (rightChar == quote) {
                return {
                  text: '',
                  selection: [1, 1]
                };
              }
            }
          }
        }
      });
      this.add("string_dquotes", "deletion", function(state, action, editor, session, range) {
        var selected = session.doc.getTextRange(range);
        if (!range.isMultiLine() && (selected == '"' || selected == "'")) {
          initContext(editor);
          var line = session.doc.getLine(range.start.row);
          var rightChar = line.substring(range.start.column + 1, range.start.column + 2);
          if (rightChar == selected) {
            range.end.column++;
            return range;
          }
        }
      });
    };
    CstyleBehaviour.isSaneInsertion = function(editor, session) {
      var cursor = editor.getCursorPosition();
      var iterator = new TokenIterator(session, cursor.row, cursor.column);
      if (!this.$matchTokenType(iterator.getCurrentToken() || "text", SAFE_INSERT_IN_TOKENS)) {
        var iterator2 = new TokenIterator(session, cursor.row, cursor.column + 1);
        if (!this.$matchTokenType(iterator2.getCurrentToken() || "text", SAFE_INSERT_IN_TOKENS))
          return false;
      }
      iterator.stepForward();
      return iterator.getCurrentTokenRow() !== cursor.row || this.$matchTokenType(iterator.getCurrentToken() || "text", SAFE_INSERT_BEFORE_TOKENS);
    };
    CstyleBehaviour.$matchTokenType = function(token, types) {
      return types.indexOf(token.type || token) > -1;
    };
    CstyleBehaviour.recordAutoInsert = function(editor, session, bracket) {
      var cursor = editor.getCursorPosition();
      var line = session.doc.getLine(cursor.row);
      if (!this.isAutoInsertedClosing(cursor, line, context.autoInsertedLineEnd[0]))
        context.autoInsertedBrackets = 0;
      context.autoInsertedRow = cursor.row;
      context.autoInsertedLineEnd = bracket + line.substr(cursor.column);
      context.autoInsertedBrackets++;
    };
    CstyleBehaviour.recordMaybeInsert = function(editor, session, bracket) {
      var cursor = editor.getCursorPosition();
      var line = session.doc.getLine(cursor.row);
      if (!this.isMaybeInsertedClosing(cursor, line))
        context.maybeInsertedBrackets = 0;
      context.maybeInsertedRow = cursor.row;
      context.maybeInsertedLineStart = line.substr(0, cursor.column) + bracket;
      context.maybeInsertedLineEnd = line.substr(cursor.column);
      context.maybeInsertedBrackets++;
    };
    CstyleBehaviour.isAutoInsertedClosing = function(cursor, line, bracket) {
      return context.autoInsertedBrackets > 0 && cursor.row === context.autoInsertedRow && bracket === context.autoInsertedLineEnd[0] && line.substr(cursor.column) === context.autoInsertedLineEnd;
    };
    CstyleBehaviour.isMaybeInsertedClosing = function(cursor, line) {
      return context.maybeInsertedBrackets > 0 && cursor.row === context.maybeInsertedRow && line.substr(cursor.column) === context.maybeInsertedLineEnd && line.substr(0, cursor.column) == context.maybeInsertedLineStart;
    };
    CstyleBehaviour.popAutoInsertedClosing = function() {
      context.autoInsertedLineEnd = context.autoInsertedLineEnd.substr(1);
      context.autoInsertedBrackets--;
    };
    CstyleBehaviour.clearMaybeInsertedClosing = function() {
      if (context) {
        context.maybeInsertedBrackets = 0;
        context.maybeInsertedRow = -1;
      }
    };
    oop.inherits(CstyleBehaviour, Behaviour);
    exports.CstyleBehaviour = CstyleBehaviour;
  });
  ace.define("ace/mode/folding/cstyle", ["require", "exports", "module", "ace/lib/oop", "ace/range", "ace/mode/folding/fold_mode"], function(acequire, exports, module) {
    "use strict";
    var oop = acequire("../../lib/oop");
    var Range = acequire("../../range").Range;
    var BaseFoldMode = acequire("./fold_mode").FoldMode;
    var FoldMode = exports.FoldMode = function(commentRegex) {
      if (commentRegex) {
        this.foldingStartMarker = new RegExp(this.foldingStartMarker.source.replace(/\|[^|]*?$/, "|" + commentRegex.start));
        this.foldingStopMarker = new RegExp(this.foldingStopMarker.source.replace(/\|[^|]*?$/, "|" + commentRegex.end));
      }
    };
    oop.inherits(FoldMode, BaseFoldMode);
    (function() {
      this.foldingStartMarker = /(\{|\[)[^\}\]]*$|^\s*(\/\*)/;
      this.foldingStopMarker = /^[^\[\{]*(\}|\])|^[\s\*]*(\*\/)/;
      this.getFoldWidgetRange = function(session, foldStyle, row, forceMultiline) {
        var line = session.getLine(row);
        var match = line.match(this.foldingStartMarker);
        if (match) {
          var i = match.index;
          if (match[1])
            return this.openingBracketBlock(session, match[1], row, i);
          var range = session.getCommentFoldRange(row, i + match[0].length, 1);
          if (range && !range.isMultiLine()) {
            if (forceMultiline) {
              range = this.getSectionRange(session, row);
            } else if (foldStyle != "all")
              range = null;
          }
          return range;
        }
        if (foldStyle === "markbegin")
          return ;
        var match = line.match(this.foldingStopMarker);
        if (match) {
          var i = match.index + match[0].length;
          if (match[1])
            return this.closingBracketBlock(session, match[1], row, i);
          return session.getCommentFoldRange(row, i, -1);
        }
      };
      this.getSectionRange = function(session, row) {
        var line = session.getLine(row);
        var startIndent = line.search(/\S/);
        var startRow = row;
        var startColumn = line.length;
        row = row + 1;
        var endRow = row;
        var maxRow = session.getLength();
        while (++row < maxRow) {
          line = session.getLine(row);
          var indent = line.search(/\S/);
          if (indent === -1)
            continue;
          if (startIndent > indent)
            break;
          var subRange = this.getFoldWidgetRange(session, "all", row);
          if (subRange) {
            if (subRange.start.row <= startRow) {
              break;
            } else if (subRange.isMultiLine()) {
              row = subRange.end.row;
            } else if (startIndent == indent) {
              break;
            }
          }
          endRow = row;
        }
        return new Range(startRow, startColumn, endRow, session.getLine(endRow).length);
      };
    }).call(FoldMode.prototype);
  });
  ace.define("ace/mode/javascript", ["require", "exports", "module", "ace/lib/oop", "ace/mode/text", "ace/mode/javascript_highlight_rules", "ace/mode/matching_brace_outdent", "ace/range", "ace/worker/worker_client", "ace/mode/behaviour/cstyle", "ace/mode/folding/cstyle"], function(acequire, exports, module) {
    "use strict";
    var oop = acequire("../lib/oop");
    var TextMode = acequire("./text").Mode;
    var JavaScriptHighlightRules = acequire("./javascript_highlight_rules").JavaScriptHighlightRules;
    var MatchingBraceOutdent = acequire("./matching_brace_outdent").MatchingBraceOutdent;
    var Range = acequire("../range").Range;
    var WorkerClient = acequire("../worker/worker_client").WorkerClient;
    var CstyleBehaviour = acequire("./behaviour/cstyle").CstyleBehaviour;
    var CStyleFoldMode = acequire("./folding/cstyle").FoldMode;
    var Mode = function() {
      this.HighlightRules = JavaScriptHighlightRules;
      this.$outdent = new MatchingBraceOutdent();
      this.$behaviour = new CstyleBehaviour();
      this.foldingRules = new CStyleFoldMode();
    };
    oop.inherits(Mode, TextMode);
    (function() {
      this.lineCommentStart = "//";
      this.blockComment = {
        start: "/*",
        end: "*/"
      };
      this.getNextLineIndent = function(state, line, tab) {
        var indent = this.$getIndent(line);
        var tokenizedLine = this.getTokenizer().getLineTokens(line, state);
        var tokens = tokenizedLine.tokens;
        var endState = tokenizedLine.state;
        if (tokens.length && tokens[tokens.length - 1].type == "comment") {
          return indent;
        }
        if (state == "start" || state == "no_regex") {
          var match = line.match(/^.*(?:\bcase\b.*\:|[\{\(\[])\s*$/);
          if (match) {
            indent += tab;
          }
        } else if (state == "doc-start") {
          if (endState == "start" || endState == "no_regex") {
            return "";
          }
          var match = line.match(/^\s*(\/?)\*/);
          if (match) {
            if (match[1]) {
              indent += " ";
            }
            indent += "* ";
          }
        }
        return indent;
      };
      this.checkOutdent = function(state, line, input) {
        return this.$outdent.checkOutdent(line, input);
      };
      this.autoOutdent = function(state, doc, row) {
        this.$outdent.autoOutdent(doc, row);
      };
      this.createWorker = function(session) {
        var worker = new WorkerClient(["ace"], require("npm:brace@0.5.0/worker/javascript"), "JavaScriptWorker");
        worker.attachToDocument(session.getDocument());
        worker.on("jslint", function(results) {
          session.setAnnotations(results.data);
        });
        worker.on("terminate", function() {
          session.clearAnnotations();
        });
        return worker;
      };
      this.$id = "ace/mode/javascript";
    }).call(Mode.prototype);
    exports.Mode = Mode;
  });
  global.define = __define;
  return module.exports;
});



System.register("npm:react@0.12.2/lib/React", ["npm:react@0.12.2/lib/DOMPropertyOperations", "npm:react@0.12.2/lib/EventPluginUtils", "npm:react@0.12.2/lib/ReactChildren", "npm:react@0.12.2/lib/ReactComponent", "npm:react@0.12.2/lib/ReactCompositeComponent", "npm:react@0.12.2/lib/ReactContext", "npm:react@0.12.2/lib/ReactCurrentOwner", "npm:react@0.12.2/lib/ReactElement", "npm:react@0.12.2/lib/ReactElementValidator", "npm:react@0.12.2/lib/ReactDOM", "npm:react@0.12.2/lib/ReactDOMComponent", "npm:react@0.12.2/lib/ReactDefaultInjection", "npm:react@0.12.2/lib/ReactInstanceHandles", "npm:react@0.12.2/lib/ReactLegacyElement", "npm:react@0.12.2/lib/ReactMount", "npm:react@0.12.2/lib/ReactMultiChild", "npm:react@0.12.2/lib/ReactPerf", "npm:react@0.12.2/lib/ReactPropTypes", "npm:react@0.12.2/lib/ReactServerRendering", "npm:react@0.12.2/lib/ReactTextComponent", "npm:react@0.12.2/lib/Object.assign", "npm:react@0.12.2/lib/deprecated", "npm:react@0.12.2/lib/onlyChild", "npm:react@0.12.2/lib/ExecutionEnvironment", "github:jspm/nodelibs-process@0.1.1"], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  (function(process) {
    "use strict";
    var DOMPropertyOperations = require("npm:react@0.12.2/lib/DOMPropertyOperations");
    var EventPluginUtils = require("npm:react@0.12.2/lib/EventPluginUtils");
    var ReactChildren = require("npm:react@0.12.2/lib/ReactChildren");
    var ReactComponent = require("npm:react@0.12.2/lib/ReactComponent");
    var ReactCompositeComponent = require("npm:react@0.12.2/lib/ReactCompositeComponent");
    var ReactContext = require("npm:react@0.12.2/lib/ReactContext");
    var ReactCurrentOwner = require("npm:react@0.12.2/lib/ReactCurrentOwner");
    var ReactElement = require("npm:react@0.12.2/lib/ReactElement");
    var ReactElementValidator = require("npm:react@0.12.2/lib/ReactElementValidator");
    var ReactDOM = require("npm:react@0.12.2/lib/ReactDOM");
    var ReactDOMComponent = require("npm:react@0.12.2/lib/ReactDOMComponent");
    var ReactDefaultInjection = require("npm:react@0.12.2/lib/ReactDefaultInjection");
    var ReactInstanceHandles = require("npm:react@0.12.2/lib/ReactInstanceHandles");
    var ReactLegacyElement = require("npm:react@0.12.2/lib/ReactLegacyElement");
    var ReactMount = require("npm:react@0.12.2/lib/ReactMount");
    var ReactMultiChild = require("npm:react@0.12.2/lib/ReactMultiChild");
    var ReactPerf = require("npm:react@0.12.2/lib/ReactPerf");
    var ReactPropTypes = require("npm:react@0.12.2/lib/ReactPropTypes");
    var ReactServerRendering = require("npm:react@0.12.2/lib/ReactServerRendering");
    var ReactTextComponent = require("npm:react@0.12.2/lib/ReactTextComponent");
    var assign = require("npm:react@0.12.2/lib/Object.assign");
    var deprecated = require("npm:react@0.12.2/lib/deprecated");
    var onlyChild = require("npm:react@0.12.2/lib/onlyChild");
    ReactDefaultInjection.inject();
    var createElement = ReactElement.createElement;
    var createFactory = ReactElement.createFactory;
    if ("production" !== process.env.NODE_ENV) {
      createElement = ReactElementValidator.createElement;
      createFactory = ReactElementValidator.createFactory;
    }
    createElement = ReactLegacyElement.wrapCreateElement(createElement);
    createFactory = ReactLegacyElement.wrapCreateFactory(createFactory);
    var render = ReactPerf.measure('React', 'render', ReactMount.render);
    var React = {
      Children: {
        map: ReactChildren.map,
        forEach: ReactChildren.forEach,
        count: ReactChildren.count,
        only: onlyChild
      },
      DOM: ReactDOM,
      PropTypes: ReactPropTypes,
      initializeTouchEvents: function(shouldUseTouch) {
        EventPluginUtils.useTouchEvents = shouldUseTouch;
      },
      createClass: ReactCompositeComponent.createClass,
      createElement: createElement,
      createFactory: createFactory,
      constructAndRenderComponent: ReactMount.constructAndRenderComponent,
      constructAndRenderComponentByID: ReactMount.constructAndRenderComponentByID,
      render: render,
      renderToString: ReactServerRendering.renderToString,
      renderToStaticMarkup: ReactServerRendering.renderToStaticMarkup,
      unmountComponentAtNode: ReactMount.unmountComponentAtNode,
      isValidClass: ReactLegacyElement.isValidClass,
      isValidElement: ReactElement.isValidElement,
      withContext: ReactContext.withContext,
      __spread: assign,
      renderComponent: deprecated('React', 'renderComponent', 'render', this, render),
      renderComponentToString: deprecated('React', 'renderComponentToString', 'renderToString', this, ReactServerRendering.renderToString),
      renderComponentToStaticMarkup: deprecated('React', 'renderComponentToStaticMarkup', 'renderToStaticMarkup', this, ReactServerRendering.renderToStaticMarkup),
      isValidComponent: deprecated('React', 'isValidComponent', 'isValidElement', this, ReactElement.isValidElement)
    };
    if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ !== 'undefined' && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.inject === 'function') {
      __REACT_DEVTOOLS_GLOBAL_HOOK__.inject({
        Component: ReactComponent,
        CurrentOwner: ReactCurrentOwner,
        DOMComponent: ReactDOMComponent,
        DOMPropertyOperations: DOMPropertyOperations,
        InstanceHandles: ReactInstanceHandles,
        Mount: ReactMount,
        MultiChild: ReactMultiChild,
        TextComponent: ReactTextComponent
      });
    }
    if ("production" !== process.env.NODE_ENV) {
      var ExecutionEnvironment = require("npm:react@0.12.2/lib/ExecutionEnvironment");
      if (ExecutionEnvironment.canUseDOM && window.top === window.self) {
        if (navigator.userAgent.indexOf('Chrome') > -1) {
          if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ === 'undefined') {
            console.debug('Download the React DevTools for a better development experience: ' + 'http://fb.me/react-devtools');
          }
        }
        var expectedFeatures = [Array.isArray, Array.prototype.every, Array.prototype.forEach, Array.prototype.indexOf, Array.prototype.map, Date.now, Function.prototype.bind, Object.keys, String.prototype.split, String.prototype.trim, Object.create, Object.freeze];
        for (var i = 0; i < expectedFeatures.length; i++) {
          if (!expectedFeatures[i]) {
            console.error('One or more ES5 shim/shams expected by React are not available: ' + 'http://fb.me/react-warning-polyfills');
            break;
          }
        }
      }
    }
    React.version = '0.12.2';
    module.exports = React;
  })(require("github:jspm/nodelibs-process@0.1.1"));
  global.define = __define;
  return module.exports;
});



System.register("npm:event-emitter@0.3.3", ["npm:event-emitter@0.3.3/index"], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  module.exports = require("npm:event-emitter@0.3.3/index");
  global.define = __define;
  return module.exports;
});



System.register("npm:react@0.12.2/react", ["npm:react@0.12.2/lib/React"], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  module.exports = require("npm:react@0.12.2/lib/React");
  global.define = __define;
  return module.exports;
});



System.register("app/event", ["npm:event-emitter@0.3.3"], function($__export) {
  "use strict";
  var __moduleName = "app/event";
  var ee;
  return {
    setters: [function($__m) {
      ee = $__m.default;
    }],
    execute: function() {
      $__export('default', ee({}));
    }
  };
});



System.register("npm:react@0.12.2", ["npm:react@0.12.2/react"], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  module.exports = require("npm:react@0.12.2/react");
  global.define = __define;
  return module.exports;
});



System.register("app/input.jsx!github:floatdrop/plugin-jsx@0.1.1", ["npm:react@0.12.2", "app/event", "app/about.jsx!github:floatdrop/plugin-jsx@0.1.1", "npm:brace@0.5.0", "npm:brace@0.5.0/mode/javascript"], function($__export) {
  "use strict";
  var __moduleName = "app/input.jsx!github:floatdrop/plugin-jsx@0.1.1";
  var React,
      emitter,
      AboutProject,
      ace,
      Range;
  return {
    setters: [function($__m) {
      React = $__m.default;
    }, function($__m) {
      emitter = $__m.default;
    }, function($__m) {
      AboutProject = $__m.default;
    }, function($__m) {
      ace = $__m.default;
    }, function($__m) {}],
    execute: function() {
      var $__1;
      (($__1 = ace.acequire('ace/range'), Range = $__1.Range, $__1));
      $__export('default', React.createClass({
        highlightRange: function(startRow, startCol, endRow, endCol) {
          var range = new (Function.prototype.bind.apply(Range, $traceurRuntime.spread([null], arguments)))();
          this.marker = this.editor.getSession().addMarker(range, 'code-highlight', 'text', true);
        },
        shouldComponentUpdate: function(nextProps) {
          return false;
        },
        componentDidMount: function() {
          var $__0 = this;
          this.editor = ace.edit('ace-editor');
          this.editor.getSession().setMode('ace/mode/javascript');
          this.editor.setHighlightActiveLine(false);
          emitter.on('active-node', (function(node) {
            $__0.editor.getSession().removeMarker($__0.marker);
            $__0.highlightRange(node.loc.start.line - 1, node.loc.start.column - 1, node.loc.end.line - 1, node.loc.end.column - 1);
          }));
          emitter.on('deactive-node', (function(node) {
            $__0.editor.getSession().removeMarker($__0.marker);
          }));
        },
        handleSubmit: function(e) {
          e.preventDefault();
          this.emitChange();
        },
        emitChange: function() {
          var input = this.editor.getValue();
          emitter.emit('input-change', {code: input});
        },
        render: function() {
          return (React.createElement("div", null, React.createElement("form", {
            className: "input-form",
            onSubmit: this.handleSubmit
          }, React.createElement("input", {
            type: "submit",
            className: "btn",
            value: "Render"
          }), React.createElement("pre", {id: "ace-editor"}, this.props.code)), React.createElement(AboutProject, null)));
        }
      }));
    }
  };
});



System.register("app/main.jsx!github:floatdrop/plugin-jsx@0.1.1", ["npm:react@0.12.2", "app/input.jsx!github:floatdrop/plugin-jsx@0.1.1", "app/ast-output.jsx!github:floatdrop/plugin-jsx@0.1.1", "app/event", "app/starting-code.js!github:systemjs/plugin-text@0.0.2"], function($__export) {
  "use strict";
  var __moduleName = "app/main.jsx!github:floatdrop/plugin-jsx@0.1.1";
  var React,
      CodeInput,
      ASTOutput,
      emitter,
      code,
      MainComponent;
  return {
    setters: [function($__m) {
      React = $__m.default;
    }, function($__m) {
      CodeInput = $__m.default;
    }, function($__m) {
      ASTOutput = $__m.default;
    }, function($__m) {
      emitter = $__m.default;
    }, function($__m) {
      code = $__m.default;
    }],
    execute: function() {
      MainComponent = React.createClass({
        displayName: "MainComponent",
        onInputChange: function(args) {
          this.setState({code: args.code});
        },
        componentWillMount: function() {
          emitter.on('input-change', this.onInputChange);
        },
        componentWillUnmount: function() {
          emitter.off('input-change', this.onInputChange);
        },
        getInitialState: function() {
          return {
            code: code,
            allVisible: false,
            showOnlyTree: false
          };
        },
        onToggleAllClick: function(e) {
          e.preventDefault();
          var newVisible = !this.state.allVisible;
          emitter.emit('toggle-all', {visible: newVisible});
          this.setState({allVisible: newVisible});
        },
        onShowTreeToggle: function(e) {
          e.preventDefault();
          this.setState({showOnlyTree: !this.state.showOnlyTree});
        },
        renderCodeInput: function() {
          if (this.state.showOnlyTree)
            return ;
          return (React.createElement("div", {className: "code"}, React.createElement(CodeInput, {code: this.state.code})));
        },
        renderTreeOutput: function() {
          return (React.createElement("div", {className: this.state.showOnlyTree ? 'full-screen ast' : 'ast'}, React.createElement(ASTOutput, {code: this.state.code})));
        },
        render: function() {
          var showOnlyTreeText = this.state.showOnlyTree ? 'View Code and Tree' : 'View Just Tree';
          var toggleText = this.state.allVisible ? 'Close Tree' : 'Expand Tree';
          return (React.createElement("div", {className: "app"}, React.createElement("div", {className: "header"}, React.createElement("h1", null, "ReactJS AST Viewer"), React.createElement("p", null, "By ", React.createElement("a", {href: "http://twitter.com/Jack_Franklin"}, "@Jack_Franklin"))), React.createElement("div", {className: "app-btns"}, React.createElement("a", {
            href: "#",
            className: "btn",
            onClick: this.onShowTreeToggle
          }, showOnlyTreeText), React.createElement("a", {
            href: "#",
            className: "btn",
            onClick: this.onToggleAllClick
          }, toggleText)), this.renderCodeInput(), this.renderTreeOutput()));
        }
      });
      React.render(React.createElement(MainComponent, null), document.querySelector('.wrap'));
    }
  };
});



});
//# sourceMappingURL=app.js.map